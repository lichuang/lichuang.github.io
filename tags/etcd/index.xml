<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>etcd on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/etcd/</link>
    <description>Recent content in etcd on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 28 Jun 2021 17:01:53 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/etcd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Etcd Raft库的日志存储</title>
      <link>https://www.codedump.info/post/20210628-etcd-wal/</link>
      <pubDate>Mon, 28 Jun 2021 17:01:53 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210628-etcd-wal/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;之前看etcd raft实现的时候，由于wal以及日志的落盘存储部分，没有放在raft模块中，对这部分没有扣的特别细致。而且，以前我的观点认为etcd raft把WAL这部分留给了上层的应用去实现，自身通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层落盘的数据，这个观点也有失偏颇，etcd只是没有把这部分代码放在raft模块中，属于代码组织的范畴问题，并不是需要应用层自己来实现。&lt;/p&gt;
&lt;p&gt;于是，决定专门写一篇文章把这部分内容给讲解一下，主要涉及以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志（包括快照）文件的格式。&lt;/li&gt;
&lt;li&gt;日志（包括快照）内容的落盘、恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;wal及快照文件格式&#34;&gt;WAL及快照文件格式&lt;/h1&gt;
&lt;p&gt;首先来讲解这两种文件的格式，了解了格式才能继续展开下面的讲述。&lt;/p&gt;
&lt;h2 id=&#34;wal文件格式&#34;&gt;WAL文件格式&lt;/h2&gt;
&lt;p&gt;wal文件的文件名格式为：seq-index.wal（见函数&lt;code&gt;walName&lt;/code&gt;）。其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;seq：序列号，从0开始递增。&lt;/li&gt;
&lt;li&gt;index：该wal文件存储的第一条日志数据的索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果将一个目录下的所有wal文件按照名称排序之后，给定一个日志索引，很快就能知道该索引的日志落在哪个wal文件之中的。&lt;/p&gt;
&lt;p&gt;WAL文件中每条记录的格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Record&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int64&lt;/span&gt; type  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint32&lt;/span&gt; crc  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt; data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;type：记录的类型，下面解释。&lt;/li&gt;
&lt;li&gt;crc：后面data部分数据的crc32校验值。&lt;/li&gt;
&lt;li&gt;data：数据部分，根据类型的不同有不同格式的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录数据的类型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下是WAL存放的数据类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 元数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	metadataType &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int64&lt;/span&gt; = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 日志数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	entryType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 状态数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	stateType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 校验初始值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	crcType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	snapshotType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面展开解释。&lt;/p&gt;
&lt;h3 id=&#34;元数据&#34;&gt;元数据&lt;/h3&gt;
&lt;p&gt;元数据就是应用层自定义的数据，需要注意的是，一个服务中如果有多个wal文件，且这些文件中有多份元数据，那么这些元数据都必须一致，否则报错。&lt;/p&gt;
&lt;p&gt;对于etcd这个服务而言，存储的元数据就是节点ID以及集群ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	metadata &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; pbutil.&lt;span style=&#34;color:#00a000&#34;&gt;MustMarshal&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pb.Metadata{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			NodeID:    &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(member.ID),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			ClusterID: &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(cl.&lt;span style=&#34;color:#00a000&#34;&gt;ID&lt;/span&gt;()),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; w, err = wal.&lt;span style=&#34;color:#00a000&#34;&gt;Create&lt;/span&gt;(cfg.&lt;span style=&#34;color:#00a000&#34;&gt;WALDir&lt;/span&gt;(), metadata); err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		plog.&lt;span style=&#34;color:#00a000&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;create wal error: %v&amp;#34;&lt;/span&gt;, err)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;日志数据&#34;&gt;日志数据&lt;/h3&gt;
&lt;p&gt;日志数据的格式，就是&lt;code&gt;raft.proto&lt;/code&gt;中&lt;code&gt;Entry&lt;/code&gt;的格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Entry&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;     Term  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// must be 64-bit aligned for atomic operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;     Index &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// must be 64-bit aligned for atomic operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; EntryType  Type  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt;      Data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态数据&#34;&gt;状态数据&lt;/h3&gt;
&lt;p&gt;保存当前“硬状态（HardState）”的记录，HardState包括：当前任期号、当前给哪个节点ID投票、当前提交的最大日志索引。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;HardState&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; term   &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; vote   &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; commit &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;校验初始值&#34;&gt;校验初始值&lt;/h3&gt;
&lt;p&gt;校验数据这一块，挺有意思的，可以展开好好说一下。&lt;/p&gt;
&lt;p&gt;使用CRC算法来计算数据的校验值，除了需要原始数据之外，还需要一个校验初始值（即校验种子seed），在每个wal文件中，类型为&lt;code&gt;校验初始值&lt;/code&gt;的记录就用于存储这个值。其值和使用方式有以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个wal文件必须有&lt;code&gt;校验初始值&lt;/code&gt;类型的数据，后续所有写入该wal文件的记录，都使用该初始值来计算CRC校验值。&lt;/li&gt;
&lt;li&gt;第一个wal文件，即序列号为0的wal文件，其校验初始值为0（见wal.go的Create函数）。&lt;/li&gt;
&lt;li&gt;当生成下一个wal文件时，以上一个wal文件的最后一条日志数据的CRC校验码来做为该文件的校验初始值，这样就要求类型为&lt;code&gt;校验初始值&lt;/code&gt;的记录，必须存储在同一个wal文件中第一条日志数据的前面，否则计算出来该日志数据的crc校验码就不准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-crc.png&#34; alt=&#34;wal文件的校验初始值&#34; title=&#34;wal文件的校验初始值&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，通过这个机制，将多个连续的wal文件“串联”了起来：使用上一个wal文件的最后一个日志数据的crc校验值，来做为下一个wal文件的校验初始值，可以有效的校验同一个项目中wal文件的正确性。&lt;/p&gt;
&lt;h3 id=&#34;快照数据&#34;&gt;快照数据&lt;/h3&gt;
&lt;p&gt;在wal文件中存储的快照数据类型的记录，其中仅存储了当前快照的索引和任期号，而快照的详细数据都放到快照数据文件中存储，下面讲到数据恢复时再展开讨论这部分内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; index &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; term  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;快照文件格式&#34;&gt;快照文件格式&lt;/h2&gt;
&lt;p&gt;快照文件的文件名格式为：任期号-索引号.snap（见函数&lt;code&gt;Snapshotter::save&lt;/code&gt;）。每次来一个快照数据，都新建一个快照文件，文件中存储快照数据的格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint32&lt;/span&gt; crc  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt; data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即：只存储快照数据及其校验值，数据的具体格式由存储快照数据的使用方来解释。在etcd这个服务里，这份快照数据的格式就是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt;            data     &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; SnapshotMetadata metadata &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;数据恢复流程&#34;&gt;数据恢复流程&lt;/h1&gt;
&lt;p&gt;日志、快照数据的落盘，都是为了重启时恢复数据，了解了上面wal以及快照文件的格式，可以来看看数据的恢复流程。&lt;/p&gt;
&lt;p&gt;其大体流程如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;到快照目录中取出最新的一份无错的快照文件，首先取出这个文件中存储的快照数据。（见函数&lt;code&gt;Snapshotter::Load&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;此时，从快照数据中可以反序列化出：快照数据、对应的任期号、索引号。&lt;/li&gt;
&lt;li&gt;根据第二步拿到的快照数据，到wal目录中拿到日志索引号在快照数据索引号之后的日志，遍历满足条件的记录进行数据恢复。（见函数&lt;code&gt;WAL::ReadAll&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面具体来看每种wal记录格式数据在进行数据恢复时的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志数据：由于还可能存在一小部分小于快照索引的日志，所以恢复时会忽略掉这部分数据。&lt;/li&gt;
&lt;li&gt;状态数据：每一条状态数据都会反序列化出来，以最后一条状态数据为准。&lt;/li&gt;
&lt;li&gt;元数据：前面提到过，同一个服务的元数据必须一致，所以这里会校验元数据前后是否一致，不一致将报错退出数据恢复流程。&lt;/li&gt;
&lt;li&gt;校验初始值数据：可以参见前面关于该类型数据的讲解。&lt;/li&gt;
&lt;li&gt;快照数据：下面详细解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举一个例子来描述前面根据快照文件和WAL文件恢复数据的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-snap.png&#34; alt=&#34;WAL与快照文件关系&#34; title=&#34;WAL与快照文件关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快照文件集合为&lt;code&gt;[1-50.snap,1-150.snap]&lt;/code&gt;，取最新的快照文件，即&lt;code&gt;1-150.snap&lt;/code&gt;，而&lt;code&gt;1-50.snap&lt;/code&gt;文件的数据为过期数据。&lt;/li&gt;
&lt;li&gt;由于快照文件中存储的日志索引到150，即在此之前的日志已经全部被压缩到了快照文件中，因此wal文件集合中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0-100.wal&lt;/code&gt;中的数据已经全部被压缩。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1-200.wal&lt;/code&gt;中的数据部分被压缩，恢复数据时要忽略日志索引小于150的日志数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3-300.wal&lt;/code&gt;中的数据都没有被压缩，恢复数据时要如实全部重放该文件的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面分析快照数据类型的时候，提到过这个类型的数据在wal文件中的记录，只会存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前快照时对应的任期号。&lt;/li&gt;
&lt;li&gt;当前快照时对应的索引号。&lt;/li&gt;
&lt;li&gt;而具体的快照数据内容存储在快照文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，当生成一份新的快照数据时，将会把这份快照数据相关的以上三部分内容存储到wal和快照文件中。&lt;/p&gt;
&lt;p&gt;所以当恢复数据的时候，此时已经反序列化出快照数据了，这时拿着快照数据读wal文件时，如果读到了快照类型的数据，就会去对比起任期号和索引号是否一致，不一致报错停止恢复流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; snapshotType: &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;var&lt;/span&gt; snap walpb.Snapshot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			pbutil.&lt;span style=&#34;color:#00a000&#34;&gt;MustUnmarshal&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;snap, rec.Data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; snap.Index &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; w.start.Index { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 两者的索引相同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; snap.Term &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; w.start.Term { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 但是任期号不同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;					state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回ErrSnapshotMismatch错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, ErrSnapshotMismatch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存快照数据匹配的标志位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				match = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上，解释清楚了wal、快照文件的格式，以及数据恢复的流程。&lt;/p&gt;
&lt;p&gt;因为wal文件和快照文件的读写，都与磁盘读写相关，所以在etcd服务中，将这两个结构体，统一到&lt;code&gt;etcdserver/storage.go&lt;/code&gt;的&lt;code&gt;storage&lt;/code&gt;结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; storage &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wal.WAL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;snap.Snapshotter
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由&lt;code&gt;storage&lt;/code&gt;结构体统一对外提供wal、快照文件的读写接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; Storage &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Save function saves ents and state to the underlying stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Save MUST block until st and ents are on stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;Save&lt;/span&gt;(st raftpb.HardState, ents []raftpb.Entry) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// SaveSnap function saves snapshot to the underlying stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;SaveSnap&lt;/span&gt;(snap raftpb.Snapshot) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// DBFilePath returns the file path of database snapshot saved with given
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// id.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;DBFilePath&lt;/span&gt;(id &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;) (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Close closes the Storage and performs finalization.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面，解释一下写wal文件中需要注意的一些细节。&lt;/p&gt;
&lt;h1 id=&#34;写优化问题&#34;&gt;写优化问题&lt;/h1&gt;
&lt;h2 id=&#34;数据对齐&#34;&gt;数据对齐&lt;/h2&gt;
&lt;p&gt;每条写入wal的记录，都会将其大小向上8字节对齐，多出来的部分填零：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;encodeFrameSize&lt;/span&gt;(dataBytes &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;) (lenField &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;, padBytes &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	lenField = &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(dataBytes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// force 8 byte alignment so length never gets a torn write
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	padBytes = (&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; (dataBytes &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;)) &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; padBytes &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		lenField &lt;span style=&#34;color:#666&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;0x80&lt;/span&gt;|padBytes) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;56&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/record.png&#34; alt=&#34;WAL记录数据需8字节对齐&#34; title=&#34;WAL记录数据需8字节对齐&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;写缓冲区&#34;&gt;写缓冲区&lt;/h2&gt;
&lt;p&gt;另外，为了缓解写文件的IO负担，etcd做了一个写优化：落盘的数据首先写到一个内存缓冲区中，只有每次填满了一个page的数据才会进行落盘操作。&lt;/p&gt;
&lt;p&gt;etcd中定义了几个常量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const minSectorSize = 512&lt;/li&gt;
&lt;li&gt;const walPageBytes = 8 * minSectorSize&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中：&lt;code&gt;minSectorSize&lt;/code&gt;表示一个sector的大小，而&lt;code&gt;walPageBytes&lt;/code&gt;必须为&lt;code&gt;minSectorSize&lt;/code&gt;的整数倍。&lt;/p&gt;
&lt;p&gt;etcd中定义了一个&lt;code&gt;PageWriter&lt;/code&gt;结构体，用于实现写入日志的操作，内部定义了一个循环缓冲区，只有填满一个&lt;code&gt;walPageBytes&lt;/code&gt;大小的数据才会进行落盘。&lt;/p&gt;
&lt;p&gt;下图是写入数据落盘后循环缓冲区的变化的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/cyclic-buffer.png&#34; alt=&#34;写入数据落盘后循环缓冲区的变化&#34; title=&#34;写入数据落盘后循环缓冲区的变化&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黄色方块表示一个page的空闲空间，绿色方块表示待写入数据，红色方块表示当前已经写入数据的缓冲区。&lt;/li&gt;
&lt;li&gt;刚开始，第一个page已经有部分数据写入，还剩余一部分空闲空间。因此，当写入数据时，只会把写入数据凑齐一个页面大小来落盘。&lt;/li&gt;
&lt;li&gt;落盘完毕之后，第一个page重新变成黄色，即空闲页面，而第二个页面存储了写入数据中没有落盘的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码流程见函数&lt;code&gt;PageWriter::Write&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从上面的写入落盘流程可以看到，一次写入的数据可能会有一部分落盘，一部分还在内存中，这样当系统发生宕机这部分数据就是被损坏（corruption）的数据。&lt;/p&gt;
&lt;p&gt;因此，etcd中还需要有办法来识别和恢复数据。&lt;/p&gt;
&lt;h2 id=&#34;识别部分写入partial-write数据&#34;&gt;识别部分写入（partial write）数据&lt;/h2&gt;
&lt;p&gt;函数&lt;code&gt;decoder::isTornEntry&lt;/code&gt;用于判断一条记录是否为部分写的损坏数据。&lt;/p&gt;
&lt;p&gt;其原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次新创建用于写入记录的wal文件，都会将剩余文件清零。&lt;/li&gt;
&lt;li&gt;读入记录的数据之后，将数据根据不大于每个chunk为&lt;code&gt;minSectorSize&lt;/code&gt;大小的方式，存入chunk数组中。&lt;/li&gt;
&lt;li&gt;遍历这些chunk，如果有一个chunk的数据全部是零，则认为这块数据是部分写入的损坏数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个地方要跟前面落盘流程来对照看：因为每次落盘都是以一个page为单位落盘，而page大小又是&lt;code&gt;minSectorSize&lt;/code&gt;的整数倍，因此以&lt;code&gt;minSectorSize&lt;/code&gt;为一个chunk的大小来判断是否损坏。&lt;/p&gt;
&lt;h2 id=&#34;修复wal文件流程&#34;&gt;修复wal文件流程&lt;/h2&gt;
&lt;p&gt;当进行数据恢复时，可能会出现前面的部分写导致数据损坏问题，etcd会进行如下的修复操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分写导致数据损坏都只会出现在最后一个wal文件，因此打开最后一个wal文件进行处理（见函数&lt;code&gt;openLast&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;出现部分写导致损坏的记录，解析过程中都会返回&lt;code&gt;ErrUnexpectedEOF&lt;/code&gt;错误，对于这样的文件：
&lt;ul&gt;
&lt;li&gt;将损坏的文件重命名为&lt;code&gt;原文件名.broken&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;记录下来最后一个无损记录的偏移量，将损坏之后的数据都截断（Truncate）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;只读和只写文件的区别&#34;&gt;只读和只写文件的区别&lt;/h2&gt;
&lt;p&gt;在etcd中，wal文件有两种并不能同时共存的模式：对于同一个wal文件而言，要么处于只读模式，要么处于append写模式，这两种模式不能同时存在。见&lt;code&gt;WAL&lt;/code&gt;结构体的注释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// WAL is a logical representation of the stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// WAL is either in read mode or append mode but not both.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// A newly created WAL is in append mode, and ready for appending records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// A just opened WAL is in read mode, and ready for reading records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// The WAL will be ready for appending after reading out all the previous records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据上面可能使用缓冲区优化写操作可知，两种模式下在读记录时能容忍的错误级别也不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读模式：读模式下可能读到部分写的数据，所以可以容忍这种错误。&lt;/li&gt;
&lt;li&gt;写模式：写模式下，不能容忍读到部分写的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt; w.&lt;span style=&#34;color:#00a000&#34;&gt;tail&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// We do not have to read out all entries in read mode.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// The last record maybe a partial written one, so
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ErrunexpectedEOF might be returned.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在只读模式下，可能没有读完全部的记录。最后一条记录可能是只写了一部分，此时就会返回ErrunexpectedEOF错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.EOF &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.ErrUnexpectedEOF { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是EOF以及ErrunexpectedEOF错误的情况就返回错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;default&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 写模式下必须读完全部的记录
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// We must read all of the entries if WAL is opened in write mode.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.EOF { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是EOF错误，说明没有读完数据就报错了，这种情况也是返回错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;数据落盘的全流程&#34;&gt;数据落盘的全流程&lt;/h1&gt;
&lt;p&gt;以上了解了wal、快照文件的格式，以及写入流程，这里把之前写的不够好的数据落盘流程重新梳理一下。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/#%E8%BE%93%E5%85%A5%E5%8F%8A%E8%BE%93%E5%87%BA&#34;&gt;etcd Raft库解析 - codedump的网络日志&lt;/a&gt;中，曾经指出etcd raft库是通过&lt;code&gt;Ready&lt;/code&gt;结构体，来通知应用层的当前的数据的，不清楚的话可以回看一下之前的内容。在这里，只解释该结构体中与数据落盘相关的几个成员的数据走向流程，即日志数据（成员&lt;code&gt;Entries&lt;/code&gt;）、快照数据（&lt;code&gt;Snapshot&lt;/code&gt;）、已提交日志（&lt;code&gt;CommittedEntries&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;日志数据-1&#34;&gt;日志数据&lt;/h2&gt;
&lt;p&gt;日志数据从客户端提交到落盘的走向是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由客户端提交给服务器（注：只有leader节点才能接收客户端提交的日志数据，其他节点需转发给leader）。&lt;/li&gt;
&lt;li&gt;服务器收到之后，首先调用&lt;code&gt;raftLog.append&lt;/code&gt;函数保存到&lt;code&gt;unstable_log&lt;/code&gt;中，此时日志还是在内存中的，并未落地。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;newReady&lt;/code&gt;函数构建&lt;code&gt;Ready&lt;/code&gt;结构体时，将上一步保存下来的日志数据保存到&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Entries&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;应用层收到&lt;code&gt;Ready&lt;/code&gt;结构体之后，调用wal的&lt;code&gt;WAL.Save&lt;/code&gt;接口保存日志数据。这一步做完之后，可以认为日志数据已经落盘了。&lt;/li&gt;
&lt;li&gt;由于数据已经落盘到WAL日志中，所以在应用层通过&lt;code&gt;Node.Advance&lt;/code&gt;接口回调通知raft库时，暂存在&lt;code&gt;unstable_log&lt;/code&gt;中的日志就可以通过函数&lt;code&gt;raftLog.stableTo&lt;/code&gt;删除了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/log-flow.png&#34; alt=&#34;日志数据从提交到落盘的走向&#34; title=&#34;日志数据从提交到落盘的走向&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;已提交日志&#34;&gt;已提交日志&lt;/h2&gt;
&lt;p&gt;raft日志中，需要保存两个日志索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appliedIndex：通知到应用层目前为止最大的日志索引；&lt;/li&gt;
&lt;li&gt;commitIndex：当前已提交日志的最大索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，总有&lt;code&gt;appliedIndex &amp;lt;= commitIndex&lt;/code&gt;条件成立，即日志总是先被提交成功（即达成一致），才会通知给应用层。&lt;/p&gt;
&lt;p&gt;通知应用层已提交日志的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;raftLog.nextEnts()&lt;/code&gt;函数获得当前满足&lt;code&gt;appliedIndex &amp;lt;= commitIndex&lt;/code&gt;条件的日志，存入到&lt;code&gt;Ready.CommittedEntries&lt;/code&gt;通知应用层。&lt;/li&gt;
&lt;li&gt;应用层处理这部分已提交日志。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;raftLog.appliedTo()&lt;/code&gt;函数，这里会修改&lt;code&gt;appliedIndex = commitIndex&lt;/code&gt;，即所有日志都已通知应用层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/appliedIndex.png&#34; alt=&#34;通知应用层已提交日志流程&#34; title=&#34;通知应用层已提交日志流程&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;快照数据-1&#34;&gt;快照数据&lt;/h2&gt;
&lt;p&gt;快照数据由应用层生成，然后将生成的快照数据、当前appliedIndex、配置状态一起交给存储层，保存之后就可以把在该快照之前的数据给删除了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;raftNode) &lt;span style=&#34;color:#00a000&#34;&gt;maybeTriggerSnapshot&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 生成快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	data, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; rc.&lt;span style=&#34;color:#00a000&#34;&gt;getSnapshot&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 通知存储层快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.raftStorage.&lt;span style=&#34;color:#00a000&#34;&gt;CreateSnapshot&lt;/span&gt;(rc.appliedIndex, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rc.confState, data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.&lt;span style=&#34;color:#00a000&#34;&gt;saveSnap&lt;/span&gt;(snap)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将快照之前的数据压缩
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	compactIndex &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	rc.raftStorage.&lt;span style=&#34;color:#00a000&#34;&gt;Compact&lt;/span&gt;(compactIndex)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 更新快照数据索引，以便下一次生成新的快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.snapshotIndex = rc.appliedIndex
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;数据的修复&#34;&gt;数据的修复&lt;/h2&gt;
&lt;p&gt;从上面的分析中可以看到，日志数据是在客户端提交之后，就马上落盘到WAL文件中的，不会等到日志在集群中达成一致。&lt;/p&gt;
&lt;p&gt;这样会带来一个问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点A认为自己还是集群的leader节点，此时收到客户端日志之后，将数据落盘到WAL文件中。&lt;/li&gt;
&lt;li&gt;落盘之后，节点A将日志同步给集群的其它节点，但是发现自己已经不再是集群的leader节点了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这种情况下，显然第一步已经落盘的日志是无效的，需要进行修复，这时候是怎么操作的呢？&lt;/p&gt;
&lt;p&gt;etcd raft的做法是不回退日志，继续走正常的流程，用新的、正确的日志添加在错误的日志后面，这样回放数据的时候恢复数据。&lt;/p&gt;
&lt;p&gt;继续以上面的例子为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点A在认为自己是leader的情况下落盘日志到本地WAL中，落盘完毕之后同步给集群内其他节点。&lt;/li&gt;
&lt;li&gt;同步到集群其他节点的过程中，才发现节点A已经不是集群的leader，此时节点A降级为follower节点，并开始从正确的集群节点那里同步日志。&lt;/li&gt;
&lt;li&gt;同步日志的流程中，节点A将收到来自leader节点的正确日志，这些日志也将落盘到节点A的WAL中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二步中同步日志的流程可以参见 &lt;a href=&#34;https://www.codedump.info/post/20180921-raft/#%E6%96%B0leader%E4%B8%8Efollower%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE&#34;&gt;Raft算法原理 - codedump的网络日志&lt;/a&gt;，这里不再阐述。&lt;/p&gt;
&lt;p&gt;上面的流程之后，节点A的WAL中将存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认为自己是leader时已落盘的日志；&lt;/li&gt;
&lt;li&gt;集群leader纠正节点A同步过来的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，当重启恢复时，会一并将这些日志重放，应用层只要按顺序回放日志即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-failback.png&#34; alt=&#34;WAL日志的纠错机制&#34; title=&#34;WAL日志的纠错机制&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点认为自己是leader节点时，落盘到WAL文件中的日志是&lt;code&gt;[(1,10),(1,11)]&lt;/code&gt;，列表中的二元组数据中，第一个元素是任期号，第二个元素是日志索引号。&lt;/li&gt;
&lt;li&gt;在落盘日志之后，节点将数据广播到集群，才发现自己已经不是集群的leader节点，此时集群的leader节点发现从日志10开始，该节点的数据就是不对的，开始同步正确的日志给节点，于是把正确的日志&lt;code&gt;[(2,10),(2,11)]&lt;/code&gt;同步给了节点，这部分日志会添加到前面错误的日志之后。&lt;/li&gt;
&lt;li&gt;假设节点重启恢复，那么会依次重放前面这四条日志，其中前两条日志是错误的日志，但是由于有后面的两条正确日志，最终节点的状态还是会恢复正确状态。&lt;/li&gt;
&lt;li&gt;随着后面日志数据压缩成快照文件，冗余的错误日志的磁盘占用将被解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读者不妨在这里就着这个流程多思考一个问题：做为follower的节点，是什么时候将日志落盘到WAL文件中，是在收到leader节点同步过来的日志时，还是在leader节点通知某个日志已经在集群达成一致？为什么以及流程是怎样的？&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;etcd的wal模块，虽然并没有和raft模块放在一起，但并不是说这一部分就需要应用者来自己实现，这两部分其实是一起打包做为整个etcd raft算法库提供给使用者的。可以认为raft模块提供算法，wal和快照模块提供日志存储读写的接口。&lt;/li&gt;
&lt;li&gt;日志落盘部分，包括wal文件以及快照文件读写这两部分内容，etcd将这两部分统一到&lt;code&gt;Storage&lt;/code&gt;接口统一对外服务。&lt;/li&gt;
&lt;li&gt;raft算法是在收到客户端日志之后就理解落盘日志到wal文件中保存的，如果后面发现出错，就走正常的同步正确日志的流程，将正确的日志添加到后面，这样恢复时重放整个日志，最终节点达成一致的正确状态。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Etcd Raft库的工程化实现</title>
      <link>https://www.codedump.info/post/20210515-raft/</link>
      <pubDate>Sat, 15 May 2021 13:52:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210515-raft/</guid>
      
      <description>&lt;p&gt;最近回顾前几年写的Raft、etcd raft的实现文章，以及重新阅读Raft论文、etcd raft代码，发现之前有些理解不够准确、深刻，但是不打算在原文上做修正，于是写这篇补充的文章做一些另外角度的解释，以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在开始展开讨论前，先介绍这个Raft论文中的示意图，我认为能理解这幅图才能对一致性算法有个全貌的了解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/statemachine.jpeg&#34; alt=&#34;Etcd Raft与应用层的交互&#34; title=&#34;Etcd Raft与应用层的交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中分为两种进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server进程：server进程中运行着一致性算法模块、持久化保存的日志、以及按照日志提交的顺序来进行顺序操作的状态机。&lt;/li&gt;
&lt;li&gt;client进程：用于向server提交日志的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，两种进程都用叠加的矩形来表示，意指系统中这两类进程不止一个。&lt;/p&gt;
&lt;p&gt;一个日志要被正确的提交，图中划分了几步：&lt;/p&gt;
&lt;p&gt;1、client进程提交数据到server进程，server进程将收到的日志数据灌入一致性模块。&lt;/p&gt;
&lt;p&gt;2、一致性模块将日志写入本地WAL，然后同步给集群中其他server进程。&lt;/p&gt;
&lt;p&gt;3、多个节点对某条日志达成一致之后，将修改本地的提交日志索引（commit index）；落盘后的日志按照顺序灌入状态机，只要保证所有server进程上的日志顺序，那么最后状态机的状态肯定就是一致的了。&lt;/p&gt;
&lt;p&gt;4、灌入状态机之后，server进程可以应答客户端。&lt;/p&gt;
&lt;p&gt;所以，本质上，一个使用了一致性算法的库，划分了成了两个不同的模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性算法库，这里泛指Raft、Paxos、Zab等一致性协议。这类一致性算法库主要做如下的事情：
&lt;ul&gt;
&lt;li&gt;用户输入库中日志（log），由库根据各自的算法来检测日志的正确性，并且通知上层的应用层。
&lt;ul&gt;
&lt;li&gt;输入到库中的日志维护和管理，算法库中需要知道哪些日志提交、提交成功、以及上层的应用层已经applied过的。当发生错误的时候，某些日志还会进行回滚（rollback）操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志的网络收发，这部分属于可选功能。有一些库，比如braft把这个事情也揽过来自己做了，优点是使用者不需要关注这部分功能，缺点是braft和它自带的网络库brpc耦合的很紧密，不可能拆开来使用；另一些raft实现，比如这里重点提到etcd raft实现，并不自己完成网络数据收发的工作，而是通知应用层，由应用层自己实现。&lt;/li&gt;
&lt;li&gt;日志的持久化存储：这部分也属于可选功能。前面说过，一致性算法库中维护了未达成一致的日志缓冲区，达成一致的日志才通知应用层，因此在这里不同的算法库又有了分歧，braft也是自己完成了日志持久化的工作，etcd raft则是将这部分工作交给了应用层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层：即工作在一致性算法之上的库使用者，这个就比上图中的“状态机”：只有达成一致并且落盘的数据才灌入应用层，只要保证灌入应用层的日志顺序一致那么最后的状态就是一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来看，一个一致性算法库有以下必选和可选功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入日志进行处理的算法（必选）。&lt;/li&gt;
&lt;li&gt;日志的维护和管理（必选）。&lt;/li&gt;
&lt;li&gt;日志（包括快照）数据的网络收发（可选）。&lt;/li&gt;
&lt;li&gt;日志（包括快照）的持久化存储（可选）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要特别说明的是，即便是后面两个工作是可选的，但是可选还是必选的区别在于，这部分工作是一致性算法库自己完成，还是由算法库通知给上面的应用层去完成，并不代表这部分工作可以完全不做。&lt;/p&gt;
&lt;p&gt;在下表中列列举了etcd raft和braft在这几个特性之间的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;etcd raft&lt;/th&gt;
&lt;th&gt;braft&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;raft一致性算法&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志的维护和管理&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志数据的网络收发&lt;/td&gt;
&lt;td&gt;交由应用层&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志数据的持久化存储&lt;/td&gt;
&lt;td&gt;交由应用层&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优缺点&lt;/td&gt;
&lt;td&gt;松耦合，易于验证、测试；需要应用者做更多的事情&lt;/td&gt;
&lt;td&gt;与其rpc库紧耦合，难拆分；应用层做的事情不多，易于用来做服务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;两种实现各有自己的优缺点，braft类实现更适合提供一个需要集成raft的服务时，可以直接用来实现服务；etcd raft类的实现，由于与网络、存储层耦合不紧密，易于进行测试，更适合拿来做为库使用。&lt;/p&gt;
&lt;p&gt;如果把前面的一致性算法的几个特性做一个抽象，我认为一致性算法库本质上就是一个“维护操作日志的算法库，只要大家都按照相同的顺序将日志灌入应用层”就好，其工作原理大体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/co-algo.png&#34; alt=&#34;一致性算法的本质&#34; title=&#34;一致性算法的本质&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果把问题抽象成这样的话，那么本质上，所谓的“一致性算法库”跟一个经常看到的tcp、kcp甚至是一个应用层的协议栈也就没有什么区别了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家都要维护一个数据区：只有确认过正确的，才会抛给上一层。以TCP协议算法来说，比如发送但未确认的数据由协议栈的缓冲区维护，如果超时还未等到对端的确认，将发起超时重传等，这些都是每种协议算法的具体细节，但是本质上这些协议都要维护一个未确认数据的缓冲区。一致性算法在数据的维护上会更复杂一些，一是参与确认的节点不止通信的C/S两端，需要集群中半数以上节点的确认；同时，在未确认之前日志需要首先落盘，在提交成功之后再抛给应用层。&lt;/li&gt;
&lt;li&gt;只要保证所有参与的节点，都以相同的数据灌入日志给应用层，那么得到的结果将最终一致。&lt;/li&gt;
&lt;li&gt;确认的流程是可以pipeline异步化的，提交日志的进程并不需要一直等待日志被提交成功，而是提交之后等待。不妨以下面的流程来做解释：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/pipeline.png&#34; alt=&#34;流水线异步化的日志提交流程&#34; title=&#34;流水线异步化的日志提交流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientA和clientB分别提交了两条日志数据，但是并没有阻塞等待日志提交成功，而是提交之后就继续别的操作了。&lt;/li&gt;
&lt;li&gt;server将两条日志数据同步出去，达成一致之后再分别通知两个client日志提交成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，client上通知日志提交成功的机制可以有很多，以etcd来说，会给每个提交的日志对应一个channel，提交成功之后会通过这个channel进行通知，也会给这个日志加一个定时器，超过时间仍未收到通知则认为提交失败。&lt;/p&gt;
&lt;h1 id=&#34;etcd-raft的实现&#34;&gt;etcd raft的实现&lt;/h1&gt;
&lt;p&gt;有了上面对一致性算法库的大体了解，下面可以详细看看etcd raft的实现了。&lt;/p&gt;
&lt;h2 id=&#34;概述-1&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;前面提到过，etcd raft库的实现中，并不自己实现网络数据收发、提交成功的数据持久化等工作，这些工作留给了应用层来自己实现，所以需要一个机制来通知应用层。etcd raft中将需要通知给应用层的数据封装在&lt;code&gt;Ready&lt;/code&gt;结构体中，其中包括如下的成员：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员名称&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于读一致性的数据，后续会详细介绍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在向其他集群发送消息之前需要先写入持久化存储的日志数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;pb.Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要写入持久化存储中的快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CommittedEntries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Messages&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要发送出去的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有了数据，还需要raft线程与上面的应用层线程交互的机制，这部分封装在&lt;code&gt;node&lt;/code&gt;结构体中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node&lt;/code&gt;结构体实现&lt;code&gt;Node&lt;/code&gt;接口，该接口用于表示Raft集群中的一个节点。在&lt;code&gt;node&lt;/code&gt;结构体中，实现了以下几个核心的channel，由于与外界进行通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;propc chan pb.Message：用于本地提交日志数据的channel。&lt;/li&gt;
&lt;li&gt;recvc chan pb.Message：用于接收来自集群中其他节点日志数据的channel。&lt;/li&gt;
&lt;li&gt;readyc chan Ready：用于本地Raft库通知应用层哪些数据已经准备好了，因此应用层需要关注readyc这个channel才能获得从Raft线程中提交的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去掉一些不太重要的接口，&lt;code&gt;Node&lt;/code&gt;接口中有如下的核心函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tick()：应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等，至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了。&lt;/li&gt;
&lt;li&gt;Propose(ctx context.Context, data []byte) error：提议写入数据到日志中，可能会返回错误。&lt;/li&gt;
&lt;li&gt;Step(ctx context.Context, msg pb.Message) error：将消息msg灌入状态机。&lt;/li&gt;
&lt;li&gt;Ready() &amp;lt;-chan Ready：返回通知&lt;code&gt;Ready&lt;/code&gt;结构体变更的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作。&lt;/li&gt;
&lt;li&gt;Advance()：Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;node&lt;/code&gt;结构体的实现中，无论是通过&lt;code&gt;Propose&lt;/code&gt;函数还是&lt;code&gt;Step&lt;/code&gt;函数提交到Raft算法库的消息，最终都是调用内部的&lt;code&gt;step&lt;/code&gt;函数的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/etcd-raft.png&#34; alt=&#34;Etcd Raft与应用层的交互&#34; title=&#34;Etcd Raft与应用层的交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上图来说明应用层与raft之间的交互流程，注意：etcd的实现中，raft是一个独立的线程，与应用层之间通过上面介绍的几个channel进行交互。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先看最中间的部分，本地提交的数据通过&lt;code&gt;propc&lt;/code&gt;channel通知raft线程，而应用层从外部网络接收到的日志数据通过&lt;code&gt;recvc&lt;/code&gt;通知raft线程。但是不管是哪个channel，最终都是通过上面提到的&lt;code&gt;step&lt;/code&gt;函数将日志数据灌入raft线程中。&lt;/li&gt;
&lt;li&gt;最右边是raft线程通知应用线程有哪些日志数据已经确认提交完毕等（&lt;code&gt;Ready&lt;/code&gt;结构体中不限于确认提交数据，该类型数据在上面已经列举出来），应用层可以通过&lt;code&gt;Ready&lt;/code&gt;数据来持久化数据等操作。&lt;/li&gt;
&lt;li&gt;最左边表示应用层线程要通过&lt;code&gt;Advance&lt;/code&gt;函数通知raft线程自己已经持久化了某些数据，这时候可以推动raft线程库中的日志缓冲区的变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一个简单的消息流程来继续解释上面的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层收到索引为N的消息，此时通过&lt;code&gt;recvc&lt;/code&gt;channel提交给Raft线程。&lt;/li&gt;
&lt;li&gt;Raft线程验证消息是正确的，于是需要广播给集群中的其他节点，此时会：
&lt;ul&gt;
&lt;li&gt;首先在Raft的日志缓冲区中保存下来这个消息，因为这个日志还未提交成功。&lt;/li&gt;
&lt;li&gt;将日志消息放入&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Messages&lt;/code&gt;成员中，通知应用层，这样应用层就将该成员中的消息转发给集群中的其他节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Raft线程继续获得从应用层下发下来的消息，当发现下发的消息中，索引为N的消息已经被集群中半数以上的节点确认过，此时就可以认为该消息能被持久化了，将日志消息放入&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;CommittedEntries&lt;/code&gt;成员中，以通知应用层该消息可以被持久化了。&lt;/li&gt;
&lt;li&gt;每次应用层持久化了某些消息之后，都会通过&lt;code&gt;Advance&lt;/code&gt;函数通知Raft线程，这样Raft线程可以将这部分已经被持久化的消息从消息缓冲区中删除，因为前面提到过消息缓冲区仅仅是用来保存还未持久化的消息的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个工作流程是pipeline化，即应用层某一次提交了索引为N的消息，并不需要一直等待该消息提交成功，而是可以返回继续做别的事情，当raft线程判断消息可以被提交时，再通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层。&lt;/p&gt;
&lt;p&gt;以上大体描述了etcd中，应用层线程与raft线程的交互流程，下面详细看看raft线程的实现。&lt;/p&gt;
&lt;h2 id=&#34;raft算法&#34;&gt;Raft算法&lt;/h2&gt;
&lt;p&gt;raft算法中，有不同的角色存在：candidate、follower、leader，本质上Raft算法是输入日志数据进行处理，而每种角色对不同类型的日志数据需要有不同的处理。&lt;/p&gt;
&lt;p&gt;所以，etcd raft的实现中，针对三种不同的角色，通过修改函数指针的方式在切换了不同角色时的处理，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/role-algo.png&#34; alt=&#34;不同角色的Raft算法处理&#34; title=&#34;不同角色的Raft算法处理&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的算法细节，不打算在本文中展开，可以回头上上面给出来的几篇文章。&lt;/p&gt;
&lt;h2 id=&#34;数据管理&#34;&gt;数据管理&lt;/h2&gt;
&lt;p&gt;数据管理分为以下几部分阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未持久化数据缓冲区&lt;/li&gt;
&lt;li&gt;持久化数据内存映像&lt;/li&gt;
&lt;li&gt;数据的持久化&lt;/li&gt;
&lt;li&gt;数据流动的全流程&lt;/li&gt;
&lt;li&gt;节点进度的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面一一展开。&lt;/p&gt;
&lt;h3 id=&#34;未持久化数据缓冲区&#34;&gt;未持久化数据缓冲区&lt;/h3&gt;
&lt;p&gt;前面提到过，Raft算法中还必须要做的是维护未确认数据的缓冲区数据，每当其中的一部分数据被确认，缓冲区的窗口随之发生移动，这就类似TCP协议算法中的滑动窗口。&lt;/p&gt;
&lt;p&gt;etcd raft中，管理未确认数据放在了&lt;code&gt;unstable&lt;/code&gt;结构体（log_unstable.go）中，其内部维护三个成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;snapshot *pb.Snapshot：保存还没有持久化的快照数据&lt;/li&gt;
&lt;li&gt;entries []pb.Entry：保存还未持久化的日志数据。&lt;/li&gt;
&lt;li&gt;offset uint64：保存快照和日志数组的分界线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，未持久化数据分为两部分：一部分是快照数据snapshot，另一部分就是日志数据数组。两者不会同时存在，快照数据只会在启动时进行快照数据恢复时存在，当应用层使用快照数据进行恢复之后，raft切换为可以接收日志数据的状态，后续的日志数据都会写到&lt;code&gt;entrise&lt;/code&gt;数组中了，而两者的分界线就是&lt;code&gt;offset&lt;/code&gt;变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/unstable.png&#34; alt=&#34;未持久化数据&#34; title=&#34;未持久化数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于是”未持久化数据的缓冲区“，因此这其中的数据可能会发生回滚（rollback）现象，因此&lt;code&gt;unstable&lt;/code&gt;结构体需要支持能回滚的操作，见函数&lt;code&gt;truncateAndAppend&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (u *unstable) truncateAndAppend(ents []pb.Entry) {
	// 先拿到这些数据的第一个索引
	after := ents[0].Index
	switch {
	case after == u.offset+uint64(len(u.entries)):
		// 如果正好是紧接着当前数据的，就直接append
		// after is the next index in the u.entries
		// directly append
		u.entries = append(u.entries, ents...)
	case after &amp;lt;= u.offset:
		u.logger.Infof(&amp;#34;replace the unstable entries from index %d&amp;#34;, after)
		// The log is being truncated to before our current offset
		// portion, so set the offset and replace the entries
		// 如果比当前偏移量小，那用新的数据替换当前数据，需要同时更改offset和entries
		u.offset = after
		u.entries = ents
	default:
		// truncate to after and copy to u.entries
		// then append
		// 到了这里，说明 u.offset &amp;lt; after &amp;lt; u.offset+uint64(len(u.entries))
		// 那么新的entries需要拼接而成
		u.logger.Infof(&amp;#34;truncate the unstable entries before index %d&amp;#34;, after)
		u.entries = append([]pb.Entry{}, u.slice(u.offset, after)...)
		u.entries = append(u.entries, ents...)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数中分为三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果传入的日志数据，刚好跟当前数据紧挨着（after == u.offset+uint64(len(u.entries))），就可以直接进行append操作。&lt;/li&gt;
&lt;li&gt;如果传入的日志数据的第一条数据索引不大于当前的offset（after &amp;lt;= u.offset），说明数据发生了回滚，直接用新的数据替换旧的数据。&lt;/li&gt;
&lt;li&gt;其他情况，说明u.offset &amp;lt; after &amp;lt; u.offset+uint64(len(u.entries))，这是新的未持久化数据由这两部分数据各取其中一部分数据拼装而成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持久化数据内存映像&#34;&gt;持久化数据内存映像&lt;/h3&gt;
&lt;p&gt;但是，仅仅有未持久化数据还不够，有时候有一些数据已经落盘，但是还需要进行查询、读取等操作。于是，etcd raft又提供了一个&lt;code&gt;Storage&lt;/code&gt;接口，该接口有面对不同的组件有不同的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于Raft库，该接口仅仅只有读操作。（如下图中的黄色函数）&lt;/li&gt;
&lt;li&gt;对于etcd 服务来说，还提供了写操作，包括：增加日志数据、生成快照、压缩数据。（如下图中的蓝色函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，这个接口及其默认实现&lt;code&gt;MemoryStorage&lt;/code&gt;，呈现了稍微不太一样的行为，以致于我最开始没有完全理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/stable.png&#34; alt=&#34;持久化数据的内存映像&#34; title=&#34;持久化数据的内存映像&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为持久化数据的内存映像，提供给Raft库的仅仅只需要读操作，所以&lt;code&gt;Storage&lt;/code&gt;接口就只有读操作，多出来的写操作只会在应用层中才会用到，因此这些写接口并没有放在公用的接口中。&lt;/p&gt;
&lt;p&gt;了解了持久化和未持久化数据的表示之后，etcd raft库将两者统一到&lt;code&gt;raftLog&lt;/code&gt;这个结构体中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/raftlog.png&#34; alt=&#34;不同视角下的raftlog&#34; title=&#34;不同视角下的raftlog&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据的持久化&#34;&gt;数据的持久化&lt;/h3&gt;
&lt;p&gt;以上解释两种缓冲区的作用，数据最终还是需要持久化到磁盘上的，那么，这个持久化数据的时机在哪里？&lt;/p&gt;
&lt;p&gt;答案：当客户端提交数据时，etcd Raft库就通过&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Entries&lt;/code&gt;成员通知应用层，将这些提交的数据进行持久化了。&lt;/p&gt;
&lt;p&gt;有代码为证。&lt;/p&gt;
&lt;p&gt;首先来看&lt;code&gt;raft&lt;/code&gt;中如何生成&lt;code&gt;Ready&lt;/code&gt;数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
	rd := Ready{
		// entries保存的是没有持久化的数据数组
		Entries:          r.raftLog.unstableEntries(),
		// 保存committed但是还没有applied的数据数组
		CommittedEntries: r.raftLog.nextEnts(),
		// 保存待发送的消息
		Messages:         r.msgs,
	}
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，&lt;code&gt;raft&lt;/code&gt;库中将未持久化数据塞到了&lt;code&gt;Entries&lt;/code&gt;数组中，而已经达成一致可以提交的日志数据放入到&lt;code&gt;CommittedEntries&lt;/code&gt;数组中。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;etcd&lt;/code&gt;代码中自带的&lt;code&gt;raftexample&lt;/code&gt;目录中的例子代码来看应用层在收到&lt;code&gt;Ready&lt;/code&gt;数据后的做法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (rc *raftNode) serveChannels() {
		case rd := &amp;lt;-rc.node.Ready():
			// 将HardState，entries写入持久化存储中
			rc.wal.Save(rd.HardState, rd.Entries)
			if !raft.IsEmptySnap(rd.Snapshot) {
				// 如果快照数据不为空，也需要保存快照数据到持久化存储中
				rc.saveSnap(rd.Snapshot)
				rc.raftStorage.ApplySnapshot(rd.Snapshot)
				rc.publishSnapshot(rd.Snapshot)
			}
			rc.raftStorage.Append(rd.Entries)
			rc.transport.Send(rd.Messages)
			if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
				rc.stop()
				return
			}
			rc.maybeTriggerSnapshot()
			rc.node.Advance()
	// ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rc.wal.Save(rd.HardState, rd.Entries)：将客户端提交数据的数据写入wal中。&lt;/li&gt;
&lt;li&gt;rc.raftStorage.Append(rd.Entries)：这里的&lt;code&gt;raftStorage&lt;/code&gt;即前面提到的持久化数据缓冲区的&lt;code&gt;Storage&lt;/code&gt;接口，由&lt;code&gt;MemoryStorage&lt;/code&gt;接口实现，这一步将这些客户端提交的数据也写入持久化缓冲区的内部映像。&lt;/li&gt;
&lt;li&gt;rc.publishEntries(rc.entriesToApply(rd.CommittedEntries))：这个调用分为两步，第一步调用&lt;code&gt;entriesToApply&lt;/code&gt;是要从已达成一致的日志数据中过滤出真正可以进行apply的日志，因为里面的一些日志可能已经被应用层apply过，第二步将第一步过滤出来的日志数据通知给应用层。在&lt;code&gt;raftexample&lt;/code&gt;这个示例代码中，最终这些已经达成一致的数据，会被遍历生成KV内存数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有一个问题：客户端提交过来的数据，还未达成集群内半数节点的一致，这时候就去做落盘操作，如果提交过程中发现出了问题，实际这条数据并不能最终达成一致，那么已落盘的数据怎么办？&lt;/p&gt;
&lt;p&gt;在这里，&lt;code&gt;etcd&lt;/code&gt;落盘客户端提交的数据时，是写入到WAL文件中的，后面发生了错误，如leader变成了follower时，日志需要进行了回滚操作等，也还是将那些正确的日志继续添加到WAL日志后面，服务如果重启，就是把这些日志按照顺序重放（replay）一遍，这里不可避免的会有一些冗余的操作，但是随着快照文件的产生，这个问题已经不大了。&lt;/p&gt;
&lt;p&gt;其次，不论是前面提到的&lt;code&gt;未持久化数据缓冲区&lt;/code&gt;，还是&lt;code&gt;持久化数据缓冲区&lt;/code&gt;，在往缓冲区中添加日志的函数实现中，都会去判断日志是否发生了回滚，会将当前传入的日志按照正确的日志索引放到缓冲区合适的位置。&lt;code&gt;未持久化数据缓冲区&lt;/code&gt;这部分操作在函数&lt;code&gt;unstable.truncateAndAppend&lt;/code&gt;中，&lt;code&gt;持久化数据缓冲区&lt;/code&gt;这部分操作在函数&lt;code&gt;MemoryStorage.Append&lt;/code&gt;中，感兴趣的可以去看看具体的实现，在这里就不再展开了。&lt;/p&gt;
&lt;h3 id=&#34;数据流动的全流程&#34;&gt;数据流动的全流程&lt;/h3&gt;
&lt;p&gt;以上解释了客户端提交的数据在两个缓冲区、持久化存储、以及最终达成一致之后给应用层的过程，下面以例子分别来解释客户端提交数据的流程以及快照数据恢复的流程。&lt;/p&gt;
&lt;h4 id=&#34;客户端提交数据的流程&#34;&gt;客户端提交数据的流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/wal.png&#34; alt=&#34;客户端提交数据的流动&#34; title=&#34;客户端提交数据的流动&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、客户端提交数据给服务器。&lt;/p&gt;
&lt;p&gt;2、接着看这条数据走过的”存储“路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、首先，`raft`库会首先将日志数据写入`未持久化数据缓冲区`。

2、由于`未持久化数据缓冲区`中有新增的数据，会通过`Ready`结构体通知给应用层。

3、应用层收到`Ready`结构体之后，将其中的数据写入WAL持久化存储，然后更新这块数据到`已持久化数据缓冲区`。

4.1、持久化完毕后，应用层通过`Advance`接口通知`Raft`库这些数据已经持久化，于是raft库修改`未持久化数据缓冲区`将客户端刚提交的数据从这个缓冲区中删除。

4.2、持久化完毕之后，除了通知删除`未持久化数据缓冲区`，还讲数据通过网络同步给集群中其他节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、集群中半数节点对该提交数据达成了一致，可以应答给客户端了。&lt;/p&gt;
&lt;h4 id=&#34;启动时使用快照数据恢复流程&#34;&gt;启动时使用快照数据恢复流程&lt;/h4&gt;
&lt;p&gt;下面以例子来实际解释etcd raft中数据在未持久化缓存、wal日志、持久化数据内容映像中的流动：&lt;/p&gt;
&lt;p&gt;1、节点N启动，加入到集群中，此时发现N上面没有数据，于是集群中的leader节点会首先通过rpc消息将快照数据发送给节点N。&lt;/p&gt;
&lt;p&gt;2、节点N收到快照数据，首先会保存到未持久化数据缓存中。&lt;/p&gt;
&lt;p&gt;3、Raft通过&lt;code&gt;Ready&lt;/code&gt;结构体通知应用层有快照数据。&lt;/p&gt;
&lt;p&gt;4、应用层（也就是etcdserver）将快照数据写入wal持久化存储中，这一步可以理解为将快照数据落盘。&lt;/p&gt;
&lt;p&gt;5、落盘之后，调用&lt;code&gt;MemoryStorage&lt;/code&gt;结构体的&lt;code&gt;ApplySnapshot&lt;/code&gt;将快照数据保存到持久化数据内存映像中。&lt;/p&gt;
&lt;p&gt;6、（图中未给出）调用Raft库的&lt;code&gt;Advance&lt;/code&gt;接口通知raft库传递过来的&lt;code&gt;Ready&lt;/code&gt;结构体数据已经操作完毕，这时候对应的，raft库就会把第二步中保存到未持久化数据缓存的快照数据给删除了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/snapshot.png&#34; alt=&#34;快照数据的流动&#34; title=&#34;快照数据的流动&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上是快照数据的流动过程，在节点N接收并持久化快照数据后，后面就可以接收正常的日志了，日志数据的流动过程跟快照数据实际是差不多的，就不再阐述了。&lt;/p&gt;
&lt;p&gt;从上面的流程中也可以看出，应用层也就是etcdserver的持久化数据，只有wal日志而已，情况确实是这样的，其接口和实现如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Storage interface {
	// Save function saves ents and state to the underlying stable storage.
	// Save MUST block until st and ents are on stable storage.
	Save(st raftpb.HardState, ents []raftpb.Entry) error
	// SaveSnap function saves snapshot to the underlying stable storage.
	SaveSnap(snap raftpb.Snapshot) error
	// DBFilePath returns the file path of database snapshot saved with given
	// id.
	DBFilePath(id uint64) (string, error)
	// Close closes the Storage and performs finalization.
	Close() error
}

type storage struct {
	*wal.WAL
	*snap.Snapshotter
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Storage&lt;/code&gt;接口是etcdserver持久化数据的接口，其保存的数据有两个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Save(st raftpb.HardState, ents []raftpb.Entry) error：保存日志数据。&lt;/li&gt;
&lt;li&gt;SaveSnap(snap raftpb.Snapshot) error：保存快照数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而&lt;code&gt;Storage&lt;/code&gt;接口由下面的&lt;code&gt;storage&lt;/code&gt;结构体来实现，其又分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wal：用于实现WAL日志的读写。&lt;/li&gt;
&lt;li&gt;snap：用于实现快照数据的读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里就不展开讨论了。&lt;/p&gt;
&lt;h3 id=&#34;节点进度的管理&#34;&gt;节点进度的管理&lt;/h3&gt;
&lt;p&gt;前面提到过，一致性算法与TCP之类的协议，本质上都需要管理未确认数据的缓冲区，但是不同的是，参与一致性算法确认的成员，不会像一般的点对点通信协议那样只有两个，在raft算法中，leader节点除了要维护未持久化缓冲区之外，还需要维护一个数据结构，用于保存集群中其他节点的进度，这部分数据在etcd raft中保存在结构体&lt;code&gt;Progress&lt;/code&gt;中，我将我之前阅读过程中加上的注释一并贴出来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志
// Progress represents a follower’s progress in the view of the leader. Leader maintains
// progresses of all followers, and sends entries to the follower based on its progress.
type Progress struct {
	// Next保存的是下一次leader发送append消息时传送过来的日志索引
	// 当选举出新的leader时，首先初始化Next为该leader最后一条日志+1
	// 如果向该节点append日志失败，则递减Next回退日志，一直回退到索引匹配为止

	// Match保存在该节点上保存的日志的最大索引，初始化为0
	// 正常情况下，Next = Match + 1
	// 以下情况下不是上面这种情况：
	// 1. 切换到Probe状态时，如果上一个状态是Snapshot状态，即正在接收快照，那么Next = max(pr.Match+1, pendingSnapshot+1)
	// 2. 当该follower不在Replicate状态时，说明不是正常的接收副本状态。
	//    此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被
	//    leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现
	Match, Next uint64
	// State defines how the leader should interact with the follower.
	//
	// When in ProgressStateProbe, leader sends at most one replication message
	// per heartbeat interval. It also probes actual progress of the follower.
	//
	// When in ProgressStateReplicate, leader optimistically increases next
	// to the latest entry sent after sending replication message. This is
	// an optimized state for fast replicating log entries to the follower.
	//
	// When in ProgressStateSnapshot, leader should have sent out snapshot
	// before and stops sending any replication message.

	// ProgressStateProbe：在每次heartbeat消息间隔期最多发一条同步日志消息给该节点
	// ProgressStateReplicate：正常的接受副本数据状态。当处于该状态时，leader在发送副本消息之后，
	// 就修改该节点的next索引为发送消息的最大索引+1
	// ProgressStateSnapshot：接收副本状态
	State ProgressStateType
	// Paused is used in ProgressStateProbe.
	// When Paused is true, raft should pause sending replication message to this peer.
	// 在状态切换到Probe状态以后，该follower就标记为Paused，此时将暂停同步日志到该节点
	Paused bool

	// PendingSnapshot is used in ProgressStateSnapshot.
	// If there is a pending snapshot, the pendingSnapshot will be set to the
	// index of the snapshot. If pendingSnapshot is set, the replication process of
	// this Progress will be paused. raft will not resend snapshot until the pending one
	// is reported to be failed.
	// 如果向该节点发送快照消息，PendingSnapshot用于保存快照消息的索引
	// 当PendingSnapshot不为0时，该节点也被标记为暂停状态。
	// raft只有在这个正在进行中的快照同步失败以后，才会重传快照消息
	PendingSnapshot uint64

	// RecentActive is true if the progress is recently active. Receiving any messages
	// from the corresponding follower indicates the progress is active.
	// RecentActive can be reset to false after an election timeout.
	RecentActive bool

	// inflights is a sliding window for the inflight messages.
	// Each inflight message contains one or more log entries.
	// The max number of entries per message is defined in raft config as MaxSizePerMsg.
	// Thus inflight effectively limits both the number of inflight messages
	// and the bandwidth each Progress can use.
	// When inflights is full, no more message should be sent.
	// When a leader sends out a message, the index of the last
	// entry should be added to inflights. The index MUST be added
	// into inflights in order.
	// When a leader receives a reply, the previous inflights should
	// be freed by calling inflights.freeTo with the index of the last
	// received entry.
	// 用于实现滑动窗口，用来做流量控制
	ins *inflights
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结来说，&lt;code&gt;Progress&lt;/code&gt;结构体做的工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护follower节点的match、next索引，以便知道下一次从哪里开始同步数据。&lt;/li&gt;
&lt;li&gt;维护着follower节点当前的状态。&lt;/li&gt;
&lt;li&gt;同步快照数据的状态。&lt;/li&gt;
&lt;li&gt;流量控制，避免follower节点超载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的算法细节，就不在这里贴出了。&lt;/p&gt;
&lt;h2 id=&#34;网络数据的收发以及日志的持久化&#34;&gt;网络数据的收发以及日志的持久化&lt;/h2&gt;
&lt;p&gt;网络数据的收发以及日志的持久化，这两部分在etcd raft库中，并不是由raft库来实现，而是通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层，由应用层来完成。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;这里将上面的几部分总结如下，有了整体的理解才能更好的了解细节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/summary.png&#34; alt=&#34;Raft算法几要素在etcd raft中的实现&#34; title=&#34;Raft算法几要素在etcd raft中的实现&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>etcd Raft库解析</title>
      <link>https://www.codedump.info/post/20180922-etcd-raft/</link>
      <pubDate>Sat, 22 Sep 2018 11:01:02 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20180922-etcd-raft/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd的raft实现是最接近论文本身的，结合论文原理一起阅读十分酸爽。这个系列文章的索引如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我个人还针对etcd 3.1.10版本的raft相关代码实现做了一些代码的注释笔记，地址在此：&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;etcd-3.1.10-codedump&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;序言&#34;&gt;序言&lt;/h1&gt;
&lt;p&gt;今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现也非常精妙，屏蔽了网络、存储等模块，提供接口由上层应用者来实现。&lt;/p&gt;
&lt;p&gt;本篇文章解析etcd的Raft库实现，基于etcd 3.1.10版本。etcd的Raft库，位于其代码目录的Raft中。&lt;/p&gt;
&lt;p&gt;我自己也单独将3.1.10的代码拉出了一个专门添加了我阅读代码注释的版本，目前Raft这部分基本都做了注释，见：
&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;https://github.com/lichuang/etcd-3.1.10-codedump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下在介绍的时候，可能会混用中文和英文术语，这里先列举出来：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;选举任期，每次选举之后递增1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Vote&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;选举投票(的ID)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Raft算法的日志数据条目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;candidate&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;候选人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leader&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;领导者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;follower&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;跟随者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;propose&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提议&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;输入及输出&#34;&gt;输入及输出&lt;/h1&gt;
&lt;p&gt;既然做为一个库使用，就有其确定的输入和输出接口，先来了解这部分再进行后续的展开讨论。&lt;/p&gt;
&lt;p&gt;作为一个一致性算法的库，不难想象使用的一般场景是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用层接收到新的写入数据请求，向该算法库写入一个数据。&lt;/li&gt;
&lt;li&gt;算法库返回是否写入成功。&lt;/li&gt;
&lt;li&gt;应用层根据写入结果进行下一步的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，Raft库却相对而言更复杂一些，因为还有以下的问题存在：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入的数据，可能是集群状态变更的数据，Raft库在执行写入这类数据之后，需要返回新的状态给应用层。&lt;/li&gt;
&lt;li&gt;Raft库中的数据不可能一直以日志的形式存在，这样会导致数据越来越大，所以有可能被压缩成快照（snapshot）的数据形式，这种情况下也需要返回这部分快照数据。&lt;/li&gt;
&lt;li&gt;由于etcd的Raft库不包括持久化数据存储相关的模块，而是由应用层自己来做实现，所以也需要返回在某次写入成功之后，哪些数据可以进行持久化保存了。&lt;/li&gt;
&lt;li&gt;同样的，etcd的Raft库也不自己实现网络传输，所以同样需要返回哪些数据需要进行网络传输给集群中的其他节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的这些，集中在raft/node.go的Ready结构体中，其包括以下成员：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员名称&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于读一致性的数据，后续会详细介绍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在向其他集群发送消息之前需要先写入持久化存储的日志数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;pb.Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要写入持久化存储中的快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CommittedEntries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Messages&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在entries被写入持久化存储中以后，需要发送出去的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上的成员说明，最开始看不一定能理解其含义和用法，不过在后续会慢慢展开讨论。&lt;/p&gt;
&lt;p&gt;根据上面的分析，应用层在写入一段数据之后，Raft库将返回这样一个Ready结构体，其中可能某些字段是空的，毕竟不是每次改动都会导致Ready结构体中的成员都发生变化，此时使用者就需要根据情况，取出其中不为空的成员进行操作了。&lt;/p&gt;
&lt;p&gt;在etcd项目中，也提供了使用Raft库的demo例子，在contrib/raftexample目录中，这里简单的演示了一下如何根据这个raft库实现一个简单的KV存储服务器，下面根据这里的代码结合着上面的Ready结构体，来分析如何使用etcd的Raft库。&lt;/p&gt;
&lt;p&gt;raft库对外提供一个Node的interface，其实现有raft/node.go中的node结构体实现，这也是应用层唯一需要与这个raft库直接打交道的结构体，简单的来看看Node接口需要实现的函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Tick&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等。至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Campaign&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;调用该函数将驱动节点进入候选人状态，进而将竞争leader。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Propose&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提议写入数据到日志中，可能会返回错误。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ProposeConfChange&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交配置变更&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Step&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;将消息msg灌入状态机中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Ready&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;这里是核心函数，将返回Ready的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Advance&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里大部分函数在这个demo中不需要进行关心，我们只看如何对接Ready结构体就好了。&lt;/p&gt;
&lt;p&gt;raftexample中，首先在main.go中创建了两个channel：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;proposeC：用于提交写入的数据。&lt;/li&gt;
&lt;li&gt;confChangeC：用于提交配置改动数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后分别启动如下核心的协程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动HTTP服务器，用于接收用户的请求数据，最终会将用户请求的数据写入前面的proposeC/confChangeC channel中。&lt;/li&gt;
&lt;li&gt;启动raftNode结构体，该结构体中有上面提到的raft/node.go中的node结构体，也就是通过该结构体实现的Node接口与raft库进行交互。同时，raftNode还会启动协程监听前面的两个channel，收到数据之后通过Node接口的函数调用raft库对应的接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的交互流程就很清楚了，HTTP服务负责接收用户数据，再写入到两个核心channel中，而raftNode负责监听这两个channel：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果收到proposeC channel的消息，说明有数据提交，则调用Node.Propose函数进行数据的提交。&lt;/li&gt;
&lt;li&gt;如果收到confChangeC channel的消息，说明有配置变更，则调用Node.ProposeConfChange函数进行配置变更。&lt;/li&gt;
&lt;li&gt;设置一个定时器tick，每次定时器到时时，调用Node.Tick函数。&lt;/li&gt;
&lt;li&gt;监听Node.Ready函数返回的Ready结构体channel，有数据变更时根据Ready结构体的不同数据类型进行相应的操作，完成了之后需要调用Node.Advance函数进行收尾。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将以上流程用伪代码实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// HTTP server
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;HttpServer主循环:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  接收用户提交的数据&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    如果是PUT请求&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      将数据写入到proposeC中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    如果是POST请求&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      将配置变更数据写入到confChangeC中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// raft Node
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;raftNode结构体主循环&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果proposeC中有数据写入&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Propose向raft库提交数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果confChangeC中有数据写入&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Node.ProposeConfChange向raft库提交配置变更数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果tick定时器到期&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Tick函数进行raft库的定时操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果node.&lt;span style=&#34;color:#00a000&#34;&gt;Ready&lt;/span&gt;()函数返回的Ready结构体channel有数据变更&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    依次处理Ready结构体中各成员数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    处理完毕之后调用node.Advance函数进行收尾处理
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到了这里，已经对raft的使用有一个基本的概念了，即通过node结构体实现的Node接口与raft库进行交互，涉及数据变更的核心数据结构就是Ready结构体，接下来可以进一步来分析该库的实现了。&lt;/p&gt;
&lt;h1 id=&#34;raft库代码结构及核心数据结构&#34;&gt;raft库代码结构及核心数据结构&lt;/h1&gt;
&lt;p&gt;现在可以来看看raft库的代码组织了。&lt;/p&gt;
&lt;p&gt;前面已经看到了raft/node.go文件中，提供出去的是Node接口及其实现node结构体，这是外界与raft库打交道的唯一接口，除此之外该路径下的其他文件并不直接与外界打交道。&lt;/p&gt;
&lt;p&gt;接着是raft算法的实现文件，raft/raft.go文件，其中包含两个核心数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Config：与raft算法相关的配置参数都包装在该结构体中。从这个结构体的命名是大写字母开头，就可以知道是提供给外部调用的。&lt;/li&gt;
&lt;li&gt;raft：具体实现raft算法的结构体。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除去以上两个文件之外，raft目录下的其他文件，都是间接给raft结构体服务的，下面的表格做一个总结和罗列：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;结构体/接口&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;所在文件&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Node接口&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;node.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提供raft库与外界交互的接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;node&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;node.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;实现Node接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Config&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;封装raft算法相关配置参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;raft&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft算法的实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;read_only.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;线性一致性读相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;readOnly&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;read_only.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;线性一致性读相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;raftLog&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;log.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;实现raft日志操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Progress&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;progress.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Storage接口&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;storage.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提供存储接口，应用层可以按照自己的需求实现该接口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;raft库日志存储相关结构&#34;&gt;raft库日志存储相关结构&lt;/h2&gt;
&lt;h3 id=&#34;unstable&#34;&gt;unstable&lt;/h3&gt;
&lt;p&gt;顾名思义，unstable数据结构用于还没有被用户层持久化的数据，而其中又包括两部分，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/unstable.png&#34; alt=&#34;unstable&#34; title=&#34;unstable&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，前半部分是快照数据，而后半部分是日志条目组成的数组entries，另外unstable.offset成员保存的是entries数组中的第一条数据在raft日志中的索引，即第i条entries数组数据在raft日志中的索引为i + unstable.offset。&lt;/p&gt;
&lt;p&gt;这两个部分，并不同时存在，同一时间只有一个部分存在。其中，快照数据仅当当前节点在接收从leader发送过来的快照数据时存在，在接收快照数据的时候，entries数组中是没有数据的；除了这种情况之外，就只会存在entries数组的数据了。因此，当接收完毕快照数据进入正常的接收日志流程时，快照数据将被置空。&lt;/p&gt;
&lt;p&gt;理解了以上unstable中数据的分布情况，就不难理解unstable各个函数成员的作用了，下面逐一进行解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maybeFirstIndex：返回unstable数据的第一条数据索引。因为只有快照数据在最前面，因此这个函数只有当快照数据存在的时候才能拿到第一条数据索引，其他的情况下已经拿不到了。&lt;/li&gt;
&lt;li&gt;maybeLastIndex：返回最后一条数据的索引。因为是entries数据在后，而快照数据在前，所以取最后一条数据索引是从entries开始查，查不到的情况下才查快照数据。&lt;/li&gt;
&lt;li&gt;maybeTerm：这个函数根据传入的日志数据索引，得到这个日志对应的任期号。前面已经提过，unstable.offset是快照数据和entries数组的分界线，因为在这个函数中，会区分传入的参数与offset的大小关系，小于offset的情况下在快照数据中查询，否则就在entries数组中查询了。&lt;/li&gt;
&lt;li&gt;stableTo：该函数传入一个索引号i和任期号t，表示应用层已经将这个索引之前的数据进行持久化了，此时unstable要做的事情就是在自己的数据中查询，只有在满足任期号相同以及i大于等于offset的情况下，可以将entries中的数据进行缩容，将i之前的数据删除。&lt;/li&gt;
&lt;li&gt;stableSnapTo：该函数传入一个索引i，用于告诉unstable，索引i对应的快照数据已经被应用层持久化了，如果这个索引与当前快照数据对应的上，那么快照数据就可以被置空了。&lt;/li&gt;
&lt;li&gt;restore：从快照数据中恢复，此时unstable将保存快照数据，同时将offset成员设置成这个快照数据索引的下一位。&lt;/li&gt;
&lt;li&gt;truncateAndAppend：传入日志条目数组，这段数据将添加到entries数组中。但是需要注意的是，传入的数据跟现有的entries数据可能有重合的部分，所以需要根据unstable.offset与传入数据的索引大小关系进行处理，有些数据可能会被截断。&lt;/li&gt;
&lt;li&gt;slice：返回索引范围在[lo-u.offset : hi-u.offset]之间的数据。&lt;/li&gt;
&lt;li&gt;mustCheckOutOfBounds：检查传入的数据索引范围是否合理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;storage接口&#34;&gt;Storage接口&lt;/h3&gt;
&lt;p&gt;Storage接口，提供了存储持久化日志相关的接口操作。其提供出来的接口函数说明如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InitialState() (pb.HardState, pb.ConfState, error)：返回当前的初始状态，其中包括硬状态（HardState）以及配置（里面存储了集群中有哪些节点）。&lt;/li&gt;
&lt;li&gt;Entries(lo, hi, maxSize uint64) ([]pb.Entry, error)：传入起始和结束索引值，以及最大的尺寸，返回索引范围在这个传入范围以内并且不超过大小的日志条目数组。&lt;/li&gt;
&lt;li&gt;Term(i uint64) (uint64, error)：传入日志索引i，返回这条日志对应的任期号。找不到的情况下error返回值不为空，其中当返回ErrCompacted表示传入的索引数据已经找不到，说明已经被压缩成快照数据了；返回ErrUnavailable：表示传入的索引值大于当前的最大索引。&lt;/li&gt;
&lt;li&gt;LastIndex() (uint64, error)：返回最后一条数据的索引。&lt;/li&gt;
&lt;li&gt;FirstIndex() (uint64, error)：返回第一条数据的索引。&lt;/li&gt;
&lt;li&gt;Snapshot() (pb.Snapshot, error)：返回最近的快照数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我对这个接口提供出来的接口函数比较有疑问，因为搜索了etcd的代码，该接口只有MemoryStorage一个实现，而实际上MemoryStorage这个结构体还有其他的函数，比如添加日志数据的操作，但是这个操作并没有在Storage接口中声明。&lt;/p&gt;
&lt;p&gt;接下来看看实现了Storage接口的MemoryStorage结构体的实现，其成员主要包括以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hardState pb.HardState：存储硬状态。&lt;/li&gt;
&lt;li&gt;snapshot  pb.Snapshot：存储快照数据。&lt;/li&gt;
&lt;li&gt;ents []pb.Entry：存储紧跟着快照数据的日志条目数组，即ents[i]保存的日志数据索引位置为i + snapshot.Metadata.Index。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;raftlog的实现&#34;&gt;raftLog的实现&lt;/h3&gt;
&lt;p&gt;有了以上的介绍unstable、Storage的准备之后，下面可以来介绍raftLog的实现，这个结构体承担了raft日志相关的操作。&lt;/p&gt;
&lt;p&gt;raftLog由以下成员组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage Storage：前面提到的存放已经持久化数据的Storage接口。&lt;/li&gt;
&lt;li&gt;unstable unstable：前面分析过的unstable结构体，用于保存应用层还没有持久化的数据。&lt;/li&gt;
&lt;li&gt;committed uint64：保存当前提交的日志数据索引。&lt;/li&gt;
&lt;li&gt;applied uint64：保存当前传入状态机的数据最高索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，一条日志数据，首先需要被提交（committed）成功，然后才能被应用（applied）到状态机中。因此，以下不等式一直成立：applied &amp;lt;= committed。&lt;/p&gt;
&lt;p&gt;raftLog结构体中，几部分数据的排列如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/raftlog.png&#34; alt=&#34;raftlog&#34; title=&#34;raftlog&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个数据排布的情况，可以从raftLog的初始化函数中看出来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;newLog&lt;/span&gt;(storage Storage, logger Logger) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;raftLog {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; storage &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		log.&lt;span style=&#34;color:#00a000&#34;&gt;Panic&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;storage must not be nil&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;raftLog{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		storage: storage,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		logger:  logger,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	firstIndex, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; storage.&lt;span style=&#34;color:#00a000&#34;&gt;FirstIndex&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f&#34;&gt;panic&lt;/span&gt;(err) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// TODO(bdarnell)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	lastIndex, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; storage.&lt;span style=&#34;color:#00a000&#34;&gt;LastIndex&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f&#34;&gt;panic&lt;/span&gt;(err) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// TODO(bdarnell)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// offset从持久化之后的最后一个index的下一个开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	log.unstable.offset = lastIndex &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log.unstable.logger = logger
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Initialize our committed and applied pointers to the time of the last compaction.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// committed和applied从持久化的第一个index的前一个开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	log.committed = firstIndex &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log.applied = firstIndex &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;firstIndex：该值取自storage.FirstIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的第一个数据索引，也就是MemoryStorage结构体中快照数据与日志条目数据的分界线。&lt;/li&gt;
&lt;li&gt;lastIndex：该值取自storage.LastIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的最后一个数据索引。&lt;/li&gt;
&lt;li&gt;unstable.offset：该值为lastIndex索引的下一个位置。&lt;/li&gt;
&lt;li&gt;committed、applied：在初始的情况下，这两个值是firstIndex的上一个索引位置，这是因为在firstIndex之前的数据既然已经是持久化数据了，说明都是已经被提交成功的数据了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，从这里的代码分析可以看出，raftLog的两部分，持久化存储和非持久化存储，它们之间的分界线就是lastIndex，在此之前都是Storage管理的已经持久化的数据，而在此之后都是unstable管理的还没有持久化的数据。&lt;/p&gt;
&lt;p&gt;以上分析中还有一个疑问，为什么并没有初始化unstable.snapshot成员，也就是unstable结构体的快照数据？原因在于，上面这个是初始化函数，也就是节点刚启动的时候调用来初始化存储状态的函数，而unstable.snapshot数据，是在启动之后同步数据的过程中，如果需要同步快照数据时才会去进行赋值修改的数据，因此在这里并没有对它进行操作的地方。&lt;/p&gt;
&lt;h2 id=&#34;raft消息结构体&#34;&gt;raft消息结构体&lt;/h2&gt;
&lt;p&gt;大体而言，raft算法本质上是一个大的状态机，任何的操作例如选举、提交数据等，最后的操作一定是封装成一个消息结构体，输入到raft算法库的状态机中。&lt;/p&gt;
&lt;p&gt;在raft/raftpb/raft.proto文件中，定义了raft算法中传输消息的结构体。熟悉raft论文的都知道，raft算法其实由好几个协议组成，但是在这里，统一定义在了Message这个结构体之中，以下总结了该结构体的成员用途。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MessageType&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息发送者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交日志索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rejectHint&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于这个Message结构体，全部将raft协议相关的数据都定义在了一起，有些协议不是用到其中的全部数据，所以这里的字段都是optinal的，我个人感觉这样不太好，会导致混合在一起显得杂乱无章，所以这里还是将每个协议（即不同的消息类型）中使用的用途做一个记录，如下。&lt;/p&gt;
&lt;h2 id=&#34;msghup消息&#34;&gt;MsgHup消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHup&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不用于节点间通信，仅用于发送给本节点让本节点进行选举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;msgbeat消息&#34;&gt;MsgBeat消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgBeat&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不用于节点间通信，仅用于leader节点在heartbeat定时器到期时向集群中其他节点发送心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;msgprop消息&#34;&gt;MsgProp消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgProp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft库使用者提议（propose）数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;raft库的使用者向raft库propose数据时，最后会封装成这个类型的消息来进行提交，不同类型的节点处理还不尽相同。&lt;/p&gt;
&lt;h3 id=&#34;candidate&#34;&gt;candidate&lt;/h3&gt;
&lt;p&gt;由于candidate节点没有处理propose数据的责任，所以忽略这类型消息。&lt;/p&gt;
&lt;h3 id=&#34;follower&#34;&gt;follower&lt;/h3&gt;
&lt;p&gt;首先会检查集群内是否有leader存在，如果当前没有leader存在说明还在选举过程中，这种情况忽略这类消息；否则转发给leader处理。&lt;/p&gt;
&lt;h3 id=&#34;leader&#34;&gt;leader&lt;/h3&gt;
&lt;p&gt;leader的处理在leader的状态机函数针对MsgProp这种case的处理下，大体如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查entries数组是否没有数据，这是一个保护性检查。&lt;/li&gt;
&lt;li&gt;检查本节点是否还在集群之中，如果已经不在了则直接返回不进行下一步处理。什么情况下会出现一个leader节点发现自己不存在集群之中了？这种情况出现在本节点已经通过配置变化被移除出了集群的场景。&lt;/li&gt;
&lt;li&gt;检查raft.leadTransferee字段，当这个字段不为0时说明正在进行leader迁移操作，这种情况下不允许提交数据变更操作，因此此时也是直接返回的。&lt;/li&gt;
&lt;li&gt;检查消息的entries数组，看其中是否带有配置变更的数据。如果其中带有数据变更而raft.pendingConf为true，说明当前有未提交的配置更操作数据，根据raft论文，每次不同同时进行一次以上的配置变更，因此这里会将entries数组中的配置变更数据置为空数据。&lt;/li&gt;
&lt;li&gt;到了这里可以进行真正的数据propose操作了，将调用raft算法库的日志模块写入数据，根据返回的情况向其他节点广播消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgappmsgsnap消息&#34;&gt;MsgApp/MsgSnap消息&lt;/h2&gt;
&lt;h3 id=&#34;msgapp消息&#34;&gt;MsgApp消息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgApp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向集群中其他节点同步数据的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;索引ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;msgsnap消息&#34;&gt;MsgSnap消息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgSnap&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向follower同步数据用的快照消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果说前面的MsgProp消息是集群中的节点向leader转发用户提交的数据，那么MsgApp消息就是相反的，是leader节点用于向集群中其他节点同步数据的。&lt;/p&gt;
&lt;p&gt;在这里把MsgSnap消息和MsgApp消息放在一起，是因为MsgSnap消息做的事情其实跟前面提到的MsgApp消息是一样的：都是用于leader向follower同步数据。实际上对于leader而言，向某个节点同步数据这个操作，都封装在raft.sendAppend函数中，至于具体用的哪种消息类型由这个函数内部实现。&lt;/p&gt;
&lt;p&gt;那么，什么情况下会用到快照数据来同步呢？raft算法中，任何的数据要提交成功，首先leader会在本地写一份日志，再广播出去给集群的其他节点，只有在超过半数以上的节点同意，leader才能进行提交操作，这一个流程在前面讲解MsgAppResp消息流程时做了解释。&lt;/p&gt;
&lt;p&gt;但是，如果这个日志文件不停的增长，显然是不能接受的。因此，在某些时刻，节点会将日志数据进行压缩处理，就是把当前的数据写入到一个快照文件中。而leader在向某一个节点进行数据同步时，是根据该节点上的日志记录进行数据同步的。&lt;/p&gt;
&lt;p&gt;比方说，leader上已经有最大索引为10的日志数据，而节点A的日志索引是2，那么leader将从3开始向节点A同步数据。&lt;/p&gt;
&lt;p&gt;但是如果前面的数据已经进行了压缩处理，转换成了快照数据，而压缩后的快照数据实际上已经没有日志索引相关的信息了。这时候只能将快照数据全部同步给节点了。还是以前面的流程为例，假如leader上日志索引为7之前的数据都已经被压缩成了快照数据，那么这部分数据在同步时是需要整份传输过去的，只有当同步完成节点赶上了leader上的日志进度时，才开始正常的日志同步流程。
而同步数据时，需要区分两种情况：&lt;/p&gt;
&lt;h2 id=&#34;msgappresp消息&#34;&gt;MsgAppResp消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgAppResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;集群中其他节点针对leader的MsgApp/MsgSnap消息的应答消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝同步日志的请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rejectHint&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在节点收到leader的MsgApp/MsgSnap消息时，可能出现leader上的数据与自身节点数据不一致的情况，这种情况下会返回reject为true的MsgAppResp消息，同时rejectHint字段是本节点raft最后一条日志的索引ID。&lt;/p&gt;
&lt;p&gt;而index字段则返回的是当前节点的日志索引ID，用于向leader汇报自己已经commit的日志数据ID，这样leader就知道下一次同步数据给这个节点时，从哪条日志数据继续同步了。&lt;/p&gt;
&lt;p&gt;leader节点在收到MsgAppResp消息的处理流程大体如下（stepLeader函数中MsgAppResp case的处理流程）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，收到节点的MsgAppResp消息，说明该节点是活跃的，因此保存节点状态的RecentActive成员置为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来，再根据msg.Reject的返回值，即节点是否拒绝了这次数据同步，来区分两种情况进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;msgreject为true的情况&#34;&gt;msg.Reject为true的情况&lt;/h3&gt;
&lt;p&gt;如果msg.Reject为true，说明节点拒绝了前面的MsgApp/MsgSnap消息，根据msg.RejectHint成员回退leader上保存的关于该节点的日志记录状态。比如leader前面认为从日志索引为10的位置开始向节点A同步数据，但是节点A拒绝了这次数据同步，同时返回RejectHint为2，说明节点A告知leader在它上面保存的最大日志索引ID为2，这样下一次leader就可以直接从索引为2的日志数据开始同步数据到节点A。而如果没有这个RejectHint成员，leader只能在每次被拒绝数据同步后都递减1进行下一次数据同步，显然这样是低效的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为上面节点拒绝了这次数据同步，所以节点的状态可能存在一些异常，此时如果leader上保存的节点状态为ProgressStateReplicate，那么将切换到ProgressStateProbe状态（关于这几种状态，下面会谈到）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前面已经按照msg.RejectHint修改了leader上关于该节点日志状态的索引数据，接着再次尝试按照这个新的索引数据向该节点再次同步数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;msgreject为false的情况&#34;&gt;msg.Reject为false的情况&lt;/h3&gt;
&lt;p&gt;这种情况说明这个节点通过了leader的这一次数据同步请求，这种情况下根据msg.Index来判断在leader中保存的该节点日志数据索引是否发生了更新，如果发生了更新那么就说明这个节点通过了新的数据，这种情况下会做以下的几个操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改节点状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果该节点之前在ProgressStateProbe状态，说明之前处于探测状态，此时可以切换到ProgressStateReplicate，开始正常的接收leader的同步数据了。&lt;/li&gt;
&lt;li&gt;如果之前处于ProgressStateSnapshot状态，即还在同步副本，说明节点之前可能落后leader数据比较多才采用了接收副本的状态。这里还需要多做一点解释，因为在节点落后leader数据很多的情况下，可能leader会多次通过snapshot同步数据给节点，而当 pr.Match &amp;gt;= pr.PendingSnapshot的时候，说明通过快照来同步数据的流程完成了，这时可以进入正常的接收同步数据状态了，这就是函数Progress.needSnapshotAbort要做的判断。&lt;/li&gt;
&lt;li&gt;如果之前处于ProgressStateReplicate状态，此时可以修改leader关于这个节点的滑动窗口索引，释放掉这部分数据索引，好让节点可以接收新的数据了。关于这个滑动窗口设计，见下面详细解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;判断是否有新的数据可以提交（commit）了。因为raft的提交数据的流程是这样的：首先节点将数据提议（propose）给leader，leader在将数据写入到自己的日志成功之后，再通过MsgApp把这些提议的数据广播给集群中的其他节点，在某一条日志数据收到超过半数（qurom）的节点同意之后，才认为是可以提交（commit）的。因此每次leader节点在收到一条MsgAppResp类型消息，同时msg.Reject又是false的情况下，都需要去检查当前有哪些日志是超过半数的节点同意的，再将这些可以提交（commit）的数据广播出去。而在没有数据可以提交的情况下，如果之前节点处于暂停状态，那么将继续向该节点同步数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后还要做一个跟leader迁移相关的操作。如果该消息节点是准备迁移过去的新leader节点（raft.leadTransferee == msg.From），而且此时该节点上的Match索引已经跟旧的leader的日志最大索引一致，说明新旧节点的日志数据已经同步，可以正式进行集群leader迁移操作了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgvotemsgprevote消息以及msgvoterespmsgprevoteresp消息&#34;&gt;MsgVote/MsgPreVote消息以及MsgVoteResp/MsgPreVoteResp消息&lt;/h2&gt;
&lt;p&gt;这里把这四种消息放在一起了，因为不论是Vote还是PreVote流程，其请求和应答时传输的数据都是一样的。&lt;/p&gt;
&lt;p&gt;先看请求数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgVote/MsgPreVote&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点投票给自己以进行新一轮的选举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;应答数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgVoteResp/MsgPreVoteResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;投票应答消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;节点调用raft.campaign函数进行投票给自己进行一次新的选举，其中的参数CampaignType有以下几种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;campaignPreElection：对应PreVote的场景。&lt;/li&gt;
&lt;li&gt;campaignElection：正常的选举场景。&lt;/li&gt;
&lt;li&gt;campaignTransfer：由于leader迁移发生的选举。如果是这种类型的选举，那么msg.Context字段保存的是“CampaignTransfer”`字符串，这种情况下会强制进行leader的迁移。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MsgVote还需要带上几个与本节点日志相关的数据（Index、LogTerm），因为raft算法要求，一个节点要成为leader的一个必要条件之一就是这个节点上的日志数据是最新的。&lt;/p&gt;
&lt;h3 id=&#34;prevote&#34;&gt;PreVote&lt;/h3&gt;
&lt;p&gt;这里需要特别解释一下PreVote的场景。&lt;/p&gt;
&lt;p&gt;考虑到一种情况：当出现网络分区的时候，A、B、C、D、E五个节点被划分成了两个网络分区，A、B、C组成的分区和D、E组成的分区，其中的D节点，如果在选举超时到来时，都没有收到来自leader节点A的消息（因为网络已经分区），那么D节点认为需要开始一次新的选举了。&lt;/p&gt;
&lt;p&gt;正常的情况下，节点D应该把自己的任期号term递增1，然后发起一次新的选举。由于网络分区的存在，节点D肯定不会获得超过半数以上的的投票，因为A、B、C三个节点组成的分区不会收到它的消息，这会导致节点D不停的由于选举超时而开始一次新的选举，而每次选举又会递增任期号。&lt;/p&gt;
&lt;p&gt;在网络分区还没恢复的情况下，这样做问题不大。但是当网络分区恢复时，由于节点D的任期号大于当前leader节点的任期号，这会导致集群进行一次新的选举，即使节点D肯定不会获得选举成功的情况下（因为节点D的日志落后当前集群太多，不能赢得选举成功）。&lt;/p&gt;
&lt;p&gt;为了避免这种无意义的选举流程，节点可以有一种PreVote的状态，在这种状态下，想要参与选举的节点会首先连接集群的其他节点，只有在超过半数以上的节点连接成功时，才能真正发起一次新的选举。&lt;/p&gt;
&lt;p&gt;所以，在PreVote状态下发起选举时，并不会导致节点本身的任期号递增1，而只有在进行正常选举时才会将任期号加1进行选举。&lt;/p&gt;
&lt;h3 id=&#34;msgvotemsgprevote的处理流程&#34;&gt;MsgVote/MsgPreVote的处理流程&lt;/h3&gt;
&lt;p&gt;来看看节点对于投票消息的处理，这些处理有两处，但是都在raft.Step函数中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先该函数会判断msg.Term是否大于本节点的Term，如果消息的任期号更大则说明是一次新的选举。这种情况下将根据msg.Context是否等于“CampaignTransfer”字符串来确定是不是一次由于leader迁移导致的强制选举过程。同时也会根据当前的electionElapsed是否小于electionTimeout来确定是否还在租约期以内。如果既不是强制leader选举又在租约期以内，那么节点将忽略该消息的处理，在论文4.2.3部分论述这样做的原因，是为了避免已经离开集群的节点在不知道自己已经不在集群内的情况下，仍然频繁的向集群内节点发起选举导致耗时在这种无效的选举流程中。如果以上检查流程通过了，说明可以进行选举了，如果消息类型还不是MsgPreVote类型，那么此时节点会切换到follower状态且认为发送消息过来的节点msg.From是新的leader。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	case m.Term &amp;gt; r.Term:
		// 消息的Term大于节点当前的Term
		lead := m.From
		if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
			// 如果收到的是投票类消息

			// 当context为campaignTransfer时表示强制要求进行竞选
			force := bytes.Equal(m.Context, []byte(campaignTransfer))
			// 是否在租约期以内
			inLease := r.checkQuorum &amp;amp;&amp;amp; r.lead != None &amp;amp;&amp;amp; r.electionElapsed &amp;lt; r.electionTimeout
			if !force &amp;amp;&amp;amp; inLease {
				// 如果非强制，而且又在租约期以内，就不做任何处理
				// 非强制又在租约期内可以忽略选举消息，见论文的4.2.3，这是为了阻止已经离开集群的节点再次发起投票请求
				// If a server receives a RequestVote request within the minimum election timeout
				// of hearing from a current leader, it does not update its term or grant its vote
				r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)&amp;#34;,
					r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)
				return nil
			}
			// 否则将lead置为空
			lead = None
		}
		switch {
		// 注意Go的switch case不做处理的话是不会默认走到default情况的
		case m.Type == pb.MsgPreVote:
			// Never change our term in response to a PreVote
			// 在应答一个prevote消息时不对任期term做修改
		case m.Type == pb.MsgPreVoteResp &amp;amp;&amp;amp; !m.Reject:
			// We send pre-vote requests with a term in our future. If the
			// pre-vote is granted, we will increment our term when we get a
			// quorum. If it is not, the term comes from the node that
			// rejected our vote so we should become a follower at the new
			// term.
		default:
			r.logger.Infof(&amp;#34;%x [term: %d] received a %s message with higher term from %x [term: %d]&amp;#34;,
				r.id, r.Term, m.Type, m.From, m.Term)
			// 变成follower状态
			r.becomeFollower(m.Term, lead)
		}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在raft.Step函数的后面，会判断消息类型是MsgVote或者MsgPreVote来进一步进行处理。其判断条件是以下两个条件同时成立：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当前没有给任何节点进行过投票（r.Vote == None ），或者消息的任期号更大（m.Term &amp;gt; r.Term ），或者是之前已经投过票的节点（r.Vote == m.From)）。这个条件是检查是否可以还能给该节点投票。&lt;/li&gt;
&lt;li&gt;同时该节点的日志数据是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm) ）。这个条件是检查这个节点上的日志数据是否足够的新。
只有在满足以上两个条件的情况下，节点才投票给这个消息节点，将修改raft.Vote为消息发送者ID。如果不满足条件，将应答msg.Reject=true，拒绝该节点的投票消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	case pb.MsgVote, pb.MsgPreVote:
		// 收到投票类的消息
		// The m.Term &amp;gt; r.Term clause is for MsgPreVote. For MsgVote m.Term should
		// always equal r.Term.
		if (r.Vote == None || m.Term &amp;gt; r.Term || r.Vote == m.From) &amp;amp;&amp;amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) {
			// 如果当前没有给任何节点投票（r.Vote == None）或者投票的节点term大于本节点的（m.Term &amp;gt; r.Term）
			// 或者是之前已经投票的节点（r.Vote == m.From）
			// 同时还满足该节点的消息是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm)），那么就接收这个节点的投票
			r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d&amp;#34;,
				r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
			r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type)})
			if m.Type == pb.MsgVote {
				// Only record real votes.
				// 保存下来给哪个节点投票了
				r.electionElapsed = 0
				r.Vote = m.From
			}
		} else {
			// 否则拒绝投票
			r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d&amp;#34;,
				r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
			r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type), Reject: true})
		}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;msgvoterespmsgprevoteresp的处理流程&#34;&gt;MsgVoteResp/MsgPreVoteResp的处理流程&lt;/h3&gt;
&lt;p&gt;来看节点收到投票应答数据之后的处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点调用raft.poll函数，其中传入msg.Reject参数表示发送者是否同意这次选举，根据这些来计算当前集群中有多少节点给这次选举投了同意票。&lt;/li&gt;
&lt;li&gt;如果有半数的节点同意了，如果选举类型是PreVote，那么进行Vote状态正式进行一轮选举；否则该节点就成为了新的leader，调用raft.becomeLeader函数切换状态，然后开始同步日志数据给集群中其他节点了。&lt;/li&gt;
&lt;li&gt;而如果半数以上的节点没有同意，那么重新切换到follower状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; myVoteRespType:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 计算当前集群中有多少节点给自己投了票
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		gr &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; r.&lt;span style=&#34;color:#00a000&#34;&gt;poll&lt;/span&gt;(m.From, m.Type, !m.Reject)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [quorum:%d] has received %d %s votes and %d vote rejections&amp;#34;&lt;/span&gt;, r.id, r.&lt;span style=&#34;color:#00a000&#34;&gt;quorum&lt;/span&gt;(), gr, m.Type, &lt;span style=&#34;color:#a2f&#34;&gt;len&lt;/span&gt;(r.votes)&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;gr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt; r.&lt;span style=&#34;color:#00a000&#34;&gt;quorum&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; gr:	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果进行投票的节点数量正好是半数以上节点数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; r.state &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; StatePreCandidate {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;campaign&lt;/span&gt;(campaignElection)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			} &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 变成leader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;becomeLeader&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;bcastAppend&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;len&lt;/span&gt;(r.votes) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; gr:	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果是半数以上节点拒绝了投票
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 变成follower
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			r.&lt;span style=&#34;color:#00a000&#34;&gt;becomeFollower&lt;/span&gt;(r.Term, None)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;msgheartbeatmsgheartbeatresp消息&#34;&gt;MsgHeartbeat/MsgHeartbeatResp消息&lt;/h2&gt;
&lt;p&gt;心跳请求消息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHeartbeat&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向follower发送心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交日志索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据，在这里保存一致性读相关的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;心跳请求应答消息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHeartbeatResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于follower向leader应答心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据，在这里保存一致性读相关的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;leader中会定时向集群中其他节点发送心跳消息，该消息的作用除了探测节点的存活情况之外，还包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;commit成员：leader选择min[节点上的Match，leader日志最大提交索引]，用于告知节点哪些日志可以进行提交（commit）。&lt;/li&gt;
&lt;li&gt;context：与线性一致性读相关，后面会进行解释。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgunreachable消息&#34;&gt;MsgUnreachable消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgUnreachable&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于应用层向raft库汇报某个节点当前已不可达&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不可用的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;仅leader才处理这类消息，leader如果判断该节点此时处于正常接收数据的状态（ProgressStateReplicate），那么就切换到探测状态。&lt;/p&gt;
&lt;h2 id=&#34;msgsnapstatus消息&#34;&gt;MsgSnapStatus消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgSnapStatus&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于应用层向raft库汇报某个节点当前接收快照状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;仅leader处理这类消息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果reject为false：表示接收快照成功，将切换该节点状态到探测状态。&lt;/li&gt;
&lt;li&gt;否则接收失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgcheckquorum消息&#34;&gt;MsgCheckQuorum消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgCheckQuorum&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader检查集群可用性的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;leader的定时器函数，在超过选举时间时，如果当前打开了raft.checkQuorum开关，那么leader将给自己发送一条MsgCheckQuorum消息，对该消息的处理是：检查集群中所有节点的状态，如果超过半数的节点都不活跃了，那么leader也切换到follower状态。&lt;/p&gt;
&lt;h2 id=&#34;msgtransferleader消息&#34;&gt;MsgTransferLeader消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgTransferLeader&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于迁移leader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;注意这里不是发送者的ID了，而是准备迁移过去成为新leader的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这类消息follower将转发给leader处理，因为follower并没有修改集群配置状态的权限。&lt;/p&gt;
&lt;p&gt;leader在收到这类消息时，是以下的处理流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果当前的raft.leadTransferee成员不为空，说明有正在进行的leader迁移流程。此时会判断是否与这次迁移是同样的新leader ID，如果是则忽略该消息直接返回；否则将终止前面还没有完毕的迁移流程。&lt;/li&gt;
&lt;li&gt;如果这次迁移过去的新节点，就是当前的leader ID，也直接返回不进行处理。&lt;/li&gt;
&lt;li&gt;到了这一步就是正式开始这一次的迁移leader流程了，一个节点能成为一个集群的leader，其必要条件是上面的日志与当前leader的一样多，所以这里会判断是否满足这个条件，如果满足那么发送MsgTimeoutNow消息给新的leader通知该节点进行leader迁移，否则就先进行日志同步操作让新的leader追上旧leader的日志数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; pb.MsgTransferLeader:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  leadTransferee &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; m.From
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; r.leadTransferee
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; None {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 判断是否已经有相同节点的leader转让流程在进行中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; leadTransferee {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r.id, r.Term, leadTransferee, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果是，直接返回
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 否则中断之前的转让流程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;abortLeaderTransfer&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] abort previous transferring leadership to %x&amp;#34;&lt;/span&gt;, r.id, r.Term, lastLeadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 判断是否转让过来的leader是否本节点，如果是也直接返回，因为本节点已经是leader了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; leadTransferee &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; r.id {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Debugf&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x is already leader. Ignored transferring leadership to self&amp;#34;&lt;/span&gt;, r.id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Transfer leadership to third party.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] starts to transfer leadership to %x&amp;#34;&lt;/span&gt;, r.id, r.Term, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  r.electionElapsed = &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  r.leadTransferee = leadTransferee
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; pr.Match &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; r.raftLog.&lt;span style=&#34;color:#00a000&#34;&gt;lastIndex&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果日志已经匹配了，那么就发送timeoutnow协议过去
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;sendTimeoutNow&lt;/span&gt;(leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log&amp;#34;&lt;/span&gt;, r.id, leadTransferee, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 否则继续追加日志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;sendAppend&lt;/span&gt;(leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;msgtimeoutnow消息&#34;&gt;MsgTimeoutNow消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgTimeoutNow&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;leader迁移时，当新旧leader的日志数据同步后，旧leader向新leader发送该消息通知可以进行迁移了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;新的leader ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;旧的leader的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;新的leader节点，在还未迁移之前仍然是follower，在收到这条消息后，就可以进行迁移了，此时会调用前面分析MsgVote时说过的campaign函数，传入的参数是campaignTransfer，表示这是一次由于迁移leader导致的选举流程。&lt;/p&gt;
&lt;h2 id=&#34;msgreadindex和msgreadindexresp消息&#34;&gt;MsgReadIndex和MsgReadIndexResp消息&lt;/h2&gt;
&lt;p&gt;这两个消息一一对应，使用的成员也一样，在后面分析读一致性的时候再详细解释。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgReadIndex&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于读一致性的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;接收者节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;发送者节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，entries数组只会有一条数据，带上的是应用层此次请求的标识数据，在follower收到MsgReadIndex消息进行应答时，同样需要把这个数据原样带回返回给leader，详细的线性读一致性的实现在后面展开分析。&lt;/p&gt;
&lt;h1 id=&#34;节点状态&#34;&gt;节点状态&lt;/h1&gt;
&lt;p&gt;每个raft的节点，分为以下三种状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;candidate：候选人状态，节点切换到这个状态时，意味着将进行一次新的选举。&lt;/li&gt;
&lt;li&gt;follower：跟随者状态，节点切换到这个状态时，意味着选举结束。&lt;/li&gt;
&lt;li&gt;leader：领导者状态，所有数据提交都必须先提交到leader上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个状态都有其对应的状态机，每次收到一条提交的数据时，都会根据其不同的状态将消息输入到不同状态的状态机中。同时，在进行tick操作时，每种状态对应的处理函数也是不一样的。&lt;/p&gt;
&lt;p&gt;所以raft结构体中将不同的状态，及其不同的处理函数独立出来几个成员变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;保存当前节点状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tick函数&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;tick函数，每个状态对应的tick函数不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;step函数&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;状态机函数，同样每个状态对应的状态机也不相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;raft库中提供几个成员函数becomeCandidate、becomeFollower、becomeLeader分别进入这几种状态的，这些函数中做的事情，概况起来就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;切换raft.state成员到对应状态。&lt;/li&gt;
&lt;li&gt;切换raft.tick函数到对应状态的处理函数。&lt;/li&gt;
&lt;li&gt;切换raft.step函数到对应状态的状态机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;选举流程&#34;&gt;选举流程&lt;/h1&gt;
&lt;p&gt;raft算法的第一步是首先选举出一个leader出来，在没有产生leader的情况下，其他数据提交等操作都无从谈起，所以这里首先从选举的流程开始谈起。&lt;/p&gt;
&lt;h2 id=&#34;发起选举的节点&#34;&gt;发起选举的节点&lt;/h2&gt;
&lt;p&gt;只有在candidate或者follower状态下的节点，才有可能发起一个选举流程，而这两种状态的节点，其对应的tick函数都是raft.tickElection函数，这个函数的主要流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将选举超时递增1。&lt;/li&gt;
&lt;li&gt;当选举超时到期，同时该节点又在集群中时，说明此时可以进行一轮新的选举。此时会向本节点发送HUP消息，这个消息最终会走到状态机函数raft.Step中进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明白了raft.tickElection函数的作用，可以来看选举流程了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;节点启动时都以follower状态启动，同时随机选择自己的选举超时时间。之所以每个节点随机选择自己的超时时间，是为了避免同时有两个节点同时进行选举，这种情况下会出现没有任何一个节点赢得半数以上的投票从而这一轮选举失败，继续再进行下一轮选举&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在follower的tick函数tickElection函数中，当选举超时到时，节点向自己发送HUP消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在状态机函数raft.Step函数中，在收到HUP消息之后，节点首先判断当前有没有没有apply的配置变更消息，如果有就忽略该消息。其原因在于，当有配置更新的情况下不能进行选举操作，即要保证每一次集群成员变化时只能同时变化一个，不能同时有多个集群成员的状态发生变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则进入campaign函数中进行选举：首先将任期号+1，然后广播给其他节点选举消息，带上的其它字段包括：节点当前的最后一条日志索引（Index字段），最后一条日志对应的任期号（LogTerm字段），选举任期号（Term字段，即前面已经进行+1之后的任期号），Context字段（目的是为了告知这一次是否是leader转让类需要强制进行选举的消息）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在一个选举超时之内，该发起新的选举流程的节点，得到了超过半数的节点投票，那么状态就切换到leader状态，成为leader的同时，leader将发送一条dummy的append消息，目的是为了提交该节点上在此任期之前的值（见疑问部分如何提交之前任期的值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;收到选举消息的节点&#34;&gt;收到选举消息的节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当收到任期号大于当前节点任期号的消息，同时该消息类型如果是选举类的消息（类型为prevote或者vote）时，会做以下判断：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先会判断一下该消息是否为强制要求进行选举的类型（context为campaignTransfer，context为这种类型时表示在进行leader转让，流程见下面的leader转让流程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断当前是否在租约期以内，判断的条件包括：checkQuorum为true，当前节点保存的leader不为空，没有到选举超时，前面这三个条件同时满足。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不是强制要求选举，同时又在租约期以内，那么就忽略该选举消息返回不进行处理，这么做是为了避免出现那些离开集群的节点，频繁发起新的选举请求（见论文4.2.3）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不是前面的忽略选举消息的情况，那么除非是prevote类的选举消息，在收到其他消息的情况下，该节点都切换为follower状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时需要针对投票类型中带来的其他字段进行处理了，需要同时满足以下两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有在没有给其他节点进行过投票，或者消息的term任期号大于当前节点的任期号，或者之前的投票给的就是这个发出消息的节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行选举的节点，它的日志是更新的，条件为：logterm比本节点最新日志的任期号大，在两者相同的情况下，消息的index大于等于当前节点最新日志的index，即总要保证该选举节点的日志比自己的大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在同时满足以上两个条件的情况下，才能同意该节点的选举，否则都会被拒绝。这么做的原因是：保证最后能胜出来当新的leader的节点，它上面的日志都是最新的。&lt;/p&gt;
&lt;h1 id=&#34;集群成员变化流程&#34;&gt;集群成员变化流程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;大原则是不能同时进行两个以上的成员变更&lt;/strong&gt;，因为同时进行两个以上的成员变更，可能会出现集群中有两个leader即导致了集群分裂的情况出现。&lt;/p&gt;
&lt;p&gt;成员变化分为以下几种情况：成员删减、leader转让，下面分开讲解。&lt;/p&gt;
&lt;h2 id=&#34;一般的成员删减&#34;&gt;一般的成员删减&lt;/h2&gt;
&lt;p&gt;成员变化操作做为日志的特殊类型，当可以进行commit的情况下，各个节点拿出该消息进行节点内部的成员删减操作。&lt;/p&gt;
&lt;h2 id=&#34;leader转让&#34;&gt;leader转让&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;旧leader在接收到转让leader消息之后，会做如下的判断：
a.  如果新的leader上的日志，已经跟当前leader上的日志同步了，那么发送timeout消息。
b.  否则继续发append消息到新的leader上，目的为了让其能够与旧leader日志同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当旧leader处于转让leader状态时，将停止接收新的prop消息，这样就避免出现在转让过程中新旧leader一直日志不能同步的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当旧leader收到append消息应答时，如果当前处于leader转让状态，那么会判断新的leader日志是否已经与当前leader同步，如果是将发送timeout消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的leader当收到timeout消息时，将使用context为campaignTransfer的选举消息发起新一轮选举，当context为该类型时，此时的选举是强制进行的（见前面的选举流程）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何做到线性一致性&#34;&gt;如何做到线性一致性？&lt;/h1&gt;
&lt;p&gt;线性一致性（Linearizable Read）通俗来讲，就是读请求需要读到最新的已经commit的数据，不会读到老数据。&lt;/p&gt;
&lt;p&gt;由于所有的leader和follower都能处理客户端的读请求，所以存在可能造成返回读出的旧数据的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;leader和follower之间存在状态差，因为follower总是由leader同步过去的，可能会返回同步之前的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发生了网络分区，某个leader实际上已经被隔离出了集群之外，但是该leader并不知道，如果还继续响应客户端的读请求，也可能会返回旧的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在接收到客户端的读请求时，需要保证返回的数据都是当前最新的。&lt;/p&gt;
&lt;h2 id=&#34;readonlysafe方式&#34;&gt;ReadOnlySafe方式&lt;/h2&gt;
&lt;p&gt;leader在接收到读请求时，需要向集群中的超半数server确认自己仍然是当前的leader，这样它返回的就是最新的数据。&lt;/p&gt;
&lt;p&gt;在etcd-raft中，为了实现ReadOnlySafe，有如下的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; ReadState &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Index &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RequestCtx []&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Index：接收到该读请求时，当前节点的commit索引。&lt;/li&gt;
&lt;li&gt;RequestCtx：客户端读请求的唯一标识。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ReadState结构体用于保存读请求到来时的节点状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; readIndexStatus &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; req pb.Message
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; index &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; acks &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;]&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;readIndexStatus数据结构用于追踪leader向follower发送的心跳信息，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;req：保存原始的readIndex请求。&lt;/li&gt;
&lt;li&gt;index：leader当前的commit日志索引。&lt;/li&gt;
&lt;li&gt;acks：存放该readIndex请求有哪些节点进行了应答，当超过半数应答时，leader就可以确认自己还是当前集群的leader。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; readOnly &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; option ReadOnlyOption
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; pendingReadIndex &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;readIndexStatus
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; readIndexQueue []&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;readOnly用于管理全局的readIndx数据，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;option：readOnly选项。&lt;/li&gt;
&lt;li&gt;pendingReadIndex：当前所有待处理的readIndex请求，其中key为客户端读请求的唯一标识。&lt;/li&gt;
&lt;li&gt;readIndexQueue：保存所有readIndex请求的请求唯一标识数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了以上的数据结构介绍，后面是流程介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;server收到客户端的读请求，此时会调用raft.ReadIndex函数发起一个MsgReadIndex的请求，带上的参数是客户端读请求的唯一标识（此时可以对照前面分析的MsgReadIndex及其对应应答消息的格式）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower将向leader直接转发MsgReadIndex消息，而leader收到不论是本节点还是由其他server发来的MsgReadIndex消息，其处理都是：&lt;/p&gt;
&lt;p&gt;a. 首先如果该leader在成为新的leader之后没有提交过任何值，那么会直接返回不做处理。&lt;/p&gt;
&lt;p&gt;b. 调用r.readOnly.addRequest(r.raftLog.committed, m)保存该MsgreadIndex请求到来时的commit索引。&lt;/p&gt;
&lt;p&gt;c. r.bcastHeartbeatWithCtx(m.Entries[0].Data)，向集群中所有其他节点广播一个心跳消息MsgHeartbeat，并且在其中带上该读请求的唯一标识。&lt;/p&gt;
&lt;p&gt;d. follower在收到leader发送过来的MsgHeartbeat，将应答MsgHeartbeatResp消息，并且如果MsgHeartbeat消息中有ctx数据，MsgHeartbeatResp消息将原样返回这个ctx数据。&lt;/p&gt;
&lt;p&gt;e. leader在接收到MsgHeartbeatResp消息后，如果其中有ctx字段，说明该MsgHeartbeatResp消息对应的MsgHeartbeat消息，是收到ReadIndex时leader消息为了确认自己还是集群leader发送的心跳消息。首先会调用r.readOnly.recvAck(m)函数，根据消息中的ctx字段，到全局的pendingReadIndex中查找是否有保存该ctx的带处理的readIndex请求，如果有就在acks map中记录下该follower已经进行了应答。&lt;/p&gt;
&lt;p&gt;f. 当ack数量超过了集群半数时，意味着该leader仍然还是集群的leader，此时调用r.readOnly.advance(m)函数，将该readIndex之前的所有readIndex请求都认为是已经成功进行确认的了，所有成功确认的readIndex请求，将会加入到readStates数组中，同时leader也会向follower发送MsgReadIndexResp。&lt;/p&gt;
&lt;p&gt;g. follower收到MsgReadIndexResp消息时，同样也会更新自己的readStates数组信息。&lt;/p&gt;
&lt;p&gt;h. readStates数组的信息，将做为ready结构体的信息更新给上层的raft协议库的使用者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要特别说明的是，处理读请求时，实际上leader需要确保当前自己是不是leader、该读请求对应的commit索引是否得到了半数投票，而当一个节点刚成为leader的时候，如果没有提交过任何数据，那么在它所在的这个任期（term）内的commit索引当时是并不知道的，因此在成为leader之后，需要马上提交一个no-op的空日志，这样拿到该任期的第一个commit索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/msgreadindex-1.png&#34; alt=&#34;msgreadindex-1&#34; title=&#34;msgreadindex-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，在leader收到MsgReadIndex后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向readOnly中添加与这次请求ctx相关的数据：
&lt;ul&gt;
&lt;li&gt;向pendingReadIndex中添加以ctx为key的readIndexStatus，其中保存了当前的commitIndex、原始的MsgReadIndex消息、以及用于存放有哪些节点应答了该消息的acks数组。&lt;/li&gt;
&lt;li&gt;向readIndexQueue数组中添加ctx。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leader向集群中其他节点广播MsgHeartbeat消息，其中带上这次MsgReadIndex的ctx。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这之后，follower应答leader的MsgHeartbeat消息，如果消息中存在ctx字段都会带上应答，于是leader中的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到MsgHeartbeatResp消息之后，如果发现其中有ctx，就去计算应答有没有超过半数，没有超过半数则返回。&lt;/li&gt;
&lt;li&gt;走到这里就是超过半数应答了，此时拿到新的readIndexStatus数组。&lt;/li&gt;
&lt;li&gt;遍历前面拿到的readIndexStatus数组，生成新的readStates数组。&lt;/li&gt;
&lt;li&gt;放到Ready中下一次给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，分为四步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader检查自己在当前任期有没有commit过一条entry，没有提交过则不允许处理readIndex请求。&lt;/li&gt;
&lt;li&gt;leader记录下来收到readIndex请求时候的commit index，然后leader向集群中所有节点发心跳广播，其中带上readIndex相关的ctx字段。&lt;/li&gt;
&lt;li&gt;当超过半数的节点应答了第二部的心跳消息，说明此时leader还是集群的leader。&lt;/li&gt;
&lt;li&gt;生成新的readStates数组放入Ready结构体中，等待下一次客户端来获取该数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;杂项&#34;&gt;杂项&lt;/h1&gt;
&lt;h2 id=&#34;节点的几种状态&#34;&gt;节点的几种状态&lt;/h2&gt;
&lt;p&gt;一个节点在leader上保存的状态有:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateProbe ProgressStateType = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;iota&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateReplicate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateSnapshot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下来分开解释这几种状态。&lt;/p&gt;
&lt;h3 id=&#34;progressstateprobe&#34;&gt;ProgressStateProbe&lt;/h3&gt;
&lt;p&gt;探测状态，当节点拒绝了最近的append消息时，那么就会进入探测状态，此时leader会试图继续往前追述该节点的日志从哪里开始丢失的，让该节点的日志能跟leader同步上。在probe状态时，只能向它发送一次append消息，此后除非状态发生变化，否则就暂停向该节点发送新的append消息了。&lt;/p&gt;
&lt;p&gt;只有在以下情况才会恢复取消暂停状态（调用Progress的resume函数）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到该节点的心跳消息。&lt;/li&gt;
&lt;li&gt;该节点成功应答了前面的最后一条append消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于Probe状态，只有在该节点成功应答了Append消息之后，在leader上保存的索引值发生了变化，才会修改其状态切换到Replicate状态。&lt;/p&gt;
&lt;h3 id=&#34;progressstatereplicate&#34;&gt;ProgressStateReplicate&lt;/h3&gt;
&lt;p&gt;正常接收副本数据的状态，当处于该状态时，leader在发送副本消息之后，就修改该节点的next索引为发送消息的最大索引+1&lt;/p&gt;
&lt;h3 id=&#34;progressstatesnapshot&#34;&gt;ProgressStateSnapshot&lt;/h3&gt;
&lt;p&gt;接收快照状态。
当leader向某个follower发送append消息，试图让该follower状态跟上leader时，发现此时leader上保存的索引数据已经对不上了，比如leader在index为10之前的数据都已经写入快照中了，但是该follower需要的是10之前的数据，此时就会切换到该状态下，发送快照给该follower。&lt;/p&gt;
&lt;p&gt;因为快照数据可能很多，不知道会同步多久，所以单独把这个状态抽象出来。&lt;/p&gt;
&lt;p&gt;当快照数据同步追上之后，并不是直接切换到Replicate状态，而是首先切换到Probe状态。&lt;/p&gt;
&lt;h2 id=&#34;progress上的数据索引&#34;&gt;Progress上的数据索引&lt;/h2&gt;
&lt;p&gt;Progress结构体中有两个保存该follower节点日志索引的数据，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Next：保存下一次leader发送append消息给该follower时的日志索引。&lt;/li&gt;
&lt;li&gt;Match：保存该follower节点上的最大日志索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在正常情况下，Next = Match + 1，也就是Next总是节点当前保存最大日志索引的下一条索引。&lt;/p&gt;
&lt;p&gt;有两种情况除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收快照状态：此时Next = max(pr.Match+1, pendingSnapshot+1)&lt;/li&gt;
&lt;li&gt;当该follower不在Replicate状态时，说明不是正常的接收副本状态。此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/next-match.jpg&#34; alt=&#34;next-match&#34; title=&#34;next-match&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，节点s1上最大日志索引为2，即Match = 2，Next = 3。
但是，由于新选出来的leader s2，其最大日志索引为3，此时s3需要同步日志到s1上，发现s1上的日志与自己的不匹配，所以会一直找到两者最开始匹配的索引位置，即最终找到索引1，因此会保存s1的Next索引为1，而Match还是2（因为此时还没有修改s1上的日志）。当最终s1上的数据与s2同步时，此时Next = 4，Match=3。&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;Progress结构体中，使用另一个inflights的数据结构用于流量控制。
该结构体使用一个固定大小的循环缓冲区来控制给一个节点同步数据的流量控制，每当给该follower发送同步消息时，就占用该缓冲区的一个空间；反之，当收到该follower的成功接收了该同步消息的应答之后，就释放缓冲区的空间。&lt;/p&gt;
&lt;p&gt;当该缓冲区数据饱和时，将暂停继续同步数据到该follower。&lt;/p&gt;
&lt;p&gt;##快照、日志的存储&lt;/p&gt;
&lt;h1 id=&#34;疑问采集&#34;&gt;疑问采集&lt;/h1&gt;
</description>
      
    </item>
    
  </channel>
</rss>
