<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux系统 on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/linux%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in Linux系统 on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 20 Jun 2020 12:19:08 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/linux%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之Linux系统平均负载</title>
      <link>https://www.codedump.info/post/20200620-sgfap-loadavg/</link>
      <pubDate>Sat, 20 Jun 2020 12:19:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200620-sgfap-loadavg/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;Linux中可以使用uptime、top等命令来查看系统的平均负载情况，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ uptime
 10:54:37 up 29 days,  1:35,  2 users,  load average: 0.81, 0.65, 0.64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的&lt;code&gt;load average: 0.81, 0.65, 0.64&lt;/code&gt;数据，给出了系统在最近1分钟、5分钟、15分钟的系统平均负载情况。&lt;/p&gt;
&lt;p&gt;这一节讲解系统平均负载这个数据的来源，内容包括以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统平均负载值来源于哪里？&lt;/li&gt;
&lt;li&gt;平均负载包括了哪些指标？&lt;/li&gt;
&lt;li&gt;内核是如何计算平均负载值的？&lt;/li&gt;
&lt;li&gt;平均负载的意义是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;平均负载值的来源&#34;&gt;平均负载值的来源&lt;/h1&gt;
&lt;p&gt;通过uptime命令可以看到系统最近1分钟、5分钟以及15分钟的平均负载值，所以要知道这个值的来源，最简单的方式就是了解uptime命令是从哪里获取到这些数据的，一方面可以看uptime命令的代码实现，但是直觉告诉我们一般这类命令都是通过读取/proc文件系统来获取系统的一些指标，所以更简单的方式是strace一下uptime命令，看看都去读取了哪些/proc文件系统的文件，果然看到了如下一行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;openat(AT_FDCWD, &amp;#34;/proc/loadavg&amp;#34;, O_RDONLY) = 4
lseek(4, 0, SEEK_SET)                   = 0
read(4, &amp;#34;0.42 0.20 0.07 3/137 1322\n&amp;#34;, 8191) = 26
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到读取了&lt;code&gt;/proc/loadavg&lt;/code&gt;文件，通过&lt;code&gt;man proc&lt;/code&gt;命令来看看关于这个文件的说明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/proc/loadavg
		The first three fields in this file are load average figures giving the number of jobs in the run queue (state R) or  wait‐
		ing  for  disk  I/O  (state  D) averaged over 1, 5, and 15 minutes.  They are the same as the load average numbers given by
		uptime(1) and other programs.  The fourth field consists of two numbers separated by a slash (/).  The first  of  these  is
		the  number of currently runnable kernel scheduling entities (processes, threads).  The value after the slash is the number
		of kernel scheduling entities that currently exist on the system.  The fifth field is the PID of the process that was  most
		recently created on the system.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上文档中说明了，系统负载的统计数据源，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统当前就绪队列中的进程（处于就绪状态即R状态）；&lt;/li&gt;
&lt;li&gt;以及处于等待IO的不可被信号中断（即D状态）的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;/proc/loadavg&lt;/code&gt;文件的前三个字段，正是uptime命令用于输出系统平均负载的数据来源，可以cat该文件内容来看看：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;➜  ~ cat /proc/loadavg
0.03 0.01 0.00 1/135 1735
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;于是，这里的第一个疑问解决了：&lt;code&gt;uptime&lt;/code&gt;等命令行工具是通过读取&lt;code&gt;/proc/loadavg&lt;/code&gt;文件获取当前系统在最近1分钟、5分钟、15分钟的平均负载值。&lt;/p&gt;
&lt;h2 id=&#34;负载进程来源&#34;&gt;负载进程来源&lt;/h2&gt;
&lt;p&gt;在前面的描述中，提到了参与计算平均负载的进程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统当前就绪队列中的进程（处于就绪状态即R状态）；&lt;/li&gt;
&lt;li&gt;以及处于等待IO的不可被信号中断（即D状态）的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处于R状态的进程被算入其中符合预期，因为系统负载本来就是对CPU这一项资源的度量，但是处于等待I/O并未占用CPU资源的D状态进程也被算入其中就让人有些意外了。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&#34;&gt;Linux Load Averages: Solving the Mystery&lt;/a&gt;一文中，&lt;code&gt;Brendan Gregg&lt;/code&gt;详细探究了Linux系统这么做的原因，有兴趣的读者可以点开链接看看这篇文章。简单的把结论放在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Linux系统中，平均负载就是&lt;code&gt;system load avg&lt;/code&gt;，包括了正在工作和在等待工作（磁盘IO、锁等）的进程。与此等价的说法是，在Linux系统中平均负载反映的是系统中所有非idle的进程。&lt;/li&gt;
&lt;li&gt;而在非Linux系统中，平均负载只包括运行已经就绪准备运行的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由以上可知，在Linux系统中，通过&lt;code&gt;uptime&lt;/code&gt;等命令查看出来的平均负载如果突然变高，并不见得就是系统一定出现了问题，不能简单的把负载数量除以CPU资源数量，因为其中可能包括了在等待磁盘I/O的D状态进程。在上文中，提到了如果发现系统负载突然升高，还可以配合以下手段进一步查验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每CPU利用率: mpstat -P ALL 1&lt;/li&gt;
&lt;li&gt;每进程的CPU利用率：top, pidstat 1&lt;/li&gt;
&lt;li&gt;每线程的run queue调度延迟：/proc/PID/schedstats, delaystats, perf sched&lt;/li&gt;
&lt;li&gt;CPU run queue延迟：/proc/schedstat, perf sched, runqlat, bcc工具&lt;/li&gt;
&lt;li&gt;CPU run queue队列长度：vmstat 1的&lt;code&gt;r&lt;/code&gt;列，runqlen bcc工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两个是利用率指标，可用来识别工作负载的特征；后三个是饱和度指标，可用来进行性能分析。除了CPU量化，还可以对磁盘I/O进行量化。这些命令具体的使用后续章节会给出。&lt;/p&gt;
&lt;p&gt;以上，解决了系统负载数据的来源问题，接着又有了下一个疑问：&lt;code&gt;/proc&lt;/code&gt;文件系统是内核用于输出一些系统状态的文件系统，内核又是如何计算系统的平均负载值的？&lt;/p&gt;
&lt;h1 id=&#34;内核如何计算平均负载&#34;&gt;内核如何计算平均负载&lt;/h1&gt;
&lt;h2 id=&#34;指数平滑法&#34;&gt;指数平滑法&lt;/h2&gt;
&lt;p&gt;内核不可能一直监控着内核中的进程数量，更现实的做法是隔一段时间采集一组数据，再与前面的数据一起来预测当前的系统负载。如果将过去和现在的数据都同等对待，给予同样的权重，那么计算公式就是简单的使用过去的数据加上现在的数据来求平均值。&lt;/p&gt;
&lt;p&gt;然而如果这样的话，过去的数据就和现在的数据一样重要。很显然，在使用数据来预测未来时，还是更近的数据权重更高更有说服力。&lt;/p&gt;
&lt;p&gt;在这部分，内核采用的方式是所谓的指数平滑法（Exponential smoothing），其思想在于：给当前采集的数据，以及上一次采集周期的数据分别以权重值，通过把两部分加成起来计算平滑均值，公式如下：&lt;/p&gt;
&lt;p&gt;$$ load_t = α * x_{t- 1} + n * (1 - α) * load_{t-1} $$&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$load_t$：时间t的平滑平均值。&lt;/li&gt;
&lt;li&gt;$x_{t-1}$：时间t-1的实际值。&lt;/li&gt;
&lt;li&gt;$s_{t-1}$：时间t-1的平滑平均值。&lt;/li&gt;
&lt;li&gt;α：平滑常数（平滑因子），范围在[0,1]之间。&lt;/li&gt;
&lt;li&gt;n：当前时间的活跃进程数（状态为是RUNNABLE状态和TASK_UNINTERRUPTIBLE状态的进程数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，这里的平滑常数α，如果趋近于1，则$s_{t-1}$对$s_t$的影响越小。&lt;/p&gt;
&lt;p&gt;内核就是通过这个算法来计算最近5分钟，10分钟，十五分钟的平滑均值。&lt;/p&gt;
&lt;p&gt;其中的平滑常数，Linux内核是这样来选择的：&lt;/p&gt;
&lt;p&gt;$$ α = e^{-5/(60*m)} $$&lt;/p&gt;
&lt;p&gt;其中:
5：表示5s，作分子。
60：表示60s。
m: 表示分钟，1, 5, 15。 60 * m作为分母。&lt;/p&gt;
&lt;p&gt;把m带入到公式计算，分别能计算出α为0.920044415，0.983471454，0.994459848&lt;/p&gt;
&lt;h2 id=&#34;定点运算fixed-point-arithmetic&#34;&gt;定点运算（Fixed-point arithmetic）&lt;/h2&gt;
&lt;p&gt;然而即便是这样，内核也不能直接计算系统的平均负载，因为内核并不能直接进行浮点计算。&lt;/p&gt;
&lt;p&gt;因此，需要首先把浮点数运算转换成定点数运算，采用的办法就是将浮点数乘以相应进制的n次方，其中n为保留的小数点的位数。比如3.1415926，如果要转换成只保留3位小数的定点数运算，就需要乘以1000，也就是得到3141，后面的926丢弃。&lt;/p&gt;
&lt;p&gt;在这里，Linux内核将上面的平滑常数α转换成2进制的定点数，其中保留的精度为11位，因此：&lt;/p&gt;
&lt;p&gt;$$ 0.920044415 * 2^{11} = 1884 $$
$$ 0.983471454 * 2^{11} = 2014 $$
$$ 0.994459848 * 2^{11} = 2037 $$&lt;/p&gt;
&lt;h2 id=&#34;linux内核的实现代码&#34;&gt;Linux内核的实现代码&lt;/h2&gt;
&lt;p&gt;有了前面的分析，可以看到通过“指数退避算法”，并不需要详细的保存过去1分钟、5分钟、15分钟的所有负载值来做计算，而是在每次计算的时候，拿到当前的值以及上一次保存的值，套用到前面的公式计算即可，这样做的好处是只需要保持一份上一次的数据即可。同时，由于需要拿到就绪状态以及不可中断中断状态的进程数量之和，也是通过采样的方式去定时获取这个值，默认是5秒采样一次。&lt;/p&gt;
&lt;p&gt;与平均负载计算相关的几个宏列举如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;（linux/sched.h）
#define FSHIFT		11		/* nr of bits of precision */
#define FIXED_1		(1&amp;lt;&amp;lt;FSHIFT)	/* 1.0 as fixed-point */
#define LOAD_FREQ	(5*HZ+1)	/* 5 sec intervals */
#define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */
#define EXP_5		2014		/* 1/exp(5sec/5min) */
#define EXP_15		2037		/* 1/exp(5sec/15min) */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FSHIFT：计算精度，可以看到是11位精度。&lt;/li&gt;
&lt;li&gt;FIXED_1：2进程11位精度下的1.0。&lt;/li&gt;
&lt;li&gt;LOAD_FREQ：计算间隔，5秒计算一次平均负载。&lt;/li&gt;
&lt;li&gt;EXP_1、EXP_5、EXP_15：1分钟、5分钟、15分钟平滑时间常数的2进程11位精度定点数，也就是前面定点计算部分介绍的预计算出来的几个常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核中根据“指数退避算法”计算平均负载的工作由函数&lt;code&gt;calc_load&lt;/code&gt;完成：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(sched/proc.c)

/*
 * a1 = a0 * e + a * (1 - e)
 */
static unsigned long
calc_load(unsigned long load, unsigned long exp, unsigned long active)
{
	load *= exp;
	load += active * (FIXED_1 - exp);
	load += 1UL &amp;lt;&amp;lt; (FSHIFT - 1);
	return load &amp;gt;&amp;gt; FSHIFT;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，该函数的内容，就是通过前面列举出来的宏，套用指数退避算法的公式计算即可。&lt;/p&gt;
&lt;p&gt;内核中使用数组&lt;code&gt;avenrun&lt;/code&gt;来保存上一次计算得到的1分钟、5分钟、15分钟的平均负载，每一次的计算结果保存在这个数组之中，下一次再计算的时候将上次保存的结果拿出来做为这一次计算的参数就好。&lt;/p&gt;
&lt;p&gt;有了算法、数据，最后就是介绍计算的触发点以及入口函数了，这个函数是内核中的&lt;code&gt;calc_global_load&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
 * calc_load - update the avenrun load estimates 10 ticks after the
 * CPUs have updated calc_load_tasks.
 */
void calc_global_load(unsigned long ticks)
{
	long active, delta;

	if (time_before(jiffies, calc_load_update + 10))
		return;

	/*
	 * Fold the &amp;#39;old&amp;#39; idle-delta to include all NO_HZ cpus.
	 */
	delta = calc_load_fold_idle();
	if (delta)
		atomic_long_add(delta, &amp;amp;calc_load_tasks);

	active = atomic_long_read(&amp;amp;calc_load_tasks);
	active = active &amp;gt; 0 ? active * FIXED_1 : 0;

	avenrun[0] = calc_load(avenrun[0], EXP_1, active);
	avenrun[1] = calc_load(avenrun[1], EXP_5, active);
	avenrun[2] = calc_load(avenrun[2], EXP_15, active);

	calc_load_update += LOAD_FREQ;

	/*
	 * In case we idled for multiple LOAD_FREQ intervals, catch up in bulk.
	 */
	calc_global_nohz();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;系统平均负载的意义&#34;&gt;系统平均负载的意义&lt;/h1&gt;
&lt;p&gt;从以上的分析，可以看出来，“系统平均负载”值反映的是系统在过去一段时间中，“就绪状态进程数量”加上“不可被中断进程数量”之和的一种趋势，只是进程状态的一些统计信息，和CPU的使用率并没有直接关系。&lt;/p&gt;
&lt;p&gt;因为“系统平均负载”统计了这两类进程的总和，所以如果仔细区分起来，与CPU使用率可能存在以下几种关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中有大量CPU密集型的进程，比如大量进程都在进行计算，此时的系统平均负载与CPU使用率的关联就很大。&lt;/li&gt;
&lt;li&gt;系统中有大量IO密集型进程，这些进程中有很多时间都在等待IO完成，此时系统平均负载高但是CPU使用率并不见得就高。&lt;/li&gt;
&lt;li&gt;就绪队列中有大量处于就绪状态等待CPU资源的进程，这种情况下会导致系统平均负载升高，而且CPU使用率也变高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，当发现系统平均负载升高时，还需要其他工具来查看究竟是上面的哪种情况。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;uptime等查看当前CPU负载的命令，通过读取/proc/loadavg文件获取最近1分钟、5分钟、15分钟系统的平均负载。&lt;/li&gt;
&lt;li&gt;Linux计算平均负载时包括了R状态进程和D状态进程，Linux系统中平均负载反映的是系统中所有非idle的进程。在发现Linux系统平均负载升高时需要配合其他工具一起查证。&lt;/li&gt;
&lt;li&gt;内核使用指数平滑法来计算系统的平均负载。&lt;/li&gt;
&lt;li&gt;最近1分钟、5分钟、15分钟系统的平均负载反映的是系统负载的趋势走向，而不是一个精准的值。&lt;/li&gt;
&lt;li&gt;内核在计算平均负载时，将相应的参数转换为定点数进行计算，保留的数据精度是11位，计算间隔是5秒一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html&#34;&gt;Linux Load Averages: Solving the Mystery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之软中断</title>
      <link>https://www.codedump.info/post/20200522-sgfap-softirq/</link>
      <pubDate>Fri, 22 May 2020 21:52:58 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200522-sgfap-softirq/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;中断（interrupt）通常被定义为一个事件，该事件改变处理器执行的指令顺序。中断分为同步和异步两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步中断在指令执行时由CPU控制单元产生，之所以称为同步，是因为只有在一条指令终止执行后CPU才发生中断。&lt;/li&gt;
&lt;li&gt;异步中断是由其他硬件设备依照CPU时钟信号随机产生的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Intel的处理器手册中，将同步中断称为“异常（exception）”，异步中断称为“中断”。&lt;/p&gt;
&lt;p&gt;异常通常由程序的错误产生，或者是由内核必须处理的异常条件产生的。比如程序中有除零异常，比如进程运行过程中产生的“缺页异常（pagefault）”等，都属于异常。&lt;/p&gt;
&lt;p&gt;而中断是由定时器和I/O设备产生的，比如用户的一次按键、网卡收到数据，都会产生中断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200522-sgfap-softirq/interrupt-type.png&#34; alt=&#34;interrupt-type&#34; title=&#34;interrupt-type&#34;&gt;&lt;/p&gt;
&lt;p&gt;处理器一旦收到中断，就必须打断当前的执行，转而去执行中断处理函数。中断处理函数，本身有一些缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能在进程上下文中执行，因此不能阻塞。&lt;/li&gt;
&lt;li&gt;中断处理程序会打断程序执行，为了避免这个打断的流程停止时间过长，所以应该执行的越短越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为以上的原因，Linux内核将中断的处理分为了上下两部分，其中上半部就是前面提到的中断处理函数，这部分能够最快的响应中断，并且做一些中断后必须要做的事情，而一些可以在中断处理函数后继续执行的操作，则可以放在下半部中。&lt;/p&gt;
&lt;p&gt;以网卡接收到数据来举例，网卡通过中断告诉内核有数据可以接收，此时内核就会到网卡的中断处理程序中执行一些网卡硬件的必要设置，而对应的下半部就是处理网卡收到的数据，因为处理网卡数据没有必要在中断处理函数里面马上执行。&lt;/p&gt;
&lt;p&gt;两者的主要区别在于：中断不能被相同类型的中断打断，而下半部依然可以被中断打断；中断对于时间非常敏感，而下半部基本上都是一些可以延迟的工作。由于二者的这种区别，所以对于一个工作是放在上半部还是放在下半部去执行，可以参考下面4条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个任务对时间非常敏感，将其放在中断处理程序中执行。&lt;/li&gt;
&lt;li&gt;如果一个任务和硬件相关，将其放在中断处理程序中执行。&lt;/li&gt;
&lt;li&gt;如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。&lt;/li&gt;
&lt;li&gt;其他所有任务，考虑放在下半部去执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有写内核任务需要延后执行，因此才有的下半部，进而实现了三种实现下半部的方法。这就是本文要讨论的软中断、tasklet和工作队列。&lt;/p&gt;
&lt;h1 id=&#34;软中断&#34;&gt;软中断&lt;/h1&gt;
&lt;p&gt;软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）。软中断一般是“可延迟函数”的总称，有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：&lt;/p&gt;
&lt;p&gt;产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断(即单个cpu上软中断不能嵌套执行)，只能被硬件中断打断（上半部）。
可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保其数据结构。&lt;/p&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;软中断由系统在启动的时候注册到内核中，由一个全局数组来维护软中断：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; softirq_action
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;	(&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;action)(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; softirq_action &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，本质上结构体softirq_action存储的是函数指针而已，软中断有以下类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;enum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HI_SOFTIRQ&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理高优先级的tasklet
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	TIMER_SOFTIRQ,    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 定时器的下半部
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	NET_TX_SOFTIRQ,   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 网卡发送数据包
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	NET_RX_SOFTIRQ,   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 网卡接收数据包
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	BLOCK_SOFTIRQ,    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// BLOCK装置     
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	IRQ_POLL_SOFTIRQ, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	TASKLET_SOFTIRQ,  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理常规的tasklet
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	SCHED_SOFTIRQ,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	HRTIMER_SOFTIRQ, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	RCU_SOFTIRQ,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	NR_SOFTIRQS
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;系统提供了open_softirq函数用于各个需要使用到软中断的系统注册对应的软中断处理函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;open_softirq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nr, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;action)(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; softirq_action &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	softirq_vec[nr].action &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; action;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同时，还提供了softirq_to_name数组，用于把软中断的索引映射到对应的软中断名称：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; softirq_to_name[NR_SOFTIRQS] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;HI&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;TIMER&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;NET_TX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;NET_RX&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;BLOCK&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;IRQ_POLL&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;TASKLET&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;SCHED&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;HRTIMER&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;RCU&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Linux下面，可以通过查看&lt;code&gt;/proc/softirqs&lt;/code&gt;文件知道当前系统软中断的情况：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:     276180     286764    2509097     254357
       TIMER:    1550133    1285854    1440533    1812909
      NET_TX:     102895         16         15         57
      NET_RX:        155        178        115    1619192
       BLOCK:       1713      15048     251826       1082
    IRQ_POLL:          0          0          0          0
     TASKLET:          9         63          6       2830
       SCHED:    1484942    1207449    1310735    1724911
     HRTIMER:          0          0          0          0
         RCU:     690954     685825     787447     878963
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;触发软中断&#34;&gt;触发软中断&lt;/h2&gt;
&lt;p&gt;触发软中断的入口函数是raise_softirq：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;raise_softirq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; flags;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_save(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	raise_softirq_irqoff(nr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_restore(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，由于调用软中断处理函数必须禁用中断，所以local_irq_save宏将保存在eflags寄存器中的IF标志，同时禁用本地处理器的中断。对应的，local_irq_restore宏将保存下来的flags标志位恢复回去，同时打开本地处理器的中断。&lt;/p&gt;
&lt;p&gt;接着看raise_softirq_irqoff函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;raise_softirq_irqoff&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	__raise_softirq_irqoff(nr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;in_interrupt())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		wakeup_softirqd();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，调用&lt;code&gt;__raise_softirq_irqoff&lt;/code&gt;将本地处理器的中&lt;code&gt;__softirq_pending&lt;/code&gt;变量对应nr这个软中断的位置为1，表示该类型的软中断被触发了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后，通过&lt;code&gt;in_interrupt&lt;/code&gt;函数来判断处理器当前是否在处理中断状态，如果没有则调用&lt;code&gt;wakeup_softirqd&lt;/code&gt;函数唤醒本处理器的&lt;code&gt;ksoftirqd&lt;/code&gt;内核进程：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;wakeup_softirqd&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;tsk &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __this_cpu_read(ksoftirqd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (tsk &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; tsk&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; TASK_RUNNING)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		wake_up_process(tsk);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Linux系统中，每个CPU都会运行一个&lt;code&gt;ksoftirqd&lt;/code&gt;内核进程，专门由这个进程来处理本CPU的软中断。&lt;code&gt;ksoftirqd&lt;/code&gt;内核进程的主要流程在函数&lt;code&gt;__do_softirq&lt;/code&gt;中完成，其核心是一个循环，用来检测当前有哪些未处理的软中断，调用其注册的处理函数来处理软中断：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;asmlinkage __visible &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; __softirq_entry &lt;span style=&#34;color:#00a000&#34;&gt;__do_softirq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; ((softirq_bit &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ffs(pending))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		trace_softirq_entry(vec_nr);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 记录开始处理软中断的trace event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		h&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;action(h);									&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调用注册的软中断处理函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		trace_softirq_exit(vec_nr);		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 记录结束处理软中断的trace event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200522-sgfap-softirq/softirq.png&#34; alt=&#34;softirq&#34; title=&#34;softirq&#34;&gt;&lt;/p&gt;
&lt;p&gt;总结来说，要触发一个软中断只需要以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存IF标志，禁用中断。&lt;/li&gt;
&lt;li&gt;将这个软中断对应的位置为1。&lt;/li&gt;
&lt;li&gt;通知本CPU的ksoftirqd内核进程，有软中断需要处理。&lt;/li&gt;
&lt;li&gt;恢复IF标志，开启中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到，有了软中断机制，内核在禁用中断的状态中实际上并没有耗费太多时间，仅仅修改了一个标记然后唤醒&lt;code&gt;ksoftirqd&lt;/code&gt;内核进程就可以返回了。&lt;/p&gt;
&lt;h1 id=&#34;tasklet&#34;&gt;tasklet&lt;/h1&gt;
&lt;p&gt;软中断有以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能在系统启动时注册，另外数量和类型不能动态变更。&lt;/li&gt;
&lt;li&gt;因为每个处理器上都有一个&lt;code&gt;ksoftirqd&lt;/code&gt;内核进程，可能同时在处理同一种类型的软中断，软中断必须实现为可重入函数，导致开发上的复杂度提高。如果某种应用并不需要在多个CPU上并行执行，那么软中断是没有必要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此基于软中断之上又实现tasklet，这是最常见的实现延迟中断处理的机制。它具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种类型的tasklet只能运行在一个CPU上，不能并行而只能串行执行。&lt;/li&gt;
&lt;li&gt;多个不同类型的tasklet可以并行在多个CPU上。&lt;/li&gt;
&lt;li&gt;软中断是静态，只能支持有限的几种软中断类型，一旦内核编译好之后就不能改变；而tasklet灵活很多，可以通过添加内核模块的方式在运行时修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行。&lt;/p&gt;
&lt;p&gt;首先来看初始化，对应的是softirq_init函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; __init &lt;span style=&#34;color:#00a000&#34;&gt;softirq_init&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	for_each_possible_cpu(cpu) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		per_cpu(tasklet_vec, cpu).tail &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;per_cpu(tasklet_vec, cpu).head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		per_cpu(tasklet_hi_vec, cpu).tail &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;per_cpu(tasklet_hi_vec, cpu).head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，tasklet各有一个基于TASKLET_SOFTIRQ和HI_SOFTIRQ两个类型软中断的tasklet，这两个类型分别对应低优先级和高优先级的tasklet，变量tasklet_vec和tasklet_hi_vec的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_head {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;tail;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;DEFINE_PER_CPU&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_head, tasklet_vec);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;DEFINE_PER_CPU&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_head, tasklet_hi_vec);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两个变量分别定义了两个存储tasklet_struct结构体的链表。结构体tasklet_struct定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中包含了五个成员变量，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struct tasklet_struct *next：链表中下一个成员的指针。&lt;/li&gt;
&lt;li&gt;unsigned long state：tasklet的状态。&lt;/li&gt;
&lt;li&gt;atomic_t count：原子变量，表示这个tasklet当前是否活跃。&lt;/li&gt;
&lt;li&gt;void (*func)(unsigned long)：处理这个tasklet的回调函数。&lt;/li&gt;
&lt;li&gt;unsigned long data：回调函数参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;触发tasklet&#34;&gt;触发tasklet&lt;/h2&gt;
&lt;p&gt;内核通过函数tasklet_schedule触发一个tasklet被执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tasklet_schedule&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;t)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;test_and_set_bit(TASKLET_STATE_SCHED, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;t&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		__tasklet_schedule(t);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，使用test_and_set_bit函数判断t-&amp;gt;state中的TASKLET_STATE_SCHED是否被置为1，如果没有则调用函数__tasklet_schedule调度tasklet来执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/softirq.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;__tasklet_schedule&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;t)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; flags;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_save(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	t&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;__this_cpu_read(tasklet_vec.tail) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	__this_cpu_write(tasklet_vec.tail, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;(t&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	raise_softirq_irqoff(TASKLET_SOFTIRQ);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_restore(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数首先和前面软中断的处理一样，保存IF标志位同时禁用中断，然后修改tasklet_vec链表将新增的tasklet添加到链表尾部，调用raise_softirq_irqoff触发TASKLET_SOFTIRQ类型的软中断执行，最后恢复IF标志位同时启用中断。&lt;/p&gt;
&lt;p&gt;在函数softirq_init中，两类用于处理tasklet的处理函数分别是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着看函数tasklet_action的实现，其核心就是从前面的链表中依次取出tasklet_struct结构体数据调用其处理函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/softirq.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; __latent_entropy &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;tasklet_action&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; softirq_action &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;list;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (list) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tasklet_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;t &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; list;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		t&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;func(t&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的工作流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用local_irq_disable禁用本地CPU的中断。&lt;/li&gt;
&lt;li&gt;从tasklet_vec链表头取出头元素list。&lt;/li&gt;
&lt;li&gt;调用local_irq_enable启用本地CPU的中断。&lt;/li&gt;
&lt;li&gt;接着，就是遍历整个tasklet_vec链表，依次处理这些tasklet了。每次取出一个tasklet的时候，也是像前面一样应用本地CPU的中断，取出之后再开启中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;workqueue&#34;&gt;workqueue&lt;/h1&gt;
&lt;p&gt;workqueue是另外一种延迟处理中断的机制。与tasklet相比，两者有以下的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;workqueue函数运行在内核进程上下文中（context of kernel process），而tasklet运行在中断上下文中。&lt;/li&gt;
&lt;li&gt;tasklet都在它最初被触发的CPU中执行，而workqueue则没有这个限制。&lt;/li&gt;
&lt;li&gt;如果处理函数执行过程中需要睡眠和阻塞，那就必须使用工作队列了。软中断运行在中断上下文中，因此不能阻塞和睡眠，而tasklet使用软中断实现，所以也不能阻塞和睡眠。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据结构-1&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;内核使用结构体worker_pool来管理所有CPU上面的worker，在这里仅列举其中的一部分成员：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/workqueue.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; worker_pool {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	spinlock_t		lock;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* the pool lock */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			cpu;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* I: the associated cpu */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			node;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* I: the associated node ID */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			id;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* I: pool ID */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;		flags;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* X: flags */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt;		watchdog_ts;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: watchdog timestamp */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; list_head	worklist;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: list of pending works */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			nr_workers;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: total number of workers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;worker_pool中管理的每个worker如下定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/workqueue_internal.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; worker {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* on idle list while idle, on busy hash table while busy */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;union&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; list_head	entry;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: while idle */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; hlist_node	hentry;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: while busy */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; work_struct	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;current_work;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: work being processed */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	work_func_t		current_func;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: current_work&amp;#39;s fn */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; pool_workqueue	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;current_pwq; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: current_work&amp;#39;s pwq */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;			desc_valid;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -&amp;gt;desc is valid */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; list_head	scheduled;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* L: scheduled works */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个CPU上运行的kworker进程：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ps aux | grep kworker
root         4  0.0  0.0      0     0 ?        I&amp;lt;   1月30   0:00 [kworker/0:0H]
root        18  0.0  0.0      0     0 ?        I&amp;lt;   1月30   0:00 [kworker/1:0H]
root        24  0.0  0.0      0     0 ?        I&amp;lt;   1月30   0:00 [kworker/2:0H]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;添加任务到workqueue&#34;&gt;添加任务到workqueue&lt;/h2&gt;
&lt;p&gt;内核提供函数queue_work将任务放入workqueue中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// include/linux/workqueue.h
static inline bool queue_work(struct workqueue_struct *wq,
			      struct work_struct *work)
{
	return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着看函数queue_work_on：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/workqueue.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;queue_work_on&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; workqueue_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wq,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; work_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;work)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; ret &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; flags;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_save(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		__queue_work(cpu, wq, work);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		ret &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	local_irq_restore(flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它做的事情很简单，同样也是前后禁用、启用中断，在判断WORK_STRUCT_PENDING_BIT被置为1失败之后，调用__queue_work将任务放入workqueue：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;__queue_work&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; workqueue_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wq,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			 &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; work_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;work)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ....
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (req_cpu &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; WORK_CPU_UNBOUND)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		cpu &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; wq_select_unbound_cpu(raw_smp_processor_id());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;(wq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; WQ_UNBOUND))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		pwq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; per_cpu_ptr(wq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cpu_pwqs, cpu);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		pwq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; unbound_pwq_by_node(wq, cpu_to_node(cpu));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	insert_work(pwq, work, worklist, work_flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里裁剪掉无关的代码，来看核心的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，如果work加入时未指定要运行的CPU，通过wq_select_unbound_cpu进行选择，默认使用当前CPU。如果该CPU不在wq_unbound_cpumask (全局 cpumask)内，则从wq_unbound_cpumask中通过round robin方式选择。&lt;/li&gt;
&lt;li&gt;对于 bound workqueue ，取出当前 per CPU变量中的pool_workqueue 。对于unbound workqueue，取出当前CPU 所在node对应的pool_workqueue。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在kwork内核进程内部，最终会在函数&lt;code&gt;process_one_work&lt;/code&gt;中处理work：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/workqueue.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;process_one_work&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; worker &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;worker, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; work_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;work)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	trace_workqueue_execute_start(work);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 记录开始处理work的trace event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	worker&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;current_func(work);						&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调用work的处理函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	trace_workqueue_execute_end(work);		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 记录结束处理work的trace event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;使用systemtap追踪软中断&#34;&gt;使用systemtap追踪软中断&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;systemtap&lt;/code&gt;上提供了可以跟踪软中断以及工作队列的&lt;code&gt;probe&lt;/code&gt;事件，可以在&lt;code&gt;systemtap&lt;/code&gt;的&lt;code&gt;tapset\linux\irq.stp&lt;/code&gt;中看到相关的定义，比较简单这里就不做解释，这里仅列举网上看到的一个使用这些tapset来追踪软中断事件的例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global hard, soft, wq
 
// 记录硬中断
probe irq_handler.entry {
  hard[irq, dev_name]++;
}
 
// 每隔一秒打印中断、软中断、工作队列的统计信息
probe timer.s(1) {
  println(&amp;#34;==irq number:dev_name&amp;#34;)
  foreach( [irq, dev_name] in hard- limit 5) {
    printf(&amp;#34;%d,%s-&amp;gt;%d\n&amp;#34;, irq, kernel_string(dev_name), hard[irq, dev_name]);       
  }
 
  println(&amp;#34;==softirq cpu:h:vec:action&amp;#34;)
  foreach(  in soft- limit 5) {
    printf(&amp;#34;%d:%x:%x:%s-&amp;gt;%d\n&amp;#34;, c, h, vec, symdata(action), soft);       
  }
 
  println(&amp;#34;==workqueue wq_thread:work_func&amp;#34;)
  foreach( [wq_thread,work_func] in wq- limit 5) {
    printf(&amp;#34;%x:%x-&amp;gt;%d\n&amp;#34;, wq_thread, work_func, wq[wq_thread, work_func]);  
  }
 
  println(&amp;#34;\n&amp;#34;)
  delete hard
  delete soft
  delete wq
}
 
// 统计软中断
probe softirq.entry {
  soft[cpu(), h,vec,action]++;
}
 
// 统计工作队列执行信息
probe workqueue.execute {
  wq[wq_thread, work_func]++
}
 
 
probe begin {
  println(&amp;#34;~&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;参考文献&#34;&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html&#34;&gt;Redis 高负载下的中断优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.yufeng.info/archives/2037&#34;&gt;MYSQL数据库网卡软中断不平衡问题及解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/alantu2018/p/8527205.html&#34;&gt;Linux内核中的软中断、tasklet和工作队列详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之系统调用</title>
      <link>https://www.codedump.info/post/20200516-sgfap-syscall/</link>
      <pubDate>Sat, 16 May 2020 16:31:03 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200516-sgfap-syscall/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;应用程序需要使用内核提供出来的一些功能，才能完成相应的操作，这个由内核提供出来给用户态程序调用的接口，就是“系统调用（system call）”。比如打开文件时需要调用&lt;code&gt;open&lt;/code&gt;系统调用，写文件时需要调用&lt;code&gt;write&lt;/code&gt;系统调用，等等。&lt;/p&gt;
&lt;p&gt;本节将简单描述Linux在X86下系统调用的工作原理，接着描述如何追踪用户层进程的系统调用。&lt;/p&gt;
&lt;h1 id=&#34;系统调用原理&#34;&gt;系统调用原理&lt;/h1&gt;
&lt;h2 id=&#34;传统系统调用legacy-system-calls&#34;&gt;传统系统调用（Legacy system calls）&lt;/h2&gt;
&lt;p&gt;在这里先讨论系统调用的传统实现方式，在这里需要解决以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态怎么触发系统调用？&lt;/li&gt;
&lt;li&gt;用户态怎么传递参数给系统调用？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核预留了一个特殊的软中断号 128 (0x80)，用户空间程序使用它可以进入内核执行系统调用，在内核中定义了宏&lt;code&gt;IA32_SYSCALL_VECTOR&lt;/code&gt;与之对应：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// arch/x86/include/asm/irq_vectors.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define IA32_SYSCALL_VECTOR		0x80
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;触发给软中断时会调用到汇编编写的函数&lt;code&gt;	entry_INT80_32&lt;/code&gt;中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// arch/x86/kernel/idt.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;entry_INT80_32&lt;/code&gt;函数在&lt;code&gt;arch/x86/entry/entry_32.S&lt;/code&gt;中实现，其最终会走到&lt;code&gt;do_int80_syscall_32&lt;/code&gt;函数中调用系统调用。&lt;/p&gt;
&lt;p&gt;以上解决了第一个问题，即用户态通过触发软中断&lt;code&gt;int 0x80&lt;/code&gt;来调用系统调用的，接下来的问题是，内核如何知道调用的是哪个系统调用，以及怎么解决给系统调用传递参数的问题。&lt;/p&gt;
&lt;p&gt;在函数&lt;code&gt;entry_INT80_32&lt;/code&gt;的注释中，看到有如下的描述：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// arch/x86/entry/entry_32.S
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * Arguments:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * eax  system call number
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * ebx  arg1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * ecx  arg2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * edx  arg3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * esi  arg4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * edi  arg5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * ebp  arg6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见，寄存器&lt;code&gt;eax&lt;/code&gt;中存放的是系统调用编号，接下来的几个寄存器分别存放传递进来的参数。&lt;/p&gt;
&lt;p&gt;于是上面的两个疑问也解决了。&lt;/p&gt;
&lt;p&gt;内核中使用一个数组，来具体保存具体系统调用编号与其实现函数的对应关系，该数组名称为&lt;code&gt;ia32_sys_call_table&lt;/code&gt;，因此在最后一步调用系统调用时，代码是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// arch/x86/entry/common.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; __always_inline &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;do_syscall_32_irqs_on&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; pt_regs &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;regs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ax &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ia32_sys_call_table[nr](
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;bx, (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cx,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;dx, (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;si,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;di, (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;)regs&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;bp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而数组&lt;code&gt;ia32_sys_call_table&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// arch/x86/syscall_32.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;__visible &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; sys_call_ptr_t ia32_sys_call_table[__NR_syscall_compat_max&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;	 * Smells like a compiler bug -- it doesn&amp;#39;t work
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;	 * when the &amp;amp; below is removed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;	 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; ... __NR_syscall_compat_max] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;sys_ni_syscall,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;asm/syscalls_32.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见，会以&lt;code&gt;sys_ni_syscall&lt;/code&gt;的值来初始化数组&lt;code&gt;ia32_sys_call_table&lt;/code&gt;，&lt;code&gt;sys_ni_syscall&lt;/code&gt;是由汇编定义的一个大数组，内部就是各种系统调用对应的处理函数，在此不再列出。&lt;/p&gt;
&lt;p&gt;把以上流程大体总结如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-syscall/legacy-syscalls.png&#34; alt=&#34;legacy-syscalls&#34; title=&#34;legacy-syscalls&#34;&gt;&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过0x80（128）号软中断触发系统调用。&lt;/li&gt;
&lt;li&gt;触发系统调用时，&lt;code&gt;eax&lt;/code&gt;寄存器存储了系统调用编号，而其余的几个寄存器存储了传入系统调用的参数。&lt;/li&gt;
&lt;li&gt;内核使用一个大的系统调用数组来存储系统调用编号与其处理函数的对应关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写一个简单的程序来演示一下上面这个调用系统调用的流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; syscall_nr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; exit_status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;asm&lt;/span&gt; (&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;movl %0, %%eax&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 编号为0的系统调用是exit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;             &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;movl %1, %%ebx&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 传入ebx寄存器的参数输入的参数1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;       &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;int $0x80&amp;#34;&lt;/span&gt;                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 触发软中断0x80
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt; (syscall_nr), &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt; (exit_status) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 输出参数，其中$0即syscall_nr表示输入参数的数量，$1表示传入系统调用的参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* registers that we are &amp;#34;clobbering&amp;#34;, unneeded since we are calling exit */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;eax&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;ebx&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，编号为0的系统调用是&lt;code&gt;exit&lt;/code&gt;，传入给它的参数是&lt;code&gt;42&lt;/code&gt;，因此执行之后的结果如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;快速系统调用&#34;&gt;快速系统调用&lt;/h2&gt;
&lt;p&gt;以上是传统的系统调用实现，由于源头使用的是软中断，所以其效率并不高。为了加速系统调用的速度，Intel CPU又提供了专门给系统调用使用的指令，称为“快速系统调用（Fast System Call）指令”，分别都包含了进入内核和离开内核的指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 32bit 系统上，使用 sysenter 和 sysexit&lt;/li&gt;
&lt;li&gt;在 64bit 系统上，使用 syscall 和 sysret&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，并不打算讨论这些指令的原理，唯一需要说明的是，前面通过软中断触发系统调用时，使用的寄存器在这种情况并不适用，以64位系统来说，其分别使用以下寄存器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;%rax：存储系统调用编号。&lt;/li&gt;
&lt;li&gt;%rdi、%rsi、%rdx、%r10、%r8、%r9：依次存储传入系统调用的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，前面的演示代码如果换用了快速系统调用指令可以修改如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; syscall_nr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;60&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; exit_status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;asm&lt;/span&gt; (&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;movq %0, %%rax&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;movq %1, %%rdi&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;syscall&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* output parameters, we aren&amp;#39;t outputting anything, no none */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* (none) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt; (syscall_nr), &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;m&amp;#34;&lt;/span&gt; (exit_status)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* registers that we are &amp;#34;clobbering&amp;#34;, unneeded since we are calling exit */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;rax&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;rdi&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果同上面一样。&lt;/p&gt;
&lt;h2 id=&#34;现实中的系统调用&#34;&gt;现实中的系统调用&lt;/h2&gt;
&lt;p&gt;以上简述了系统调用的实现原理，然后现实代码中，绝大部分时候，是通过&lt;code&gt;glibc&lt;/code&gt;这样的C库来封装系统调用的。&lt;/p&gt;
&lt;p&gt;C语言标准中定义了一系列标准函数，只要支持C语言标准的编译器都应该实现这些函数，而&lt;code&gt;glibc&lt;/code&gt;这样的库负责封装C标准库函数，转换为对应的系统调用。&lt;/p&gt;
&lt;p&gt;以C库中的标准函数&lt;code&gt;fwrite&lt;/code&gt;为例来说明，其流程图大体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-syscall/glibc-syscall.png&#34; alt=&#34;glibc-syscall&#34; title=&#34;glibc-syscall&#34;&gt;&lt;/p&gt;
&lt;p&gt;引入&lt;code&gt;glibc&lt;/code&gt;这样的中间层有以下几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C标准库是一套独立于具体平台的标准，不同的系统虽然内部实现不同，但是只要声称是支持C标准的编译器其都应该实现这些标准的库函数，&lt;code&gt;glibc&lt;/code&gt;的存在屏蔽了各个平台具体内部的实现，使用者只需要调用这些标准C函数即可，不需要关心各个系统的实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glibc&lt;/code&gt;能够优化用户进程系统调用的次数和频率，以上面的&lt;code&gt;fwrite&lt;/code&gt;来说，并不是每一次&lt;code&gt;fwrite&lt;/code&gt;都马上会转换成一次&lt;code&gt;write&lt;/code&gt;系统调用，&lt;code&gt;glibc&lt;/code&gt;库会将这些写操作进行缓存再一次性调用系统调用写入以达到减少系统调用的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，以上的两个演示程序中，都是使用的在C代码中嵌入汇编的方式来调用系统调用，而实际上Linux已经提供了调用一个系统调用的函数，可以&lt;code&gt;man 2 syscall&lt;/code&gt;看看如何使用，这里不再阐述。&lt;/p&gt;
&lt;h1 id=&#34;追踪系统调用&#34;&gt;追踪系统调用&lt;/h1&gt;
&lt;p&gt;由于系统调用会进入内核态，其中会涉及到用户态数据参数的传入、用户态切换到内核态等操作，所以系统调用是常见的系统杀手之一。常见的跟踪一个进程都调用了哪些系统调用的方式，可以使用&lt;code&gt;strace&lt;/code&gt;命令来完成，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ strace cat /dev/null
execve(&amp;#34;/bin/cat&amp;#34;, [&amp;#34;cat&amp;#34;, &amp;#34;/dev/null&amp;#34;], [/* 37 vars */]) = 0
brk(NULL)                               = 0x1c55000
access(&amp;#34;/etc/ld.so.nohwcap&amp;#34;, F_OK)      = -1 ENOENT (No such file or directory)
access(&amp;#34;/etc/ld.so.preload&amp;#34;, R_OK)      = -1 ENOENT (No such file or directory)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，&lt;code&gt;strace&lt;/code&gt;只有系统调用的名称，没有耗时、统计等功能，在这里接下来会演示一些与系统调用相关的&lt;code&gt;systemtap&lt;/code&gt;脚本的使用。&lt;/p&gt;
&lt;h2 id=&#34;查询系统调用&#34;&gt;查询系统调用&lt;/h2&gt;
&lt;p&gt;系统调用都以&lt;code&gt;syscall&lt;/code&gt;为前缀，因此可以这样查询系统调用，需要过滤则搭配&lt;code&gt;grep&lt;/code&gt;命令即可，比如想查询系统调用&lt;code&gt;open&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;syscall.*&amp;#39; | grep open
syscall.mq_open name:string name_uaddr:long filename:string u_attr_uaddr:long oflag:long oflag_str:string mode:long argstr:string $u_name:long int $oflag:long int $mode:long int $u_attr:long int
syscall.open filename:string mode:long __nr:long name:string flags:long flags_str:string argstr:string $filename:long int $flags:long int $mode:long int
syscall.open_by_handle_at name:string mount_dfd:long mount_dfd_str:string handle_uaddr:long flags:long flags_str:string argstr:string $mountdirfd:long int $handle:long int $flags:long int
syscall.openat name:string dfd:long dfd_str:string filename:string flags:long flags_str:string mode:long argstr:string $dfd:long int $filename:long int $flags:long int $mode:long int
syscall.perf_event_open name:string attr_uaddr:long pid:long cpu:long group_fd:long flags:long flags_str:string argstr:string $attr_uptr:long int $pid:long int $cpu:long int $group_fd:long int $flags:long int $ret:long int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，如果只是查询系统上的系统调用，实际上并不需要祭出&lt;code&gt;systemtap&lt;/code&gt;这把牛刀，这里只是做一个简单的演示。&lt;/p&gt;
&lt;h2 id=&#34;查询系统调用的时长&#34;&gt;查询系统调用的时长&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Systemtap&lt;/code&gt;脚本中，在&lt;code&gt;.return&lt;/code&gt;后缀里，可以通过使用&lt;code&gt;@entry&lt;/code&gt;操作符，在函数被调用的时候存储一个值，比如存储进入这个系统调用时的时间，然后在这里再进行计算。因此可以这样打印出进程调用了某个系统调用的耗时：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// syscall-time.stp
probe syscall.$1.return {
  if (target() != 0 &amp;amp;&amp;amp; target() != pid()) next

  time = gettimeofday_us()-@entry(gettimeofday_us())
  printf(&amp;#34;[%s:%d] syscall.%s time: %d\n&amp;#34;, execname(), pid(), @1, time)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo stap syscall-time.stp open -x 15055

[top:15055] syscall.open time: 3
[top:15055] syscall.open time: 2
[top:15055] syscall.open time: 2
[top:15055] syscall.open time: 2
[top:15055] syscall.open time: 3
[top:15055] syscall.open time: 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该脚本中，传入要追踪的系统调用名称（本例中是&lt;code&gt;open&lt;/code&gt;），以及要监控的进程pid，输出该进程中每次调用这个系统调用耗费的时间。&lt;/p&gt;
&lt;p&gt;另外，其实&lt;code&gt;systemtap&lt;/code&gt;的&lt;code&gt;tapset&lt;/code&gt;中已经封装了对任何系统调用的&lt;code&gt;probe&lt;/code&gt;事件：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// tapset/linux/syscall_any.stp
probe syscall_any = kernel.trace(&amp;#34;sys_enter&amp;#34;)
{
	__set_syscall_pt_regs($regs)
	syscall_nr = $id
	name = syscall_name($id)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，&lt;code&gt;syscall_any&lt;/code&gt;在内核的trace事件&lt;code&gt;sys_enter&lt;/code&gt;中被触发，变量&lt;code&gt;syscall_nr&lt;/code&gt;存储了系统调用编号，而&lt;code&gt;name&lt;/code&gt;存储了系统调用名称。因此如果要跟进任何的系统调用，可以类似下面的脚本这么来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe syscall_any {
    entry_time[tid()] = gettimeofday_ns();
    sys[tid()] = syscall_nr
}
probe syscall_any.return {
    et = entry_time[tid()]
    id = sys[tid()]
    delete entry_time[tid()]
    delete sys[tid()]
    if (et)
       arr[pid(), id] += (gettimeofday_ns() - et)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;查询占用时间最长的系统调用&#34;&gt;查询占用时间最长的系统调用&lt;/h2&gt;
&lt;p&gt;既然可以拿到每个系统调用的时间，就可以使用&lt;code&gt;systemtap&lt;/code&gt;中的统计函数对调用的系统调用进行统计，定时输出统计结果，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# syscall-count.stp
global follow_fork = 0
global thread_time
global time_count

global syscalls_nonreturn[2]
probe begin
{
	/* list those syscalls that never .return */
	syscalls_nonreturn[&amp;#34;exit&amp;#34;]=1
	syscalls_nonreturn[&amp;#34;exit_group&amp;#34;]=1
}

function filter_p()
{
	if (target() == 0) return 0; /* system-wide */
	if (!follow_fork &amp;amp;&amp;amp; pid() != target()) return 1; /* single-process */
	if (follow_fork &amp;amp;&amp;amp; !target_set_pid(pid())) return 1; /* multi-process */
	return 0;
}

# 任何一次系统调用
probe nd_syscall.*
{
	if (filter_p()) next;

	thread_time[execname(),pid(),name]=gettimeofday_us()
}

# 任何一次系统调用返回
probe nd_syscall.*.return
{
	if (filter_p()) next;
	if (name in syscalls_nonreturn) next

	s = thread_time[execname(),pid(),name]
	if (s!=0) {
		time_count[execname(),pid(),name] &amp;lt;&amp;lt;&amp;lt; gettimeofday_us() - s
		delete thread_time[execname(),pid(),name]
	}
}

probe timer.s(1) {
  printf(&amp;#34;[exe:pid]syscall time:count\n\n&amp;#34;)
  foreach ([exe,pid,name] in time_count- limit 10)
    printf(&amp;#34;[%s:%d]%s %d:%d\n&amp;#34;, exe,pid,name, @sum(time_count[exe, pid,name]), @count(time_count[exe, pid,name]))
  delete time_count
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出举例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap syscall-count.stp -x 2449 -T 2 -w
[exe:pid]syscall time:count

[dockerd:2449]futex 504414:18
[dockerd:2449]pselect6 640:10
[dockerd:2449]epoll_wait 500719:6
[dockerd:2449]read 55:4
[dockerd:2449]write 54:2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个脚本注意以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为要追踪所有的系统调用，实际耗时是很长的，所以在查询完毕有对应的系统调用之后，再具体看特定的系统调用。&lt;/li&gt;
&lt;li&gt;有一些系统调用是不会返回的，其作用就是退出进程，比如exit和exit_group，在begin的时候把这两个系统调用记录下来，不针对它们打印时间了。&lt;/li&gt;
&lt;li&gt;可以根据全局变量follow_fork来控制是否跟踪子进程。&lt;/li&gt;
&lt;li&gt;在这里没有办法使用前面例子中的@entry操作符，因为它不能用在通配符的探针函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;打印系统调用的用户调用栈&#34;&gt;打印系统调用的用户调用栈&lt;/h2&gt;
&lt;p&gt;如果已经知道是哪个系统函数的耗时最多，此时就可以具体打印到底是哪些进程调用栈调用了这个系统调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# syscall-backtrace.stp
global backtrace

probe syscall.$1.call {
  if (target() != 0 &amp;amp;&amp;amp; target() != pid()) next

  backtrace[execname(), pid(), ubacktrace()] &amp;lt;&amp;lt;&amp;lt; 1
}

probe timer.s(1) {
  foreach ([exe,pid,ubt] in backtrace- limit 10) {
    printf(&amp;#34;[%s:%d]%s %d\n&amp;#34;, exe,pid,name, @count(backtrace[exe, pid,ubt]))
    print_usyms(ubt);
  }
  delete backtrace
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个脚本当每次调用系统调用时，记录其用户调用栈，然后在定时器中打印出来。&lt;/p&gt;
&lt;p&gt;直接打印用户调用栈可能只能得到一串十六进制的地址，此时最好使用&lt;code&gt;print_usyms&lt;/code&gt;这个tapset函数，对应的内核调用栈就使用&lt;code&gt;print_syms&lt;/code&gt;，当然即便是这样，在没有调试符号信息的情况下也只能输出十六进制地址。&lt;/p&gt;
&lt;p&gt;输出示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap syscall-backtrace.stp futex -x 2449 -T 2 -w --all-modules
[dockerd:2449] 30
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;
&lt;p&gt;在本节中，简单描述了系统调用的实现原理，其传统方式采用软中断实现，这种方式的效率较低，更新的办法使用了CPU提供的专门针对系统调用的指令来实现。绝大部分情况下，用户进程并不会直接使用系统调用来访问内核的资源，而是通过&lt;code&gt;glibc&lt;/code&gt;封装好的C语言标准库来完成工作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strace&lt;/code&gt;命令可以打印一个用户进程在运行过程中调用的系统调用，然而这些信息对于跟踪进程和系统的行为还不够，因为没有系统调用相关的统计、耗时等信息，这时候&lt;code&gt;systemtap&lt;/code&gt;又发挥了作用，本节的最后介绍了&lt;code&gt;systemtap&lt;/code&gt;如何追踪系统及进程系统调用行为的一些脚本示例。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://arthurchiao.art/blog/system-call-definitive-guide-zh/&#34;&gt;[译] Linux 系统调用权威指南（2016）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/&#34;&gt;LINUX SYSTEM CALL TABLE FOR X86 64&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之使用systemtap分析进程的行为</title>
      <link>https://www.codedump.info/post/20200503-sgfap-process-systemtap/</link>
      <pubDate>Sun, 03 May 2020 14:32:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200503-sgfap-process-systemtap/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;以上描述进程的创建、执行、调度器的工作原理，有了这些准备之后，可以使用systemtap在系统中埋点进行一些跟踪，以便理解进程的行为。&lt;/p&gt;
&lt;h1 id=&#34;分析进程对cpu的占用&#34;&gt;分析进程对CPU的占用&lt;/h1&gt;
&lt;p&gt;简单回顾一下前面进程调度相关的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核中使用就绪队列来维护当前所有处于可运行状态的进程，可运行状态不包括等待IO、休眠等状态的进程。&lt;/li&gt;
&lt;li&gt;进程调度器负责从就绪队列中选择处于可运行状态的进程来执行。&lt;/li&gt;
&lt;li&gt;而所有不处于可运行状态的进程，并不占用CPU资源，这些进程都等待被相关的事件比如网络IO唤醒，唤醒之后的进程更改状态为可运行状态，同时加入到就绪队列中，然后才能被调度器算法选择执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个进程的整个生命周期中，虽然看上去进程一直存在，但是并不是所有时候都占用CPU资源。根据CPU占用资源与否，或者说当前是否在运行，分为&lt;code&gt;on cpu&lt;/code&gt;和&lt;code&gt;off cpu&lt;/code&gt;状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-systemtap/onoffcpu.png&#34; alt=&#34;onoffcpu&#34; title=&#34;onoffcpu&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中就一个进程执行的时间线做了简单的阶段划分，其中省略掉了进程被创建出来和最后退出时的情况，仅列出占用CPU资源状态的切换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程占用CPU获得执行权的时候，称为&lt;code&gt;on cpu&lt;/code&gt;时间。&lt;/li&gt;
&lt;li&gt;进程因为各种原因（被其他进程抢占、自己调用了sleep系统调用主动进入睡眠状态、等待网络IO等）被剥夺了执行权的时候，首先会调用&lt;code&gt;deactivate_task&lt;/code&gt;函数从就绪队列中删除，接下来调用&lt;code&gt;context_switch&lt;/code&gt;函数进行进程的上下文切换，这个时候旧的进程失去CPU的执行权，此时正式进入&lt;code&gt;off cpu&lt;/code&gt;时间中。&lt;/li&gt;
&lt;li&gt;在此之后，进程由于各种原因被唤醒，唤醒之后首先会被再次调用&lt;code&gt;activate_task&lt;/code&gt;函数加入到就绪队列中，进入就绪队列的进程也并不是马上就能够获得执行权的，是由进程调度算法来决定哪一个在就绪队列中的进程来执行。这段时间又可以分为两个部分：
&lt;ul&gt;
&lt;li&gt;进程被切换出去直到重新进入就绪队列，这部分时间内进程等待被唤醒。&lt;/li&gt;
&lt;li&gt;进入就绪队列到被调度器选中执行，这部分时间内进程等待被调度执行。&lt;/li&gt;
&lt;li&gt;以上两部分时间的总和，加起来就是进程休眠的时间，即处于&lt;code&gt;off cpu&lt;/code&gt;状态的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这里看出来，一个进程虽然看上去一直存在，但并不是所有时间都在执行，跟进一个程序的运行时间时，需要区分其&lt;code&gt;on&lt;/code&gt;和&lt;code&gt;off&lt;/code&gt; cpu的时间，如果off的时间过长，那需要看看是什么原因导致了进程一直没有被唤醒执行。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，进程处于就绪状态，并不一定就是在运行，有可能还在就绪队列中等待被调度执行；但是反之则不然，一个占用CPU在执行的进程，其状态一定是就绪状态。即：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;进程处于就绪状态的时间 = 进程在就绪队列的时间 + 进程在执行的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于&lt;code&gt;off cpu&lt;/code&gt;这一概念，&lt;a href=&#34;http://www.brendangregg.com/offcpuanalysis.html&#34;&gt;Off-CPU Analysis&lt;/a&gt;一文中有更多的讲述。&lt;/p&gt;
&lt;p&gt;有了上面对&lt;code&gt;on cpu&lt;/code&gt;和&lt;code&gt;off cpu&lt;/code&gt;的介绍，下面来看看使用systemtap如何跟踪这些状态以及所处的时间。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu&#34;&gt;off CPU&lt;/h2&gt;
&lt;p&gt;systemtap中自带的tapset中，有一个scheduler.stp文件，里面定义了与调度器相关的一些probe。&lt;/p&gt;
&lt;p&gt;其中跟踪&lt;code&gt;off cpu&lt;/code&gt;的probe是&lt;code&gt;scheduler.cpu_off&lt;/code&gt; ：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe scheduler.cpu_off =
	kernel.trace(&amp;#34;sched_switch&amp;#34;) !,
	kernel.function(&amp;#34;context_switch&amp;#34;)
{
    name = &amp;#34;cpu_off&amp;#34;
    task_prev = $prev
    task_next = $next
    idle = __is_idle()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结合代码和最开始的示意图，可以知道该probe事件是针对内核trace事件&lt;code&gt;sched_switch&lt;/code&gt;以及内核函数&lt;code&gt;context_switch&lt;/code&gt;的封装，这两个事件都在进程上下文切换时触发。&lt;/p&gt;
&lt;p&gt;在该probe事件中，能获取到的参数是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;task_prev：保存切换之前的进程&lt;code&gt;task_struct&lt;/code&gt;结构体。&lt;/li&gt;
&lt;li&gt;task_next：保存切换之后的进程&lt;code&gt;task_struct&lt;/code&gt;结构体。&lt;/li&gt;
&lt;li&gt;idle：表示当前CPU是否空闲。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为这个probe事件记录了进程切换前后的信息，因此可以用来完成类似记录系统切换最多的进程跟踪的功能：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-stp&#34; data-lang=&#34;stp&#34;&gt;global csw_count
global idle_count
 
probe scheduler.cpu_off {
  csw_count[task_prev, task_next]++
  idle_count+=idle
}

function fmt_task(task_prev, task_next)
{
   return sprintf(&amp;#34;%s(%d)-&amp;gt;%s(%d)&amp;#34;,
                                task_execname(task_prev),
                                task_pid(task_prev),
                                task_execname(task_next),
                                task_pid(task_next))
}
 
function print_cswtop () {
  printf (&amp;#34;%45s %10s\n&amp;#34;, &amp;#34;Context switch&amp;#34;, &amp;#34;COUNT&amp;#34;)
  foreach ([task_prev, task_next] in csw_count- limit 20) {
    printf(&amp;#34;%45s %10d\n&amp;#34;, fmt_task(task_prev, task_next), csw_count[task_prev, task_next])
  }
  printf(&amp;#34;%45s %10d\n&amp;#34;, &amp;#34;idle&amp;#34;, idle_count)
 
  delete csw_count
  delete idle_count
}
 
probe timer.s($1) {
  print_cswtop ()
  printf(&amp;#34;--------------------------------------------------------------\n&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（脚本出自文章&lt;a href=&#34;https://blog.yufeng.info/archives/747&#34;&gt;Linux下谁在切换我们的进程&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;该脚本在&lt;code&gt;scheduler.cpu_off&lt;/code&gt;中累加进程切换的次数，然后在定时器中按照进程切换次数进行排序输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap process/cswmon.stp 1 -T 2
                               Context switch      COUNT
           swapper/0(0)-&amp;gt;update-manager(3926)        515
           update-manager(3926)-&amp;gt;swapper/0(0)        514
                     Xorg(1418)-&amp;gt;swapper/2(0)        430
                     swapper/2(0)-&amp;gt;Xorg(1418)        429
                   swapper/1(0)-&amp;gt;compiz(1855)         59
                   compiz(1855)-&amp;gt;swapper/1(0)         59
               swapper/3(0)-&amp;gt;bamfdaemon(1733)         57
               bamfdaemon(1733)-&amp;gt;swapper/3(0)         57
               Xorg(1418)-&amp;gt;kworker/2:0(28665)         51
               kworker/2:0(28665)-&amp;gt;Xorg(1418)         50
                   swapper/3(0)-&amp;gt;rcu_sched(8)         12
                   rcu_sched(8)-&amp;gt;swapper/3(0)         12
                  swapper/2(0)-&amp;gt;dockerd(2449)         12
                  dockerd(2449)-&amp;gt;swapper/2(0)         12
             swapper/2(0)-&amp;gt;kworker/2:0(28665)         11
             kworker/2:0(28665)-&amp;gt;swapper/2(0)         11
          swapper/0(0)-&amp;gt;docker-containe(2563)          8
          docker-containe(2563)-&amp;gt;swapper/0(0)          8
            swapper/1(0)-&amp;gt;kworker/u8:1(28452)          8
            kworker/u8:1(28452)-&amp;gt;swapper/1(0)          8
                                         idle       1202
--------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;on-cpu&#34;&gt;on CPU&lt;/h2&gt;
&lt;p&gt;与&lt;code&gt;scheduler.cpu_off&lt;/code&gt;相反的是，&lt;code&gt;scheduler.cpu_on&lt;/code&gt;就是追踪进程获得CPU执行权时的probe事件了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe scheduler.cpu_on = kernel.function(&amp;#34;finish_task_switch&amp;#34;) ?
{
    name = &amp;#34;cpu_on&amp;#34;
    task_prev = $prev
    idle = __is_idle()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内核函数在&lt;code&gt;finish_task_switch&lt;/code&gt;在完成进程切换时被调用，其中的参数&lt;code&gt;task_prev&lt;/code&gt;记录的是被切换出去的进程&lt;code&gt;task_struct&lt;/code&gt;结构体指针。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;scheduler.cpu_off&lt;/code&gt;是在&lt;code&gt;context_switch&lt;/code&gt;函数中被触发，而&lt;code&gt;scheduler.cpu_on&lt;/code&gt;是在&lt;code&gt;finish_task_switch&lt;/code&gt;函数中被触发，&lt;code&gt;context_switch&lt;/code&gt;函数中调用了&lt;code&gt;finish_task_switch&lt;/code&gt;函数来完成进程上下文切换的工作，这时候才意味着新的进程真正获得了执行权。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-systemtap/context_switch_probe.png&#34; alt=&#34;context_switch_probe&#34; title=&#34;context_switch_probe&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，可以认为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scheduler.cpu_off&lt;/code&gt;：在这个调用点上一个执行进程失去执行权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler.cpu_on&lt;/code&gt;：在这个调用点下一个执行进程得到执行权，正式开始执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用&lt;code&gt;scheduler.cpu_on&lt;/code&gt; probe事件，同时搭配上进程进出就绪队列的函数调用，就可以知道一个进程在从就绪队列中删除以及重新回到就绪队列，中间的延迟时间有多少。&lt;/p&gt;
&lt;p&gt;比如systemtap安装包中提供的例子脚本&lt;a href=&#34;https://sourceware.org/systemtap/examples/profiling/latencytap.stp&#34;&gt;latencytap.stp&lt;/a&gt;，其工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核函数&lt;code&gt;activate_task&lt;/code&gt;和&lt;code&gt;deactivate_task&lt;/code&gt;分别是进程进出就绪队列的函数调用点，两者之间的时间差值就是进程等待就绪的时间差。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheduler.cpu_on&lt;/code&gt;中将上一步的就绪时间差记录到统计数组中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述核心代码简略如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe kernel.trace(&amp;#34;deactivate_task&amp;#34;) !,
      kernel.function(&amp;#34;deactivate_task&amp;#34;) {
  s = task_state($p)
  # 只有满足TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE状态的才记录
  if (log_event($p) &amp;amp;&amp;amp; (s &amp;amp; 3)) {
    # 在离队队列中记录下来当前的时间
    dequeue[$p] = gettimeofday_us();
  }
}

# activate_task在一个任务不活跃的时候触发
probe kernel.trace(&amp;#34;activate_task&amp;#34;) !,
      kernel.function(&amp;#34;activate_task&amp;#34;) {
  a = gettimeofday_us()
  # 拿到开始休眠的时间点
  d = dequeue[$p]
  # 删除记录
  delete dequeue[$p]
  # 如果存在这个休眠时间，就去计算时长
  if (d) {
    sleep = a - d
    if (sleep &amp;gt; 0) {
       # 记录下来休眠的时长
       this_sleep[$p] = sleep
    }
  }
}

probe scheduler.cpu_on {
   p = task_current()
   t = this_sleep[p]
   if (t){
     delete this_sleep[p]
     # 将休眠时间以进程调用栈为键值记录到统计数组中
     sleep_time[backtrace()] &amp;lt;&amp;lt;&amp;lt; t
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这个以调用栈为键值记录时间到统计数组的工作，完全可以同样放在&lt;code&gt;activate_task&lt;/code&gt;函数中，官方的解释是，在&lt;code&gt;activate_task&lt;/code&gt;函数中做这个操作会增大这个监控在进程上下文切换时的影响，所以就放在&lt;code&gt;scheduler.cpu_on&lt;/code&gt;这个probe中来完成了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#FIXME: It would be nicer to get backtrace information in activate_task probe.
# This would eliminate the overhead of probing every context switch
# and this_sleep associate array. However, this needs a properly working
# task_backtrace() to eliminate this probe.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;off-cpu的时间计算以及调用栈&#34;&gt;off cpu的时间计算以及调用栈&lt;/h2&gt;
&lt;p&gt;从上面的分析可以看到，将进程的时间按照按照其是否占用CPU来执行的时间来划分，可以分为&lt;code&gt;on cpu&lt;/code&gt;和&lt;code&gt;off cpu&lt;/code&gt;时间。观察一个服务进程，如果其在繁忙的时候，CPU时间一直上不去，说明某些原因导致其&lt;code&gt;off cpu&lt;/code&gt;时间过多，这时候就需要查看原因了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scheduler.cpu_off&lt;/code&gt;和&lt;code&gt;scheduler.cpu_on&lt;/code&gt;这两个probe事件，在进程被调度进出CPU资源的时候触发，在这里可以记录等待CPU时间以及调用堆栈。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/openresty/openresty-systemtap-toolkit&#34;&gt;openresty-systemtap-toolkit&lt;/a&gt;项目中的&lt;a href=&#34;https://github.com/openresty/openresty-systemtap-toolkit/blob/master/sample-bt-off-cpu&#34;&gt;sample-bt-off-cpu&lt;/a&gt;脚本，可以用来观测并打印进程&lt;code&gt;off cpu&lt;/code&gt;时间的调用栈，该脚本由perl语言实现，如果带上&lt;code&gt;-d&lt;/code&gt;参数可以输出成systemtap的stap脚本内容，如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ./sample-bt-off-cpu -p `pidof top` -t 2 -u -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里几个参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-p：待观测的进程pid，这里为了示范就选择top命令。&lt;/li&gt;
&lt;li&gt;-t：采集多少秒的数据之后就退出。&lt;/li&gt;
&lt;li&gt;-d：并不实际工作，而是输出systemtap的stp脚本文件内容。&lt;/li&gt;
&lt;li&gt;-u：打印的调用栈是用户层调用栈，反之如果使用&lt;code&gt;-k&lt;/code&gt;就是输出的内核调用栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上命令在我机器上输出的stp脚本内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global bts
global start_time

global quit = 0;
global found

probe begin {
    warn(sprintf(&amp;#34;Tracing %d (/usr/bin/top)...\n&amp;#34;, target()))
}


probe scheduler.cpu_off {
    if (pid() == target()) {
        if (!quit) {
            start_time[tid()] = gettimeofday_us()

        } else {
            foreach (bt in bts- limit 1024) {
                print_ustack(bt)
                printf(&amp;#34;\t%d\n&amp;#34;, @sum(bts[bt]))
            }

            exit()
        }
    }
}

probe scheduler.cpu_on {
    if (pid() == target() &amp;amp;&amp;amp; !quit) {
        t = tid()
        begin = start_time[t]
        if (begin &amp;gt; 0) {
            elapsed = gettimeofday_us() - begin
            if (elapsed &amp;gt;= 4) {
                bts[ubacktrace()] &amp;lt;&amp;lt;&amp;lt; elapsed
                found = 1
            }
            delete start_time[t]
        }
    }
}

probe timer.s(2) {
    if (!found) {
        warn(&amp;#34;No backtraces found. Quitting now...\n&amp;#34;)
        exit()

    } else {
        warn(&amp;#34;Time&amp;#39;s up. Quitting now...(it may take a while)\n&amp;#34;)
        quit = 1
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，这段脚本有在两个probe事件上加了处理函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scheduler.cpu_off：进程失去cpu时，记录此时的时间。&lt;/li&gt;
&lt;li&gt;scheduler.cpu_on：进程获取到cpu资源准备执行时，拿到此时的时间，如果与off cpu的时间相差了超过4us，就记录下此时的用户层调用栈以及时间差。&lt;/li&gt;
&lt;li&gt;当设置的脚本退出时间到来时，按照前面统计时间从到到少打印进程的调用栈信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;on-cpu的时间计算以及调用栈&#34;&gt;on cpu的时间计算以及调用栈&lt;/h2&gt;
&lt;p&gt;进程除了在&lt;code&gt;off cpu&lt;/code&gt;时间上等待被唤醒之外，就是在&lt;code&gt;on cpu&lt;/code&gt;时间上一直执行了。与&lt;code&gt;off cpu&lt;/code&gt;测量所不同的是，&lt;code&gt;on cpu&lt;/code&gt;的时间上可以看出程序执行的热点，这部分调用栈的观察使用的是采样的方式。即：定时打印进程调用栈的信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/openresty/openresty-systemtap-toolkit&#34;&gt;openresty-systemtap-toolkit&lt;/a&gt;项目中的&lt;a href=&#34;https://github.com/openresty/openresty-systemtap-toolkit/blob/master/sample-bt&#34;&gt;sample-bt&lt;/a&gt;脚本，其使用时的命令行参数与前面的&lt;code&gt;sample-bt-off-cpu&lt;/code&gt;并无不同，这个脚本打印的是进程在&lt;code&gt;on cpu&lt;/code&gt;状态下的调用栈，这样就可以观察出程序的执行热点来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ./sample-bt -p `pidof top` -t 2 -u -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe begin {
    warn(sprintf(&amp;#34;Tracing %d (/usr/bin/top) in user-space only...\n&amp;#34;, target()))
}


global bts;
global quit = 0;

probe timer.profile {
    if (pid() == target()) {
        if (!quit) {
            bts[ubacktrace()] &amp;lt;&amp;lt;&amp;lt; 1;

        } else {

            foreach (bt in bts- limit 1024) {
                print_ustack(bt);
                printf(&amp;#34;\t%d\n&amp;#34;, @count(bts[bt]));
            }

            exit()
        }
    }
}

probe timer.s(2) {
    nstacks = 0
    foreach (bt in bts limit 1) {
        nstacks++
    }

    if (nstacks == 0) {
        warn(&amp;#34;No backtraces found. Quitting now...\n&amp;#34;)
        exit()

    } else {
        warn(&amp;#34;Time&amp;#39;s up. Quitting now...(it may take a while)\n&amp;#34;)
        quit = 1
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段脚本的工作原理是：在&lt;code&gt;timer.profile&lt;/code&gt;这个probe事件中，判断当前执行的pid如果是所要观察的pid，就记录其调用栈信息到统计数组里，在最后脚本到期的时候按照统计数组的降序排列打印调用栈即可。&lt;/p&gt;
&lt;h2 id=&#34;火焰图&#34;&gt;火焰图&lt;/h2&gt;
&lt;p&gt;以上，解释了如何打印进程在&lt;code&gt;off cpu&lt;/code&gt;和&lt;code&gt;on cpu&lt;/code&gt;两种状态下的调用栈信息，由于这些信息都是使用采样的方式进行收集的，因此还统计并且输出进程在这些状态下到底消耗在哪些地方。&lt;/p&gt;
&lt;p&gt;此时，就需要召唤“火焰图”了。火焰图是一种根据输入的采样信息，统计生成热点的图片，在这里可以很方便的看到从采集的数据中，进程都消耗在哪些函数调用里。&lt;/p&gt;
&lt;p&gt;生成火焰图的工具由&lt;code&gt;brendangregg&lt;/code&gt;提供的项目&lt;a href=&#34;https://github.com/brendangregg/FlameGraph&#34;&gt;FlameGraph&lt;/a&gt;生成，该项目提供多种Perl语言编写的脚本，数据源可以来自Perf、systemtap等多种Linux下面的profile工具，systemtap的输出可以由项目中的stackcollapse-stap.pl脚本来生成火焰图。&lt;/p&gt;
&lt;p&gt;以使用前面的&lt;code&gt;openresty-systemtap-toolkit&lt;/code&gt;项目中的&lt;code&gt;sample-bt&lt;/code&gt;脚本为例，搭配火焰图使用的步骤大体如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 跟踪pid为22222的进程，采样时间20秒，只采用用户层信息，输出到tmp.bt文件中
./sample-bt -p 22222 -t 20 -u &amp;gt; tmp.bt

# 调用stackcollapse-stap.pl文件，将第一步采样的数据生成cbt格式文件
./stackcollapse-stap.pl flame.bt &amp;gt; flame.cbt

# 生成火焰图的svg文件
./flamegraph.pl flame.cbt &amp;gt; flame.svg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上的流程总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-systemtap/hotpot.png&#34; alt=&#34;hotpot&#34; title=&#34;hotpot&#34;&gt;&lt;/p&gt;
&lt;p&gt;下图是火焰图的一个示例，火焰图分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;横轴：函数调用的时间占比。直观来看，横轴上越宽的函数调用，其采样到的数据就越多，这样才能直观的看到“热点”在哪些函数调用上。&lt;/li&gt;
&lt;li&gt;纵轴：函数的调用栈信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-systemtap/hotpot-example.svg&#34; alt=&#34;hotpot-example&#34; title=&#34;hotpot-example&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;进程状态的切换&#34;&gt;进程状态的切换&lt;/h1&gt;
&lt;p&gt;前面几个部分，已经可以观测出来进程在&lt;code&gt;on cpu&lt;/code&gt;和&lt;code&gt;off cpu&lt;/code&gt;上面花费的时间、执行热点、调用栈等信息了，但是程序在非执行时间，其实还可以细分为以下几个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程的执行权是被抢占的，本身并没有任何放弃执行权的操作。此时就意味着，进程还一直在就绪队列中，只不过被优先级更高的进程抢占了执行权。&lt;/li&gt;
&lt;li&gt;进程因为等待IO、主动休眠等原因，让出了执行权，此时还可以细分为进程是休眠还是在等待IO事件完成后再唤醒进程执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-systemtap/offcpu.png&#34; alt=&#34;offcpu&#34; title=&#34;offcpu&#34;&gt;&lt;/p&gt;
&lt;p&gt;本节中来看看如何使用systemtap脚本来具体统计程序在这几个细分状态中的执行时间。&lt;/p&gt;
&lt;p&gt;先从描述进程的&lt;code&gt;task_struct&lt;/code&gt;结构体信息说起，这部分在前面专门讲解&lt;code&gt;task_struct&lt;/code&gt;结构体的部分有专门介绍，这里仅作简单的回顾。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt;结构体中，成员&lt;code&gt;state&lt;/code&gt;用来表示进程当前的状态，有以下几个互斥的值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define TASK_RUNNING			0x0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define TASK_INTERRUPTIBLE		0x0001
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define TASK_UNINTERRUPTIBLE		0x0002
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，&lt;code&gt;TASK_RUNNING&lt;/code&gt;状态就是就绪状态。可以认为，只要&lt;code&gt;state&lt;/code&gt;值为0（即TASK_RUNNING）的情况下，进程就是就绪状态的，此时只可能处于两种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;占用CPU在执行。&lt;/li&gt;
&lt;li&gt;在就绪队列中等待被唤醒执行，这种进程还是就绪状态却被调度出CPU的情况，一般都是被优先级更高的进程抢占了执行权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，当进程被调度让出cpu执行权时，如果&lt;code&gt;state&lt;/code&gt;为0说明此时还在就绪队列中，否则就不是就绪状态。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;task_struct&lt;/code&gt;结构体中还有另一个成员&lt;code&gt;in_iowait&lt;/code&gt;，用于表示当前进程是否在等待IO。因此，根据这个成员是否为1，就可以知道非就绪状态的进程是在等待IO还是在休眠。&lt;/p&gt;
&lt;p&gt;总结上面的内容如下，当进程被剥夺执行权的时候：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果当前进程状态还是&lt;code&gt;TASK_RUNNING&lt;/code&gt;，说明这时候回到就绪队列中排队等待调度执行。&lt;/li&gt;
&lt;li&gt;如果进程状态大于0，此时会区分两种情况：
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;in_iowait&lt;/code&gt;为1：说明在等待IO。&lt;/li&gt;
&lt;li&gt;否则说明在休眠。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三种情况就是进程状态小于0的状态，此时进程已经死亡。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;systemtap中自带的例子脚本&lt;a href=&#34;https://sourceware.org/systemtap/examples/process/schedtimes.stp&#34;&gt;schedtimes&lt;/a&gt;提供了统计以上三种时间的例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap schedtimes.stp -T 10

        execname:    pid    run(us)  sleep(us) iowait(us) queued(us)  total(us)

         systemd:      1         29   10034958          0          5   10034992
       rcu_sched:      8        632   10030313          0       1432   10032377
      watchdog/0:     11         49    8284090          0        102    8284241
      watchdog/1:     14         47    8284082          0        102    8284231
     ksoftirqd/1:     16         50   10028298          0          9   10028357
      watchdog/2:     20         68    8280096          0         76    8280240
     ksoftirqd/2:     22         97    7916416          0        141    7916654
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;脚本中能统计出程序在执行状态（run）、休眠状态（sleep）、等待IO状态（iowait）、在就绪队列中等待被调度状态（queued）的时间。&lt;/p&gt;
&lt;p&gt;这个脚本的工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kernel.trace(&amp;quot;sched_switch&amp;quot;)&lt;/code&gt;事件中：这个事件在进程被切换出去cpu时被触发，此时可以拿到进程&lt;code&gt;task_struct&lt;/code&gt;结构体的&lt;code&gt;state&lt;/code&gt;成员，根据上面描述进程状态判断，就可以知道是主动让出执行权、排在就绪队列等待、还是死亡状态了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kernel.trace(&amp;quot;sched_wakeup&amp;quot;)&lt;/code&gt;事件中：这个事件在进程被再次执行时触发，此时判断进程在切换出去时的状态如果是主动让出执行权的话，那么如果这时&lt;code&gt;task_struct-&amp;gt;in_iowait&lt;/code&gt;为1，说明在等待IO，否则就是在休眠状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这部分相关代码及注释如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 进程状态发生变化时触发，用于更新进程各种状态的统计时间
function update_times(pid, now)
{
  delta = now - previous_timestamp[pid]
  // 首先更新这一次统计的时间戳
  previous_timestamp[pid] = now

  if ((state = pid_state[pid]) &amp;gt; 0) {
    // 进程状态大于0，说明进程没有就绪
    if (state == SLEEPING)
      // 更新休眠时间
      sleep_time[pid] += delta
    else if (state == QUEUED)
      // 更新排队时间
      queued_time[pid] += delta
    else if (state == RUNNING)
      // 更新运行时间
      run_time[pid] += delta
  }

  return delta
}

probe kernel.trace(&amp;#34;sched_switch&amp;#34;)
{
  // Task $prev is scheduled off this cpu
  if (task_targeted($prev)) {
    pid = $prev-&amp;gt;pid
    state = $prev-&amp;gt;state
    update_times(pid, timestamp())

    // 根据进程状态来判断
    if (state &amp;gt; 0) {
      // 大于0说明不在运行状态，在休眠
      @set_iowait($rq, $prev)
      pid_state[pid] = SLEEPING
    } else if (state == 0) {
      // =0说明在运行状态，只不过被抢占了执行权
      pid_state[pid] = QUEUED
    } else {
      // 小于0说明进程死了
      pid_state[pid] = DEAD
    }
  }

  // Task $next is scheduled onto this cpu
  if (task_targeted($next)) {
    pid = $next-&amp;gt;pid
    update_times(pid, timestamp())

    @clear_iowait($rq, $next)
    pid_state[pid] = RUNNING
  }
}

// 进程被唤醒时触发
probe kernel.trace(&amp;#34;sched_wakeup&amp;#34;)
{
  // Task $p is awakened
  if (@choose_defined($success, 1) &amp;amp;&amp;amp; task_targeted($p)) {
    pid = $p-&amp;gt;pid
    delta = update_times(pid, timestamp())
    // 在休眠同时在iowait，增加iowait时间
    if (pid_state[pid] == SLEEPING &amp;amp;&amp;amp; @in_iowait($p)) {
      iowait_time[pid] += delta
    }
    // 状态是就绪队列状态
    pid_state[pid] = QUEUED
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;
&lt;p&gt;总结一下这一节涉及到的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程的执行划分为&lt;code&gt;on cpu&lt;/code&gt;和&lt;code&gt;off cpu&lt;/code&gt;两部分时间。前者表示进程在占用CPU执行的时间，后者是除此之外的进程时间。&lt;/li&gt;
&lt;li&gt;如果进程的CPU一直上不去，可以看看进程的&lt;code&gt;off cpu&lt;/code&gt;时间都分布在哪些函数调用上；反之，可以从进程的&lt;code&gt;on cpu&lt;/code&gt;时间中看到进程执行时的热点函数。&lt;/li&gt;
&lt;li&gt;有了不同状态下的函数调用栈采样数据之后，可以生成火焰图直观查看采样数据。&lt;/li&gt;
&lt;li&gt;使用systemtap脚本可以跟进这两部分时间、进程上下文切换、进程状态切换的情况。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之进程调度</title>
      <link>https://www.codedump.info/post/20200503-sgfap-process-schedule/</link>
      <pubDate>Sun, 03 May 2020 09:53:34 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200503-sgfap-process-schedule/</guid>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;一种资源，如果本身数量有限，需要多个资源需求方来使用的情况下，就涉及到&lt;code&gt;资源调度&lt;/code&gt;的问题。在内核中，CPU就是一种有限的资源，同时在系统中处于运行状态的进程数量有很多，此时就需要设计出一种方法，尽可能的保证这种资源被公平的分配到进程中间。&lt;/p&gt;
&lt;p&gt;Linux内核中的进程调度，涉及到以下几个重要概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心调度器：核心调度器可以认为是内核中进程调度模块，对外提供了周期性调度（定时触发）以及主调度器两个接口。&lt;/li&gt;
&lt;li&gt;就绪队列：所有当前运行的进程都在这个队列中维护，需要选择出下一个执行的进程也从这个队列中选举。&lt;/li&gt;
&lt;li&gt;调度优先级：给予不同的进程不同的优先级，这样分配到的时间就不一样。&lt;/li&gt;
&lt;li&gt;调度算法：不同类型的进程使用不同的调度算法来选择执行进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下来简单阐述这几个组件如何一起作用完成进程调度的工作。&lt;/p&gt;
&lt;p&gt;每个CPU维护自己的就绪队列，就绪队列由结构体&lt;code&gt;rq&lt;/code&gt;来表示，队列中的每个元素都是前面提到的描述进程信息的结构体&lt;code&gt;task_struct&lt;/code&gt;。这里需要注意的是，虽然称之为“队列”，内部的实现中，根据不同的调度算法，使用了不同的数据结构来保存进程，比如CFS调度器使用了红黑树来保存进程，这一点在后面展开阐述，目前为止，暂且认为就绪队列是一个维护CPU所有当前就绪进程的容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/runqueue.png&#34; alt=&#34;runqueue&#34; title=&#34;runqueue&#34;&gt;&lt;/p&gt;
&lt;p&gt;不同的调度器算法，无论内部如何实现，其最终都是从就绪队列中选择下一个可执行的进程来运行。
在这个版本的内核中一共实现了如下几种调度器算法，它们统一由结构体&lt;code&gt;sched_class&lt;/code&gt;来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/sched_class.png&#34; alt=&#34;sched_class&#34; title=&#34;sched_class&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;调度器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;对应调度策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;dl_sched_class&lt;/td&gt;
&lt;td&gt;deadline调度器&lt;/td&gt;
&lt;td&gt;SCHED_DEADLINE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rt_sched_class&lt;/td&gt;
&lt;td&gt;实时调度器&lt;/td&gt;
&lt;td&gt;SCHED_FIFO、SCHED_RR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fair_sched_class&lt;/td&gt;
&lt;td&gt;完全公平调度器&lt;/td&gt;
&lt;td&gt;SCHED_NORMAL、SCHED_BATCH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;idle_sched_class&lt;/td&gt;
&lt;td&gt;idle调度器&lt;/td&gt;
&lt;td&gt;SCHED_IDLE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上列举了进程的几种调度器及对应的调度策略，其优先级依次递减。在下面的内容中，将详细介绍完全公平调度器（Completely Fair Scheduler，简称CFS），因为这是最普遍的进程调度器。&lt;/p&gt;
&lt;p&gt;从以上的介绍可以看到，内核的调度器负责维护就绪队列，即提供了调度进程所需的数据来源；而不同的调度器算法则根据自己的实现来从就绪队列中选择进程来执行，那么选择的依据又是什么？答案是进程的优先级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/schedule.png&#34; alt=&#34;schedule&#34; title=&#34;schedule&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上简单阐述了Linux进程调度中涉及到的四个最重要的要素，下面将展开讨论。&lt;/p&gt;
&lt;p&gt;首先将介绍进程的优先级，通过这个值如何计算得到进程的权重，进一步得到&lt;code&gt;CFS&lt;/code&gt;调度器算法中所需的虚拟运行时间。&lt;/p&gt;
&lt;p&gt;紧接着介绍与进程调度相关的数据结构，以及内核中进程调度的核心调度器的实现。&lt;/p&gt;
&lt;p&gt;最后就是详细展开&lt;code&gt;CFS&lt;/code&gt;调度器内部的实现。&lt;/p&gt;
&lt;h1 id=&#34;优先级权重和虚拟运行时间&#34;&gt;优先级、权重和虚拟运行时间&lt;/h1&gt;
&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;
&lt;p&gt;Linux通过nice命令设置进程的静态优先级，进程的nice值在[-20,19]之间，值越小优先级越高。而内核本身，选择范围[0,139]在内部表示优先级，同样是数值越低优先级越高：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/nice.png&#34; alt=&#34;nice&#34; title=&#34;nice&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于普通的进程，可以认为优先级不会发生变化，而实时进程则不然：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;effective_prio&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;normal_prio &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; normal_prio(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是实时进程，返回前面normal_prio的计算结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;rt_prio(p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prio))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;normal_prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于在这里不讨论实时进程，仅讨论普通进程，因此可以认为进程优先级就是静态不变的。&lt;/p&gt;
&lt;h2 id=&#34;cpu时间权重&#34;&gt;CPU时间权重&lt;/h2&gt;
&lt;p&gt;CFS调度器的设计理念，就是能够实现理想、精确的多任务CPU进程调度。与以往的调度器不同的是，CFS调度器没有时间片的概念，使用的是分配CPU时间的比例。通过进程的优先级，就可以计算出来一个进程在就绪队列中所占时间的权重了。&lt;/p&gt;
&lt;p&gt;nice值与权重之间是一对一的关系，为了实现普通进程的nice值到CPU时间权重的快速计算，内核预计算好了一个映射数组：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sched_prio_to_weight[&lt;span style=&#34;color:#666&#34;&gt;40&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -20 */&lt;/span&gt;     &lt;span style=&#34;color:#666&#34;&gt;88761&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;71755&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;56483&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;46273&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;36291&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -15 */&lt;/span&gt;     &lt;span style=&#34;color:#666&#34;&gt;29154&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;23254&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;18705&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;14949&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;11916&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -10 */&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;9548&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;7620&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;6100&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;4904&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;3906&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  -5 */&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;3121&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;2501&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;1991&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;1586&lt;/span&gt;,      &lt;span style=&#34;color:#666&#34;&gt;1277&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*   0 */&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;1024&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;820&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;655&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;526&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;423&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*   5 */&lt;/span&gt;       &lt;span style=&#34;color:#666&#34;&gt;335&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;272&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;215&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;172&lt;/span&gt;,       &lt;span style=&#34;color:#666&#34;&gt;137&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  10 */&lt;/span&gt;       &lt;span style=&#34;color:#666&#34;&gt;110&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;87&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;70&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;56&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;45&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  15 */&lt;/span&gt;        &lt;span style=&#34;color:#666&#34;&gt;36&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;29&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;23&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;18&lt;/span&gt;,        &lt;span style=&#34;color:#666&#34;&gt;15&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该数组的可以认为是这样根据nice值预先计算出来的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;weight = 1024 / (1.25 ^ nice)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;公式中的1.25取值依据是：进程每降低一个nice值，将多获得10%的cpu时间。公式中以1024权重为基准值计算得来，1024权重对应nice值为0，其权重被称为NICE_0_LOAD。默认情况下，大部分进程的权重基本都是NICE_0_LOAD。&lt;/p&gt;
&lt;p&gt;根据进程的权重值，可以得到分配给进程的CPU时间计算公式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;分配给进程的时间 = 总的cpu时间 * 进程的权重/就绪队列中所有进程权重之和
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;虚拟运行时间&#34;&gt;虚拟运行时间&lt;/h2&gt;
&lt;p&gt;有了进程在CPU运行的权重之后，内核就可以根据权重值计算出进程的虚拟运行时间（virtual runtime）。什么是“虚拟运行时间”，就是内核根据进程运行的实际时间和权重计算出来的一个时间，CFS调度器只需要保证在同一个CPU上面运行的进程，其虚拟运行时间一致即可。&lt;/p&gt;
&lt;p&gt;比如，进程A和进程B，权重分别为1024和820（nice值分别为0和1），在6ms的运行周期中，进程A获得的运行时间&lt;code&gt;6*1024/(1024+820) = 3.3ms&lt;/code&gt;，进程B获得的运行时间为&lt;code&gt;6*820/(1024+820) = 2.7ms&lt;/code&gt;。进程A的cpu使用比例是&lt;code&gt;3.3/6x100%=55%&lt;/code&gt;，进程B的cpu使用比例是&lt;code&gt;2.7/6x100%=45%&lt;/code&gt;。计算结果也符合上面说的“进程每降低一个nice值，将多获得10% CPU的时间”。使用下面的公式转换成虚拟运行时间：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vriture_runtime = wall_time * NICE_0_LOAD / weight
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：进程A的虚拟时间&lt;code&gt;3.3 * 1024 / 1024 = 3.3ms&lt;/code&gt;，可以看出nice值为0的进程的虚拟时间和实际时间是相等的。进程B的虚拟时间是&lt;code&gt;2.7 * 1024 / 820 = 3.3ms&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看出尽管A和B进程的权重值不一样，但是计算得到的虚拟时间是一样的。CFS调度器只要保证在同一个CPU上面运行的进程，其虚拟时间一致即可。&lt;/p&gt;
&lt;p&gt;从上面虚拟运行时间的计算也可以知道，一个进程的虚拟允许时间越小，其权重反而是越大的，即虚拟运行时间小的进程被调度执行的权重更大。&lt;/p&gt;
&lt;p&gt;为了避免浮点数运算，内核中采用先放大再缩小的方法以保证计算精度。内核又对前面计算虚拟运行时间的公式做了如下转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vriture_runtime = (wall_time * NICE_0_LOAD) / weight
= (wall_time * NICE_0_LOAD * 2 ^32 / weight) &amp;gt;&amp;gt; 32
= (wall_time * NICE_0_LOAD * inv_weight) &amp;gt;&amp;gt; 32 (其中inv_weight=(2^32 / weight))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便计算inv_weight的值，内核定义了一个预分配数组sched_prio_to_wmult，其中每一项的值为(2^32 / sched_prio_to_weight[prio])：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; u32 sched_prio_to_wmult[&lt;span style=&#34;color:#666&#34;&gt;40&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -20 */&lt;/span&gt;     &lt;span style=&#34;color:#666&#34;&gt;48388&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;59856&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;76040&lt;/span&gt;,     &lt;span style=&#34;color:#666&#34;&gt;92818&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;118348&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -15 */&lt;/span&gt;    &lt;span style=&#34;color:#666&#34;&gt;147320&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;184698&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;229616&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;287308&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;360437&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* -10 */&lt;/span&gt;    &lt;span style=&#34;color:#666&#34;&gt;449829&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;563644&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;704093&lt;/span&gt;,    &lt;span style=&#34;color:#666&#34;&gt;875809&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;1099582&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  -5 */&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;1376151&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;1717300&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;2157191&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;2708050&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;3363326&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*   0 */&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;4194304&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;5237765&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;6557202&lt;/span&gt;,   &lt;span style=&#34;color:#666&#34;&gt;8165337&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;10153587&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*   5 */&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;12820798&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;15790321&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;19976592&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;24970740&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;31350126&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  10 */&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;39045157&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;49367440&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;61356676&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;76695844&lt;/span&gt;,  &lt;span style=&#34;color:#666&#34;&gt;95443717&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  15 */&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;119304647&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;148102320&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;186737708&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;238609294&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;286331153&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;内核中使用结构体&lt;code&gt;load_weight&lt;/code&gt;来描述进程的权重信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// include/linux/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; load_weight {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt;			weight;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u32				inv_weight;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，成员&lt;code&gt;weight&lt;/code&gt;存储进程的权重，而成员&lt;code&gt;inv_weight&lt;/code&gt;存储&lt;code&gt;2^32/ weight&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有了前面的铺垫，来看内核中对应的实现，内核中使用函数&lt;code&gt;__calc_delta&lt;/code&gt;来将实际时间转换为虚拟时间，算法原理就是前面介绍到的公式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; u64 &lt;span style=&#34;color:#00a000&#34;&gt;__calc_delta&lt;/span&gt;(u64 delta_exec, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; weight, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; load_weight &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;lw)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 fact &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; scale_load_down(weight);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; shift &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; WMULT_SHIFT;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	__update_inv_weight(lw);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (unlikely(fact &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (fact &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			fact &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			shift&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* hint to use a 32x32-&amp;gt;64 mul */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	fact &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (u64)(u32)fact &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; lw&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inv_weight;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (fact &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		fact &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		shift&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; mul_u64_u32_shr(delta_exec, fact, shift);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下将前面的nice值、权重、虚拟运行时间的关系总结如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/vruntime.png&#34; alt=&#34;vruntime&#34; title=&#34;vruntime&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;更新虚拟运行时间&#34;&gt;更新虚拟运行时间&lt;/h2&gt;
&lt;p&gt;由于更新进程调度实体以及就绪队列的虚拟运行时间的操作如此重要，所以内核中有一个专门的&lt;code&gt;update_curr&lt;/code&gt;函数完成这个工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/update_curr.png&#34; alt=&#34;update_curr&#34; title=&#34;update_curr&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里，&lt;code&gt;update_curr&lt;/code&gt;函数除了更新进程本身的虚拟运行时间之外，还要更新就绪队列的&lt;code&gt;min_vruntime&lt;/code&gt;（最小虚拟运行时间），下面介绍到CFS调度算法时讲解释这个值的作用。&lt;/p&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;p&gt;前面描述了进程的优先级是如何与进程的虚拟运行时间相关联的，接着继续看与进程调度相关的核心数据结构。&lt;/p&gt;
&lt;h2 id=&#34;task_struct中与调度相关的成员&#34;&gt;task_struct中与调度相关的成员&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt;中与调度算法相关的成员：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// include/linux/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;				prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;				static_prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;				normal_prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_class	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;sched_class;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity		se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			policy;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;				nr_cpus_allowed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cpumask_t			cpus_allowed;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;task_struct&lt;/code&gt;使用了如下几个成员表示进程的优先级，其中&lt;code&gt;prio&lt;/code&gt;和&lt;code&gt;normal_prio&lt;/code&gt;表示动态优先级，&lt;code&gt;static_prio&lt;/code&gt;表示静态优先级。静态优先级在程序启动的时候就分配好了，可以使用&lt;code&gt;nice&lt;/code&gt;命令进行修改。&lt;code&gt;normal_prio&lt;/code&gt;是在进程运行过程中，根据静态优先级和调度策略动态计算出来的优先级。&lt;/li&gt;
&lt;li&gt;结构体&lt;code&gt;sched_class&lt;/code&gt;用来表示进程所所属的调度器类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policy&lt;/code&gt;保存了进程的调度策略，其中有三个可能的值：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SCHED_NORMAL&lt;/code&gt;用于普通进程，该类型使用完全公平调度器来处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCHED_BATCH&lt;/code&gt;和&lt;code&gt;SCHED_IDLE&lt;/code&gt;：也使用完全公平调度器来处理，不过可以用于次要的进程。&lt;code&gt;SCHED_BATCH&lt;/code&gt;用于非交互、CPU密集的批处理进程，这类进程绝不会抢占CFS调度器的另一个进程，因此不会干扰交互式进程。&lt;code&gt;SCHED_IDLE&lt;/code&gt;类进程的重要级很低，因为权重最小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCHED_FIFO&lt;/code&gt;和&lt;code&gt;SCHED_RR&lt;/code&gt;：用于实现软实时进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpus_allowed&lt;/code&gt;：是一个位域，在多处理器系统上使用，用来限制进程可以在哪些CPU上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器类&#34;&gt;调度器类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sched_class&lt;/code&gt;是用于表示所有调度器算法的结构体，各种调度器算法需要实现里面的成员函数，可以用面向对象的思想理解为所有调度器的“基类”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/sched.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_class {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_class &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;enqueue_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;dequeue_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;yield_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;yield_to_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; preempt);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;check_preempt_curr) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pick_next_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;						&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;prev,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;						&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq_flags &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;put_prev_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;set_curr_task) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;task_tick) (&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; queued);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中的几个重要成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enqueue_task&lt;/code&gt;：进程从睡眠状态切换到可运行状态时调用，意为向就绪队列放入一个进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dequeue_task&lt;/code&gt;：用于实现进程出队列操作，当进程从可运行状态切换到不可运行状态时调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yield_task&lt;/code&gt;：进程要让出对CPU的占用时，可使用系统调用&lt;code&gt;sched_yield&lt;/code&gt;，最终会调用&lt;code&gt;yield_task&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_preempt_curr&lt;/code&gt;：用一个新创建的进程来抢占当前进程，比如当&lt;code&gt;wake_up_new_task&lt;/code&gt;函数唤醒新进程就会使用这个函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pick_next_task&lt;/code&gt;：用于选择下一个将要执行的进程，而&lt;code&gt;put_prev_task&lt;/code&gt;则在另一个进程代替当前运行的进程之前调用。这两个操作并不等价于将进程加入或撤出就绪队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;task_tick&lt;/code&gt;：由周期性调度器调用，下面会谈到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;就绪队列&#34;&gt;就绪队列&lt;/h2&gt;
&lt;p&gt;就绪队列用于维护所有当前可运行的进程，每个CPU上都有一个就绪队列，由结构体&lt;code&gt;rq&lt;/code&gt;来表示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nr_running;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080&#34;&gt;#define CPU_LOAD_IDX_MAX 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; cpu_load[CPU_LOAD_IDX_MAX];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; load_weight load;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq cfs;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;idle, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;stop;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 clock;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nr_running&lt;/code&gt;：就绪队列上可运行进程的数目。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load&lt;/code&gt;：提供CPU就绪队列当前负载的度量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu_load&lt;/code&gt;：跟踪当前的负荷状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cfs&lt;/code&gt;：分别用于完全公平调度器的就绪队列。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curr&lt;/code&gt;：指向当前运行进程的&lt;code&gt;task_struct&lt;/code&gt;结构体指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idle&lt;/code&gt;：指向当前&lt;code&gt;idle&lt;/code&gt;进程的&lt;code&gt;task_struct&lt;/code&gt;结构体指针，当当前没有进程在运行的时候执行该进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clock&lt;/code&gt;：用于实现就绪队列自身的时钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核中用如下的宏来定义了per-CPU的变量&lt;code&gt;runqueues&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;DECLARE_PER_CPU_SHARED_ALIGNED(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq, runqueues);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也提供了另外一些与就绪队列相关的宏：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 得到该CPU的就绪队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define cpu_rq(cpu)		(&amp;amp;per_cpu(runqueues, (cpu)))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 得到当前CPU的就绪队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define this_rq()		this_cpu_ptr(&amp;amp;runqueues)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 根据task_struct指针拿到对应CPU的就绪队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define task_rq(p)		cpu_rq(task_cpu(p))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 得到cpu当前运行的进程task_struct指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define cpu_curr(cpu)		(cpu_rq(cpu)-&amp;gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cfs调度器的就绪队列&#34;&gt;CFS调度器的就绪队列&lt;/h2&gt;
&lt;p&gt;前面看到就绪队列结构体&lt;code&gt;rq&lt;/code&gt;中，使用结构体&lt;code&gt;cfs_rq&lt;/code&gt;来维护CFS调度器的就绪进程，下面简单了解一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; load_weight load;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nr_running;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 min_vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rb_root_cached tasks_timeline;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load：就绪队列上所有进程的累积负载值。&lt;/li&gt;
&lt;li&gt;nr_running：就绪队列上的进程数量。&lt;/li&gt;
&lt;li&gt;min_vruntime：记录就绪队列上进程的最小虚拟运行时间。这个值是计算就绪队列虚拟运行时间的基础，大部分情况下是CFS红黑树最小子节点（最左节点）的虚拟运行时间，但实际情况下可能有时候会比最小子节点的虚拟运行时间稍大一些，后面将展开讨论。&lt;/li&gt;
&lt;li&gt;tasks_timeline：将就绪队列上所有进程的虚拟运行时间维护的红黑树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度实体&#34;&gt;调度实体&lt;/h2&gt;
&lt;p&gt;CFS调度器可以操作的对象是比进程更一般的实体，所以又使用了&lt;code&gt;sched_entity&lt;/code&gt;结构体来描述进程调度的实体信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/linux/sched.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 权重信息，在计算虚拟时间的时候会用到inv_weight成员。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; load_weight		load;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt;			runnable_weight;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// CFS调度器使用红黑树维护调度的进程信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rb_node			run_node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 进入就绪队列是为1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;			on_rq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64				exec_start;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调度实体已经运行实际时间总合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	u64				sum_exec_runtime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调度实体已经运行的虚拟时间总合。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	u64				vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64				prev_sum_exec_runtime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结上面提到的&lt;code&gt;rq&lt;/code&gt;、&lt;code&gt;cfs_rq&lt;/code&gt;以及&lt;code&gt;sched_entity&lt;/code&gt;结构体的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/cfs_rq.png&#34; alt=&#34;cfs_rq&#34; title=&#34;cfs_rq&#34;&gt;&lt;/p&gt;
&lt;p&gt;即：&lt;code&gt;rq&lt;/code&gt;结构体内部有一个类型为&lt;code&gt;cfs_rq&lt;/code&gt;结构体的成员，用于维护CFS算法的运行队列，而&lt;code&gt;cfs_rq&lt;/code&gt;内部又是使用红黑树结构来维护成员的，每个红黑树成员是&lt;code&gt;sched_entity&lt;/code&gt;结构体类型的节点。&lt;/p&gt;
&lt;h1 id=&#34;核心调度器&#34;&gt;核心调度器&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;核心调度器&lt;/code&gt;指的是内核的进程调度框架，由内核来触发调度进程的时机，而如何选择进程的工作，交予调度器类来实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/scheduler-core.png&#34; alt=&#34;scheduler-core&#34; title=&#34;scheduler-core&#34;&gt;&lt;/p&gt;
&lt;p&gt;核心调度器中，一共有以下几处地方有机会触发进程调度，下面来分别说明。&lt;/p&gt;
&lt;h2 id=&#34;周期性调度器&#34;&gt;周期性调度器&lt;/h2&gt;
&lt;p&gt;周期性调度器的入口函数是&lt;code&gt;scheduler_tick&lt;/code&gt;，内核会按照系统频率HZ来自动调用该函数，将&lt;code&gt;scheduler_tick&lt;/code&gt;函数精简如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;scheduler_tick&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; smp_processor_id();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cpu_rq(cpu);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调用调度类对应的task_tick方法，针对CFS调度类该函数是task_tick_fair。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;sched_class&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;task_tick(rq, curr, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，周期性调度器通过调度器算法的task_tick函数来完成调度工作，下面讲解CFS算法时详细分析。&lt;/p&gt;
&lt;h2 id=&#34;主调度器&#34;&gt;主调度器&lt;/h2&gt;
&lt;p&gt;主调度器的入口函数是&lt;code&gt;schedule&lt;/code&gt;，在内核中，当需要将CPU分配给与当前进程不同的另一个进程时，就会调用&lt;code&gt;schedule&lt;/code&gt;函数来选择下一个可执行进程。&lt;code&gt;schedule&lt;/code&gt;函数最终调用的是&lt;code&gt;__schedule&lt;/code&gt;函数，所以这里将&lt;code&gt;__schedule&lt;/code&gt;函数拆分来讲解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; __sched notrace &lt;span style=&#34;color:#00a000&#34;&gt;__schedule&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; preempt)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;prev, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;switch_count;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq_flags rf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cpu &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; smp_processor_id();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cpu_rq(cpu);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	prev &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	switch_count &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;prev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;nivcsw;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;preempt &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; prev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (unlikely(signal_pending_state(prev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state, prev))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			prev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; TASK_RUNNING;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		} &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			deactivate_task(rq, prev, DEQUEUE_SLEEP &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; DEQUEUE_NOCLOCK);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			prev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	next &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; pick_next_task(rq, prev, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rf);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	clear_tsk_need_resched(prev);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	clear_preempt_need_resched();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (likely(prev &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; next)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; context_switch(rq, prev, next, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rf);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;如果当前进程处于可中断的睡眠状态，同时现在接收到了信号，那么将再次被提升为可运行进程。&lt;/li&gt;
&lt;li&gt;否则就调用&lt;code&gt;deactivate_task&lt;/code&gt;函数将当前进程变成不活跃状态，这个函数最终会调用调度器类的&lt;code&gt;dequeue_task&lt;/code&gt;完成删除进程的工作。将进程的on_rq标志位置为0，表示不在就绪队列上了。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;pick_next_task&lt;/code&gt;函数选择下一个执行的进程。&lt;/li&gt;
&lt;li&gt;清除当前进程的&lt;code&gt;TIF_NEED_RESCHED&lt;/code&gt;标志位，意味着不需要重调度。&lt;/li&gt;
&lt;li&gt;如果下一个被调度执行进程不是当前进程，调用&lt;code&gt;context_switch&lt;/code&gt;函数进行进程上下文切换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;与fork的交互&#34;&gt;与fork的交互&lt;/h2&gt;
&lt;p&gt;除了以上两种场景，即周期性调度器以及主调度器之外，fork创建出新进程的时候也会出现与调度器类的交互，其入口函数是&lt;code&gt;sched_fork&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;sched_fork&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; clone_flags, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;sched_class&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;task_fork)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;sched_class&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;task_fork(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;sched_fork&lt;/code&gt;函数中会调用到对应调度器类的&lt;code&gt;task_fork&lt;/code&gt;成员函数来处理，下面讲到CFS调度器的时候再详细分析对应的函数。&lt;/p&gt;
&lt;p&gt;另外，调用&lt;code&gt;wake_up_new_task&lt;/code&gt;唤醒新的子进程执行时，也可能调用到抢占进程相关的操作，下面会分析到。&lt;/p&gt;
&lt;h1 id=&#34;cfs调度器&#34;&gt;CFS调度器&lt;/h1&gt;
&lt;h2 id=&#34;概述-1&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;了解了优先级、虚拟运行时间、相关数据结构、内核调度框架之后，下面正式进入CFS调度器的讲解。&lt;/p&gt;
&lt;p&gt;前面介绍了从进程的优先级出发，如何计算出进程在就绪队列中的时间权重，进而再计算出进程的虚拟运行时间。&lt;/p&gt;
&lt;p&gt;CFS调度器内部维护一颗红黑树，红黑树的键值即为进程的虚拟运行时间，虚拟运行时间越小的进程，被调度执行的优先级越高，获得更多的CPU时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/cfs.png&#34; alt=&#34;cfs&#34; title=&#34;cfs&#34;&gt;&lt;/p&gt;
&lt;p&gt;对比两个调度实体在红黑树中的先后顺序，也就只需要对比其中的虚拟运行时间即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;entity_before&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;a,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; (s64)(a&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; b&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个进程在刚刚加入到CFS就绪队列的红黑树中时，需要有一个基准值，即这个新加入的进程，应该和什么虚拟运行时间进行对比，找到它在红黑树中的合适位置。这个值由就绪队列中的最小虚拟运行时间来维护，对应的成员是&lt;code&gt;min_vruntime&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为什么这个最小虚拟运行时间不能直接取最左子节点对应进程的虚拟运行时间？因为系统在运行，对应的里面的每个进程其虚拟运行时间也是一直在增加，因此每个就绪队列的最小虚拟运行时间也一直是增加的才对。正因为这样，这个值不能取最左子节点进程的虚拟运行时间，而是根据系统的情况一直累加，不能发生回退。&lt;/p&gt;
&lt;p&gt;还需要注意的一点是，既然虚拟运行时间是一直累加的，那么在进程一直运行的情况下，就可能发生数据溢出现象，因此在对比两个虚拟运行时间大小的时候，不是直接比较而是判断的两者的差值（包括上面的&lt;code&gt;entity_before&lt;/code&gt;函数也是比较的差值）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;inline&lt;/span&gt; u64 &lt;span style=&#34;color:#00a000&#34;&gt;max_vruntime&lt;/span&gt;(u64 max_vruntime, u64 vruntime)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	s64 delta &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (s64)(vruntime &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; max_vruntime);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (delta &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		max_vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; max_vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面首先讲就绪队列最小虚拟运行时间的计算逻辑。&lt;/p&gt;
&lt;h2 id=&#34;最小虚拟运行时间的更新&#34;&gt;最小虚拟运行时间的更新&lt;/h2&gt;
&lt;p&gt;前面讲解虚拟运行时间的计算时，已经介绍了对应的函数&lt;code&gt;update_curr&lt;/code&gt;的核心流程，其中最后一步是更新CFS就绪队列的最小虚拟运行时间值，来看对应的&lt;code&gt;update_min_vruntime&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;update_min_vruntime&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rb_node &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;leftmost &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rb_first_cached(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tasks_timeline);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (curr) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq)	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (leftmost) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* non-empty tree */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rb_entry(leftmost, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity, run_node);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; min_vruntime(vruntime, se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ensure we never gain time by being placed backwards. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; max_vruntime(cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime, vruntime);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 6 *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;首先根据CFS就绪队列的tasks_timeline成员，拿到红黑树的最左子节点。&lt;/li&gt;
&lt;li&gt;拿到当期就绪队列的最小虚拟运行时间。&lt;/li&gt;
&lt;li&gt;在当前就绪队列运行进程存在且该进程on_rq标志为1的情况下，使用该进程的虚拟运行时间。&lt;/li&gt;
&lt;li&gt;在最左子节点存在的情况下，如果当前进程不存在，那么就取最左子节点的虚拟运行时间。&lt;/li&gt;
&lt;li&gt;否则取当前进程以及最左子节点进程的虚拟运行时间的最小值。&lt;/li&gt;
&lt;li&gt;更新CFS就绪队列的最小虚拟运行时间，其值取当前最小虚拟进程与前面拿到的较小的虚拟运行时间的较大值，这样就能保证CFS就绪队列的最小虚拟运行时间不会发生回退现象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/min_vruntime.png&#34; alt=&#34;min_vruntime&#34; title=&#34;min_vruntime&#34;&gt;&lt;/p&gt;
&lt;p&gt;之所以要保证CFS就绪队列的最小虚拟运行时间不回退，是因为CFS就绪队列中的红黑树排序是以调度实体的vruntime作为基准来进行计算的。vruntime值越小的节点，说明虚拟运行时间越少，对应的当前被调度的优先级就越往前，会被更快的调度来执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进程运行的时候，vruntime值稳定增加，于是在红黑树中就是向右边移动。&lt;/li&gt;
&lt;li&gt;进程在睡眠时，vruntime值保持不变，而每个队列的min_vruntime时间在增加，那么当睡眠进程被唤醒时（比如等待IO事件），其在红黑树中的位置就靠左，因为其键值变小了，于是会被更快的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;place_entity函数&#34;&gt;place_entity函数&lt;/h2&gt;
&lt;p&gt;place_entity函数属于CFS调度器算法内部使用的一个函数，其作用是调整进程调度实体的虚拟运行时间，传入的第三个参数initial为1的情况下表示是新创建的进程，否则是被唤醒的进程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;place_entity&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; initial)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (initial &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sched_feat(START_DEBIT))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		vruntime &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; sched_vslice(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;initial) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; thresh &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; sysctl_sched_latency;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (sched_feat(GENTLE_FAIR_SLEEPERS))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			thresh &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		vruntime &lt;span style=&#34;color:#666&#34;&gt;-=&lt;/span&gt; thresh;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; max_vruntime(se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime, vruntime);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;initial为1的情况下，表示是新创建的进程，此时将加上一个虚拟时间表示惩罚，因为虚拟时间越大在红黑树中位置就越靠右，被调度执行的顺序也越在后面。计算这个惩罚时间的函数是sched_vslice，后面展开解释。&lt;/li&gt;
&lt;li&gt;这种情况是针对被唤醒的进程，期望它能够更快的得到调度执行，所以这里减去一个虚拟运行时间做为补偿。&lt;/li&gt;
&lt;li&gt;调度实体的虚拟运行时间，取上面计算出来的时间以及自身的虚拟运行时间的较大值，保证不会发生回退情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接着看计算惩罚新创建进程虚拟运行时间的函数sched_vslice：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/fair.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; u64 &lt;span style=&#34;color:#00a000&#34;&gt;sched_vslice&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; calc_delta_fair(sched_slice(cfs_rq, se), se);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; u64 &lt;span style=&#34;color:#00a000&#34;&gt;sched_slice&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	u64 slice &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __sched_period(cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;nr_running &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	slice &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __calc_delta(slice, se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;load.weight, load);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; slice;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;通过__sched_period函数计算调度周期时间。&lt;/li&gt;
&lt;li&gt;将第一步中计算得到的周期时间通过__calc_delta函数转换为虚拟运行时间。__calc_delta()函数有两个功能，除了可以把计算进程运行时间转换成虚拟时间以外，还有第二个功能：计算调度实体se的权重占整个就绪队列权重的比例，然后乘以调度周期时间即可得到当前调度实体应该运行的时间（参数weught传递调度实体se权重，参数lw传递就绪队列权重cfs_rq-&amp;gt;load）。例如，就绪队列权重是3072，当前调度实体se权重是1024，调度周期是6ms，那么调度实体应该得到的时间是6*1024/3072=2ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;创建新进程时&#34;&gt;创建新进程时&lt;/h2&gt;
&lt;p&gt;在调用&lt;code&gt;fork&lt;/code&gt;函数创建子进程的时候，会调用&lt;code&gt;sched_fork&lt;/code&gt;函数设置子进程调度器相关的信息。该函数会调用调度器类中的&lt;code&gt;task_fork&lt;/code&gt;成员函数来完成工作，CFS调度器对应的函数就是&lt;code&gt;task_fork_fair&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;task_fork_fair&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;se, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; this_rq();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq_flags rf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cfs_rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; task_cfs_rq(current);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (curr) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		update_curr(cfs_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	place_entity(cfs_rq, se, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;-=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;更新CFS就绪队列的虚拟运行时间信息。&lt;/li&gt;
&lt;li&gt;初始化新创建的进程对应进程调度实体的虚拟运行时间，与当前进程（其父进程）一样。&lt;/li&gt;
&lt;li&gt;place_entity函数在新创建进程以及进程被唤醒的时候都会被调用，新创建的情况下第三个参数为1。&lt;/li&gt;
&lt;li&gt;以当前CPU的就绪队列最小虚拟时间为基准，对虚拟运行时间进行一定的补偿（虚拟时间越小，调度的顺位越靠前）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里，需要就第四段代码做一个说明。进程在刚创建的时候，其虚拟运行时间是根据当时所在的CPU就绪队列的最小虚拟运行时间为基础计算的，而进程真正开始被调度执行的时候，其所在的CPU很有可能不是最开始创建时所在的CPU了，中间发生了进程在不同CPU之间的迁移。因为不同的CPU之间，其虚拟运行时间也不尽相同，所以这里要做一下处理。比如进程从虚拟运行时间更小的CPU A迁移到虚拟运行时间更大的CPU B上时，可能就会占便宜，因为这个进程比CPU B上面其他的进程虚拟运行时间都小，将获得更大的执行时间。反过来也是如此。&lt;/p&gt;
&lt;p&gt;因此，内核对这部分相关情况的处理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程刚创建时（函数task_fork_fair）：在以就绪队列的最小虚拟运行时间为基准设置其最初的虚拟运行时间时，还需要再减去队列的最小虚拟运行时间。&lt;/li&gt;
&lt;li&gt;进程加入一个CFS就绪队列时（函数enqueue_entity）：虚拟运行时间要加上就绪队列的最小虚拟运行时间。&lt;/li&gt;
&lt;li&gt;进程离开一个CFS就绪队列时（函数dequeue_entity）：虚拟运行时间要减去就绪队列的最小虚拟运行时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;队列操作&#34;&gt;队列操作&lt;/h2&gt;
&lt;h3 id=&#34;入队列操作&#34;&gt;入队列操作&lt;/h3&gt;
&lt;p&gt;CFS调度算法的入队列操作是函数是&lt;code&gt;enqueue_task_fair&lt;/code&gt;，其最终会调用&lt;code&gt;enqueue_entity&lt;/code&gt;函数完成一个调度实体入队列的操作，来看看这个函数的工作流程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;enqueue_entity&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; flags)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; renorm &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;(flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; ENQUEUE_WAKEUP) &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; (flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; ENQUEUE_MIGRATED);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (renorm &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	update_curr(cfs_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (renorm &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	account_entity_enqueue(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; ENQUEUE_WAKEUP)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		place_entity(cfs_rq, se, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		__enqueue_entity(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 6 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 7 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;如果传入的调度实体是当前进程，并且当前进程不是被唤醒或者迁移CPU，那么当前进程的虚拟运行时间就需要加上队列当前的最小虚拟运行时间。虚拟运行时间增加，意味着在红黑树中往右边移动，下一次会更晚的被调度到。这一步需要在下面调用update_curr函数之前进行。&lt;/li&gt;
&lt;li&gt;调用update_curr更新当前CFS就绪队列的虚拟运行时间信息。&lt;/li&gt;
&lt;li&gt;如果不是被唤醒或者迁移CPU，并且不是当前进程，那么task_fork_fair中减去的虚拟运行时间这里加回来。&lt;/li&gt;
&lt;li&gt;flags有ENQUEUE_WAKEUP标志，意味着是被唤醒的进程，调用place_entity函数给予一定的补偿。&lt;/li&gt;
&lt;li&gt;不是当前进程的情况下，调用__enqueue_entity函数将调度实体加入红黑树中。&lt;/li&gt;
&lt;li&gt;将on_rq标志位置为1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;出队列操作&#34;&gt;出队列操作&lt;/h3&gt;
&lt;p&gt;CFS调度算法的入队列操作是函数是&lt;code&gt;dequeue_task_fair&lt;/code&gt;，其最终会调用&lt;code&gt;dequeue_entity&lt;/code&gt;函数完成一个调度实体入队列的操作，来看看这个函数的工作流程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;dequeue_entity&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; flags)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	update_curr(cfs_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (se &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		__dequeue_entity(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	account_entity_dequeue(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;(flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; DEQUEUE_SLEEP))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;-=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;min_vruntime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;更新CFS就绪队列的当前虚拟运行时间。&lt;/li&gt;
&lt;li&gt;如果不是当前进程，调用__dequeue_entity从红黑树中删除该调度实体。&lt;/li&gt;
&lt;li&gt;on_rq标志位置为0，表示不在就绪队列中。&lt;/li&gt;
&lt;li&gt;调用account_entity_dequeue更新队列的权重信息。&lt;/li&gt;
&lt;li&gt;如果进程不是由于睡眠导致的出队（比如是因为CPU迁移），那么进程的虚拟运行时间就需要减去就绪队列的最小虚拟运行时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;选择下一个执行进程&#34;&gt;选择下一个执行进程&lt;/h2&gt;
&lt;p&gt;CFS调度器选择下一个执行进程的操作由函数pick_next_task_fair完成，其主要流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/pick_next_task_fair.png&#34; alt=&#34;pick_next_task_fair&#34; title=&#34;pick_next_task_fair&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面逐个分析这几个函数。&lt;/p&gt;
&lt;h3 id=&#34;put_prev_task&#34;&gt;put_prev_task&lt;/h3&gt;
&lt;p&gt;put_prev_task函数的作用，是将即将逝去执行权的当前进程，放回到其调度器的就绪队列中，核心工作由put_prev_entity函数完成：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)
{
	if (prev-&amp;gt;on_rq)                            /* 1 */
		update_curr(cfs_rq);
	if (prev-&amp;gt;on_rq) {

		__enqueue_entity(cfs_rq, prev);         /* 2 */

		update_load_avg(cfs_rq, prev, 0);       /* 3 */
	}
	cfs_rq-&amp;gt;curr = NULL;                        /* 4 */
} 
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;如果进程的on_rq为1，表示当进程被剥夺执行权的时候，还是在就绪队列上面的，那么极有可能就是被抢占了执行权。在这种情况下，需要调用update_curr函数更新就绪队列的虚拟运行时间。反之，如果进程不在就绪队列上了，这里并不做操作跳过更新，因为在deactivate_task函数中已经调用update_curr函数进行了更新。&lt;/li&gt;
&lt;li&gt;如果进程还在就绪队列上，调用__enqueue_entity函数重新加入就绪队列的红黑树中。&lt;/li&gt;
&lt;li&gt;调用update_load_avg函数更新就绪队列的负载信息。&lt;/li&gt;
&lt;li&gt;将就绪队列的当前进程指针置为NULL。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pick_next_entity&#34;&gt;pick_next_entity&lt;/h3&gt;
&lt;p&gt;pick_next_entity函数的作用是从红黑树中选择下一个调度进程的调度实体返回：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;pick_next_entity&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;left &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __pick_first_entity(cfs_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;left &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; (curr &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; entity_before(curr, left)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		left &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; left; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;skip &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; se) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;second;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (se &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; curr) {	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			second &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __pick_first_entity(cfs_rq);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		} &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			second &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __pick_next_entity(se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 6 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;second &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; (curr &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; entity_before(curr, second)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				second &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 7 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (second &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wakeup_preempt_entity(second, left) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; second;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 8 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;last &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wakeup_preempt_entity(cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;last, left) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;last;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 9 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wakeup_preempt_entity(cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next, left) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 10 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;调用__pick_first_entity函数，取红黑树最左子节点的调度实体，根据我们前面的分析，这是目前虚拟运行时间最小的进程。&lt;/li&gt;
&lt;li&gt;如果left为NULL，或者当前进程curr的虚拟运行时间比left节点更小，说明curr进程是主动放弃了执行权力，且其优先级比最左子节点的进程更优，此时将left指向curr。&lt;/li&gt;
&lt;li&gt;此时left存储的是目前最优的调度实体指针，se保存下来。&lt;/li&gt;
&lt;li&gt;cfs_rq-&amp;gt;skip存储了需要调过不参与调度的进程调度实体，如果我们挑选出来的最优调度实体se正好是skip，就需要重新作出选择。&lt;/li&gt;
&lt;li&gt;如果前面选择的se指针，正好是当前进程，这样就重新__pick_first_entity拿到当前红黑树的最左子节点。&lt;/li&gt;
&lt;li&gt;否则，skip = se = left的情况，调用__pick_next_entity选择se的下一个子节点。&lt;/li&gt;
&lt;li&gt;如果second == NULL，说明没有次优的进程，或者curr不为NULL的情况下，且curr进程比second进程更优，就将second指向curr，即curr是最优的进程。&lt;/li&gt;
&lt;li&gt;在second不为NULL，且left和second的vruntime的差距是否小于sysctl_sched_wakeup_granularity的情况下，那么second进程能抢占left的执行权。&lt;/li&gt;
&lt;li&gt;判断上一个执行的进程能否抢占left的执行权。&lt;/li&gt;
&lt;li&gt;判断next的执行权能否抢占left的执行权。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;set_next_entity&#34;&gt;set_next_entity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;set_next_entity&lt;/code&gt;函数用于将调度实体存放的进程做为下一个可执行进程的信息保存下来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;set_next_entity&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;on_rq) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		__dequeue_entity(cfs_rq, se);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		update_load_avg(cfs_rq, se, UPDATE_TG);	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	cfs_rq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;curr &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; se;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prev_sum_exec_runtime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;sum_exec_runtime;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;__dequeue_entity用于将调度实体从红黑树中删除。对于即将被调度执行的进程，都会从红黑树中删除。而当进程被抢占后，会调用&lt;code&gt;put_prev_entity&lt;/code&gt;函数重新插入到红黑树中。因此这里与&lt;code&gt;put_prev_entity&lt;/code&gt;函数中插入红黑树的操作一一对应。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;update_load_avg&lt;/code&gt;函数更新就绪队列的负载信息，在负载均衡的时候会用到。&lt;/li&gt;
&lt;li&gt;更新就绪队列的当前在执行进程指针。&lt;/li&gt;
&lt;li&gt;更新调度实体的&lt;code&gt;prev_sum_exec_runtime&lt;/code&gt;成员，该成员用于统计当前进程已经运行的时间，&lt;code&gt;check_preempt_tick&lt;/code&gt;函数中会使用到，做为判断进程是否能够被抢占的依据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;处理周期性调度器&#34;&gt;处理周期性调度器&lt;/h2&gt;
&lt;p&gt;CFS调度器中，处理周期性调度器的函数是&lt;code&gt;task_tick_fair&lt;/code&gt;，实际工作由&lt;code&gt;entity_tick&lt;/code&gt;函数负责，其核心流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/entity_tick.png&#34; alt=&#34;entity_tick&#34; title=&#34;entity_tick&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;update_curr&lt;/code&gt;是更新就绪队列虚拟运行时间的函数，前面已经介绍过就不再阐述，重点看这里的&lt;code&gt;check_preempt_tick&lt;/code&gt;函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;check_preempt_tick&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;curr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; ideal_runtime, delta_exec;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	s64 delta;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ideal_runtime &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; sched_slice(cfs_rq, curr);    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	delta_exec &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;sum_exec_runtime &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prev_sum_exec_runtime;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (delta_exec &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ideal_runtime) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		resched_curr(rq_of(cfs_rq));              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 3 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		clear_buddies(cfs_rq, curr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (delta_exec &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; sysctl_sched_min_granularity)    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 4 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __pick_first_entity(cfs_rq);             &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 5 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	delta &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; se&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;vruntime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (delta &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 6 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (delta &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ideal_runtime)                    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 7 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		resched_curr(rq_of(cfs_rq));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;sched_slice()函数上面已经分析过，计算curr进程在本次调度周期中应该分配的时间片。时间片用完就应该被抢占。&lt;/li&gt;
&lt;li&gt;sum_exec_runtime与prev_sum_exec_runtime的差值delta_exec是当前进程已经运行的实际时间。&lt;/li&gt;
&lt;li&gt;如果实际运行时间已经超过分配给进程的时间片，自然就需要抢占当前进程。设置TIF_NEED_RESCHED flag。&lt;/li&gt;
&lt;li&gt;为了防止频繁过度抢占，我们应该保证每个进程运行时间不应该小于最小粒度时间sysctl_sched_min_granularity。因此如果运行时间小于最小粒度时间，不应该抢占。&lt;/li&gt;
&lt;li&gt;从红黑树中找到虚拟时间最小的调度实体。&lt;/li&gt;
&lt;li&gt;如果当前进程的虚拟时间仍然比红黑树中最左边调度实体虚拟时间小，也不应该发生调度。&lt;/li&gt;
&lt;li&gt;这里把虚拟时间和实际时间比较，看起来很奇怪。感觉就像是bug一样，然后经过查看提交记录，作者的意图是：希望权重小的任务更容易被抢占。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;唤醒抢占&#34;&gt;唤醒抢占&lt;/h2&gt;
&lt;p&gt;当进程被唤醒时（wake_up_new_task、try_to_wake_up等），也是检查进程是否可以抢占当前进程执行权的时机，此时会调用&lt;code&gt;check_preempt_curr&lt;/code&gt;来做这个抢占检查的工作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
{
	const struct sched_class *class;
 
	if (p-&amp;gt;sched_class == rq-&amp;gt;curr-&amp;gt;sched_class) {
		rq-&amp;gt;curr-&amp;gt;sched_class-&amp;gt;check_preempt_curr(rq, p, flags);   /* 1 */
	} else {
		for_each_class(class) {                                    /* 2 */
			if (class == rq-&amp;gt;curr-&amp;gt;sched_class)
				break;
			if (class == p-&amp;gt;sched_class) {
				resched_curr(rq);
				break;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;唤醒的进程和当前的进程同属于一个调度类，直接调用调度类的&lt;code&gt;check_preempt_curr&lt;/code&gt;函数检查抢占条件。&lt;/li&gt;
&lt;li&gt;否则如果唤醒的进程和当前进程不属于一个调度类，就需要按照调度器类的优先级来选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CFS调度器的&lt;code&gt;check_preempt_curr&lt;/code&gt;函数由&lt;code&gt;check_preempt_wakeup&lt;/code&gt;实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;check_preempt_wakeup&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; wake_flags)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; sched_entity &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;se &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;curr&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;se, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pse &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;se;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; cfs_rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cfs_rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; task_cfs_rq(curr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (wakeup_preempt_entity(se, pse) &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;goto&lt;/span&gt; preempt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;preempt&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	resched_curr(rq);                           &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;wakeup_preempt_entity&lt;/code&gt;函数检查唤醒的进程是否满足抢占当前进程的条件。&lt;/li&gt;
&lt;li&gt;如果可以抢占当前进程，调用&lt;code&gt;resched_curr&lt;/code&gt;函数，其内部实现是设置TIF_NEED_RESCHED flag。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;wakeup_preempt_entity&lt;/code&gt;函数传入两个调度实体，返回对比结果，分为以下几种情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200503-sgfap-process-schedule/wakeup_preempt_entity.png&#34; alt=&#34;wakeup_preempt_entity&#34; title=&#34;wakeup_preempt_entity&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里之所以要在大于se虚拟运行时间的情况下，需要保证大于gran值才返回1允许调度，是为了避免抢占过于频繁，导致大量上下文切换影响系统性能。默认情况下，wakeup_gran()函数返回的值是1ms根据调度实体se的权重计算的虚拟时间。&lt;/p&gt;
&lt;p&gt;因此，满足抢占的条件就是，唤醒的进程的虚拟时间首先要比正在运行进程的虚拟时间小，
并且差值还要大于一定的值才行（这个值是sysctl_sched_wakeup_granularity，称作唤醒抢占粒度）。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《深入Linux内核架构》第2章《进程管理和调度》&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wowotech.net/process_management/447.html&#34;&gt;CFS调度器（1）-基本原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wowotech.net/process_management/448.html&#34;&gt;CFS调度器（2）-源码解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之进程</title>
      <link>https://www.codedump.info/post/20200502-sgfap-process/</link>
      <pubDate>Sat, 02 May 2020 14:41:22 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200502-sgfap-process/</guid>
      
      <description>&lt;p&gt;本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;概论&#34;&gt;概论&lt;/h1&gt;
&lt;p&gt;进程即处于执行状态的程序。操作系统执行进程时，大体经历了以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为进程分配空间及其他相关资源。&lt;/li&gt;
&lt;li&gt;加载进程可执行程序到内存中。&lt;/li&gt;
&lt;li&gt;由调度器选择进程来占用CPU资源执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的描述可以看到，进程并不是仅仅只有可执行程序二进制文件就可以运行起来，还需要执行时所需要的资源（内存、CPU等）、进程执行时需要的其他共享库等。&lt;/p&gt;
&lt;p&gt;在现代操作系统中，进程提供了针对两种资源的虚拟机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟处理器。&lt;/li&gt;
&lt;li&gt;虚拟内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然在同一时间有多个进程在执行，即分享处理器资源，但是虚拟处理器提供了一种假象：让这些进程认为自己都在独占处理器执行，这里涉及到进程调度部分的内容，在后面进程调度篇再展开讨论。&lt;/p&gt;
&lt;p&gt;同时，进程使用的内存实际上虚拟内存，虚拟内存机制使进程以为自己拥有整个4G空间（32位处理器下）而不必关心其他进程的内存空间，这部分内容在内存篇中讲解。&lt;/p&gt;
&lt;p&gt;程序本身并不是进程，进程是在执行的程序以及相关资源的总称。&lt;/p&gt;
&lt;p&gt;本篇从进程开始讲起，涉及内核管理进程的数据结构、与进程创建和执行相关的系统调用、进程的状态。&lt;/p&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;p&gt;Linux内核使用&lt;code&gt;task_struct&lt;/code&gt;结构体来描述一个进程的所有信息。考虑这个结构体的内容太多，这里并不打算全部列举出来，到讲解需要涉及到的时候才提出其中的某些成员详细说明，这里只列出最关键的几个成员：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/task_struct.png&#34; alt=&#34;task_struct&#34; title=&#34;task_struct&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state：用于表示进程的状态，下面将展开讨论。&lt;/li&gt;
&lt;li&gt;pid：每个进程都有一个pid与之对应。&lt;/li&gt;
&lt;li&gt;mm：类型为&lt;code&gt;mm_struct&lt;/code&gt;，用于表示进程的内存地址信息，后面内存部分将展开讨论。&lt;/li&gt;
&lt;li&gt;fs：类型为&lt;code&gt;fs_struct&lt;/code&gt;，用于表示文件系统信息，后面IO部分将展开讨论。&lt;/li&gt;
&lt;li&gt;files：类型为&lt;code&gt;files_struct&lt;/code&gt;，用于表示进程打开文件的信息，后面IO部分将展开讨论。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程的状态&#34;&gt;进程的状态&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;task_struct&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;成员，用于表示当前进程的状态，进程的状态必然处于以下五种状态之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TASK_RUNNING：进程是可执行的（Runnable），表示进程要么正在执行，要么正要准备执行（已经就绪），等待cpu时间片的调度。&lt;/li&gt;
&lt;li&gt;TASK_INTERRUPTIBLE：进程因为等待一些条件而被挂起（阻塞）而所处的状态。这些条件主要包括：硬中断、资源、一些信号等，一旦等待的条件成立，进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING。&lt;/li&gt;
&lt;li&gt;TASK_UNINTERRUPTIBLE：此进程状态类似于&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;，只是它不会处理信号。中断处于这种状态的进程是不合适的，因为它可能正在完成某些重要的任务。 当它所等待的事件发生时，进程将被显式的唤醒呼叫唤醒。&lt;/li&gt;
&lt;li&gt;TASK_TRACED：正被调试程序等其它进程监控时，进程将进入这种状态。&lt;/li&gt;
&lt;li&gt;TASK_STOPPED：进程被停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几个状态之间，转换关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/taskstate.png&#34; alt=&#34;taskstate&#34; title=&#34;taskstate&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的状态转换图中，休眠状态（SLEEPING）包括了&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;和&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;，并没有做区分；另外，按照前面的讲述，&lt;code&gt;TASK_RUNNING&lt;/code&gt;状态区分了就绪以及在运行状态，由于这两者都是&lt;code&gt;TASK_RUNNING&lt;/code&gt;状态，所以分到了同一组里，又因为需要细化这两者之间的状态，内部也有状态之间的迁移。&lt;/p&gt;
&lt;p&gt;根据上面的状态转换图，进程状态的转换有这几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;正在运行的进程，由于需要等待某些事件（比如网络IO、磁盘IO等），进入休眠状态。&lt;/li&gt;
&lt;li&gt;正在运行的进程，由于时间片用完或者被其他更高优先级的进程抢占等因素，虽然还是就绪状态，但是被剥夺了执行权，进入就绪队列等待下一次被唤醒执行。&lt;/li&gt;
&lt;li&gt;处于休眠状态的进程，由于等待的事件满足被唤醒，进入就绪队列中等待被调度运行。&lt;/li&gt;
&lt;li&gt;处于就绪队列中的进程，被调度器分配CPU时间调度执行。&lt;/li&gt;
&lt;li&gt;在运行的进程退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了上面几种状态以外，还有僵尸（zombie）状态（内核使用&lt;code&gt;EXIT_ZOMBIE&lt;/code&gt;宏表示），用于表示进程已经不再执行，等待被回收的状态。&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;ps aux&lt;/code&gt;命令时，可以查询到系统中进程所处的状态，与上面描述的内核中进程状态一一对应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S：休眠状态（sleeping），对应&lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;R：等待运行（runable）对应&lt;code&gt;TASK_RUNNING&lt;/code&gt;，进程处于运行或就绪状态。&lt;/li&gt;
&lt;li&gt;I：空闲状态（idle）。&lt;/li&gt;
&lt;li&gt;Z：僵尸状态（zombie），对应&lt;code&gt;EXIT_ZOMBIE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;T：暂停或跟踪状态（Traced），对应&lt;code&gt;TASK_TRACED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;D: 不可中断的睡眠状态，对应&lt;code&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，需要再次强调的是，进程处于&lt;code&gt;Runnable&lt;/code&gt;状态时，并不代表就在执行，而是处于就绪可执行状态，由调度器最终决定进程执行。&lt;/p&gt;
&lt;h1 id=&#34;进程的创建&#34;&gt;进程的创建&lt;/h1&gt;
&lt;p&gt;Unix系统将进程的执行放在两个不同的函数中执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fork：fork函数拷贝父进程来创建一个子进程，fork函数调用后会分别在父子进程中各返回一次，区别在于：父进程中的返回值是所创建的子进程的进程pid，而子进程则是返回0表示创建成功。&lt;/li&gt;
&lt;li&gt;exec函数组：在fork调用返回后，子进程就创建完成了，如果需要运行一个与父进程不同的可执行文件，就通过&lt;code&gt;exec&lt;/code&gt;函数组来完成这个工作。如果不调用&lt;code&gt;exec&lt;/code&gt;，那么也就意味着父子进程运行的是同一份可执行文件代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他操作系统，有一些把以上两步合在一个函数中完成，即在同一个函数中既完成子进程的创建，也完成子进程的执行，Unix系统将以上两步分开成两个步骤，为shell执行程序提供了方便，因为shell可以在&lt;code&gt;fork&lt;/code&gt;创建进程之后，调用&lt;code&gt;exec&lt;/code&gt;来执行程序之前改变子进程的一些行为。比如让shell方便的实现类似重定向（redirect）的功能：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wc test.txt &amp;gt; stat
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面的脚本中，希望将&lt;code&gt;wc&lt;/code&gt;命令的输出结果重定向到文件&lt;code&gt;stat&lt;/code&gt;中。shell在&lt;code&gt;fork&lt;/code&gt;创建了子进程之后，在&lt;code&gt;exec&lt;/code&gt;执行之前，关闭该子进程的标准输出，然后打开文件&lt;code&gt;stat&lt;/code&gt;，这样打开的文件就获得了刚刚关闭的标准输出的fd，执行&lt;code&gt;wc&lt;/code&gt;命令的子进程结果就写入到了文件&lt;code&gt;stat&lt;/code&gt;中。&lt;/p&gt;
&lt;h2 id=&#34;写时复制机制&#34;&gt;写时复制机制&lt;/h2&gt;
&lt;p&gt;前面提到过，fork函数为子进程创建一个父进程地址空间的副本，复制属于父进程的页面。然而，考虑到许多子进程在创建之后立即调用系统调用exec函数组来执行另外的程序代码，父进程地址空间的复制可能没有必要。&lt;/p&gt;
&lt;p&gt;因此，Linux内核在实现时，使用了写时复制的技术（Copy On Write，简称COW），子进程在刚开始创建时与父进程共享同样的地址空间，仅当子进程要修改父进程地址空间的内容时才创建新的地址空间，从而使父子进程有各自的拷贝。&lt;/p&gt;
&lt;p&gt;Redis在生成RDB快照文件时，就利用了Linux写时复制机制。生成快照文件时，Redis主进程&lt;code&gt;fork&lt;/code&gt;创建一个子进程，根据这里的解释，此时子进程的内存地址就是共享的父进程的空间。这样，父进程可以继续服务请求，而子进程跟进进程创建时候的内存信息，生成快照文件，结束了之后自行退出即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/redis.png&#34; alt=&#34;redis&#34; title=&#34;redis&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;fork的实现&#34;&gt;fork的实现&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;fork&lt;/code&gt;函数之外，还有另外几个提供给用户态用于创建进程相关的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vfork：与&lt;code&gt;fork&lt;/code&gt;的区别在于，vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。&lt;/li&gt;
&lt;li&gt;clone：&lt;code&gt;pthread&lt;/code&gt;函数族使用clone来创建轻量级进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个函数，内部实际上最终都调用&lt;code&gt;_do_fork&lt;/code&gt;的内核函数完成创建子进程的工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/fork.png&#34; alt=&#34;fork&#34; title=&#34;fork&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面就展开简单分析&lt;code&gt;_do_fork&lt;/code&gt;函数的实现。&lt;/p&gt;
&lt;h3 id=&#34;_do_fork函数流程&#34;&gt;_do_fork函数流程&lt;/h3&gt;
&lt;p&gt;创建新进程，调用的是&lt;code&gt;_do_fork&lt;/code&gt;函数，其主要流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/do_fork.png&#34; alt=&#34;do_fork&#34; title=&#34;do_fork&#34;&gt;&lt;/p&gt;
&lt;p&gt;以下就这几个核心流程来做分析。&lt;/p&gt;
&lt;h4 id=&#34;copy_process&#34;&gt;copy_process&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;copy_process&lt;/code&gt;函数中完成复制进程数据相关的工作，下面再展开对这个函数的详细分析。&lt;/p&gt;
&lt;h4 id=&#34;获取子进程pid&#34;&gt;获取子进程pid&lt;/h4&gt;
&lt;p&gt;调用&lt;code&gt;get_task_pid&lt;/code&gt;函数获得子进程的pid。&lt;/p&gt;
&lt;h4 id=&#34;vfork相关的初始化处理&#34;&gt;vfork相关的初始化处理&lt;/h4&gt;
&lt;p&gt;如果传入的标志位中有&lt;code&gt;CLONE_VFORK&lt;/code&gt;标志位，执行相关的初始化，主要是初始化&lt;code&gt;completion&lt;/code&gt;结构体。&lt;/p&gt;
&lt;h4 id=&#34;wake_up_new_task&#34;&gt;wake_up_new_task&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;wake_up_new_task&lt;/code&gt;函数将初始化一些与进程调度器相关的数据，将新创建的子进程加入到调度器的就绪队列中，让子进程有机会被调度器调度执行，同时切换进程状态为&lt;code&gt;TASK_RUNNING&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;wake_up_new_task&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq_flags rf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; rq &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  raw_spin_lock_irqsave(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pi_lock, rf.flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 切换进程状态为TASK_RUNNING
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; TASK_RUNNING;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 对调度器运行队列加锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; __task_rq_lock(p, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将进程放入调度器运行队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	activate_task(rq, p, ENQUEUE_NOCLOCK);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 进程入队列的trace event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	trace_sched_wakeup_new(p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	task_rq_unlock(rq, p, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;vfork相关的处理&#34;&gt;vfork相关的处理&lt;/h4&gt;
&lt;p&gt;如果传入的标志位中有&lt;code&gt;CLONE_VFORK&lt;/code&gt;标志位，父进程等待子进程执行exec函数来替换地址空间。在这里，会用到前面初始化的&lt;code&gt;completion&lt;/code&gt;结构体，用于父进程等待子进程执行完毕。&lt;/p&gt;
&lt;h3 id=&#34;copy_process函数的流程&#34;&gt;copy_process函数的流程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;copy_process&lt;/code&gt;函数负责在创建子进程时拷贝父进程的相关信息，即创建好子进程的&lt;code&gt;task_struct&lt;/code&gt;结构体，其主要流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/copy_process.png&#34; alt=&#34;copy_process&#34; title=&#34;copy_process&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用函数dup_task_struct，复制父进程的task_struct结构体信息。此时，子进程与父进程的描述符是完全相同的。&lt;/li&gt;
&lt;li&gt;初始化task_struct结构体信息。&lt;/li&gt;
&lt;li&gt;调用sched_fork函数，设置调度器相关信息。&lt;/li&gt;
&lt;li&gt;调用copy_*函数，复制、共享父进程的数据，如mm、fs等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sched_fork&#34;&gt;sched_fork&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;sched_fork&lt;/code&gt;函数用于初始化子进程与调度器相关的信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/sched/core.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;sched_fork&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;long&lt;/span&gt; clone_flags, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;p)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 分配进程执行的cpu
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cpu &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; get_cpu();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 设置调度器相关的信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	__sched_fork(clone_flags, p);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 刚创建好的进程，其状态为TASK_NEW
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; TASK_NEW;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 设置进程优先级
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	p&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;prio &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; current&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;normal_prio;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 设置进程的cpu信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	__set_task_cpu(p, cpu);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;复制共享父进程资源数据&#34;&gt;复制/共享父进程资源数据&lt;/h4&gt;
&lt;p&gt;task_struct结构体中包含一些表示进程资源的指针，比如&lt;code&gt;mm&lt;/code&gt;，&lt;code&gt;files&lt;/code&gt;等，创建进程的标志位中有很多名为&lt;code&gt;CLONE_*&lt;/code&gt;的标志，表示是从父进程拷贝一份这部分数据，还是与父进程共享一份数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当这个标志位为0时：说明需要从父进程复制一份该类型资源数据，子进程复制完毕之后，将该资源计数赋值为1，而父进程资源计数维持不变。&lt;/li&gt;
&lt;li&gt;当这个标志位为1时：说明子进程共享父进程的该类型资源数据，此时该资源计数递增1即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200502-sgfap-process/clone_res.png&#34; alt=&#34;clone_res&#34; title=&#34;clone_res&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里调用了如下的&lt;code&gt;copy_*&lt;/code&gt;函数完成工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;copy_semundo&lt;/code&gt;函数：如果&lt;code&gt;COPY_SYSVSEM&lt;/code&gt;置位，则使用父进程的System V信号量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_files&lt;/code&gt;函数：如果&lt;code&gt;CLONE_FILES&lt;/code&gt;置位，则使用父进程的进程描述符（结构体&lt;code&gt;files_struct&lt;/code&gt;），否则调用函数&lt;code&gt;dup_fd&lt;/code&gt;复制一份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_fs&lt;/code&gt;函数：如果&lt;code&gt;CLONE_FS&lt;/code&gt;置位，则使用父进程的上下文（结构体&lt;code&gt;fs_struct&lt;/code&gt;），否则调用函数&lt;code&gt;copy_fs_struct&lt;/code&gt;复制一份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_sighand&lt;/code&gt;函数：如果&lt;code&gt;CLONE_SIGHAND&lt;/code&gt;或者&lt;code&gt;CLONE_THREAD&lt;/code&gt;置位，则使用父进程的信号处理程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_signal&lt;/code&gt;函数：如果&lt;code&gt;CLONE_THREAD&lt;/code&gt;置位，则与父进程使用同一份结构体&lt;code&gt;signal_struct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_mm&lt;/code&gt;函数：如果&lt;code&gt;CLONE_VM&lt;/code&gt;置位，则父子进程共享同一份地址空间，这种情况下父子进程使用同一份&lt;code&gt;mm_struct&lt;/code&gt;实例。如果&lt;code&gt;CLONE_VM&lt;/code&gt;没有置位，并不意味着子进程需要复制一份父进程的整个地址空间，内核确实会创建页表的一份数据，但是这里还并不复制页表的内容，这是由&lt;code&gt;COW&lt;/code&gt;机制决定的，只有在子进程需要修改地址空间内容时才进行实际的复制操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_thread&lt;/code&gt;函数：复制进程中特定于线程中的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;进程的启动&#34;&gt;进程的启动&lt;/h1&gt;
&lt;p&gt;创建完成新进程之后，将使用新进程的代码替换现有代码，即可启动新进程。这一工作由系统调用&lt;code&gt;execve&lt;/code&gt;完成，该系统调用的内核入口函数是&lt;code&gt;sys_execve&lt;/code&gt;函数，其最终会调用&lt;code&gt;do_execveat_common&lt;/code&gt;函数完成工作。&lt;/p&gt;
&lt;p&gt;其大体工作流程不外乎以下几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开二进制可执行文件。&lt;/li&gt;
&lt;li&gt;初始化启动时的一些信息，比如命令行参数、环境变量等。&lt;/li&gt;
&lt;li&gt;调用对应的可执行文件加载函数解析该二进制文件信息，执行进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（这里不展开这部分讨论了）&lt;/p&gt;
&lt;h1 id=&#34;进程的退出&#34;&gt;进程的退出&lt;/h1&gt;
&lt;p&gt;如果进程先于其父进程退出，那么它的父进程需要调用&lt;code&gt;wait&lt;/code&gt;系统调用等待子进程的退出，进行资源的回收。
没有调用&lt;code&gt;wait&lt;/code&gt;回收的子进程，将成为“僵尸进程”，除此之外，还有另一种进程叫“孤儿进程”，下面展开看看这两种进程。&lt;/p&gt;
&lt;h2 id=&#34;孤儿进程和僵尸进程&#34;&gt;孤儿进程和僵尸进程&lt;/h2&gt;
&lt;p&gt;在Linux系统中，正常情况下，当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。&lt;/p&gt;
&lt;p&gt;但是这个过程也有以外的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;孤儿进程：一个父进程先于它的子进程退出，这些子进程将成为&lt;code&gt;孤儿进程&lt;/code&gt;。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。&lt;/li&gt;
&lt;li&gt;僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，当&lt;code&gt;init&lt;/code&gt;成为进程的父进程时，内部会循环调用&lt;code&gt;wait&lt;/code&gt;函数等待其管辖的子进程的退出，因此孤儿进程并不会有什么危害。&lt;/p&gt;
&lt;p&gt;相反，僵尸进程因为一直没有被回收，其占用的进程pid也就一直不会回收，而进程pid属于系统的一个资源，这将导致这个资源的泄露，因此僵尸进程是有害的。如果使用&lt;code&gt;ps aux&lt;/code&gt;命令来查看进程状态，那么僵尸进程的状态就是&lt;code&gt;Z&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面简单演示两种进程的产生。&lt;/p&gt;
&lt;p&gt;首先是孤儿进程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; fork();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        perror(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;fork error:&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exit(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;I am the child process.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid: %d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;ppid:%d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;,getpid(),getppid());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;I will sleep five seconds.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sleep(&lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid: %d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;ppid:%d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;,getpid(),getppid());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;child process is exited.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;I am father process.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sleep(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;father process is  exited.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父进程调用&lt;code&gt;fork&lt;/code&gt;函数创建一个子进程，返回之后马上退出。&lt;/li&gt;
&lt;li&gt;子进程在&lt;code&gt;fork&lt;/code&gt;调用返回之后打印出自己的父进程pid，此时就是上面的父进程，然后休眠五秒钟等待父进程退出，然后再次打印父进程pid。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我的机器上输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;I am father process.
I am the child process.
pid: 5938	ppid:5937
I will sleep five seconds.
father process is  exited.

pid: 5938	ppid:1
child process is exited.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，子进程的父进程pid在五秒之后变成1，即&lt;code&gt;init&lt;/code&gt;进程。&lt;/p&gt;
&lt;p&gt;再来看僵尸进程的产生：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; fork();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        perror(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;fork error:&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exit(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (pid &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;I am child process.I am exiting.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        exit(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;I am father process.I will sleep two seconds&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sleep(&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    system(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;ps -o pid,ppid,state,tty,command&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;father process is exiting.&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子进程在&lt;code&gt;fork&lt;/code&gt;调用返回之后马上退出。&lt;/li&gt;
&lt;li&gt;父进程在&lt;code&gt;fork&lt;/code&gt;调用返回之后先休眠2秒等待子进程退出，然后调用&lt;code&gt;system&lt;/code&gt;函数打印出&lt;code&gt;ps&lt;/code&gt;命令的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;I am father process.I will sleep two seconds
I am child process.I am exiting.
  PID  PPID S TT       COMMAND
 5817  5816 S pts/19   -zsh
 5971  5817 S pts/19   ./t
 5972  5971 Z pts/19   [t] &amp;lt;defunct&amp;gt;
 5973  5971 S pts/19   sh -c ps -o pid,ppid,state,tty,command
 5974  5973 R pts/19   ps -o pid,ppid,state,tty,command
father process is exiting.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，子进程的状态变成了&lt;code&gt;Z&lt;/code&gt;，也就是僵尸进程。&lt;/p&gt;
&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;
&lt;p&gt;总结一下进程这一节涉及到的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程是在执行的程序以及相关资源的总称。&lt;/li&gt;
&lt;li&gt;Linux内核中使用&lt;code&gt;task_struct&lt;/code&gt;结构体来描述一个进程的所有信息。&lt;/li&gt;
&lt;li&gt;进程会在不同的状态之间切换，可以使用&lt;code&gt;ps aux&lt;/code&gt;命令来查看进程的状态。&lt;/li&gt;
&lt;li&gt;Linux内核使用&lt;code&gt;fork&lt;/code&gt;函数来创建子进程时，采用的是“写时复制”机制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt;、&lt;code&gt;vfork&lt;/code&gt;、&lt;code&gt;clone&lt;/code&gt;函数最终由&lt;code&gt;do_fork&lt;/code&gt;函数实现。&lt;/li&gt;
&lt;li&gt;Unix系统将创建子进程和执行分开，给shell实现一些特殊的操作提供了方便。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》导论</title>
      <link>https://www.codedump.info/post/20200501-system-guide-for-application-programmer/</link>
      <pubDate>Fri, 01 May 2020 21:43:43 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200501-system-guide-for-application-programmer/</guid>
      
      <description>&lt;h1 id=&#34;导论&#34;&gt;导论&lt;/h1&gt;
&lt;p&gt;我想整理这份文档很久了。&lt;/p&gt;
&lt;p&gt;做为一个主要工作在应用层、用户态的开发者，我看了不少的所谓“内核资料”。我身边不少与我相似工作背景的人，也在不停的看“内核”、写各种内核代码分析。另一方面，在遇到很多系统方面的知识时，并没有太多能够系统解答这部分内容的地方，比如如下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;free&lt;/code&gt;命令中的&lt;code&gt;buffer&lt;/code&gt;和&lt;code&gt;cache&lt;/code&gt;分别是什么？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uptime&lt;/code&gt;命令中显示的数据来源是什么？&lt;/li&gt;
&lt;li&gt;用户态进程的CPU时间，都由哪些部分组成？&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是这两个维度层面的断档：内核资料大部分是写给在内核态工作的人看的，并没有从用户态的角度去解释一些系统相关的概念，导致了用户态开发者看各种内核文档时云里雾里，最后并没有给自己理解和解决系统问题带来太多的帮助。&lt;/p&gt;
&lt;p&gt;所以，我想从应用开发者的角度，抽出系统中最重要的那些概念，结合一些不那么复杂的内核代码解读（毕竟复杂的我也不会）、相关命令指标的数据来源（比如前面的&lt;code&gt;free&lt;/code&gt;命令）、&lt;code&gt;systemtap&lt;/code&gt;脚本等等手段，帮助工作在Linux上的应用开发者来更好的理解系统。&lt;/p&gt;
&lt;p&gt;如果打一个可能不是很恰当的比方，内核文档在我看来就是写给数学系的《数学分析》，但是工科学生并不需要了解的过于深入，他们需要的是一本面向工科生、实际解决他们遇到的问题的《高等数学》即可。&lt;/p&gt;
&lt;p&gt;这份文档就想能够写一本给应用开发者的“《高等数学》”，最后完成时，不一定能尽善尽美，但是希望能打开一扇窗户：应用开发者不应该在过多的内核细节中深入，而是应该从自己遇到的问题出发，带着问题抽丝剥茧在内核中去掉不重要的细节，寻找自己问题的答案。&lt;/p&gt;
&lt;p&gt;这份文档将逐渐更新（希望最后不会太监），将主要分为CPU篇、内存篇、IO篇，本来还应该有个网络篇，不过我还是先完成前面这个小目标再继续吧。&lt;/p&gt;
&lt;p&gt;本文档基于Ubuntu16、内核版本4.15进行讲解，但是其中大部分的概念、内容应该都不会随着版本有太大的变动。&lt;/p&gt;
&lt;p&gt;今后的文档，将更新到下面这个目录中。&lt;/p&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;h2 id=&#34;基础篇&#34;&gt;基础篇&lt;/h2&gt;
&lt;p&gt;因为后续会使用&lt;code&gt;systemtap&lt;/code&gt;脚本来理解内核的一些行为，所以&lt;code&gt;systemtap&lt;/code&gt;的相关的原理和使用放在基础篇中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200128-systemtap-by-example/&#34;&gt;通过实例快速入门Systemtap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200218-linux-traceevent/&#34;&gt;Systemtap中内核trace事件的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu篇&#34;&gt;CPU篇&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200502-sgfap-process/&#34;&gt;进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-schedule/&#34;&gt;进程调度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-systemtap/&#34;&gt;使用systemtap分析进程的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200516-sgfap-syscall/&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;&gt;软中断&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存篇&#34;&gt;内存篇&lt;/h2&gt;
&lt;h2 id=&#34;io篇&#34;&gt;IO篇&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>Systemtap中内核trace事件的实现</title>
      <link>https://www.codedump.info/post/20200218-linux-traceevent/</link>
      <pubDate>Tue, 18 Feb 2020 17:37:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200218-linux-traceevent/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;内核中定义了一系列的trace point，这些trace point在特定的内核函数中被触发调用时被记录，而对应到systemtap中就是&lt;code&gt;kernel.trace&lt;/code&gt;类型的probe事件，可以使用命令来查看系统所有的trace point：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;kernel.trace(&amp;#34;*&amp;#34;)&amp;#39; | more
kernel.trace(&amp;#34;9p:9p_client_req&amp;#34;) $clnt:struct p9_client* $type:int8_t $tag:int
kernel.trace(&amp;#34;9p:9p_client_res&amp;#34;) $clnt:struct p9_client* $type:int8_t $tag:int $err:int
kernel.trace(&amp;#34;9p:9p_protocol_dump&amp;#34;) $clnt:struct p9_client* $pdu:struct p9_fcall*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换言之，通过systemtap能够对这些已经静态注册的内核调用记录点进行监控、跟踪。&lt;/p&gt;
&lt;p&gt;以下来解释trace point在内核的实现以及与systemtap相关的内容。&lt;/p&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;p&gt;内核通过&lt;code&gt;DECLARE_TRACE&lt;/code&gt;来声明一个trace point：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DECLARE_TRACE(subsys_eventname,
	TP_PROTO(int firstarg, struct task_struct *p),
	TP_ARGS(firstarg, p));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;subsys_eventname是定义trace事件的唯一字符串，又能拆解成两部分：subsys就是子系统的名称，而eventname是事件名称。比如下面将作为实例的&lt;code&gt;softirq_entry&lt;/code&gt;，就定义了一个在&lt;code&gt;softirq&lt;/code&gt;子系统中的&lt;code&gt;entry&lt;/code&gt;事件。&lt;/li&gt;
&lt;li&gt;TP_PROTO(int firstarg, struct task_struct *p)：定义了传入trace函数的参数原型。&lt;/li&gt;
&lt;li&gt;TP_ARGS(firstarg, p)：定义了参数名称，其类型与TP_PROTO中的类型一一对应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个宏的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// include/linux/tracepoint.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define DECLARE_TRACE(name, proto, args)				\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			cpu_online(raw_smp_processor_id()),		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			PARAMS(void *__data, proto),			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			PARAMS(__data, args))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中的宏&lt;code&gt;__DECLARE_TRACE&lt;/code&gt;定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	extern struct tracepoint __tracepoint_##name;			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline void trace_##name(proto)				\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		if (static_key_false(&amp;amp;__tracepoint_##name.key))		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			__DO_TRACE(&amp;amp;__tracepoint_##name,		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;				TP_PROTO(data_proto),			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;				TP_ARGS(data_args),			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;				TP_CONDITION(cond), 0);			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		if (IS_ENABLED(CONFIG_LOCKDEP) &amp;amp;&amp;amp; (cond)) {		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			rcu_read_lock_sched_notrace();			\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			rcu_dereference_sched(__tracepoint_##name.funcs);\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;			rcu_read_unlock_sched_notrace();		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		}							\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	__DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		PARAMS(cond), PARAMS(data_proto), PARAMS(data_args))	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline int						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	register_trace_##name(void (*probe)(data_proto), void *data)	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		return tracepoint_probe_register(&amp;amp;__tracepoint_##name,	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;						(void *)probe, data);	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline int						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	register_trace_prio_##name(void (*probe)(data_proto), void *data,\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;				   int prio)				\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		return tracepoint_probe_register_prio(&amp;amp;__tracepoint_##name, \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;					      (void *)probe, data, prio); \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline int						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	unregister_trace_##name(void (*probe)(data_proto), void *data)	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		return tracepoint_probe_unregister(&amp;amp;__tracepoint_##name,\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;						(void *)probe, data);	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline void						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	check_trace_callback_type_##name(void (*cb)(data_proto))	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static inline bool						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	trace_##name##_enabled(void)					\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	{								\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		return static_key_false(&amp;amp;__tracepoint_##name.key);	\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，这个宏做了如下的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明了一个类型为&lt;code&gt;tracepoint&lt;/code&gt;的结构体变量&lt;code&gt;__tracepoint_##name&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;定义了几个相关的函数，分别用于处理trace event、注册、注销等。其中需要重点关注的是宏&lt;code&gt;trace_##name&lt;/code&gt;，这里定义了对对应的traceevent进行跟踪的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，宏里面一个字符串跟着&lt;code&gt;##name&lt;/code&gt;表示这个字符串与name的连接形成的字符串。&lt;/p&gt;
&lt;p&gt;这里的结构体&lt;code&gt;tracepoint&lt;/code&gt;定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// include/linux/tracepoint-defs.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tracepoint {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;name;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Tracepoint name */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; static_key key;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;regfunc)(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;unregfunc)(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; tracepoint_func __rcu &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;funcs;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该结构体中分别定义了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;traceevent名称。&lt;/li&gt;
&lt;li&gt;注册、注销、被触发时的处理函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上只是声明了&lt;code&gt;tracepoint&lt;/code&gt;结构体变量，而具体定义变量的宏是&lt;code&gt;DEFINE_TRACE&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// include/linux/tracepoint.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define DEFINE_TRACE(name)						\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	DEFINE_TRACE_FN(name, NULL, NULL);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define DEFINE_TRACE_FN(name, reg, unreg)				 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static const char __tpstrtab_##name[]				 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	__attribute__((section(&amp;#34;__tracepoints_strings&amp;#34;))) = #name;	 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	struct tracepoint __tracepoint_##name				 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	__attribute__((section(&amp;#34;__tracepoints&amp;#34;))) =			 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		{ __tpstrtab_##name, STATIC_KEY_INIT_FALSE, reg, unreg, NULL };\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	__attribute__((section(&amp;#34;__tracepoints_ptrs&amp;#34;))) =		 \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;		&amp;amp;__tracepoint_##name;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，&lt;code&gt;DEFINE_TRACE&lt;/code&gt;的作用就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;__tracepoints_strings&lt;/code&gt;section中定义了字符串数组变量&lt;code&gt;__tpstrtab_##name&lt;/code&gt;，其值为name。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;__tracepoints&lt;/code&gt;section中定义了结构体tracepoint变量&lt;code&gt;__tracepoint_##name&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上解释了trace point相关的数据结构、宏、变量等，下面以一个实例来展开说明。&lt;/p&gt;
&lt;h1 id=&#34;实例&#34;&gt;实例&lt;/h1&gt;
&lt;p&gt;这里以软中断被调用时的入口trace event为例，其定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DEFINE_EVENT(softirq, softirq_entry,

	TP_PROTO(unsigned int vec_nr),

	TP_ARGS(vec_nr)
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的宏&lt;code&gt;DEFINE_EVENT&lt;/code&gt;不过是前面&lt;code&gt;DECLARE_TRACE&lt;/code&gt;宏的一个包装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define DEFINE_EVENT(template, name, proto, args)		\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的讨论可以知道，这里声明了一个名为&lt;code&gt;__tracepoint_softirq_entry&lt;/code&gt;的&lt;code&gt;tracepoint&lt;/code&gt;类型结构体。而根据我们前面对宏的展开分析，&lt;code&gt;trace_##name&lt;/code&gt;也就是这里展开的&lt;code&gt;trace_softirq_entry&lt;/code&gt;是对这个trace event进行调用的入口，果然在&lt;code&gt;__do_softirq&lt;/code&gt;函数中看到了它的身影：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// kernel/softirq.c
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;asmlinkage __visible &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; __softirq_entry &lt;span style=&#34;color:#00a000&#34;&gt;__do_softirq&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  trace_softirq_entry(vec_nr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;systemtap相关&#34;&gt;systemtap相关&lt;/h1&gt;
&lt;p&gt;这里需要注意的另一个问题是，每个systemtap中的kernel.trace当时可以知道的参数，除了trace event本身的参数之外，还有当时所在嵌入函数内部的变量，比如这里的&lt;code&gt;softirq_entry&lt;/code&gt;这个probe，在systemtap对应的tapset中是这样的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe softirq.entry = kernel.trace(&amp;#34;irq_softirq_entry&amp;#34;) !,
     		      kernel.trace(&amp;#34;softirq_entry&amp;#34;) ?
{
	# kernels &amp;lt; 2.6.37
	h = @choose_defined($h, 0)
	vec = @choose_defined($vec, 0)
	action = (@defined($h) ? @cast($h,&amp;#34;softirq_action&amp;#34;,&amp;#34;kernel&amp;lt;linux/interrupt.h&amp;gt;&amp;#34;)-&amp;gt;action : 0)
	# kernels &amp;gt;= 2.6.37
	vec_nr = @choose_defined($vec_nr, 0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以的变量&lt;code&gt;h&lt;/code&gt;类型是在内核中的头文件&lt;code&gt;&amp;lt;linux/interrupt.h&amp;gt;&lt;/code&gt;中定义的&lt;code&gt;softirq_action&lt;/code&gt;，因为这个变量就是在上面的函数&lt;code&gt;__do_softirq&lt;/code&gt;中定义的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// kernel/softirq.c
asmlinkage __visible void __softirq_entry __do_softirq(void)
{
  // ...
  struct softirq_action *h;

  // ...
  trace_softirq_entry(vec_nr);
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，要看一个systemtap的kernel.trace能引用哪些变量，除了看其自身，还包括看其所嵌入函数的上下文中的变量，最好直接到对应的tapset的说明，因为-L只能打印出这个kernel.trace自身定义的变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;kernel.trace(&amp;#34;softirq_entry&amp;#34;)&amp;#39;
kernel.trace(&amp;#34;irq:softirq_entry&amp;#34;) $vec_nr:unsigned int
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;总结&#34;&gt;总结：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;内核中的trace事件以&lt;code&gt;trace_*&lt;/code&gt;来命名。&lt;/li&gt;
&lt;li&gt;看到systemtap中的&lt;code&gt;&#39;kernel.trace(&amp;quot;xx&amp;quot;)&#39;&lt;/code&gt;，其对应的内核代码可以使用&lt;code&gt;trace_xx&lt;/code&gt;来搜索，通过阅读这个trace事件所嵌入的代码也可以或者这个probe事件能打印的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;tracepoint.txt：内核自带文档，路径&amp;quot;Documentation/trace/tracepoint.txt&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/1609_houp_ftrace/index.html&#34;&gt;ftrace 中 eventtracing 的实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;man tapset：可以查看当前systemtap自带定义的tapset详细定义。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceware.org/systemtap/tapsets/&#34;&gt;SystemTap Tapset Reference Manual&lt;/a&gt;：tapset手册的线上版本。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>通过实例快速入门Systemtap</title>
      <link>https://www.codedump.info/post/20200128-systemtap-by-example/</link>
      <pubDate>Tue, 28 Jan 2020 11:56:56 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200128-systemtap-by-example/</guid>
      
      <description>&lt;p&gt;我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个&lt;a href=&#34;https://github.com/lichuang/awesome-systemtap-cn&#34;&gt;awesome-systemtap-cn&lt;/a&gt;项目，收集systemtap相关的优秀学习资源，欢迎提供其他更好的参考资料。&lt;/p&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;systemtap是一款“动态跟踪（dynamic tracing）”工具，为什么需要这类工具？打一个比方，这类工具就好比医生的听诊器，病人就好比是在运行的系统，很多时候查看一些问题需要在系统在运行的时候来观察，这时候就需要这类动态跟踪工具。与之对应的是，类似gdb这样的调试工具，其工作原理是让进程在某些断点暂停下来，查看进程的行为，这种技术称为“静态调试”。&lt;/p&gt;
&lt;p&gt;关于动态跟踪技术，推荐阅读&lt;a href=&#34;https://openresty.org/posts/dynamic-tracing/&#34;&gt;《动态追踪技术漫谈》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200128-systemtap-by-example/Smileytap.svg_.png&#34; alt=&#34;Smileytap.svg&#34; title=&#34;systemtap&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文旨在通过实例，快速解释systemtap脚本语言的最常见用法和语法。&lt;/p&gt;
&lt;h1 id=&#34;工作原理&#34;&gt;工作原理&lt;/h1&gt;
&lt;p&gt;如下图，systemtap使用.stp脚本语言，由命令行&lt;code&gt;stap&lt;/code&gt;编译生成对应的内核模块，动态放入内核中执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200128-systemtap-by-example/systemtap.gif&#34; alt=&#34;systemtap&#34; title=&#34;systemtap&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stap 流程从将脚本转换成解析树开始 (pass 1)。&lt;/li&gt;
&lt;li&gt;然后使用细化（elaboration）步骤 (pass 2) 中关于当前运行的内核的符号信息解析符号。&lt;/li&gt;
&lt;li&gt;接下来，转换流程将解析树转换成 C 源代码 (pass 3) 并使用解析后的信息和 tapset 脚本（SystemTap 定义的库，包含有用的功能）。&lt;/li&gt;
&lt;li&gt;stap 的最后步骤是构造使用本地内核模块构建进程的内核模块 (pass 4)。&lt;/li&gt;
&lt;li&gt;有了可用的内核模块之后，stap 完成了自己的任务，并将控制权交给其他两个实用程序 SystemTap：staprun 和 stapio。这两个实用程序协调工作，负责将模块安装到内核中并将输出发送到 stdout (pass 5)。如果在 shell 中按组合键 Ctrl-C 或脚本退出，将执行清除进程，这将导致卸载模块并退出所有相关的实用程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;stap命令行参数&#34;&gt;stap命令行参数&lt;/h1&gt;
&lt;h2 id=&#34;-x-pid&#34;&gt;-x PID&lt;/h2&gt;
&lt;p&gt;-x用于传递PID参数给systemtap脚本，这样在脚本内部可以通过target()函数拿到这个传递进来的参数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// $ sudo stap x-param.stp -x 10
// 输出：pid:10
probe begin
{
  printf(&amp;#34;pid:%d\n&amp;#34;, target())
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-t-seconds&#34;&gt;-T seconds&lt;/h2&gt;
&lt;p&gt;-T 参数后面可以带上秒数，这样脚本在这个时间之后自动退出，这样可以设置脚本执行的时间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// $ sudo stap T-params.stp -T 3
// 输出：time:2
global count

probe timer.s(1) {
  count += 1
}

probe end {
  printf(&amp;#34;time:%d\n&amp;#34;, count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-l和-l&#34;&gt;-L和-l&lt;/h2&gt;
&lt;p&gt;这两个参数大体作用一样，都可以列举出二进制文件对应的函数在哪里（所在文件和行数），所不同的是，-L比-l还多了一些信息：可以打印出函数局部变量的信息。&lt;/p&gt;
&lt;p&gt;比如下面这个简单的C代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func1&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; b) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; a,b,c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  c &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; func1(a,b);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;c:%d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  func();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用两个大小写不同的-l参数的输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;) $a:int $b:int $c:int

$ sudo stap -l &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，要探测的二进制文件必须有调试信息，比如上面的test.c编译出来的a.out文件，需要使用-g参数编译这样才能带上调试信息，否则输出就是这样的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还要注意的是，有一些编译优化级别可能会把局部变量优化掉，比如上面的文件分别使用O0和O2编译，看到的结果就不一样了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ gcc test.c -g -O0
$ sudo stap -L &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;) $a:int $b:int $c:int


$ gcc test.c -g -O2
$ sudo stap -L &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这两个命令行参数，搭配&lt;code&gt;grep&lt;/code&gt;命令很容易的查询到相应的探针。&lt;/p&gt;
&lt;p&gt;查询应用层程序探针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;*&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;__do_global_dtors_aux&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;__libc_csu_fini&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;__libc_csu_init&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;_fini&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;_init&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;_start&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;deregister_tm_clones&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;frame_dummy&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func1@/home/codedump/source/systemtap-examples/src/test.c:3&amp;#34;) $a:int $b:int
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;) $d:int $n:char const* $a:int $b:int $c:int
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;main@/home/codedump/source/systemtap-examples/src/test.c:16&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;register_tm_clones&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询内核中包含&lt;code&gt;tcp_&lt;/code&gt;的探针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -L &amp;#39;kernel.function(&amp;#34;*&amp;#34;)&amp;#39; | grep tcp_ | more
kernel.function(&amp;#34;__parse_nl_addr@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_metrics.c:785&amp;#34;) $addr:struct inetpeer_addr* $hash:unsigned int* $optional:int $v4:int $v6:int
kernel.function(&amp;#34;__pskb_trim_head@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_output.c:1398&amp;#34;) $skb:struct sk_buff* $len:int
kernel.function(&amp;#34;__tcp_ack_snd_check@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_input.c:5062&amp;#34;) $sk:struct sock* $ofo_possible:int
kernel.function(&amp;#34;__tcp_add_write_queue_tail@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/include/net/tcp.h:1647&amp;#34;)
kernel.function(&amp;#34;__tcp_alloc_md5sig_pool@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp.c:3371&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-g-varval&#34;&gt;-G VAR=VAL&lt;/h2&gt;
&lt;p&gt;-G命令行参数，可以设置全局变量VAR的值为VAL，相应地就可以作为开关来控制脚本的行为，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// sudo stap G-params.stp -G flag=1
// flag has set
global flag=0

probe begin {
  if (flag == 0) {
    printf(&amp;#34;flag not set\n&amp;#34;)
  } else {
    printf(&amp;#34;flag has set\n&amp;#34;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;探测点&#34;&gt;探测点&lt;/h1&gt;
&lt;p&gt;由于systemtap用于动态跟踪探测，所以首先的第一步就是在语言中定义探测点，在systemtap中被称为“probe”。其基本语法是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe event { statement }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，“event”分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步事件：发生在进程执行某一条确定的命令时的事件。&lt;/li&gt;
&lt;li&gt;异步事件：不是执行到指定的指令或代码位置，这一类包括计时器，定时器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下分开解释。&lt;/p&gt;
&lt;h2 id=&#34;同步事件&#34;&gt;同步事件&lt;/h2&gt;
&lt;p&gt;同步事件有好多种，同步事件的探测点又分为以下几个组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀部分，定义所在的模块：可以是内核，还可以是内核模块，还可以是用户进程，还可以是systemtap在tapset中预定义的探测点。&lt;/li&gt;
&lt;li&gt;中间部分，定义所在的函数：函数可以通过函数名指定，也可以根据文件名:行号指定。&lt;/li&gt;
&lt;li&gt;后缀部分，定义调用时机：可以在函数调用时触发，也可以在函数返回时触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据以上几个划分，再来拆解“探测点”就相对容易了。&lt;/p&gt;
&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;
&lt;p&gt;其中几类的语法分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核：语法为kernel.function(PATTERN)，即以“kernel”开头来指定的就是内核中的函数。&lt;/li&gt;
&lt;li&gt;内核模块：语法为module(MPATTERN).function(PATTERN)，即以“module(MPATTERN)”开头来指定的就是内核模块中的函数。&lt;/li&gt;
&lt;li&gt;用户进程：语法为process(PROCESSPATH).function(PATTERN)，即以“process(PROCESSPATH)”开头来指定的就是用户进程的函数。&lt;/li&gt;
&lt;li&gt;异步调用的模块：比如begin、end、timer等。&lt;/li&gt;
&lt;li&gt;如果不是以上的格式，那么大概率就是systemtap自带的tapset中已经定义的探测点，实际上这些还是封装了以上几种调用的别名（alias）探测点，后面将谈到探测点的别名定义。tapset于systemtap的意义，就好比libc库于C程序的意义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;所在的函数&#34;&gt;所在的函数&lt;/h3&gt;
&lt;p&gt;所在的函数，可以通过两种方式指定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;function(PATTERN)&lt;/li&gt;
&lt;li&gt;statement(PATTERN)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PATTERN由三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数名（必填）。&lt;/li&gt;
&lt;li&gt;@文件名：选填。&lt;/li&gt;
&lt;li&gt;如果存在“@文件名”的情况下，还可以选填行号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即PATTERN的格式是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func[@file][:linenumber]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，函数名这部分可以使用通配符（wildcarded）来定义文件的名字以及函数的名字，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 所有内核中以sys_前缀开头的函数
kernel.function(&amp;#34;sys_*)

# nginx用户进程中名为ngx_http_process_*的函数
process(&amp;#34;/home/admin/nginx/bin/nginx&amp;#34;).function(&amp;#34;ngx_http_process_*&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时候如果不确定函数的名字，那么就可以使用前面的-L和-l命令来辅助查询，比如还是上面test.c的例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -l &amp;#39;process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;fu*&amp;#34;)&amp;#39;
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func1@/home/codedump/source/systemtap-examples/src/test.c:3&amp;#34;)
process(&amp;#34;/home/codedump/source/systemtap-examples/src/a.out&amp;#34;).function(&amp;#34;func@/home/codedump/source/systemtap-examples/src/test.c:7&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;statement&lt;/code&gt;可以很方便定位到具体的某一行代码执行前后，变量的变化情况，比如下面这个最简单的C代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;argv[])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	a &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;a:%d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, a);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	a &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;a:%d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, a);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用下面这个systemtap脚本针对代码中的第8行和第10行打印当时变量a的值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe process(&amp;#34;./a.out&amp;#34;).statement(&amp;#34;main@./cc_stap_test.c:8&amp;#34;)
{
    printf(&amp;#34;systemtap probe line 8 a:%d\n&amp;#34;, $a);
}

probe process(&amp;#34;./a.out&amp;#34;).statement(&amp;#34;main@./cc_stap_test.c:10&amp;#34;)
{
    printf(&amp;#34;systemtap probe line 10 a:%d\n&amp;#34;, $a);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap cc_stap_test.stp -c ./a.out
a:1
a:2
systemtap probe line 8 a:1
systemtap probe line 10 a:2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;调用时机&#34;&gt;调用时机&lt;/h3&gt;
&lt;p&gt;有了以上两个要素，已经可以在具体的函数、文件行中定义探测点了，但是有时候针对某一个具体函数，想在不同的时机定义探测点，比如函数被调用和调用返回的时候，那么可以在后面以后缀的方式定义出来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe kernel.function(&amp;#34;*@net/socket.c&amp;#34;).call {
  printf (&amp;#34;%s -&amp;gt; %s\n&amp;#34;, thread_indent(1), probefunc())
}
probe kernel.function(&amp;#34;*@net/socket.c&amp;#34;).return {
  printf (&amp;#34;%s &amp;lt;- %s\n&amp;#34;, thread_indent(-1), probefunc())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如这两个探测点，分别在socket.c中的任何函数被调用以及返回的时候被调用。&lt;/p&gt;
&lt;h2 id=&#34;异步事件&#34;&gt;异步事件&lt;/h2&gt;
&lt;p&gt;常见的异步事件是begin、end、never、timers。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;begin、end分别在脚本开始执行以及结束执行的时候被调用。&lt;/li&gt;
&lt;li&gt;timers用于定义定时器探测点，常见的格式timer.s(1)来定义每秒触发的探测点。&lt;/li&gt;
&lt;li&gt;never定义的探测点不会被调用到，很多时候加这个探测点只是为了检查一些语法错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里统一用一个例子来说明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// sudo stap begin.stp -T 2
// 输出：
// probe begin
// in timer
// probe end

probe begin {
  printf(&amp;#34;probe begin\n&amp;#34;)
}

probe end {
  printf(&amp;#34;probe end\n&amp;#34;)
}

probe timer.s(1) {
  printf(&amp;#34;in timer\n&amp;#34;)
}

probe never {
  printf(&amp;#34;never do this\n&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下图片简单总结探针事件的划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200128-systemtap-by-example/probe-event.png&#34; alt=&#34;probe-event&#34; title=&#34;probe-event&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;探测点别名alias&#34;&gt;探测点别名（alias）&lt;/h2&gt;
&lt;p&gt;除了以上的探测点之后，还可以通过探测点别名技术将多个探测点的处理行为合并在一个处理函数中，比如tapset scheduler中是这么定义scheduler.cpu_off这个探测点的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe scheduler.cpu_off =
	kernel.trace(&amp;#34;sched_switch&amp;#34;) !,
	kernel.function(&amp;#34;context_switch&amp;#34;)
{
    name = &amp;#34;cpu_off&amp;#34;
    task_prev = $prev
    task_next = $next
    idle = __is_idle()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，新定义的别名探测点scheduler.cpu_off将内核的两个探测点kernel.trace(&amp;ldquo;sched_switch&amp;rdquo;)和kernel.function(&amp;ldquo;context_switch&amp;rdquo;)的处理行为合并在了一起。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;kernel.trace(&amp;quot;sched_switch&amp;quot;) &lt;/code&gt;这个探测点的后面加上了&lt;code&gt;!&lt;/code&gt;，这表示这个探测点可能由于版本的差异是不存在的，但是一旦存在，那么将不再解析这个探测点以后的以&lt;code&gt;,&lt;/code&gt;隔开的其他探测点，所以&lt;code&gt;!&lt;/code&gt;一定用在多个以&lt;code&gt;,&lt;/code&gt;分隔开的探测点列表中。相应地，还有&lt;code&gt;?&lt;/code&gt;后缀，也是表示这个探测点可能不存在，但是与前面的区别是，即便存在这种探测点也不影响其他探测点的检测，所以&lt;code&gt;?&lt;/code&gt;后缀的探测点可以独立存在。&lt;/p&gt;
&lt;h3 id=&#34;探测点动态定义&#34;&gt;探测点动态定义&lt;/h3&gt;
&lt;p&gt;此外，还可以根据命令行参数来指定探测点，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function trace(entry_p)
{
  printf(&amp;#34;%s%s%s\n&amp;#34;,
         thread_indent (entry_p),
         (entry_p&amp;gt;0?&amp;#34;-&amp;gt;&amp;#34;:&amp;#34;&amp;lt;-&amp;#34;),
         ppfunc ())
}

probe $1.call   { trace(1) }
probe $1.return { trace(-1) }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个脚本可以根据脚本中传入的第一个参数，来打印其调用情况，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ stap callgraph.stp &amp;#39;kernel.function(&amp;#34;sys_open&amp;#34;)&amp;#39;

     0 nscd(23451):-&amp;gt;SyS_open
     6 nscd(23451):&amp;lt;-SyS_open
     0 nscd(23451):-&amp;gt;SyS_open
     7 nscd(23451):&amp;lt;-SyS_open
     0 roxterm(21323):-&amp;gt;SyS_open
    43 roxterm(21323):&amp;lt;-SyS_open
     0 roxterm(21323):-&amp;gt;SyS_open
  2604 roxterm(21323):&amp;lt;-SyS_open
     0 systemd-udevd(637):-&amp;gt;SyS_open
   268 systemd-udevd(637):&amp;lt;-SyS_open
     0 roxterm(21323):-&amp;gt;SyS_open
    24 roxterm(21323):&amp;lt;-SyS_open
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;变量&#34;&gt;变量&lt;/h1&gt;
&lt;h2 id=&#34;目标变量target-variables&#34;&gt;目标变量（Target Variables）&lt;/h2&gt;
&lt;p&gt;目标变量指的是当前代码位置可见的变量，官方文档对这个概念的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The probe events that map to actual locations in the code (for example kernel.function(“function”) and kernel.statement(“statement”)) allow the use of target variables to obtain the value of variables visible at that location in the code. You can use the -L option to list the target variable available at a probe point.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如前面提过的，可以使用-L命令行参数，拿到一个探测点的位置及相关的变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stap -L &amp;#39;kernel.function(&amp;#34;vfs_read&amp;#34;)&amp;#39;
kernel.function(&amp;#34;vfs_read@fs/read_write.c:277&amp;#34;) $file:struct file* $buf:char* $count:size_t $pos:loff_t*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，给出变量相关信息的时候，是以如下格式给出的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$变量名:变量类型
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如这里的&lt;code&gt;$file:struct file*&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;全局变量&#34;&gt;全局变量&lt;/h2&gt;
&lt;p&gt;如果不是在当前代码位置的变量，此时可以通过这种格式拿到：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@var(&amp;#34;varname@src/file.c&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// test2.c
#include &amp;lt;stdio.h&amp;gt;

int g = 100;
int func1(int a, int b) {
  g = 102;
  return a+b;
}

int func(int d, const char *n) {
  int a,b,c;

  g = 101;
  a = 1;
  b = 3;
  c = func1(a,b);
  return c;
}

int main() {
  func(100, &amp;#34;test&amp;#34;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;stp脚本如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;).call {
	printf(&amp;#34;call func:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}

probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;) {
	printf(&amp;#34;func:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}

probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;).return {
	printf(&amp;#34;return func:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}

probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func1&amp;#34;).call {
	printf(&amp;#34;call func1:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}

probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func1&amp;#34;) {
	printf(&amp;#34;func1:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}

probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func1&amp;#34;).return {
	printf(&amp;#34;return func1:g=%d\n&amp;#34;, @var(&amp;#34;g@test.c&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;code&gt;sudo stap t.stap -c ./a.out&lt;/code&gt;得到下面的结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;call func:g=100
func:g=100
call func1:g=101
func1:g=101
return func1:g=102
return func:g=102
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;打印结构体内容&#34;&gt;打印结构体内容&lt;/h2&gt;
&lt;p&gt;有一些变量，本身是一个结构体，如果想打印其成员信息，但是又不知道结构体的成员分布的情况，可以首先使用&lt;code&gt;$变量名$&lt;/code&gt;，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;).return {printf(&amp;#34;%s\n&amp;#34;, $file$); exit(); }&amp;#39;

{.f_u={...}, .f_path={...}, .f_inode=0xffff8eaf11a9ef80, .f_op=0xffff8eafef9a7100, .f_lock={...}, .f_write_hint=0, .f_count={...}, .f_flags=34818, .f_mode=491551, .f_pos_lock={...}, .f_pos=0, .f_owner={...}, .f_cred=0xffff8eafed747f00, .f_ra={...}, .f_version=0, .f_security=0xffff8eafbfb5f708, .private_data=0x0, .f_ep_links={...}, .f_tfile_llink={...}, .f_mapping=0xffff8eaf11a9f0f8, .f_wb_err=0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就一目了然知道这个结构体的构成了。&lt;/p&gt;
&lt;p&gt;而如果需要打印某个成员的信息，就可以使用&lt;code&gt;-&amp;gt;&lt;/code&gt;操作符，注意在systemtap中，无论是指针还是引用都使用&lt;code&gt;-&amp;gt;&lt;/code&gt;来查看成员：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;).return {printf(&amp;#34;%d\n&amp;#34;, $file-&amp;gt;private_data); exit(); }&amp;#39;

0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里还有另一个知识点，即一个成员可能又是一个结构体，如果要一层一层“扒掉”成员的外衣，就需要在后面加&lt;code&gt;$&lt;/code&gt;符号，每多一个&lt;code&gt;$&lt;/code&gt;符号，就扒掉一层外衣，例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;).return {printf(&amp;#34;%s\n&amp;#34;, $file-&amp;gt;f_pos_lock$); exit(); }&amp;#39; -w
{.owner={...}, .wait_lock={...}, .osq={...}, .wait_list={...}}

$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;).return {printf(&amp;#34;%s\n&amp;#34;, $file-&amp;gt;f_pos_lock$$); exit(); }&amp;#39; -w
{.owner={.counter=-124589570406976}, .wait_lock={&amp;lt;union&amp;gt;={.rlock={.raw_lock={&amp;lt;union&amp;gt;={.val={.counter=0}, &amp;lt;class&amp;gt;={.locked=&amp;#39;\000&amp;#39;, .pending=&amp;#39;\000&amp;#39;}, &amp;lt;class&amp;gt;={.locked_pending=0, .tail=0}}}}}}, .osq={.tail={.counter=0}}, .wait_list={.next=0xffff8eaf34c8cc58, .prev=0xffff8eaf34c8cc58}}

$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;).return {printf(&amp;#34;%s\n&amp;#34;, $file-&amp;gt;f_pos_lock$$$); exit(); }&amp;#39; -w
{.owner={.counter=-124589338874240}, .wait_lock={&amp;lt;union&amp;gt;={.rlock={.raw_lock={&amp;lt;union&amp;gt;={.val={.counter=0}, &amp;lt;class&amp;gt;={.locked=&amp;#39;\000&amp;#39;, .pending=&amp;#39;\000&amp;#39;}, &amp;lt;class&amp;gt;={.locked_pending=0, .tail=0}}}}}}, .osq={.tail={.counter=0}}, .wait_list={.next=0xffff8eaf42b71458, .prev=0xffff8eaf42b71458}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结合打印全局变量和打印结构体成员这两个知识点，如果想知道全局变量的结构体成员分布，就需要：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@var(&amp;#34;全局变量名@src/file.c&amp;#34;)$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;) {
           printf (&amp;#34;current files_stat max_files: %s\n&amp;#34;,
                   @var(&amp;#34;files_stat@fs/file_table.c&amp;#34;)$);
           exit(); }&amp;#39;
current files_stat max_files: {.nr_files=0, .nr_free_files=0, .max_files=774499}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后用这个格式打印全局变量结构体成员数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@var(&amp;#34;全局变量名@src/file.c&amp;#34;)-&amp;gt;结构体成员名称
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;vfs_read&amp;#34;) {
           printf (&amp;#34;current files_stat max_files: %d\n&amp;#34;,
                   @var(&amp;#34;files_stat@fs/file_table.c&amp;#34;)-&amp;gt;max_files);
           exit(); }&amp;#39;
current files_stat max_files: 774499
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;类型转换typecasting&#34;&gt;类型转换（Typecasting）&lt;/h2&gt;
&lt;p&gt;当指针为void*指针时，如果知道它的确切类型，可以通过类型转换来输出其信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@cast(p, &amp;#34;type_name&amp;#34;[, &amp;#34;module&amp;#34;])-&amp;gt;member
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，&lt;code&gt;type_name&lt;/code&gt;是类型名称，而可选的module是模块+文件信息，好让systemtap知道到哪里找到这个类型信息，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@cast(tv, “timeval”, “&amp;lt;sys/time.h&amp;gt;”)-&amp;gt;tvsec
@cast(task, “taskstruct”, “kernel&amp;lt;linux/sched.h&amp;gt;”)-&amp;gt;tgid
@cast(task, “taskstruct”, “kernel&amp;lt;linux/sched.h&amp;gt;&amp;lt;linux/fsstruct.h&amp;gt;”)-&amp;gt;fs-&amp;gt;umask
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以可以如下例打印：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;do_dentry_open&amp;#34;) {printf(&amp;#34;%d\n&amp;#34;, @cast($f, &amp;#34;file&amp;#34;, &amp;#34;kernel&amp;lt;linux/fs.h&amp;gt;&amp;#34; )-&amp;gt;f_flags); exit(); }&amp;#39;
32768
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用&lt;code&gt;@cast&lt;/code&gt;转换类型之后，同样可以在后面加上&lt;code&gt;$&lt;/code&gt;打印更多详细信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap -e &amp;#39;probe kernel.function(&amp;#34;do_dentry_open&amp;#34;) {printf(&amp;#34;%s\n&amp;#34;, @cast($f, &amp;#34;file&amp;#34;, &amp;#34;kernel&amp;lt;linux/fs.h&amp;gt;&amp;#34;)$); exit(); }&amp;#39;
{.f_u={...}, .f_path={...}, .f_inode=0x0, .f_op=0x0, .f_lock={...}, .f_write_hint=0, .f_count={...}, .f_flags=32768, .f_mode=0, .f_pos_lock={...}, .f_pos=0, .f_owner={...}, .f_cred=0xffff8eafef8f80c0, .f_ra={...}, .f_version=0, .f_security=0xffff8eafeb5c09c0, .private_data=0x0, .f_ep_links={...}, .f_tfile_llink={...}, .f_mapping=0x0, .f_wb_err=0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;@cast&lt;/code&gt;操作符同样也可以用在应用程序中，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

typedef struct Test {
  int a;
  int b;
} Test;

int func(void *p) {
  printf(&amp;#34;in func\n&amp;#34;);
}

int main() {
  Test t = {.a=101,.b=102};
  func(&amp;amp;t);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以如下打印：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;).call {
	printf(&amp;#34;call func:g=%d\n&amp;#34;, @cast($p, &amp;#34;Test&amp;#34;)-&amp;gt;a)
}

/*输出：
in func
call func:g=101
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;打印局部变量&#34;&gt;打印局部变量&lt;/h2&gt;
&lt;p&gt;可以使用如下几个变量来打印函数局部变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$$vars：打印函数的所有局部变量以及传递进来的函数参数。&lt;/li&gt;
&lt;li&gt;$$parms：$$vars的子集，打印函数传递进来的函数参数。&lt;/li&gt;
&lt;li&gt;$$locals：$$vars的子集，打印函数的所有局部变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20200128-systemtap-by-example/vars.png&#34; alt=&#34;vars&#34; title=&#34;vars&#34;&gt;&lt;/p&gt;
&lt;p&gt;同样的，在这些变量后面也可以加上&lt;code&gt;$&lt;/code&gt;美观打印：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int func1(int a, int b) {
  return a+b;
}

int func(int d, const char *n) {
  int a,b,c;

  a = 1;
  b = 3;
  c = func1(a,b);
  return c;
}

int main() {
  func(100, &amp;#34;test&amp;#34;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;脚本如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;).call {
	printf(&amp;#34;call func:vars=%s\n&amp;#34;, $$vars)
	printf(&amp;#34;call func:vars=%s\n&amp;#34;, $$vars$)
	printf(&amp;#34;call func:params=%s\n&amp;#34;, $$parms)
	printf(&amp;#34;call func:params=%s\n&amp;#34;, $$parms$)
	printf(&amp;#34;call func:locals=%s\n&amp;#34;, $$locals)
	printf(&amp;#34;call func:locals=%s\n&amp;#34;, $$locals$)
}

/*
sudo stap t.stap -c ./a.out
call func:vars=d=0x64 n=0x4005c4 a=0x0 b=0x4003e0 c=0x0
call func:vars=d=100 n=&amp;#34;test&amp;#34; a=0 b=4195296 c=0
call func:params=d=0x64 n=0x4005c4
call func:params=d=100 n=&amp;#34;test&amp;#34;
call func:locals=a=0x0 b=0x4003e0 c=0x0
call func:locals=a=0 b=4195296 c=0  
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，如果需要打印函数的返回值，可以使用&lt;code&gt;$$return&lt;/code&gt;变量，但是要注意这个变量只能在&lt;code&gt;.return&lt;/code&gt;中使用，毕竟既然是要打印函数返回值，就要在函数返回的时候才能知道，使用下面的脚本来看上面C程序的返回值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe process(&amp;#34;./a.out&amp;#34;).function(&amp;#34;func&amp;#34;).return {
	printf(&amp;#34;call func:return=%s\n&amp;#34;, $$return)
	printf(&amp;#34;call func:return=%s\n&amp;#34;, $$return$)
}

/*
$ sudo stap t.stap -c ./a.out
call func:return=return=0x4
call func:return=return=4
 */
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;关联数组associative-arrays&#34;&gt;关联数组（Associative Arrays）&lt;/h1&gt;
&lt;p&gt;准确的说，systemtap中没有数组这个概念，关联数组就是systemtap中的字典（dict）。&lt;/p&gt;
&lt;p&gt;字典有可能是嵌套型的字典，比如C++代码中&lt;code&gt;dict[keya][keyb]&lt;/code&gt;，即一个字典中的值又是另一个字典。systemtap中的关联数组也可以做到类似的效果，但是语法略有不同，多个层级的键之间使用&lt;code&gt;,&lt;/code&gt;分隔，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bt[execname(),tid(),$mem,sprint_ubacktrace()] = 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码用C++类似表达就是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bt[execname()][tid()][$mem,sprint_ubacktrace()] = 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在systemtap中，最多允许嵌套9个键。&lt;/p&gt;
&lt;p&gt;关联数组的常规操作，并无什么特别的地方，如下代码所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 赋值
array_name[index_expression] = value

// 读取
delta = gettimeofday_s() - foo[tid()]

// 递增
array_name[index_expression] ++

// 删除数组中的某一项
delete array_name[index_expression]

// 删除整个关联数组
delete array_name
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;遍历关联数组&#34;&gt;遍历关联数组&lt;/h2&gt;
&lt;p&gt;最简单的遍历关联数组的方式，可以使用&lt;code&gt;foreach&lt;/code&gt;表达式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;foreach (element in array_name)
  statement
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads 

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++ 
} 

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads)
    printf(&amp;#34;%s : %d \n&amp;#34;, count, reads[count])
  delete reads 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap vfs-read-1.stp -T 4
stapio : 21
docker-containe : 12
dockerd : 12
gmain : 7
rtkit-daemon : 1
compiz : 6
systemd-journal : 1
gdbus : 6
upstart-dbus-br : 4
nm-applet : 3
avahi-daemon : 29
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了常规的遍历之外，&lt;code&gt;foreach&lt;/code&gt;操作符还可以指定遍历的顺序，以及遍历的数量。&lt;/p&gt;
&lt;h3 id=&#34;修改遍历关联数组顺序&#34;&gt;修改遍历关联数组顺序&lt;/h3&gt;
&lt;p&gt;上面的脚本文件稍作修改：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads 

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++ 
} 

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads+)
    printf(&amp;#34;%s : %d \n&amp;#34;, count, reads[count])
  delete reads 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即在&lt;code&gt;foreach&lt;/code&gt;所遍历的关联数组名称后面加上&lt;code&gt;+&lt;/code&gt;，表示按照键递增的顺序来遍历数组，输出为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap vfs-read-1.stp -T 4
systemd-journal : 1
indicator-datet : 3
gmain : 4
upstart-dbus-br : 5
unity-panel-ser : 6
compiz : 7
docker-containe : 12
dockerd : 12
stapio : 21
gdbus : 23
avahi-daemon : 28
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相反的，如果使用&lt;code&gt;-&lt;/code&gt;则表示是递减顺序来遍历。&lt;/p&gt;
&lt;h3 id=&#34;限定遍历关联数组数量&#34;&gt;限定遍历关联数组数量&lt;/h3&gt;
&lt;p&gt;除此之外，还可以在&lt;code&gt;foreach&lt;/code&gt;操作符中，使用&lt;code&gt;limit 数量&lt;/code&gt;来限制遍历关联数组中元素的数量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++
}

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads+ limit 2)
    printf(&amp;#34;%s : %d \n&amp;#34;, count, reads[count])
  delete reads
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出就只有两项了：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap vfs-read-1.stp -T 4
systemd-journal : 1
systemd-logind : 1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;测试元素存在性&#34;&gt;测试元素存在性&lt;/h2&gt;
&lt;p&gt;除此之外，还可以使用&lt;code&gt;in&lt;/code&gt;操作符测试一个元素是否在关联数组中，语法如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if([index_expression] in array_name) statement
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads

probe vfs.read { 
  reads[execname()] ++ 
}

probe timer.s(3) {
  printf(&amp;#34;=======\n&amp;#34;) 
  foreach (count in reads+)
    printf(&amp;#34;%s : %d \n&amp;#34;, count, reads[count]) 
  if([&amp;#34;stapio&amp;#34;] in reads) {
    printf(&amp;#34;stapio read detected, exiting\n&amp;#34;)
    exit() 
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap vfs-read-1.stp -T 4
=======
systemd-journal : 1
rtkit-daemon : 1
nm-applet : 3
gmain : 4
upstart-dbus-br : 4
compiz : 5
gdbus : 6
docker-containe : 12
dockerd : 12
avahi-daemon : 19
stapio : 21
stapio read detected, exiting
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;计算统计集合statistical-aggregates&#34;&gt;计算统计集合（Statistical Aggregates）&lt;/h1&gt;
&lt;h2 id=&#34;常规操作&#34;&gt;常规操作&lt;/h2&gt;
&lt;p&gt;systemtap中的变量，除了具备其他语言中常见的操作之外，还有一个其他语言没有的特色，可以作为统计集合来存储数据。即一个变量，可以存储多个数据，后期可以对这个变量的数据进行常规的统计计算。&lt;/p&gt;
&lt;p&gt;一个变量要存储统计数据，此时不能使用&lt;code&gt;=&lt;/code&gt;来赋值，需要使用&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;操作符。比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads 

probe vfs.read 
{ 
  reads[execname()] &amp;lt;&amp;lt;&amp;lt; $count 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的$count是内核中vfs_read函数传入的参数，存储的读取数据的数量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ssize_t vfs_read(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; file &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;file, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; __user &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;buf, size_t count, loff_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pos)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样，这个systemtap脚本就针对同一个进程，就把这个进程所有调用vfs_read函数的count值记录了下来。&lt;/p&gt;
&lt;p&gt;下面来具体看看systemtap都提供了针对统计数据的哪些操作。常规的操作有以下几种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@count(variable)：返回同一个变量中存储的数据数量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@sum(variable)：返回同一个变量中存储的数据总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@min(variable)：返回同一个变量存储的最小数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@max(variable)：返回同一个变量中存储的最大数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@avg(variable)：返回同一个变量中存储的数据均值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;@variance(variable)：返回同一个变量中存储的数据方差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的操作符，又被称为抽取函数（extractor function），即可以输入一个存有统计数据的变量，相应返回一些数据。&lt;/p&gt;
&lt;h2 id=&#34;打印柱状图数据&#34;&gt;打印柱状图数据&lt;/h2&gt;
&lt;p&gt;还可以使用&lt;code&gt;@hist_log&lt;/code&gt;来打印以2为底指数分布的直方图：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global histogram
 
probe begin {
  printf(&amp;#34;Capturing...\n&amp;#34;)
}
 
probe netdev.receive {
  histogram &amp;lt;&amp;lt;&amp;lt; length
}
 
probe netdev.transmit {
  histogram &amp;lt;&amp;lt;&amp;lt; length
}
 
probe end {
  printf( &amp;#34;\n&amp;#34; )
  print( @hist_log(histogram) )
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap hist_log.stp -T 2
Capturing...

value |-------------------------------------------------- count
    8 |                                                   0
   16 |                                                   0
   32 |@@                                                 2
   64 |@                                                  1
  128 |                                                   0
  256 |                                                   0
  512 |                                                   0
 1024 |@@@@                                               4
 2048 |                                                   0
 4096 |                                                   0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了&lt;code&gt;@hist_log&lt;/code&gt;之外，还可以使用&lt;code&gt;@hist_linear(v, start, stop, interval)&lt;/code&gt;来打印start-stop区间interval间隔的直方图&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global reads

probe netdev.receive {
	reads &amp;lt;&amp;lt;&amp;lt; length
}

probe end {
	print(@hist_linear(reads, 0, 1024, 200))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里打印的是分布在[0,1024]，并且每个柱子的数据间间隔100的柱状图，输出如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap hist_linear.stp -T 2
value |-------------------------------------------------- count
    0 |@@@@@@@@@@@@@                                      13
  200 |@@@@                                                4
  400 |                                                    0
  600 |                                                    0
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;常用函数&#34;&gt;常用函数&lt;/h1&gt;
&lt;p&gt;本节来介绍systemtap中常用的一些函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tid()：当前线程ID。&lt;/li&gt;
&lt;li&gt;uid()：当前用户ID。&lt;/li&gt;
&lt;li&gt;cpu()：当前CPU编号。&lt;/li&gt;
&lt;li&gt;ctime()：当前UNIX epoch秒数。&lt;/li&gt;
&lt;li&gt;pp()：当前探测点的描述字符串。&lt;/li&gt;
&lt;li&gt;execname()：当前运行的进程名称。&lt;/li&gt;
&lt;li&gt;probefunc()：探测点函数名称。&lt;/li&gt;
&lt;li&gt;target()：在stap使用&lt;code&gt;-c command&lt;/code&gt;或者&lt;code&gt;-x process&lt;/code&gt;命令时，target()能拿到进程的pid。&lt;/li&gt;
&lt;li&gt;name：返回系统调用的名称字符串，仅能在syscall类型的探针处理函数中使用。&lt;/li&gt;
&lt;li&gt;thread_indent(delta)：它可以输出当前probe所处的可执行程序名称、线程id、函数执行的相对时间和执行的次数（通过空格的数量）信息，它的返回值就是一个字符串。参数delta是在每次调用时增加或移除的空白数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里其他的都好理解，thread_indent需要一个例子来说明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe kernel.function(&amp;#34;*@net/socket.c&amp;#34;).call
{
  printf (&amp;#34;%s -&amp;gt; %s\n&amp;#34;, thread_indent(1), probefunc())
}
probe kernel.function(&amp;#34;*@net/socket.c&amp;#34;).return
{
  printf (&amp;#34;%s &amp;lt;- %s\n&amp;#34;, thread_indent(-1), probefunc())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0 ftp(7223): -&amp;gt; sys_socketcall
1159 ftp(7223):  -&amp;gt; sys_socket
2173 ftp(7223):   -&amp;gt; __sock_create
2286 ftp(7223):    -&amp;gt; sock_alloc_inode
2737 ftp(7223):    &amp;lt;- sock_alloc_inode
3349 ftp(7223):    -&amp;gt; sock_alloc
3389 ftp(7223):    &amp;lt;- sock_alloc
3417 ftp(7223):   &amp;lt;- __sock_create
4117 ftp(7223):   -&amp;gt; sock_create
4160 ftp(7223):   &amp;lt;- sock_create
4301 ftp(7223):   -&amp;gt; sock_map_fd
4644 ftp(7223):    -&amp;gt; sock_map_file
4699 ftp(7223):    &amp;lt;- sock_map_file
4715 ftp(7223):   &amp;lt;- sock_map_fd
4732 ftp(7223):  &amp;lt;- sys_socket
4775 ftp(7223): &amp;lt;- sys_socketcall
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，thread_indent()搭配&lt;code&gt;.call&lt;/code&gt;和&lt;code&gt;.return&lt;/code&gt;，美化输出了函数调用的流程。&lt;/p&gt;
&lt;p&gt;以下再演示一下&lt;code&gt;name&lt;/code&gt;的使用，这个变量仅能用在&lt;code&gt;syscall&lt;/code&gt;类的探针中，以下脚本每隔一秒打印出当前20个被调用最多的系统调用数量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global syscalls_count

probe syscall_any {
  syscalls_count[name] &amp;lt;&amp;lt;&amp;lt; 1
}

function print_systop () {
  printf (&amp;#34;%25s %10s\n&amp;#34;, &amp;#34;SYSCALL&amp;#34;, &amp;#34;COUNT&amp;#34;)
  foreach (syscall in syscalls_count- limit 20) {
    printf(&amp;#34;%25s %10d\n&amp;#34;, syscall, @count(syscalls_count[syscall]))
  }
  delete syscalls_count
}

probe timer.s(1) {
  print_systop ()
  printf(&amp;#34;--------------------------------------------------------------\n&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo stap syscall.stp -T 2
                  SYSCALL      COUNT
                    ioctl        127
               epoll_wait         47
                    futex         42
                 pselect6         29
                     read         28
                    write         17
                  recvmsg         16
                     poll         14
           rt_sigprocmask          8
                    fcntl          6
                   writev          5
                    ppoll          5
                 recvfrom          4
                setitimer          4
        inotify_add_watch          3
                   select          3
                nanosleep          2
          timerfd_settime          2
            clock_gettime          2
                ftruncate          1
--------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;defined和choose_defined&#34;&gt;@defined和@choose_defined&lt;/h1&gt;
&lt;p&gt;由于版本变化，有一些变量可能在新版本中不存在了，此时可以使用&lt;code&gt;@define&lt;/code&gt;来检查变量是否存在：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe vm.pagefault = kernel.function(&amp;#34;__handle_mm_fault@mm/memory.c&amp;#34;) ?,
                     kernel.function(&amp;#34;handle_mm_fault@mm/memory.c&amp;#34;) ?
{
  write_access = (@defined($flags) ? $flags &amp;amp; FAULT_FLAG_WRITE : $write_access)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的脚本根据是否存在变量flag，来给write_access不同的赋值。&lt;/p&gt;
&lt;p&gt;此外还有&lt;code&gt;@choose_defined($a,$b)&lt;/code&gt;，其作用相当于：&lt;code&gt;@defined($a)? $a : $b&lt;/code&gt;，例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;probe vm.pagefault = kernel.function(&amp;#34;handle_mm_fault@mm/memory.c&amp;#34;)
{
  write_access = @choose_defined($write_access, 0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;entry&#34;&gt;@entry&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;.return&lt;/code&gt;探针中，有一个特殊的操作符&lt;code&gt;@entry&lt;/code&gt;，用于存储该探针的入口处的表达式的值，可以使用这个操作符，完成比如计算探针函数执行时间计算等工作，比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;global sloth = 50
      
probe vfs.open.return {
  time = gettimeofday_us()-@entry(gettimeofday_us())
  if (time &amp;gt;= sloth)
    printf(&amp;#34;%s[%d] %d %s\n&amp;#34;, execname(), tid(), time, pathname)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个脚本在&lt;code&gt;vfs.open.return&lt;/code&gt;探针处理函数中，通过&lt;code&gt;@entry&lt;/code&gt;操作符，计算完成vfs.open操作的时间差，如果超过设置的阈值50就打印相关信息。&lt;/p&gt;
&lt;h1 id=&#34;嵌入c代码&#34;&gt;嵌入C代码&lt;/h1&gt;
&lt;p&gt;systemtap中支持嵌入C代码，使用guru模式（-g参数），在“%{“和“%}&amp;ldquo;标记之间就能嵌入C代码，其中访问参数的值以&lt;code&gt;STAP_ARG_+参数名&lt;/code&gt;的形式，而返回值以&lt;code&gt;STAP_RETVALUE=xxx&lt;/code&gt;的形式。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%{
	#include &amp;lt;linux/in.h&amp;gt;
	#include &amp;lt;linux/ip.h&amp;gt;
%} /* &amp;lt;-- top level */

function read_iphdr:long(skb:long)
%{
	struct iphdr *iph = ip_hdr((struct sk_buff *)STAP_ARG_skb);
	STAP_RETVALUE = (long)iph;
%}

/* Determines whether an IP packet is TCP, based on the iphdr: */
function is_tcp_packet:long(iphdr)
{
	protocol = @cast(iphdr, &amp;#34;iphdr&amp;#34;)-&amp;gt;protocol
	return (protocol == %{ IPPROTO_TCP %}) /* &amp;lt;-- expression */
}

probe begin {
	printf(&amp;#34;SystemTap start!\n&amp;#34;);
}

probe kernel.function(&amp;#34;ip_local_deliver&amp;#34;) {
	iph = read_iphdr(pointer_arg(1));
	printf(&amp;#34;tcp packet ? %s\n&amp;#34;, is_tcp_packet(iph) ? &amp;#34;yes&amp;#34; : &amp;#34;no&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的read_iphdr函数，其处理函数就使用的是嵌入C代码完成。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
