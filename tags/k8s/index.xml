<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K8s on codedump notes</title>
    <link>http://localhost:1313/tags/k8s/</link>
    <description>Recent content in K8s on codedump notes</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 01 Oct 2018 14:10:51 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/k8s/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K8S源码分析-通过CRD看资源的实现</title>
      <link>http://localhost:1313/post/20181001-k8s-crd/</link>
      <pubDate>Mon, 01 Oct 2018 14:10:51 +0800</pubDate>
      <guid>http://localhost:1313/post/20181001-k8s-crd/</guid>
      <description>&lt;h1 class=&#34;heading&#34; id=&#34;概述&#34;&gt;&#xA;  概述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;自定义资源（CustomResourceDefinitions，简称CRD）是K8S的一个重要功能。K8S中有一些资源属于K8S内部自定义的资源类型，如Pod、ConfigMap等，但是即使有了这些核心的资源类型，还是不能满足所有用户的需求的，因为考虑到不同用户的需求不一样，K8S需要另一种可扩展的方式提供给用户。所以K8S就提供了这种叫做CRD的资源类型，允许用户定义自己的资源类型，同时还享受着K8S平台一系列便利：用户可以使用K8S的API，实现对自定义资源的CRUDW操作。有了这个扩展之后，更多的功能就可以在K8S上展开了，比如istio、knative等都是通过CRD来实现与K8S平台的互通，同时K8S自身的一些核心组件比如controller manager、kubelet、ingress等，本质上也是K8S资源的监听者。&lt;/p&gt;&#xA;&lt;p&gt;所以在K8S看来，其实一个自定义的资源类型，和用户通过CRD来定义的资源类型，处理起来并没有太多不一样的地方，在本文中通过对定义CRD之后生成的一些文件，来分析在K8S中实现一个资源类型，都需要哪些操作。&lt;/p&gt;&#xA;&lt;p&gt;如果还不熟悉CRD的创建流程，可以先看看这篇文章：https://www.cn18k.com/2018/04/04/Kubernetes-Deep-Dive-Code-Generation-for-CustomResources/ ，本文中将不讲述如何创建CRD生成代码的流程。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading&#34; id=&#34;核心数据结构&#34;&gt;&#xA;  核心数据结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;要实现一个K8S资源类型，熟悉K8S的人不难想到会涉及到如下操作。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;资源的注册：该资源如何注册到K8S系统中。&lt;/li&gt;&#xA;&lt;li&gt;不同版本资源的转换：一个资源，如果有多个不同的版本，那么必然涉及到这些版本之间如何进行转换的。&lt;/li&gt;&#xA;&lt;li&gt;资源数据的序列化：资源的数据最终是存储在etcd中的，但是在应答给客户端时，又有不同的格式输出，如yaml、json等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在这里，K8S提供了一个核心的scheme数据结构进行这些操作的封装，这个数据结构定义在K8S目录的vendor/k8s.io/apimachinery/pkg/runtime/scheme.go中，它有如下成员。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;gvkToType map[schema.GroupVersionKind]reflect.Type：根据组类型映射得到该资源的反射类型的map。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;typeToGVK map[reflect.Type][]schema.GroupVersionKind：根据反射类型得到组类型的map，注意到这里的值是一个数组，也就意味着一个反射类型可能对应多个组类型。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;unversionedKinds map[string]reflect.Type：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;fieldLabelConversionFuncs map[string]map[string]FieldLabelConversionFunc：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;defaulterFuncs map[reflect.Type]func(interface{})：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;converter *conversion.Converter：转换器，负责同个类型不同版本之间的转换。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以看到，Scheme结构体中，存储了关于组版本类型与对应资源类型的信息，因此它可以同时很方便的用于以下用途。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据资源类型得到其组版本信息，这是ObjectTyper接口需要的操作。&lt;/li&gt;&#xA;&lt;li&gt;进行一个资源在不同组版本之间的转化操作，这是ObjectConvertor接口需要的操作。&lt;/li&gt;&#xA;&lt;li&gt;根据传入的组版本信息，创建一个对应的资源数据返回，这是ObjectCreater接口需要的操作。&lt;/li&gt;&#xA;&lt;li&gt;给资源赋予默认值，这是ObjectDefaulter接口需要的操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在CRD的生成代码中，首先会生成如下几个全局变量，一般在clientset/versioned/scheme/register.go中：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var Scheme = runtime.NewScheme()&#xA;var Codecs = serializer.NewCodecFactory(Scheme)&#xA;var ParameterCodec = runtime.NewParameterCodec(Scheme)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Scheme：就是我们前面提到的Scheme结构体，它是最先生成的，因为它是后面其它全局变量的基础。&lt;/li&gt;&#xA;&lt;li&gt;Codecs：进行序列化和反序列化操作的结构体，之所以需要Scheme是因为它实现了前面分析过的几种与类型相关的接口。&lt;/li&gt;&#xA;&lt;li&gt;ParameterCodec:进行不同类型之间转换的操作结构体，用到Scheme也是因为它实现了前面分析过的几种与类型相关的接口。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 class=&#34;heading&#34; id=&#34;流程&#34;&gt;&#xA;  流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;有了前面的核心数据准备，可以继续展开CRD核心流程的分析了。&lt;/p&gt;&#xA;&lt;p&gt;在clientset/versioned/scheme/register.go中，init函数里会进行如下操作。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AddToGroupVersion添加该CRD组版本类型到scheme中，在这个函数中，会将一系列的资源与这个组版本挂钩：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// AddToGroupVersion registers common meta types into schemas.&#xA;func AddToGroupVersion(scheme *runtime.Scheme, groupVersion schema.GroupVersion) {&#xA;&#x9;scheme.AddKnownTypeWithName(groupVersion.WithKind(WatchEventKind), &amp;amp;WatchEvent{})&#xA;&#x9;scheme.AddKnownTypeWithName(&#xA;&#x9;&#x9;schema.GroupVersion{Group: groupVersion.Group, Version: runtime.APIVersionInternal}.WithKind(WatchEventKind),&#xA;&#x9;&#x9;&amp;amp;InternalEvent{},&#xA;&#x9;)&#xA;&#x9;// Supports legacy code paths, most callers should use metav1.ParameterCodec for now&#xA;&#x9;scheme.AddKnownTypes(groupVersion,&#xA;&#x9;&#x9;&amp;amp;ListOptions{},&#xA;&#x9;&#x9;&amp;amp;ExportOptions{},&#xA;&#x9;&#x9;&amp;amp;GetOptions{},&#xA;&#x9;&#x9;&amp;amp;DeleteOptions{},&#xA;&#x9;)&#xA;&#x9;scheme.AddConversionFuncs(&#xA;&#x9;&#x9;Convert_versioned_Event_to_watch_Event,&#xA;&#x9;&#x9;Convert_versioned_InternalEvent_to_versioned_Event,&#xA;&#x9;&#x9;Convert_watch_Event_to_versioned_Event,&#xA;&#x9;&#x9;Convert_versioned_Event_to_versioned_InternalEvent,&#xA;&#x9;)&#xA;&#xA;&#x9;// Register Unversioned types under their own special group&#xA;&#x9;scheme.AddUnversionedTypes(Unversioned,&#xA;&#x9;&#x9;&amp;amp;Status{},&#xA;&#x9;&#x9;&amp;amp;APIVersions{},&#xA;&#x9;&#x9;&amp;amp;APIGroupList{},&#xA;&#x9;&#x9;&amp;amp;APIGroup{},&#xA;&#x9;&#x9;&amp;amp;APIResourceList{},&#xA;&#x9;)&#xA;&#xA;&#x9;// register manually. This usually goes through the SchemeBuilder, which we cannot use here.&#xA;&#x9;AddConversionFuncs(scheme)&#xA;&#x9;RegisterDefaults(scheme)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面代码可以看出，任何一个CRD，都进行了以下的注册：&lt;/p&gt;</description>
    </item>
    <item>
      <title>K8S源码分析之Apiserver</title>
      <link>http://localhost:1313/post/20180927-k8s-apiserver/</link>
      <pubDate>Thu, 27 Sep 2018 11:33:33 +0800</pubDate>
      <guid>http://localhost:1313/post/20180927-k8s-apiserver/</guid>
      <description>&lt;h1 class=&#34;heading&#34; id=&#34;概述&#34;&gt;&#xA;  概述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;apiserver是K8S几个核心组件里面最重要的一个，它对内封装了对etcd的访问，对外提供REST接口给其他组件使用。其他的组件，比如属于核心组件的controller manager、kubelet、scheduller等，本质上都是watch在apiserver上的服务，其工作本质上就是通过apiserver监听对应资源的变更情况，然后根据自己的业务来完成相关的操作。从这里可以看到，apiserver的重要性比其他K8S核心组件更高，只要apiserver异常，整个系统都无法正常运行了。&lt;/p&gt;&#xA;&lt;p&gt;apiserver要完成的核心工作包括如下几件事情：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供REST接口给各种客户端调用，这些接口可以针对不同的K8S资源（pod、service等）进行CRUD操作，外加还可以进行监听其变化的操作。&lt;/li&gt;&#xA;&lt;li&gt;封装了对etcd的访问操作，K8S的其他组件并不会直接操作etcd，都是通过apiserver。其原因在于，K8S里面的资源定义，都有一个对应的版本号，比如在定义一个StatefulSet的时候，其yaml文件中需要指定apps/v1beta1这个版本号，同样的资源在不同版本的实现中可能会有差异。而对于保存到etcd的数据而言，这些版本号相关的meta信息，是不需要etcd这个只负责存储的组件去关心的，这些都是在apiserver中完成。&lt;/li&gt;&#xA;&lt;li&gt;既然前面提到了版本号，那么在向etcd进行读写操作的时候，就涉及到不同版本之间数据转换的问题，这个操作也是由apiserver来完成的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以，看上去apiserver只是负责调用etcd完成CRUD操作，可是实际上它的设计考量还是很多。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading&#34; id=&#34;go-restful框架简述&#34;&gt;&#xA;  go-restful框架简述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-restful%e6%a1%86%e6%9e%b6%e7%ae%80%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;由于apiserver中使用go-restful这个框架来提供REST接口，所以先提前做一些了解。&lt;/p&gt;&#xA;&lt;h1 class=&#34;heading&#34; id=&#34;核心数据结构&#34;&gt;&#xA;  核心数据结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;来回顾一下前面提到的apiserver要做的事情，以此为出发点来看看apiserver相关的实现。&lt;/p&gt;&#xA;&lt;p&gt;当通过kubectl客户端向apiserver发出请求时，可以打开日志级别，看到其中详细的流程，比如执行：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl get pod -n kube-system -v=8 tengine-ingress-controller-smsnz&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;能看到流程中相关的日志是：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;I0928 16:58:25.826473   66127 loader.go:357] Config loaded from file /home/nemo/.kube/config&#xA;I0928 16:58:25.842393   66127 round_trippers.go:414] GET https://apiserver:6443/api/v1/namespaces/kube-system/pods/tengine-ingress-controller-smsnz&#xA;I0928 16:58:25.842424   66127 round_trippers.go:421] Request Headers:&#xA;I0928 16:58:25.842436   66127 round_trippers.go:424]     Accept: application/json&#xA;I0928 16:58:25.842445   66127 round_trippers.go:424]     User-Agent: kubectl/v1.9.3 (linux/amd64) kubernetes/c5cea03&#xA;I0928 16:58:25.857103   66127 round_trippers.go:439] Response Status: 200 OK in 14 milliseconds&#xA;I0928 16:58:25.857116   66127 round_trippers.go:442] Response Headers:&#xA;I0928 16:58:25.857121   66127 round_trippers.go:445]     Audit-Id: 5c973d4f-faba-415f-89fa-f4f3dd3b2bf7&#xA;I0928 16:58:25.857126   66127 round_trippers.go:445]     Content-Type: application/json&#xA;I0928 16:58:25.857131   66127 round_trippers.go:445]     Date: Fri, 28 Sep 2018 08:58:25 GMT&#xA;I0928 16:58:25.857433   66127 request.go:873] Response Body: {&amp;#34;kind&amp;#34;:&amp;#34;Pod&amp;#34;,&amp;#34;apiVersion&amp;#34;:&amp;#34;v1&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;name&amp;#34;:&amp;#34;tengine-ingress-controller-smsnz&amp;#34;,&amp;#34;generateName&amp;#34;:&amp;#34;tengine-ingress-controller-&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;kube-system&amp;#34;,&amp;#34;selfLink&amp;#34;:&amp;#34;/api/v1/namespaces/kube-system/pods/tengine-ingress-controller-smsnz&amp;#34;,&amp;#34;uid&amp;#34;:&amp;#34;617f505d-c160-11e8-b8fb-6c92bf6b2d28&amp;#34;,&amp;#34;resourceVersion&amp;#34;:&amp;#34;115930452&amp;#34;,&amp;#34;creationTimestamp&amp;#34;:&amp;#34;2018-09-26T07:47:13Z&amp;#34;,&amp;#34;labels&amp;#34;:{&amp;#34;controller-revision-hash&amp;#34;:&amp;#34;1353751459&amp;#34;,&amp;#34;k8s-app&amp;#34;:&amp;#34;tengine-ingress-controller&amp;#34;,&amp;#34;pod-template-generation&amp;#34;:&amp;#34;11504&amp;#34;},&amp;#34;annotations&amp;#34;:{&amp;#34;prometheus.io/port&amp;#34;:&amp;#34;10254&amp;#34;,&amp;#34;prometheus.io/scrape&amp;#34;:&amp;#34;true&amp;#34;},&amp;#34;ownerReferences&amp;#34;:[{&amp;#34;apiVersion&amp;#34;:&amp;#34;extensions/v1beta1&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;DaemonSet&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;tengine-ingress-controller&amp;#34;,&amp;#34;uid&amp;#34;:&amp;#34;22d6ca2b-f794-11e7-831e-042758486066&amp;#34;,&amp;#34;controller&amp;#34;:true,&amp;#34;blockOwnerDeletion&amp;#34;:true}]},&amp;#34;spec&amp;#34;:{&amp;#34;volumes&amp;#34;:[{&amp;#34;name&amp;#34;:&amp;#34;nginx-log&amp;#34;,&amp;#34;hostPath&amp;#34;:{&amp;#34;path&amp;#34;:&amp;#34;/home1/system/ingress/nginx/log&amp;#34;,&amp;#34;type&amp;#34;:&amp;#34;&amp;#34;}},{&amp;#34;name&amp;#34;:&amp;#34;logsender-log&amp;#34;,&amp;#34;hostPath&amp;#34;:{&amp;#34;path&amp;#34;:&amp;#34;/home1/system/ingress/logsender/log&amp;#34;,&amp;#34;type&amp;#34;:&amp;#34;&amp;#34;}},{&amp;#34;name&amp;#34;:&amp;#34;logsender-plugin-log&amp;#34;,&amp;#34;hostPath&amp;#34;:{&amp;#34;path&amp;#34;:&amp;#34;/home1/system/ingre [truncated 3760 chars]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这里能看到：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
