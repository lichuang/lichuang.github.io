<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>raft on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/raft/</link>
    <description>Recent content in raft on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 07 May 2022 17:57:08 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/raft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>周刊（第14期）：重读Raft论文中的集群成员变更算法（二）：实践篇</title>
      <link>https://www.codedump.info/post/20220507-weekly-14/</link>
      <pubDate>Sat, 07 May 2022 17:57:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220507-weekly-14/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：以前阅读Raft大论文的时候，对“集群变更”这部分内容似懂非懂。于是最近又重读了大论文这部分的内容，以下是重读时做的一些记录。这部分内容打算分为两篇文章，上篇讲解成员变更流程的理论基础，下篇讲解实践中存在的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;重读raft论文中的集群成员变更算法二实践篇&#34;&gt;重读Raft论文中的集群成员变更算法（二）：实践篇&lt;/h1&gt;
&lt;h2 id=&#34;单步成员变更存在的问题&#34;&gt;单步成员变更存在的问题&lt;/h2&gt;
&lt;h3 id=&#34;正确性问题&#34;&gt;正确性问题&lt;/h3&gt;
&lt;p&gt;单步变更成员时，可能出现正确性问题。如下面的例子所示，最开始时，系统的成员是&lt;code&gt;{a,b,c,d}&lt;/code&gt;这四个节点的集合，要将节点&lt;code&gt;u&lt;/code&gt;和&lt;code&gt;v&lt;/code&gt;加入集群，按照单步变更成员的做法，依次会经历：&lt;code&gt;{a,b,c,d}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d,u}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d,u,v}&lt;/code&gt;的变化，每次将一个节点加入到集群里。&lt;/p&gt;
&lt;p&gt;上面的步骤看起来很美好，但是考虑下面的例子，在变更过程中leader节点发生了变化的情况：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C₀ = {a, b, c, d}
Cᵤ = C₁ ∪ {u}
Cᵥ = C₁ ∪ {v}

Lᵢ: Leader in term `i`
Fᵢ: Follower in term `i`
☒ : crash

    |
 u  |         Cᵤ                  F₂  Cᵤ
--- | ----------------------------------
 a  | C₀  L₀  Cᵤ  ☒               L₂  Cᵤ
 b  | C₀  F₀          F₁          F₂  Cᵤ
 c  | C₀  F₀          F₁  Cᵥ          Cᵤ
 d  | C₀              L₁  Cᵥ  ☒       Cᵤ
--- | ----------------------------------
 v  |                     Cᵥ                  time
    +--------------------------------------------&amp;gt;
          t₁  t₂  t₃  t₄  t₅  t₆  t₇  t₈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（引用自&lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑 - OpenACID Blog&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;上面的流程中，纵坐标是集群中的节点，横坐标是不同的时间（注意不是任期），&lt;code&gt;Li&lt;/code&gt;表示在任期i时候的leader节点，&lt;code&gt;Fi&lt;/code&gt;表示在任期i时候的follower节点。&lt;/p&gt;
&lt;p&gt;上图的流程阐述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t1：a节点被选为任期0的leader，而b、c节点为follower。&lt;/li&gt;
&lt;li&gt;t2：将节点u加入集群，但是这条加入集群的日志，仅达到了a和u节点，由于这条日志并没有半数以上通过，所以这时候节点u还并未成功加入集群。&lt;/li&gt;
&lt;li&gt;t3：节点a宕机。&lt;/li&gt;
&lt;li&gt;t4：由于原先的leader宕机，于是集群需要选出新的leader，选出来的新leader是节点d，这是任期1时候的leader。&lt;/li&gt;
&lt;li&gt;t5：节点v加入集群，加入集群的日志，到达了节点c、d、v上面，可以看到由于这条日志到了此时集群的半数以上节点上（因为这时候节点a宕机，因此只有三个节点在服务，于是只有有2个节点同意就认为可被提交），所以实际是已经提交的，即v加入集群的操作是成功的。&lt;/li&gt;
&lt;li&gt;t6：leader d宕机。&lt;/li&gt;
&lt;li&gt;t7：宕机的节点a恢复服务，看到本地有将节点u加入到集群的日志，于是它认为节点u、b是这个任期的follower节点。&lt;/li&gt;
&lt;li&gt;t8：此时节点d恢复服务，而leader a将之前把节点u加入集群的日志同步给当前集群的所有节点，这造成了之前v加入集群且已被提交的日志丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出现这个问题，本质是因为：上一任leader的变更日志，还未同步到集群半数以上节点就宕机，这时候新一任leader就进行成员变更，这样导致了形成两个不同的集群，产生脑裂将已经提交的日志被覆盖。&lt;/p&gt;
&lt;p&gt;Raft作者在&lt;a href=&#34;https://groups.google.com/g/raft-dev/c/t4xj6dJTP6E/m/d2D9LrWRza8J&#34;&gt;bug in single-server membership changes&lt;/a&gt;描述了这一现象。&lt;/p&gt;
&lt;p&gt;解决的办法也很简单：即每次新当选的leader不允许直接提交在它本地的日志，而必须先提交一个no-op日志，才能开始同步。这个问题的描述，在之前的博客有描述：&lt;a href=&#34;https://www.codedump.info/post/20211011-raft-propose-prev-term/&#34;&gt;为什么Raft协议不能提交之前任期的日志？ - codedump的网络日志&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;可用性问题&#34;&gt;可用性问题&lt;/h3&gt;
&lt;p&gt;除了以上正确性问题，单步变更还有可能出现可用性问题：当需要替换的节点在同一机房的时候，如果这个机房网络与集群中其他机房的网络断开，就会导致无法选出leader，以致于集群无法提供服务。来看下面的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220507-weekly-14/availability.png&#34; alt=&#34;availability&#34; title=&#34;availability&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，原先集群中有三个节点分别位于三个机房：机房1的节点a、机房2的节点b、机房3的节点c。现在由于各种原因，想把机房1的节点a下线，换成同机房的节点d到集群中继续服务。&lt;/p&gt;
&lt;p&gt;可以看到，这个替换操作涉及到一个节点的加入和一个节点的离开，可能有如下两种可能的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先加入新节点d再删除节点a：&lt;code&gt;{a,b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;先删除节点a再加入新节点d：&lt;code&gt;{a,b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种步骤各有优劣，第二种方案的问题是：中间只有两个节点在服务，一旦这时候又发生宕机，则集群就不可用了。&lt;/p&gt;
&lt;p&gt;第一种方案中，按照上图中的例子，如果正好要替换的a、d节点都位于同一个机房里面，那么假如这个机房的网络也与其它机房隔离，那么只有两个节点在服务，这时候在四节点（中间步骤）的条件下也无法服务。&lt;/p&gt;
&lt;p&gt;以上是单步变更中可能出现的两类问题。可以看到，尽管单步变更算法看起来实现简单，但是实则有很多细节需要注意。虽然Raft论文中认为单步变更是更简单的办法，但是现在主流的实现都使用了Joint Consensus（联合共识）算法。&lt;/p&gt;
&lt;h2 id=&#34;joint-consensus算法如何解决可用性问题&#34;&gt;Joint Consensus算法如何解决可用性问题&lt;/h2&gt;
&lt;p&gt;针对上面提到的：替换同一机房中的不同节点，中间过程中可能由于这个机房被网络隔离，导致的集群不可用（选不出leader）问题，来看看Joint Consensus算法是如何解决的。&lt;/p&gt;
&lt;p&gt;先来回顾一下步骤，如果使用Joint Consensus算法，需要经历两阶段提交：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先提交&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后提交&lt;code&gt;C_New&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把集合换成这里的例子，就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先提交&lt;code&gt;{a,b,c}&lt;/code&gt; $\bigcup$ &lt;code&gt;{a,b,c,d}&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;然后提交 &lt;code&gt;{a,b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看这两阶段中可能出现宕机的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段时leader节点宕机，这个leader节点只有可能是两种情况，其集群配置还是&lt;code&gt;C_Old&lt;/code&gt;，或者已经收到了&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C_Old&lt;/code&gt;：由于这时候这个leader并没有第一阶段提交的&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合变更，因此那些已有&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合的follower这部分的日志将被截断，成员变更失败，回退回&lt;code&gt;C_Old&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;：这意味这个leader已经有第一阶段提交的&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合变更，可以继续将未完成的成员变更流程走完。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似的，在第二阶段时leader节点宕机，也不会导致选不出leader的情况，可以类似推导。&lt;/p&gt;
&lt;p&gt;可见：直接使用Joint Consensus算法并不会存在单步变更时的可用性问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raft集群的单步变更算法，虽然看起来”简单“，但是实践起来有不少细节需要注意。&lt;/li&gt;
&lt;li&gt;虽然论文里提到单步变更算法比之Joint Consensus算法更为简单，很多开源的Raft实现都已经以Joint Consensus算法做为默认的实现了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（之前写过etcd 3.5版本的实现解析，见：&lt;a href=&#34;https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/&#34;&gt;etcd 3.5版本的joint consensus实现解析 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/VKu7fBLliztx3tzvzYDkqw&#34;&gt;Raft成员变更的工程实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑 - OpenACID Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/g/raft-dev/c/t4xj6dJTP6E/m/d2D9LrWRza8J&#34;&gt;bug in single-server membership changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/ongardie/a11f32b70581e20d6bcd&#34;&gt;Safety of Raft single-server membership changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/peterbourgon/raft/blob/master/JOINT-CONSENSUS.md&#34;&gt;raft/JOINT-CONSENSUS.md at master · peterbourgon/raft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第13期）：重读Raft论文中的集群成员变更算法（一）：理论篇</title>
      <link>https://www.codedump.info/post/20220417-weekly-13/</link>
      <pubDate>Sun, 17 Apr 2022 15:16:30 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220417-weekly-13/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：以前阅读Raft大论文的时候，对“集群变更”这部分内容似懂非懂。于是最近又重读了大论文这部分的内容，以下是重读时做的一些记录。这部分内容打算分为两篇文章，上篇讲解成员变更流程的理论基础，下篇讲解实践中存在的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;重读raft论文中的集群成员变更算法一理论篇&#34;&gt;重读Raft论文中的集群成员变更算法（一）：理论篇&lt;/h1&gt;
&lt;p&gt;“集群成员变更（cluster membership change）”意指一个集群内节点的增、删操作，这在一个分布式系统中是必不可少的操作，因为并不能保证一个集群的所有节点都一直能工作的很好。Raft大论文《&lt;a href=&#34;https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf&#34;&gt;Consensus: Bridging Theory and Practice&lt;/a&gt;》中有专门的一节来讲解这部分内容。&lt;/p&gt;
&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;
&lt;p&gt;首先，Raft算法中要求所有操作都需要保证安全性（safety），即：任何时候都不能在集群中同时存在两个leader节点。“集群成员变更”算法也必须保证安全性这个大前提不能被破坏，于是论文中阐述了为什么直接变更多个节点是不被允许的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.2.png&#34; alt=&#34;4.2&#34; title=&#34;4.2&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图的图示中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧集群有1、2、3这三个节点，而需要将这个三节点的集群新增节点4、5变更到5节点集群去。&lt;/li&gt;
&lt;li&gt;如果直接如图中这样变更，由于每个节点的时间窗口并不一致，可能就会出现这种情况：
&lt;ul&gt;
&lt;li&gt;在某一时刻，节点1、2还使用的是旧集群（只含有{1,2,3}）的成员配置，而3、4、5已经是新集群（含有{1,2,3,4,5}）的成员配置了。&lt;/li&gt;
&lt;li&gt;这样就可能出现还使用旧集群节点配置的1、2选出了一个leader，以及已经使用了新集群配置的节点3、4、5选出了另一个leader的情况，于是违反了上面阐述的“安全性”要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，在上面这个错误的示例中，是由于有两类行为同时出现才导致的错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性变更多个节点。在例子中，就是一次性把4、5两个节点加入到集群中。&lt;/li&gt;
&lt;li&gt;直接（directly）变更。直接变更由于集群中不同节点的步子不一样，而不一样的节点如果出现了两个不同的集群，那么就可能导致选出两个不同的leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/cluster-membership-change.png&#34; alt=&#34;cluster-membership-change&#34; title=&#34;cluster-membership-change&#34;&gt;&lt;/p&gt;
&lt;p&gt;于是，由于这两个错误操作是一起发生才会导致错误，论文中给出了两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要么一次性严格限制只变更一个节点。&lt;/li&gt;
&lt;li&gt;如果实在想一次变更多个节点，那就不能直接变更，需要经过一个中间状态的过渡之后才能完成同时变更多个节点的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下分别来阐述这两种不同的实现。&lt;/p&gt;
&lt;h2 id=&#34;一次变更单个节点&#34;&gt;一次变更单个节点&lt;/h2&gt;
&lt;p&gt;如果限制每次只变更一个节点，那么就能保证“新、旧集合的quorum集合是有重合的”，由于有重合，这样就能保证新旧两个集群的集合不会选出不同的leader，就能间接保证安全性。&lt;/p&gt;
&lt;p&gt;论文中以下面几个例子来说明这样操作的正确性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.3.png&#34; alt=&#34;4.3&#34; title=&#34;4.3&#34;&gt;&lt;/p&gt;
&lt;p&gt;这几个图，是在两个维度上做示范的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增、删操作。&lt;/li&gt;
&lt;li&gt;原集群节点数量是奇数还是偶数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个维度的组合一共就是上面的4中情况，但是无论哪一种情况，由于都保证了“新、旧集合的quorum集合是有重合的”这个条件，于是不会选出不一样的leader来。&lt;/p&gt;
&lt;h2 id=&#34;一次变更多个节点&#34;&gt;一次变更多个节点&lt;/h2&gt;
&lt;p&gt;从上面的例子中可以看到：只要能保证一次只变更一个节点，是可以直接（directly）变更的。即：无需中间状态，直接从A集合变更到A+1集合，因为这两个集合的quorum肯定有重合。&lt;/p&gt;
&lt;p&gt;但是，在一次需要变更多个节点的情况下，就不能这样直接变更，因为会出现最开始示例的那样同时选出两个leader的情况。于是，为了解决这个问题，需要引入一个中间状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设原先的集群节点集合为C_Old，新的集群节点集合为C_New，那么首先变更配置到{C_Old,C_New}，也就是新旧集群节点集合的并集。&lt;/li&gt;
&lt;li&gt;上面这次变更提交之后，再向集群变更配置到C_New。在这次变更提交之后，那些不在C_New节点集合中的节点，收到这个变更时，自动下线退出集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以证明：上面两个步骤中，都不会出现“同时存在两个leader”的情况。&lt;/p&gt;
&lt;p&gt;从本质上来说，这种变更算法，属于一种两阶段的成员变更算法，Raft大论文中称之为“Joint Consensus（联合共识）”算法。下图中演示了Joint Consensus算法这两个阶段的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.8.png&#34; alt=&#34;4.8&#34; title=&#34;4.8&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;failover&#34;&gt;Failover&lt;/h3&gt;
&lt;p&gt;我们来看看Joint Consensus算法，在变更过程中如果出错，是如何failover选出新leader的。&lt;/p&gt;
&lt;p&gt;第一阶段，这时候选出来的leader只有可能有两种情况，还是旧的C_Old节点集合，或者已经收到了{C_Old,C_New}节点集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有C_Old节点集合的节点：由于这时候这个leader并没有第一阶段提交的{C_Old,C_New}节点集合变更，因此那些已有{C_Old,C_New}节点集合的follower这部分的日志将被截断，成员变更失败，回退回C_Old集合。&lt;/li&gt;
&lt;li&gt;有{C_Old,C_New}节点集合的节点：这意味这个leader已经有第一阶段提交的{C_Old,C_New}节点集合变更，可以继续将未完成的成员变更流程走完。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似的，也可以去推导一下在第二阶段出现leader宕机时，选出来的leader只可能具备两种情况，但是这两种情况都不可能选出多个leader。&lt;/p&gt;
&lt;h2 id=&#34;集群变更何时生效&#34;&gt;集群变更何时生效？&lt;/h2&gt;
&lt;p&gt;以上讲解完毕两种不同的集群变更方式，下面来聊一聊集群变更何时生效。&lt;/p&gt;
&lt;p&gt;在Raft、Paxos这类状态机模型的一致性算法中，将任何变更操作都认为是一个命令（Command），命令的处理流程是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态机收到命令，首先在自己本地将命令持久化。&lt;/li&gt;
&lt;li&gt;然后广播给集群中的其他节点。&lt;/li&gt;
&lt;li&gt;当收到集群半数以上节点的应答时，认为命令是可以被提交（commit）的，于是可以生效将这些已经被提交的日志传给应用层的状态机使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上流程可以看到：一条命令，只有在“提交（commit）”之后才能“生效（apply）”。&lt;/p&gt;
&lt;p&gt;在Raft中，“成员变更”这个操作，也是一类命令，即：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Command&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;LogEntry,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;MembershipChange,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;};&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样设计的好处在于：处理成员变更操作，和一般的日志并没有区别，于是不存在一个特定的时间被称为“处理成员变更的时间”，在这个时间里停止响应一般的命令。&lt;/p&gt;
&lt;p&gt;但是与一般命令不同的是，“成员变更”操作并不需要等到多数通过才能生效。注意，对于一般命令而言，要“生效”必须首先“提交”，而集群变更类命令的生效没有这个依赖关系。&lt;/p&gt;
&lt;p&gt;即，在Raft的成员变更流程中，节点在收到一个新集群节点配置之后，是马上生效的，无需等待半数以上通过。&lt;/p&gt;
&lt;p&gt;这是在阅读Raft论文这一部分内容时，经常被忽略的部分。为什么集群变更类指令，可以这么做，以及这样做会不会出问题？&lt;/p&gt;
&lt;p&gt;为了安全性，Raft在进行集群变更操作时，无论是“单次变更一个节点”还是“一次变更多个节点”，在不同的阶段都不能有重叠（overlap）的情况出现，因为重叠意味着可能违反前面提到的安全性。比如将一个集群节点集合从{1,2,3}变更为{1,4,5}，如果使用这两种方式，步骤分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次变更一个节点：{1,2,3}-&amp;gt;{1,2,3,4} （增加节点4）-&amp;gt;{1,2,3,4,5} （增加节点5）-&amp;gt;{1,3,4,5} （删除节点2）-&amp;gt; {1,4,5} （删除节点3）。&lt;/li&gt;
&lt;li&gt;单次变更多个节点：{1,2,3}（C_Old）-&amp;gt; {1,2,3,4,5}（{C_Old,C_New}）-&amp;gt; {1,4,5}（C_Old,C_New）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，无论采用哪一种方式，都会有多个步骤。由leader来决定当前的步骤，其判断的标准是：前一步修改的日志，是否已经被提交（半数以上同意）。所以，如果成员变更类的日志在提交之后才生效的话，leader就需要再多一个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确认日志已经被提交到半数以上节点。&lt;/li&gt;
&lt;li&gt;在这之后，再确认这个成员变更已经在节点上生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而后面的这个确认，是可以避免的。因为根据前面&lt;code&gt;failover&lt;/code&gt;部分的分析，无论哪一种情况出现，即便在变更的过程中leader宕机，也不会出现选出多个leader的情况。&lt;/p&gt;
&lt;p&gt;于是，对于成员变更类的日志来说，Raft的规则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多次提交不能重叠（overlap），即如果当前已经有还未提交的成员变更日志，在它提交之前不允许提交新的成员变更修改。&lt;/li&gt;
&lt;li&gt;成员变更的生效，无需等待提交，每个节点在收到这类日志的时候，就能马上修改本节点上的成员为最新的这个配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raft算法要求任何时候都要保证安全性（safety）：不能在同一时间在集群中存在两个不同的leader节点。&lt;/li&gt;
&lt;li&gt;如果以下两个操作同时发生，就有可能违反安全性：
&lt;ul&gt;
&lt;li&gt;一次变更多个节点。&lt;/li&gt;
&lt;li&gt;直接变更集群的节点集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由这两个限制出发，分别有以下两种实现成员变更的算法：
&lt;ul&gt;
&lt;li&gt;限制每次只变更一个节点，这种情况下可以直接变更成员。&lt;/li&gt;
&lt;li&gt;每次可以变更任意数量的节点，但是必须通过两阶段提交完成才能生效：第一次从C_Old变成{C_Old,C_New}节点集合，第二次从{C_Old,C_New}变成C_New。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“成员变更”类命令，在Raft算法看来也是一条日志。但是与普通日志命令不同的是，成员变更类日志的生效，无需等待这条日志提交了才能生效，可以在收到之后马上生效。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>etcd 3.5版本的joint consensus实现解析</title>
      <link>https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/</link>
      <pubDate>Sat, 01 Jan 2022 15:02:50 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在以前的etcd实现中，“集群节点变更”这一功能，仅支持每次变更一个节点，最新的etcd已经能支持一次变更多个节点配置的功能了。本文将就这部分的实现进行解析。&lt;/p&gt;
&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;
&lt;p&gt;Raft论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》的第四章”集群成员变更“中，支持两种集群变更方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次变更单节点，即“One Server Config Change”。&lt;/li&gt;
&lt;li&gt;多节点联合共识，即“Joint Consensus”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文先就这两种实现方式进行原理上的讲解。&lt;/p&gt;
&lt;h2 id=&#34;集群节点变更的问题&#34;&gt;集群节点变更的问题&lt;/h2&gt;
&lt;p&gt;要保证Raft协议的安全性，就是要保证任意时刻，集群中只有唯一的&lt;code&gt;leader&lt;/code&gt;节点。如果不加限制条件，那么动态向当前运行集群增删节点的操作，有可能会导致存在多个&lt;code&gt;leader&lt;/code&gt;的情况。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/multi-server.png&#34; alt=&#34;集群节点变更问题&#34; title=&#34;集群节点变更问题&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中有两种颜色的配置，绿色表示旧的集群配置（&lt;code&gt;C_old&lt;/code&gt;），蓝色表示新的集群配置（&lt;code&gt;C_new&lt;/code&gt;），如果不加任何限制，直接将配置启用，由于不同的集群节点之间，存在时间差，那么可能出现这样的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server{1,2}：当前都使用旧的集群配置，所以可能选出server1为集群的leader。&lt;/li&gt;
&lt;li&gt;Server{3,4,5}：当前都使用新的集群配置，可能选出server3为集群的leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由上图可以看到：如果不加任何限制，直接应用新的集群配置，由于时间差的原因，可能导致集群中出现两个不同leader的情况。&lt;/p&gt;
&lt;h2 id=&#34;单节点成员变更one-server-confchange&#34;&gt;单节点成员变更（One Server ConfChange）&lt;/h2&gt;
&lt;p&gt;“单节点成员变更”，意指每次只添加或删除一个节点，这样就能保证集群的安全性，不会在同一时间出现多个&lt;code&gt;leader&lt;/code&gt;的情况。之所以能有这个保证，是因为每次变更一个节点，那么新旧两种配置的半数节点（majorrity）肯定存在交集。以下图来说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/one-server-confchange.png&#34; alt=&#34;单节点成员变更&#34; title=&#34;单节点成员变更&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图演示了向偶数或奇数的集群增删一个节点的所有可能情况。不论哪种情况，新旧配置都有交集，在每个任期只能投出一张票的情况下，是不会出现多&lt;code&gt;leader&lt;/code&gt;的情况的。&lt;/p&gt;
&lt;p&gt;有了上面的理论基础，下面来看&lt;code&gt;单节点集群变更&lt;/code&gt;的全流程，当下发集群节点变更配置时，新的配置会以一种特殊的日志方式进行提交，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通日志：半数通过，提交成功时，会传给应用层的状态机。&lt;/li&gt;
&lt;li&gt;配置变更类日志：半数通过，提交成功时，集群节点将以新的集群配置生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将集群配置变更数据，序列化为日志数据，需要将日志类型标记为&lt;code&gt;集群配置变更&lt;/code&gt;类的日志，提交给&lt;code&gt;leader&lt;/code&gt;节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leader&lt;/code&gt;节点收到日志后，需要存储该日志的索引为&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;，像其它正常日志一样处理：先写本地的日志，再广播给集群的其他节点，半数应答则认为日志达成一致可以提交了。如果提交了这类日志，可以将前面保存的&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;置为空了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;集群配置变更&lt;/code&gt;日志提交之后，对照新旧的集群变更数据，该添加到集群的添加到集群，该删除的节点停机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，同一时间只能有唯一一个&lt;code&gt;集群变更类日志&lt;/code&gt;存在，怎么保证这一点？就算是在&lt;code&gt;leader&lt;/code&gt;收到该类型日志时，判断&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;是否为空。&lt;/p&gt;
&lt;h2 id=&#34;多节点联合共识joint-consensus&#34;&gt;多节点联合共识（Joint Consensus）&lt;/h2&gt;
&lt;p&gt;除了上面的单节点变更，有时候还需要一次提交多个节点的变更。但是按照前面的描述，如果一次提交多个节点，很可能会导致集群的安全性被破坏，即同时出现多个&lt;code&gt;leader&lt;/code&gt;的情况。因此，一次提交多节点时，就需要走&lt;code&gt;联合共识&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓的&lt;code&gt;联合共识&lt;/code&gt;，就是将新旧配置的节点一起做为一个节点集合，只有该节点集合达成半数一致，才能认为日志可以提交，由于新旧两个集合做了合并，那么就不会出现多&lt;code&gt;leader&lt;/code&gt;的情况了。具体流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;leader&lt;/code&gt;收到成员变更请求，新集群节点集合为&lt;code&gt;C_new&lt;/code&gt;，当前集群节点集合为&lt;code&gt;C_old&lt;/code&gt;，此时首先会以新旧节点集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;做为一个&lt;code&gt;集群配置变更&lt;/code&gt;类的日志，走正常的日志提交流程。注意，这时候的日志，需要提交到&lt;code&gt;C_{old,new}&lt;/code&gt;中的所有节点。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;C_{old,new}&lt;/code&gt;集群变更日志提交之后，&lt;code&gt;leader&lt;/code&gt;节点再马上创建一个只有&lt;code&gt;C_new&lt;/code&gt;节点集合的&lt;code&gt;集群配置变更&lt;/code&gt;类日志，再次走正常的日志提交流程。这时候的日志，只需要提交到&lt;code&gt;C_new&lt;/code&gt;中的所有节点。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;C_new&lt;/code&gt;日志被提交之后，集群的配置就能切换到&lt;code&gt;C_new&lt;/code&gt;对应的新集群配置下了。而不在&lt;code&gt;C_new&lt;/code&gt;配置内的节点，将被移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，&lt;code&gt;多节点联合共识&lt;/code&gt;的提交流程分为了两次提交：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先提交新旧集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再提交新节点集合&lt;code&gt;C_new&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下图来说明，这几个阶段中，集群的安全性都得到了保证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/Joint-Consensus.png&#34; alt=&#34;多节点联合共识&#34; title=&#34;多节点联合共识&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;C_{old,new}&lt;/code&gt;配置提交之前：在做个阶段，集群中的节点，要么处于&lt;code&gt;C_old&lt;/code&gt;配置下，要么处于&lt;code&gt;C_new,old&lt;/code&gt;配置之下。此时，如果集群的&lt;code&gt;leader&lt;/code&gt;节点宕机，那么将会基于&lt;code&gt;C_old&lt;/code&gt;或者&lt;code&gt;C_new,old&lt;/code&gt;配置来选出新的&lt;code&gt;leader&lt;/code&gt;，而不会仅仅基于&lt;code&gt;C_new&lt;/code&gt;，因此不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_{old,new}&lt;/code&gt;配置提交之后，&lt;code&gt;C_new&lt;/code&gt;下发之前：如果这时候&lt;code&gt;leader&lt;/code&gt;宕机，只会基于&lt;code&gt;C_{old,new}&lt;/code&gt;的配置选出&lt;code&gt;leader&lt;/code&gt;，因此也不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_new&lt;/code&gt;下发但还未提交时：如果这时候&lt;code&gt;leader&lt;/code&gt;宕机，只会基于&lt;code&gt;C_{old,new}&lt;/code&gt;或者&lt;code&gt;C_new&lt;/code&gt;的配置选出&lt;code&gt;leader&lt;/code&gt;，同时也不再会发给仅仅在&lt;code&gt;C_old&lt;/code&gt;中的节点了，所以无论是哪个配置，都需要得到&lt;code&gt;C_new&lt;/code&gt;的半数同意，因此不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_new&lt;/code&gt;提交之后：此时集群中只有一种配置了，安全性得到了保证。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;
&lt;p&gt;了解了原理之后，可以来具体看etcd 3.5中这部分的实现了。&lt;/p&gt;
&lt;h2 id=&#34;learner&#34;&gt;learner&lt;/h2&gt;
&lt;p&gt;首先需要了解&lt;code&gt;learner&lt;/code&gt;这个概念，在Raft中，这类型节点有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与其他节点一样，能正常接收&lt;code&gt;leader&lt;/code&gt;同步的日志。&lt;/li&gt;
&lt;li&gt;但是&lt;code&gt;learner&lt;/code&gt;节点没有投票权，即：投票时会忽略掉这类型节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也因为这样，所以&lt;code&gt;learner&lt;/code&gt;节点也常被称为&lt;code&gt;non voter&lt;/code&gt;类型的节点。&lt;/p&gt;
&lt;p&gt;那么，什么时候需要&lt;code&gt;learner&lt;/code&gt;节点呢？如果一个节点刚加入集群，此时要追上当前的进度，需要一段时间，但是由于这个新节点的加入，导致集群的不可用风险增加了，即原来三节点的集群，挂了一个还能工作；加入这个新节点之后，新节点还没赶上进度，那么可能挂了一个节点集群就不可用了。&lt;/p&gt;
&lt;p&gt;所以，对于新加入的节点，可以先将它置为&lt;code&gt;learner&lt;/code&gt;类型，即：只同步日志，不参与投票。等到进度追上了，再变成正常的有投票权的节点。&lt;/p&gt;
&lt;p&gt;一个节点，需要添加到集群中变成集群的&lt;code&gt;learner&lt;/code&gt;，或者从原集群的&lt;code&gt;voter&lt;/code&gt;变成&lt;code&gt;learner&lt;/code&gt;，也都不能直接添加，而是必须走前面正常的&lt;code&gt;集群变更&lt;/code&gt;流程，即：集群中的&lt;code&gt;learner&lt;/code&gt;集合也是集群节点配置的一部分。&lt;/p&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;h3 id=&#34;每个节点的进度数据progress结构体&#34;&gt;每个节点的进度数据（Progress结构体）&lt;/h3&gt;
&lt;p&gt;etcd中，使用&lt;code&gt;Progress&lt;/code&gt;结构体来存储集群中每个节点当前的进度数据，包括以下成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志索引类成员：
&lt;ul&gt;
&lt;li&gt;Match索引&lt;/li&gt;
&lt;li&gt;Next索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当前的进度状态：
&lt;ul&gt;
&lt;li&gt;探针状态（probe）：节点刚加入，或者刚恢复都是该状态。&lt;/li&gt;
&lt;li&gt;正常同步状态（replicate）。&lt;/li&gt;
&lt;li&gt;同步快照状态：当前没有在进行日志同步，而是在同步快照。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IsLearner：标记当前该节点是否是&lt;code&gt;learner&lt;/code&gt;状态的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，&lt;code&gt;进度状态&lt;/code&gt;类似于TCP协议中的流控，不在这里做阐述了；两个&lt;code&gt;日志索引&lt;/code&gt;也是Raft论文中用于存储节点进度数据的索引，也不在这里阐述了；唯独需要注意的是&lt;code&gt;IsLearner&lt;/code&gt;，该成员标记了该节点是否&lt;code&gt;learner&lt;/code&gt;节点。&lt;/p&gt;
&lt;h3 id=&#34;集群配置config结构体&#34;&gt;集群配置（Config结构体）&lt;/h3&gt;
&lt;p&gt;集群配置使用&lt;code&gt;Config&lt;/code&gt;结构体来保存，其成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Voters：包括新旧两个配置。新旧两个配置的节点集合合集，成为当前的所有节点集合。
&lt;ul&gt;
&lt;li&gt;[0]：&lt;code&gt;incoming&lt;/code&gt;配置，新的集群配置。&lt;/li&gt;
&lt;li&gt;[1]：&lt;code&gt;outgoing&lt;/code&gt;配置，旧的集群配置。一般这个集合为空，这个集合不为空时，存储的是变更之前旧的集群配置，因此不为空时表示当前有未提交的&lt;code&gt;joint consensus&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Learners：当前的learner集合，learner集合和前面的所有节点集合交集必须为空集。&lt;/li&gt;
&lt;li&gt;LearnersNext：集群配置提交后，从原集群的&lt;code&gt;voter&lt;/code&gt;降级为&lt;code&gt;learner&lt;/code&gt;的节点集合。&lt;/li&gt;
&lt;li&gt;AutoLeave：该配置为true时，自动让新配置生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面原理的部分，只讲解了新旧配置的变更流程，但是在etcd的实现中，集群配置里除了新旧配置，还多了存储&lt;code&gt;Learner&lt;/code&gt;节点的两种集合，这会让情况变得更复杂一些。&lt;/p&gt;
&lt;p&gt;如果一个节点要在新的集群配置中变成&lt;code&gt;Learner&lt;/code&gt;，需要区分两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该节点原先是集群的&lt;code&gt;voter&lt;/code&gt;：并不是直接加入到&lt;code&gt;Learner&lt;/code&gt;集合的，而是首先提交到&lt;code&gt;LearnersNext&lt;/code&gt;集合中，同样也是等待这个新的集群配置被成功之后，才移动到&lt;code&gt;Learner&lt;/code&gt;集合中。否则，如果直接修改加入到&lt;code&gt;Learner&lt;/code&gt;集合中，可能导致集群的安全性受到影响。比如一个三节点{a,b,c}的集群，原先有只挂了一个节点还能继续工作；现在由于各种原因，想将节点c降级为&lt;code&gt;learner&lt;/code&gt;，将节点d加入到集群中，如果直接将c节点降级为&lt;code&gt;learner&lt;/code&gt;，就会导致在这个流程里一旦一个节点不可用，整个集群就不可用了。&lt;/li&gt;
&lt;li&gt;该节点原先不是集群中的成员：这种节点由于之前并不存在，并不影响集群的安全性，这时候可以直接移动到&lt;code&gt;Learner&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/add-learner.png&#34; alt=&#34;单节点成员变更&#34; title=&#34;单节点成员变更&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以：&lt;code&gt;Voters&lt;/code&gt;两个配置，与两种&lt;code&gt;Learner&lt;/code&gt;集合，必须满足以下的关系（见函数&lt;code&gt;checkInvariants&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;LearnersNext&lt;/code&gt;中的节点，表示未提交的集群配置中待添加&lt;code&gt;learner&lt;/code&gt;节点集合的节点：
&lt;ul&gt;
&lt;li&gt;必须出现在&lt;code&gt;outgoing&lt;/code&gt;中，即必须出现在旧的集群配置中。&lt;/li&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;为False。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Learners&lt;/code&gt;中的节点，表示当前集群的&lt;code&gt;learner&lt;/code&gt;节点集合：
&lt;ul&gt;
&lt;li&gt;不能出现在任一个&lt;code&gt;voter&lt;/code&gt;集合中（&lt;code&gt;incoming&lt;/code&gt;和&lt;code&gt;outgoing&lt;/code&gt;）中，即不能出现在新、旧的集群配置中。&lt;/li&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;为True。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集群整体监控progresstracker结构体&#34;&gt;集群整体监控（ProgressTracker结构体）&lt;/h3&gt;
&lt;p&gt;有了节点的进度数据（Progress结构体），以及集群配置数据（Config结构体），整个集群的进度管控，都放在了结构体&lt;code&gt;ProgressTracker&lt;/code&gt;中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Config：存储当前集群的配置。&lt;/li&gt;
&lt;li&gt;Progress：以节点ID为键，值为&lt;code&gt;Progress结构体&lt;/code&gt;的map。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;负责提交配置流程changer结构体&#34;&gt;负责提交配置流程（Changer结构体）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Changer&lt;/code&gt;属于提交流程中存储中间状态的数据结构，对其输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前的&lt;code&gt;ProgressTracker结构体&lt;/code&gt;数据，即当前的配置和进度数据。&lt;/li&gt;
&lt;li&gt;要进行的变更数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要提交的配置数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Raft最终以其输入的配置数据，来生成&lt;code&gt;集群配置类型&lt;/code&gt;的日志，走正常的日志提交流程。提交成功之后，配置生效。&lt;/p&gt;
&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;
&lt;p&gt;按照前面原理部分的分析，&lt;code&gt;多节点联合共识&lt;/code&gt;的提交分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先提交新旧集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再提交新节点集合&lt;code&gt;C_new&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际在etcd中，也是这样做的，分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EnterJoint：将新旧集合的交集提交。&lt;/li&gt;
&lt;li&gt;LeaveJoint：提交新节点集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;enterjoint&#34;&gt;EnterJoint&lt;/h3&gt;
&lt;p&gt;该流程在&lt;code&gt;Changer::EnterJoint&lt;/code&gt;中实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拷贝当前&lt;code&gt;ProgressTracker&lt;/code&gt;结构体当前的进度（&lt;code&gt;Progress&lt;/code&gt;）和配置数据（&lt;code&gt;Config&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;如果当前有在提交的配置，就返回退出，因为同一时间只能有一个未提交的配置变更。如何判断当前是否有未提交的配置？看&lt;code&gt;Config&lt;/code&gt;中的&lt;code&gt;outgoing&lt;/code&gt;（即&lt;code&gt;voters[1]&lt;/code&gt;）是否为空。我们下面再详细解释。&lt;/li&gt;
&lt;li&gt;下面，以第一步拷贝的配置数据，生成新的配置数据：
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;Config&lt;/code&gt;中的&lt;code&gt;incoming&lt;/code&gt;数据拷贝到&lt;code&gt;outgoing&lt;/code&gt;中，即先保存当前的配置到&lt;code&gt;outgoing&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历需要修改的配置，根据不同的操作类型做操作，生成新的配置：
&lt;ul&gt;
&lt;li&gt;如果要删除某节点，调用&lt;code&gt;Changer::remove&lt;/code&gt;函数：
&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;incoming&lt;/code&gt;中删除该节点。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Learner&lt;/code&gt;以及&lt;code&gt;LearnerNext&lt;/code&gt;集合中删除该节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果增加&lt;code&gt;voter&lt;/code&gt;，调用&lt;code&gt;Changer::makeVoter&lt;/code&gt;函数：
&lt;ul&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;变为&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Learner&lt;/code&gt;以及&lt;code&gt;LearnerNext&lt;/code&gt;集合中删除该节点。&lt;/li&gt;
&lt;li&gt;将节点ID加入&lt;code&gt;incoming&lt;/code&gt;集合中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果增加&lt;code&gt;learner&lt;/code&gt;，调用&lt;code&gt;Changer::makeLearner&lt;/code&gt;函数：
&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;Changer::remove&lt;/code&gt;函数先删除该节点。&lt;/li&gt;
&lt;li&gt;判断是否在&lt;code&gt;outgoing&lt;/code&gt;配置中有该节点，表示该节点是降级节点：
&lt;ul&gt;
&lt;li&gt;有：表示在新配置下变成了&lt;code&gt;learner&lt;/code&gt;，但是此时并不能直接变成&lt;code&gt;learner&lt;/code&gt;，所以这种情况下该节点加入到了配置的&lt;code&gt;LearnersNext&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;否则，说明是新增节点，直接加入到&lt;code&gt;Learner&lt;/code&gt;集合中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上面生成了新旧配置的交集配置，以这个配置数据生成日志来进行提交，生效后应用该配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;leavejoint&#34;&gt;LeaveJoint&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;拷贝当前&lt;code&gt;ProgressTracker&lt;/code&gt;结构体当前的进度（&lt;code&gt;Progress&lt;/code&gt;）和配置数据（&lt;code&gt;Config&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;下面，以第一步拷贝的配置数据，生成新的配置数据：
&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;LearnersNext&lt;/code&gt;集合，将其中的节点：
&lt;ul&gt;
&lt;li&gt;加入&lt;code&gt;Learner&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsLearner&lt;/code&gt;置为true。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;清空&lt;code&gt;LearnerNext&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;遍历&lt;code&gt;outgoing&lt;/code&gt;节点集合：
&lt;ul&gt;
&lt;li&gt;如果一个节点，既不在&lt;code&gt;incoming&lt;/code&gt;集合中，也不在&lt;code&gt;Learner&lt;/code&gt;集合中，则认为在新的配置中没有该节点了，删除其进度数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;清空&lt;code&gt;outgoing&lt;/code&gt;节点集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上面生成了新旧配置的交集配置，以这个配置数据生成日志来进行提交，生效后应用该配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;p&gt;以一个例子来说明上面的流程，假设集群当前的配置为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投票节点：{1,2}。&lt;/li&gt;
&lt;li&gt;Learner节点：{}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新提交的配置中有以下三个操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增投票节点：{3}。&lt;/li&gt;
&lt;li&gt;降级节点{2}为&lt;code&gt;learner&lt;/code&gt;节点。&lt;/li&gt;
&lt;li&gt;新增Learner节点：{4}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要再次强调：&lt;strong&gt;无论是&lt;code&gt;EnterJoint&lt;/code&gt;还是&lt;code&gt;LeaveJoint&lt;/code&gt;操作，都并不会让配置马上生效，而是生成了一份待提交的配置，Raft拿到这份配置生成一个提交配置变更的日志，走正常的日志提交流程，待这条日志被半数通过时，才生效该配置。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;incoming节点集合&lt;/th&gt;
&lt;th&gt;outgoing节点集合&lt;/th&gt;
&lt;th&gt;Learner节点集合&lt;/th&gt;
&lt;th&gt;LearnerNext节点集合&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;提交之前&lt;/td&gt;
&lt;td&gt;{1,2}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EnterJoint&lt;/td&gt;
&lt;td&gt;{1,3}&lt;/td&gt;
&lt;td&gt;{1,2}&lt;/td&gt;
&lt;td&gt;{4}&lt;/td&gt;
&lt;td&gt;{2}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LeaveJoint&lt;/td&gt;
&lt;td&gt;{1,3}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{2,4}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;读者可以对着上面的流程，以这个例子来理解一下。&lt;/p&gt;
&lt;h2 id=&#34;自动提交&#34;&gt;自动提交&lt;/h2&gt;
&lt;p&gt;这里还有一个细节，即&lt;code&gt;多节点联合共识&lt;/code&gt;是一个两阶段的提交流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnterJoint&lt;/code&gt;之后，&lt;code&gt;outgoing&lt;/code&gt;节点集合变为一个非空集合，这时候不再能提交新的配置，需要到&lt;code&gt;LeaveJoint&lt;/code&gt;之后，才会清空这个集合。&lt;/li&gt;
&lt;li&gt;在etcd中，&lt;code&gt;LeaveJoint&lt;/code&gt;操作，并不见得会自动执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否在&lt;code&gt;EnterJoint&lt;/code&gt;之后自动执行&lt;code&gt;LeaveJoint&lt;/code&gt;，取决于当前提交的&lt;code&gt;Config&lt;/code&gt;结构体中的&lt;code&gt;AutoLeave&lt;/code&gt;字段，它有两种可能，见&lt;code&gt;ConfChangeTransition&lt;/code&gt;枚举类型的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConfChangeTransitionAuto&lt;/code&gt;和&lt;code&gt;ConfChangeTransitionJointImplicit&lt;/code&gt;：如果是这两种情况，都会自动做转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfChangeTransitionJointExplicit&lt;/code&gt;：需要用户手动执行&lt;code&gt;LeaveJoint&lt;/code&gt;操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（见函数&lt;code&gt;ConfChangeV2::EnterJoint&lt;/code&gt;的实现。）&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《CONSENSUS: BRIDGING THEORY AND PRACTICE》chapter4”Cluster membership changes“&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://etcd.io/docs/v3.3/learning/learner/&#34;&gt;Learner | etcd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么Raft协议不能提交之前任期的日志？</title>
      <link>https://www.codedump.info/post/20211011-raft-propose-prev-term/</link>
      <pubDate>Mon, 11 Oct 2021 23:14:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211011-raft-propose-prev-term/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在Raft大论文中3.6.2中，有一个细节“不允许提交之前任期的日志”，之前看了几次都理解的不够准确，把这部分内容展开阐述一下。&lt;/p&gt;
&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;
&lt;p&gt;还是先从论文的图例开始解释，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211011-raft-propose-prev-term/propose-prev-term.png&#34; alt=&#34;论文截图&#34; title=&#34;论文截图&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要特别说明的是，图例中演示的是**“如果允许提交之前任期的日志，将导致什么问题”**，这是大前提，这个前提条件后面会反复强调。&lt;/p&gt;
&lt;p&gt;有了这个前提，下面展开图中的步骤讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(a) ：S1 是leader，将黄色的日志2同步到了S2，然后S1崩溃。&lt;/li&gt;
&lt;li&gt;(b) ：S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，将蓝色日志3存储到本地，然后崩溃了。&lt;/li&gt;
&lt;li&gt;(c)：S1重新启动，选举成功。注意在这时，&lt;strong&gt;如果允许“提交之前任期的日志”&lt;/strong&gt;，将首先开始同步过往任期的日志，即将S1上的本地黄色的日志2同步到了S3。这时黄色的节点2已经同步到了集群多数节点，然后S1写了一条新日志4，然后S1又崩溃了。&lt;/li&gt;
&lt;li&gt;接下来，就可能出现两种不同的情况：
&lt;ul&gt;
&lt;li&gt;（d1）：S5重新当选，&lt;strong&gt;如果允许“提交之前任期的日志”&lt;/strong&gt;，就开始同步往期日志，将本地的蓝色日志3同步到所有的节点。结果已经被同步到半数以上节点的黄色日志2被覆盖了。这说明，如果允许“提交之前任期的日志”，会可能出现即便已经同步到半数以上节点的日志被覆盖，这是不允许的。&lt;/li&gt;
&lt;li&gt;（d2）：反之，如果在崩溃之前，S1不去同步往期的日志，而是首先同步自己任期内的日志4到所有节点，就不会导致黄色日志2被覆盖。因为leader同步日志的流程中，会通过不断的向后重试的方式，将日志同步到其他所有follower，只要日志4被复制成功，在它之前的日志2就会被复制成功。（d2）是想说明：不能直接提交过往任期的日志，即便已经被多数通过，但是可以先同步一条自己任内的日志，如果这条日志通过，就能带着前面的日志一起通过，这是（c）和（d2）两个图的区别。图（c）中，S1先去提交过往任期的日志2，图（d2）中，S1先去提交自己任内的日志4。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次强调，这里图示想演示的是**“如果允许提交之前任期的日志，将导致什么问题”**。&lt;/p&gt;
&lt;p&gt;我们可以看到的是，如果允许这么做，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(c)中，S1恢复之后，又再次提交在任期2中的黄色日志2。但是，从后面可以看到，即便这个之前任期中的黄色日志2，提交到大部分节点，如果允许“提交之前任期的日志”，仍然存在被覆盖的可能性，因为：&lt;/li&gt;
&lt;li&gt;(d1)中，S5恢复之后，也会提交在自己本地上保存的之前任期3的蓝色日志，这会导致覆盖了前面已经到半数以上节点的黄色日志2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，“如果允许提交之前任期的日志”，即如同(c)和(d1)演示的那样：重新当选之后，马上提交自己本地保存的、之前任期的日志，就会&lt;strong&gt;可能导致即便已经同步到半数以上节点的日志，被覆盖的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而“已同步到半数以上节点的日志”，一定在新当选leader上（否则这个节点不可能成为新leader）且达成了一致可提交，即不允许被覆盖。&lt;/p&gt;
&lt;p&gt;这就是矛盾的地方，即允许“提交之前任期的日志”，最终导致了违反协议规则的情况。&lt;/p&gt;
&lt;p&gt;那么，如何确保新当选的leader节点，其本地的未提交日志被正确提交呢？图(d2)展示了正常的情况：即当选之后，不要首先提交本地已有的黄色日志2，而是首先提交一条新日志4，如果这条新日志被提交成功，那么按照Raft日志的匹配规则（log matching property）：日志4如果能提交，它前面的日志也提交了。&lt;/p&gt;
&lt;p&gt;可是，新的问题又出现了，如果在(d2)中，S1重新当选之后，客户端写入没有这条新的日志4，那么前面的日志2是不是永远无法提交了？为了解决这个问题，raft要求每个leader新当选之后，马上写入一条只有任期号和索引、而没有内容的所谓“no-op”日志，以这条日志来驱动在它之前的日志达成一致。&lt;/p&gt;
&lt;p&gt;这就是论文中这部分内容想要表达的。这部分内容之所以比较难理解，是因为经常忽略了这个图示展示的是错误的情况，允许“提交之前任期的日志”可能导致的问题。&lt;/p&gt;
&lt;h1 id=&#34;其他疑问&#34;&gt;其他疑问&lt;/h1&gt;
&lt;h2 id=&#34;c和d2-有什么区别&#34;&gt;(c)和(d2) 有什么区别？&lt;/h2&gt;
&lt;p&gt;看起来，(c)和(d2)一样，S1当选后都提交了日志1、2、4，那么两者的区别在哪里？&lt;/p&gt;
&lt;p&gt;虽然两个场景中，提交的日志都是一样的，但是日志达成一致的顺序并不一致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(c)：S1成为leader之后，先提交过往任期、本地的日志2，再提交日志4。这就是“提交之前任期日志”的情况。&lt;/li&gt;
&lt;li&gt;(d2)：S1成为leader之后，先提交本次任期的日志4，如果日志4能提交成功，那么它前面的日志2就能提交成功了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于(d2)的这个场景，有可能又存在着下一个疑问：&lt;/p&gt;
&lt;h2 id=&#34;如何理解d2中本任期的日志4提交成功那么它前面的日志2也能提交成功了&#34;&gt;如何理解(d2)中，“本任期的日志4提交成功，那么它前面的日志2也能提交成功了”？&lt;/h2&gt;
&lt;p&gt;这是由raft日志的&lt;code&gt;Log Matching Property&lt;/code&gt;决定的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If two entries in different logs have the same index and term, then they store the same command.
If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.&lt;/li&gt;
&lt;li&gt;If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一条性质，说明的是在不同节点上的已提交的日志，如果任期号、索引一样，那么它们的内容肯定一样。这是由leader节点的安全性和leader上的日志只能添加不能覆盖来保证的，这样leader就永远不会在同一个任期，创建两个相同索引的日志。&lt;/p&gt;
&lt;p&gt;第二条性质，说明的是在不同节点上的日志中，如果其中有同样的一条日志（即相同任期和索引）已经达成了一致，那么在这不同节点上在这条日志之前的所有日志都是一样的。&lt;/p&gt;
&lt;p&gt;第二条性质是由leader节点向follower节点上根据&lt;code&gt;AppendEntries&lt;/code&gt;消息同步日志上保证的。leader在&lt;code&gt;AppendEntries&lt;/code&gt;消息中会携带新的新添加entries之前日志的term和index，follower会判断在log中是否存在拥有此term和index的消息，如果没有就会拒绝。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader为每一个follower维护一个nextIndex，表示待发送的下一个日志的index。初始化为日志长度。&lt;/li&gt;
&lt;li&gt;leader在follower拒绝&lt;code&gt;AppendEntries&lt;/code&gt;之后会对nextIndex减一，然后继续重试AppendEntries直到两者一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，回到我们开始的问题，(d2)场景中，在添加本任期日志4的时候，会发现有一些节点上并不存在过往任期的日志2，这时候就会相应地计算不同节点的nextIndex索引，来驱动同步日志2到这些节点上。&lt;/p&gt;
&lt;p&gt;总而言之，根据日志的性质，只要本任期的日志4能达成一致，上一条日志2就能达成一致。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Etcd Raft库的日志存储</title>
      <link>https://www.codedump.info/post/20210628-etcd-wal/</link>
      <pubDate>Mon, 28 Jun 2021 17:01:53 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210628-etcd-wal/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;之前看etcd raft实现的时候，由于wal以及日志的落盘存储部分，没有放在raft模块中，对这部分没有扣的特别细致。而且，以前我的观点认为etcd raft把WAL这部分留给了上层的应用去实现，自身通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层落盘的数据，这个观点也有失偏颇，etcd只是没有把这部分代码放在raft模块中，属于代码组织的范畴问题，并不是需要应用层自己来实现。&lt;/p&gt;
&lt;p&gt;于是，决定专门写一篇文章把这部分内容给讲解一下，主要涉及以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志（包括快照）文件的格式。&lt;/li&gt;
&lt;li&gt;日志（包括快照）内容的落盘、恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;wal及快照文件格式&#34;&gt;WAL及快照文件格式&lt;/h1&gt;
&lt;p&gt;首先来讲解这两种文件的格式，了解了格式才能继续展开下面的讲述。&lt;/p&gt;
&lt;h2 id=&#34;wal文件格式&#34;&gt;WAL文件格式&lt;/h2&gt;
&lt;p&gt;wal文件的文件名格式为：seq-index.wal（见函数&lt;code&gt;walName&lt;/code&gt;）。其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;seq：序列号，从0开始递增。&lt;/li&gt;
&lt;li&gt;index：该wal文件存储的第一条日志数据的索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果将一个目录下的所有wal文件按照名称排序之后，给定一个日志索引，很快就能知道该索引的日志落在哪个wal文件之中的。&lt;/p&gt;
&lt;p&gt;WAL文件中每条记录的格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Record&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int64&lt;/span&gt; type  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint32&lt;/span&gt; crc  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt; data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;type：记录的类型，下面解释。&lt;/li&gt;
&lt;li&gt;crc：后面data部分数据的crc32校验值。&lt;/li&gt;
&lt;li&gt;data：数据部分，根据类型的不同有不同格式的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录数据的类型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下是WAL存放的数据类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 元数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	metadataType &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int64&lt;/span&gt; = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 日志数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	entryType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 状态数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	stateType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 校验初始值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	crcType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	snapshotType
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面展开解释。&lt;/p&gt;
&lt;h3 id=&#34;元数据&#34;&gt;元数据&lt;/h3&gt;
&lt;p&gt;元数据就是应用层自定义的数据，需要注意的是，一个服务中如果有多个wal文件，且这些文件中有多份元数据，那么这些元数据都必须一致，否则报错。&lt;/p&gt;
&lt;p&gt;对于etcd这个服务而言，存储的元数据就是节点ID以及集群ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	metadata &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; pbutil.&lt;span style=&#34;color:#00a000&#34;&gt;MustMarshal&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pb.Metadata{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			NodeID:    &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(member.ID),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			ClusterID: &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(cl.&lt;span style=&#34;color:#00a000&#34;&gt;ID&lt;/span&gt;()),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; w, err = wal.&lt;span style=&#34;color:#00a000&#34;&gt;Create&lt;/span&gt;(cfg.&lt;span style=&#34;color:#00a000&#34;&gt;WALDir&lt;/span&gt;(), metadata); err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		plog.&lt;span style=&#34;color:#00a000&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;create wal error: %v&amp;#34;&lt;/span&gt;, err)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;日志数据&#34;&gt;日志数据&lt;/h3&gt;
&lt;p&gt;日志数据的格式，就是&lt;code&gt;raft.proto&lt;/code&gt;中&lt;code&gt;Entry&lt;/code&gt;的格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Entry&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;     Term  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// must be 64-bit aligned for atomic operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;     Index &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// must be 64-bit aligned for atomic operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; EntryType  Type  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt;      Data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态数据&#34;&gt;状态数据&lt;/h3&gt;
&lt;p&gt;保存当前“硬状态（HardState）”的记录，HardState包括：当前任期号、当前给哪个节点ID投票、当前提交的最大日志索引。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;HardState&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; term   &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; vote   &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; commit &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;校验初始值&#34;&gt;校验初始值&lt;/h3&gt;
&lt;p&gt;校验数据这一块，挺有意思的，可以展开好好说一下。&lt;/p&gt;
&lt;p&gt;使用CRC算法来计算数据的校验值，除了需要原始数据之外，还需要一个校验初始值（即校验种子seed），在每个wal文件中，类型为&lt;code&gt;校验初始值&lt;/code&gt;的记录就用于存储这个值。其值和使用方式有以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个wal文件必须有&lt;code&gt;校验初始值&lt;/code&gt;类型的数据，后续所有写入该wal文件的记录，都使用该初始值来计算CRC校验值。&lt;/li&gt;
&lt;li&gt;第一个wal文件，即序列号为0的wal文件，其校验初始值为0（见wal.go的Create函数）。&lt;/li&gt;
&lt;li&gt;当生成下一个wal文件时，以上一个wal文件的最后一条日志数据的CRC校验码来做为该文件的校验初始值，这样就要求类型为&lt;code&gt;校验初始值&lt;/code&gt;的记录，必须存储在同一个wal文件中第一条日志数据的前面，否则计算出来该日志数据的crc校验码就不准。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-crc.png&#34; alt=&#34;wal文件的校验初始值&#34; title=&#34;wal文件的校验初始值&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，通过这个机制，将多个连续的wal文件“串联”了起来：使用上一个wal文件的最后一个日志数据的crc校验值，来做为下一个wal文件的校验初始值，可以有效的校验同一个项目中wal文件的正确性。&lt;/p&gt;
&lt;h3 id=&#34;快照数据&#34;&gt;快照数据&lt;/h3&gt;
&lt;p&gt;在wal文件中存储的快照数据类型的记录，其中仅存储了当前快照的索引和任期号，而快照的详细数据都放到快照数据文件中存储，下面讲到数据恢复时再展开讨论这部分内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; index &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt; term  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;快照文件格式&#34;&gt;快照文件格式&lt;/h2&gt;
&lt;p&gt;快照文件的文件名格式为：任期号-索引号.snap（见函数&lt;code&gt;Snapshotter::save&lt;/code&gt;）。每次来一个快照数据，都新建一个快照文件，文件中存储快照数据的格式为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint32&lt;/span&gt; crc  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt; data  &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即：只存储快照数据及其校验值，数据的具体格式由存储快照数据的使用方来解释。在etcd这个服务里，这份快照数据的格式就是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Snapshot&lt;/span&gt; {&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bytes&lt;/span&gt;            data     &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;optional&lt;/span&gt; SnapshotMetadata metadata &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; [(gogoproto.nullable) &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;false&lt;/span&gt;];&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;数据恢复流程&#34;&gt;数据恢复流程&lt;/h1&gt;
&lt;p&gt;日志、快照数据的落盘，都是为了重启时恢复数据，了解了上面wal以及快照文件的格式，可以来看看数据的恢复流程。&lt;/p&gt;
&lt;p&gt;其大体流程如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;到快照目录中取出最新的一份无错的快照文件，首先取出这个文件中存储的快照数据。（见函数&lt;code&gt;Snapshotter::Load&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;此时，从快照数据中可以反序列化出：快照数据、对应的任期号、索引号。&lt;/li&gt;
&lt;li&gt;根据第二步拿到的快照数据，到wal目录中拿到日志索引号在快照数据索引号之后的日志，遍历满足条件的记录进行数据恢复。（见函数&lt;code&gt;WAL::ReadAll&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面具体来看每种wal记录格式数据在进行数据恢复时的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志数据：由于还可能存在一小部分小于快照索引的日志，所以恢复时会忽略掉这部分数据。&lt;/li&gt;
&lt;li&gt;状态数据：每一条状态数据都会反序列化出来，以最后一条状态数据为准。&lt;/li&gt;
&lt;li&gt;元数据：前面提到过，同一个服务的元数据必须一致，所以这里会校验元数据前后是否一致，不一致将报错退出数据恢复流程。&lt;/li&gt;
&lt;li&gt;校验初始值数据：可以参见前面关于该类型数据的讲解。&lt;/li&gt;
&lt;li&gt;快照数据：下面详细解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举一个例子来描述前面根据快照文件和WAL文件恢复数据的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-snap.png&#34; alt=&#34;WAL与快照文件关系&#34; title=&#34;WAL与快照文件关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快照文件集合为&lt;code&gt;[1-50.snap,1-150.snap]&lt;/code&gt;，取最新的快照文件，即&lt;code&gt;1-150.snap&lt;/code&gt;，而&lt;code&gt;1-50.snap&lt;/code&gt;文件的数据为过期数据。&lt;/li&gt;
&lt;li&gt;由于快照文件中存储的日志索引到150，即在此之前的日志已经全部被压缩到了快照文件中，因此wal文件集合中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0-100.wal&lt;/code&gt;中的数据已经全部被压缩。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1-200.wal&lt;/code&gt;中的数据部分被压缩，恢复数据时要忽略日志索引小于150的日志数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3-300.wal&lt;/code&gt;中的数据都没有被压缩，恢复数据时要如实全部重放该文件的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面分析快照数据类型的时候，提到过这个类型的数据在wal文件中的记录，只会存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前快照时对应的任期号。&lt;/li&gt;
&lt;li&gt;当前快照时对应的索引号。&lt;/li&gt;
&lt;li&gt;而具体的快照数据内容存储在快照文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，当生成一份新的快照数据时，将会把这份快照数据相关的以上三部分内容存储到wal和快照文件中。&lt;/p&gt;
&lt;p&gt;所以当恢复数据的时候，此时已经反序列化出快照数据了，这时拿着快照数据读wal文件时，如果读到了快照类型的数据，就会去对比起任期号和索引号是否一致，不一致报错停止恢复流程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; snapshotType: &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;var&lt;/span&gt; snap walpb.Snapshot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			pbutil.&lt;span style=&#34;color:#00a000&#34;&gt;MustUnmarshal&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;snap, rec.Data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; snap.Index &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; w.start.Index { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 两者的索引相同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; snap.Term &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; w.start.Term { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 但是任期号不同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;					state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回ErrSnapshotMismatch错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, ErrSnapshotMismatch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存快照数据匹配的标志位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				match = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上，解释清楚了wal、快照文件的格式，以及数据恢复的流程。&lt;/p&gt;
&lt;p&gt;因为wal文件和快照文件的读写，都与磁盘读写相关，所以在etcd服务中，将这两个结构体，统一到&lt;code&gt;etcdserver/storage.go&lt;/code&gt;的&lt;code&gt;storage&lt;/code&gt;结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; storage &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wal.WAL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;snap.Snapshotter
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由&lt;code&gt;storage&lt;/code&gt;结构体统一对外提供wal、快照文件的读写接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; Storage &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Save function saves ents and state to the underlying stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Save MUST block until st and ents are on stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;Save&lt;/span&gt;(st raftpb.HardState, ents []raftpb.Entry) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// SaveSnap function saves snapshot to the underlying stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;SaveSnap&lt;/span&gt;(snap raftpb.Snapshot) &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// DBFilePath returns the file path of database snapshot saved with given
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// id.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;DBFilePath&lt;/span&gt;(id &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;) (&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Close closes the Storage and performs finalization.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00a000&#34;&gt;Close&lt;/span&gt;() &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面，解释一下写wal文件中需要注意的一些细节。&lt;/p&gt;
&lt;h1 id=&#34;写优化问题&#34;&gt;写优化问题&lt;/h1&gt;
&lt;h2 id=&#34;数据对齐&#34;&gt;数据对齐&lt;/h2&gt;
&lt;p&gt;每条写入wal的记录，都会将其大小向上8字节对齐，多出来的部分填零：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;encodeFrameSize&lt;/span&gt;(dataBytes &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;) (lenField &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;, padBytes &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	lenField = &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(dataBytes)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// force 8 byte alignment so length never gets a torn write
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	padBytes = (&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; (dataBytes &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;)) &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; padBytes &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		lenField &lt;span style=&#34;color:#666&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;0x80&lt;/span&gt;|padBytes) &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;56&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/record.png&#34; alt=&#34;WAL记录数据需8字节对齐&#34; title=&#34;WAL记录数据需8字节对齐&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;写缓冲区&#34;&gt;写缓冲区&lt;/h2&gt;
&lt;p&gt;另外，为了缓解写文件的IO负担，etcd做了一个写优化：落盘的数据首先写到一个内存缓冲区中，只有每次填满了一个page的数据才会进行落盘操作。&lt;/p&gt;
&lt;p&gt;etcd中定义了几个常量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const minSectorSize = 512&lt;/li&gt;
&lt;li&gt;const walPageBytes = 8 * minSectorSize&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中：&lt;code&gt;minSectorSize&lt;/code&gt;表示一个sector的大小，而&lt;code&gt;walPageBytes&lt;/code&gt;必须为&lt;code&gt;minSectorSize&lt;/code&gt;的整数倍。&lt;/p&gt;
&lt;p&gt;etcd中定义了一个&lt;code&gt;PageWriter&lt;/code&gt;结构体，用于实现写入日志的操作，内部定义了一个循环缓冲区，只有填满一个&lt;code&gt;walPageBytes&lt;/code&gt;大小的数据才会进行落盘。&lt;/p&gt;
&lt;p&gt;下图是写入数据落盘后循环缓冲区的变化的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/cyclic-buffer.png&#34; alt=&#34;写入数据落盘后循环缓冲区的变化&#34; title=&#34;写入数据落盘后循环缓冲区的变化&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;黄色方块表示一个page的空闲空间，绿色方块表示待写入数据，红色方块表示当前已经写入数据的缓冲区。&lt;/li&gt;
&lt;li&gt;刚开始，第一个page已经有部分数据写入，还剩余一部分空闲空间。因此，当写入数据时，只会把写入数据凑齐一个页面大小来落盘。&lt;/li&gt;
&lt;li&gt;落盘完毕之后，第一个page重新变成黄色，即空闲页面，而第二个页面存储了写入数据中没有落盘的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码流程见函数&lt;code&gt;PageWriter::Write&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从上面的写入落盘流程可以看到，一次写入的数据可能会有一部分落盘，一部分还在内存中，这样当系统发生宕机这部分数据就是被损坏（corruption）的数据。&lt;/p&gt;
&lt;p&gt;因此，etcd中还需要有办法来识别和恢复数据。&lt;/p&gt;
&lt;h2 id=&#34;识别部分写入partial-write数据&#34;&gt;识别部分写入（partial write）数据&lt;/h2&gt;
&lt;p&gt;函数&lt;code&gt;decoder::isTornEntry&lt;/code&gt;用于判断一条记录是否为部分写的损坏数据。&lt;/p&gt;
&lt;p&gt;其原理是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次新创建用于写入记录的wal文件，都会将剩余文件清零。&lt;/li&gt;
&lt;li&gt;读入记录的数据之后，将数据根据不大于每个chunk为&lt;code&gt;minSectorSize&lt;/code&gt;大小的方式，存入chunk数组中。&lt;/li&gt;
&lt;li&gt;遍历这些chunk，如果有一个chunk的数据全部是零，则认为这块数据是部分写入的损坏数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个地方要跟前面落盘流程来对照看：因为每次落盘都是以一个page为单位落盘，而page大小又是&lt;code&gt;minSectorSize&lt;/code&gt;的整数倍，因此以&lt;code&gt;minSectorSize&lt;/code&gt;为一个chunk的大小来判断是否损坏。&lt;/p&gt;
&lt;h2 id=&#34;修复wal文件流程&#34;&gt;修复wal文件流程&lt;/h2&gt;
&lt;p&gt;当进行数据恢复时，可能会出现前面的部分写导致数据损坏问题，etcd会进行如下的修复操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分写导致数据损坏都只会出现在最后一个wal文件，因此打开最后一个wal文件进行处理（见函数&lt;code&gt;openLast&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;出现部分写导致损坏的记录，解析过程中都会返回&lt;code&gt;ErrUnexpectedEOF&lt;/code&gt;错误，对于这样的文件：
&lt;ul&gt;
&lt;li&gt;将损坏的文件重命名为&lt;code&gt;原文件名.broken&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;记录下来最后一个无损记录的偏移量，将损坏之后的数据都截断（Truncate）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;只读和只写文件的区别&#34;&gt;只读和只写文件的区别&lt;/h2&gt;
&lt;p&gt;在etcd中，wal文件有两种并不能同时共存的模式：对于同一个wal文件而言，要么处于只读模式，要么处于append写模式，这两种模式不能同时存在。见&lt;code&gt;WAL&lt;/code&gt;结构体的注释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// WAL is a logical representation of the stable storage.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// WAL is either in read mode or append mode but not both.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// A newly created WAL is in append mode, and ready for appending records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// A just opened WAL is in read mode, and ready for reading records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// The WAL will be ready for appending after reading out all the previous records.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据上面可能使用缓冲区优化写操作可知，两种模式下在读记录时能容忍的错误级别也不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读模式：读模式下可能读到部分写的数据，所以可以容忍这种错误。&lt;/li&gt;
&lt;li&gt;写模式：写模式下，不能容忍读到部分写的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt; w.&lt;span style=&#34;color:#00a000&#34;&gt;tail&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// We do not have to read out all entries in read mode.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// The last record maybe a partial written one, so
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ErrunexpectedEOF might be returned.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在只读模式下，可能没有读完全部的记录。最后一条记录可能是只写了一部分，此时就会返回ErrunexpectedEOF错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.EOF &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.ErrUnexpectedEOF { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是EOF以及ErrunexpectedEOF错误的情况就返回错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;default&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 写模式下必须读完全部的记录
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// We must read all of the entries if WAL is opened in write mode.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; io.EOF { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是EOF错误，说明没有读完数据就报错了，这种情况也是返回错误
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			state.&lt;span style=&#34;color:#00a000&#34;&gt;Reset&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, state, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;数据落盘的全流程&#34;&gt;数据落盘的全流程&lt;/h1&gt;
&lt;p&gt;以上了解了wal、快照文件的格式，以及写入流程，这里把之前写的不够好的数据落盘流程重新梳理一下。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/#%E8%BE%93%E5%85%A5%E5%8F%8A%E8%BE%93%E5%87%BA&#34;&gt;etcd Raft库解析 - codedump的网络日志&lt;/a&gt;中，曾经指出etcd raft库是通过&lt;code&gt;Ready&lt;/code&gt;结构体，来通知应用层的当前的数据的，不清楚的话可以回看一下之前的内容。在这里，只解释该结构体中与数据落盘相关的几个成员的数据走向流程，即日志数据（成员&lt;code&gt;Entries&lt;/code&gt;）、快照数据（&lt;code&gt;Snapshot&lt;/code&gt;）、已提交日志（&lt;code&gt;CommittedEntries&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;日志数据-1&#34;&gt;日志数据&lt;/h2&gt;
&lt;p&gt;日志数据从客户端提交到落盘的走向是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由客户端提交给服务器（注：只有leader节点才能接收客户端提交的日志数据，其他节点需转发给leader）。&lt;/li&gt;
&lt;li&gt;服务器收到之后，首先调用&lt;code&gt;raftLog.append&lt;/code&gt;函数保存到&lt;code&gt;unstable_log&lt;/code&gt;中，此时日志还是在内存中的，并未落地。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;newReady&lt;/code&gt;函数构建&lt;code&gt;Ready&lt;/code&gt;结构体时，将上一步保存下来的日志数据保存到&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Entries&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;应用层收到&lt;code&gt;Ready&lt;/code&gt;结构体之后，调用wal的&lt;code&gt;WAL.Save&lt;/code&gt;接口保存日志数据。这一步做完之后，可以认为日志数据已经落盘了。&lt;/li&gt;
&lt;li&gt;由于数据已经落盘到WAL日志中，所以在应用层通过&lt;code&gt;Node.Advance&lt;/code&gt;接口回调通知raft库时，暂存在&lt;code&gt;unstable_log&lt;/code&gt;中的日志就可以通过函数&lt;code&gt;raftLog.stableTo&lt;/code&gt;删除了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/log-flow.png&#34; alt=&#34;日志数据从提交到落盘的走向&#34; title=&#34;日志数据从提交到落盘的走向&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;已提交日志&#34;&gt;已提交日志&lt;/h2&gt;
&lt;p&gt;raft日志中，需要保存两个日志索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;appliedIndex：通知到应用层目前为止最大的日志索引；&lt;/li&gt;
&lt;li&gt;commitIndex：当前已提交日志的最大索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，总有&lt;code&gt;appliedIndex &amp;lt;= commitIndex&lt;/code&gt;条件成立，即日志总是先被提交成功（即达成一致），才会通知给应用层。&lt;/p&gt;
&lt;p&gt;通知应用层已提交日志的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;raftLog.nextEnts()&lt;/code&gt;函数获得当前满足&lt;code&gt;appliedIndex &amp;lt;= commitIndex&lt;/code&gt;条件的日志，存入到&lt;code&gt;Ready.CommittedEntries&lt;/code&gt;通知应用层。&lt;/li&gt;
&lt;li&gt;应用层处理这部分已提交日志。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;raftLog.appliedTo()&lt;/code&gt;函数，这里会修改&lt;code&gt;appliedIndex = commitIndex&lt;/code&gt;，即所有日志都已通知应用层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/appliedIndex.png&#34; alt=&#34;通知应用层已提交日志流程&#34; title=&#34;通知应用层已提交日志流程&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;快照数据-1&#34;&gt;快照数据&lt;/h2&gt;
&lt;p&gt;快照数据由应用层生成，然后将生成的快照数据、当前appliedIndex、配置状态一起交给存储层，保存之后就可以把在该快照之前的数据给删除了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;raftNode) &lt;span style=&#34;color:#00a000&#34;&gt;maybeTriggerSnapshot&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 生成快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	data, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; rc.&lt;span style=&#34;color:#00a000&#34;&gt;getSnapshot&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 通知存储层快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.raftStorage.&lt;span style=&#34;color:#00a000&#34;&gt;CreateSnapshot&lt;/span&gt;(rc.appliedIndex, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;rc.confState, data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.&lt;span style=&#34;color:#00a000&#34;&gt;saveSnap&lt;/span&gt;(snap)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将快照之前的数据压缩
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	compactIndex &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;uint64&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	rc.raftStorage.&lt;span style=&#34;color:#00a000&#34;&gt;Compact&lt;/span&gt;(compactIndex)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 更新快照数据索引，以便下一次生成新的快照数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	rc.snapshotIndex = rc.appliedIndex
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;数据的修复&#34;&gt;数据的修复&lt;/h2&gt;
&lt;p&gt;从上面的分析中可以看到，日志数据是在客户端提交之后，就马上落盘到WAL文件中的，不会等到日志在集群中达成一致。&lt;/p&gt;
&lt;p&gt;这样会带来一个问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点A认为自己还是集群的leader节点，此时收到客户端日志之后，将数据落盘到WAL文件中。&lt;/li&gt;
&lt;li&gt;落盘之后，节点A将日志同步给集群的其它节点，但是发现自己已经不再是集群的leader节点了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这种情况下，显然第一步已经落盘的日志是无效的，需要进行修复，这时候是怎么操作的呢？&lt;/p&gt;
&lt;p&gt;etcd raft的做法是不回退日志，继续走正常的流程，用新的、正确的日志添加在错误的日志后面，这样回放数据的时候恢复数据。&lt;/p&gt;
&lt;p&gt;继续以上面的例子为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点A在认为自己是leader的情况下落盘日志到本地WAL中，落盘完毕之后同步给集群内其他节点。&lt;/li&gt;
&lt;li&gt;同步到集群其他节点的过程中，才发现节点A已经不是集群的leader，此时节点A降级为follower节点，并开始从正确的集群节点那里同步日志。&lt;/li&gt;
&lt;li&gt;同步日志的流程中，节点A将收到来自leader节点的正确日志，这些日志也将落盘到节点A的WAL中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二步中同步日志的流程可以参见 &lt;a href=&#34;https://www.codedump.info/post/20180921-raft/#%E6%96%B0leader%E4%B8%8Efollower%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE&#34;&gt;Raft算法原理 - codedump的网络日志&lt;/a&gt;，这里不再阐述。&lt;/p&gt;
&lt;p&gt;上面的流程之后，节点A的WAL中将存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认为自己是leader时已落盘的日志；&lt;/li&gt;
&lt;li&gt;集群leader纠正节点A同步过来的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，当重启恢复时，会一并将这些日志重放，应用层只要按顺序回放日志即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210628-etcd-wal/wal-failback.png&#34; alt=&#34;WAL日志的纠错机制&#34; title=&#34;WAL日志的纠错机制&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点认为自己是leader节点时，落盘到WAL文件中的日志是&lt;code&gt;[(1,10),(1,11)]&lt;/code&gt;，列表中的二元组数据中，第一个元素是任期号，第二个元素是日志索引号。&lt;/li&gt;
&lt;li&gt;在落盘日志之后，节点将数据广播到集群，才发现自己已经不是集群的leader节点，此时集群的leader节点发现从日志10开始，该节点的数据就是不对的，开始同步正确的日志给节点，于是把正确的日志&lt;code&gt;[(2,10),(2,11)]&lt;/code&gt;同步给了节点，这部分日志会添加到前面错误的日志之后。&lt;/li&gt;
&lt;li&gt;假设节点重启恢复，那么会依次重放前面这四条日志，其中前两条日志是错误的日志，但是由于有后面的两条正确日志，最终节点的状态还是会恢复正确状态。&lt;/li&gt;
&lt;li&gt;随着后面日志数据压缩成快照文件，冗余的错误日志的磁盘占用将被解决。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读者不妨在这里就着这个流程多思考一个问题：做为follower的节点，是什么时候将日志落盘到WAL文件中，是在收到leader节点同步过来的日志时，还是在leader节点通知某个日志已经在集群达成一致？为什么以及流程是怎样的？&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;etcd的wal模块，虽然并没有和raft模块放在一起，但并不是说这一部分就需要应用者来自己实现，这两部分其实是一起打包做为整个etcd raft算法库提供给使用者的。可以认为raft模块提供算法，wal和快照模块提供日志存储读写的接口。&lt;/li&gt;
&lt;li&gt;日志落盘部分，包括wal文件以及快照文件读写这两部分内容，etcd将这两部分统一到&lt;code&gt;Storage&lt;/code&gt;接口统一对外服务。&lt;/li&gt;
&lt;li&gt;raft算法是在收到客户端日志之后就理解落盘日志到wal文件中保存的，如果后面发现出错，就走正常的同步正确日志的流程，将正确的日志添加到后面，这样恢复时重放整个日志，最终节点达成一致的正确状态。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Etcd Raft库的工程化实现</title>
      <link>https://www.codedump.info/post/20210515-raft/</link>
      <pubDate>Sat, 15 May 2021 13:52:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210515-raft/</guid>
      
      <description>&lt;p&gt;最近回顾前几年写的Raft、etcd raft的实现文章，以及重新阅读Raft论文、etcd raft代码，发现之前有些理解不够准确、深刻，但是不打算在原文上做修正，于是写这篇补充的文章做一些另外角度的解释，以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在开始展开讨论前，先介绍这个Raft论文中的示意图，我认为能理解这幅图才能对一致性算法有个全貌的了解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/statemachine.jpeg&#34; alt=&#34;Etcd Raft与应用层的交互&#34; title=&#34;Etcd Raft与应用层的交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中分为两种进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server进程：server进程中运行着一致性算法模块、持久化保存的日志、以及按照日志提交的顺序来进行顺序操作的状态机。&lt;/li&gt;
&lt;li&gt;client进程：用于向server提交日志的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，两种进程都用叠加的矩形来表示，意指系统中这两类进程不止一个。&lt;/p&gt;
&lt;p&gt;一个日志要被正确的提交，图中划分了几步：&lt;/p&gt;
&lt;p&gt;1、client进程提交数据到server进程，server进程将收到的日志数据灌入一致性模块。&lt;/p&gt;
&lt;p&gt;2、一致性模块将日志写入本地WAL，然后同步给集群中其他server进程。&lt;/p&gt;
&lt;p&gt;3、多个节点对某条日志达成一致之后，将修改本地的提交日志索引（commit index）；落盘后的日志按照顺序灌入状态机，只要保证所有server进程上的日志顺序，那么最后状态机的状态肯定就是一致的了。&lt;/p&gt;
&lt;p&gt;4、灌入状态机之后，server进程可以应答客户端。&lt;/p&gt;
&lt;p&gt;所以，本质上，一个使用了一致性算法的库，划分了成了两个不同的模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性算法库，这里泛指Raft、Paxos、Zab等一致性协议。这类一致性算法库主要做如下的事情：
&lt;ul&gt;
&lt;li&gt;用户输入库中日志（log），由库根据各自的算法来检测日志的正确性，并且通知上层的应用层。
&lt;ul&gt;
&lt;li&gt;输入到库中的日志维护和管理，算法库中需要知道哪些日志提交、提交成功、以及上层的应用层已经applied过的。当发生错误的时候，某些日志还会进行回滚（rollback）操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;日志的网络收发，这部分属于可选功能。有一些库，比如braft把这个事情也揽过来自己做了，优点是使用者不需要关注这部分功能，缺点是braft和它自带的网络库brpc耦合的很紧密，不可能拆开来使用；另一些raft实现，比如这里重点提到etcd raft实现，并不自己完成网络数据收发的工作，而是通知应用层，由应用层自己实现。&lt;/li&gt;
&lt;li&gt;日志的持久化存储：这部分也属于可选功能。前面说过，一致性算法库中维护了未达成一致的日志缓冲区，达成一致的日志才通知应用层，因此在这里不同的算法库又有了分歧，braft也是自己完成了日志持久化的工作，etcd raft则是将这部分工作交给了应用层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用层：即工作在一致性算法之上的库使用者，这个就比上图中的“状态机”：只有达成一致并且落盘的数据才灌入应用层，只要保证灌入应用层的日志顺序一致那么最后的状态就是一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来看，一个一致性算法库有以下必选和可选功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入日志进行处理的算法（必选）。&lt;/li&gt;
&lt;li&gt;日志的维护和管理（必选）。&lt;/li&gt;
&lt;li&gt;日志（包括快照）数据的网络收发（可选）。&lt;/li&gt;
&lt;li&gt;日志（包括快照）的持久化存储（可选）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要特别说明的是，即便是后面两个工作是可选的，但是可选还是必选的区别在于，这部分工作是一致性算法库自己完成，还是由算法库通知给上面的应用层去完成，并不代表这部分工作可以完全不做。&lt;/p&gt;
&lt;p&gt;在下表中列列举了etcd raft和braft在这几个特性之间的区别：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;etcd raft&lt;/th&gt;
&lt;th&gt;braft&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;raft一致性算法&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志的维护和管理&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志数据的网络收发&lt;/td&gt;
&lt;td&gt;交由应用层&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日志数据的持久化存储&lt;/td&gt;
&lt;td&gt;交由应用层&lt;/td&gt;
&lt;td&gt;自己实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优缺点&lt;/td&gt;
&lt;td&gt;松耦合，易于验证、测试；需要应用者做更多的事情&lt;/td&gt;
&lt;td&gt;与其rpc库紧耦合，难拆分；应用层做的事情不多，易于用来做服务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;两种实现各有自己的优缺点，braft类实现更适合提供一个需要集成raft的服务时，可以直接用来实现服务；etcd raft类的实现，由于与网络、存储层耦合不紧密，易于进行测试，更适合拿来做为库使用。&lt;/p&gt;
&lt;p&gt;如果把前面的一致性算法的几个特性做一个抽象，我认为一致性算法库本质上就是一个“维护操作日志的算法库，只要大家都按照相同的顺序将日志灌入应用层”就好，其工作原理大体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/co-algo.png&#34; alt=&#34;一致性算法的本质&#34; title=&#34;一致性算法的本质&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果把问题抽象成这样的话，那么本质上，所谓的“一致性算法库”跟一个经常看到的tcp、kcp甚至是一个应用层的协议栈也就没有什么区别了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大家都要维护一个数据区：只有确认过正确的，才会抛给上一层。以TCP协议算法来说，比如发送但未确认的数据由协议栈的缓冲区维护，如果超时还未等到对端的确认，将发起超时重传等，这些都是每种协议算法的具体细节，但是本质上这些协议都要维护一个未确认数据的缓冲区。一致性算法在数据的维护上会更复杂一些，一是参与确认的节点不止通信的C/S两端，需要集群中半数以上节点的确认；同时，在未确认之前日志需要首先落盘，在提交成功之后再抛给应用层。&lt;/li&gt;
&lt;li&gt;只要保证所有参与的节点，都以相同的数据灌入日志给应用层，那么得到的结果将最终一致。&lt;/li&gt;
&lt;li&gt;确认的流程是可以pipeline异步化的，提交日志的进程并不需要一直等待日志被提交成功，而是提交之后等待。不妨以下面的流程来做解释：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/pipeline.png&#34; alt=&#34;流水线异步化的日志提交流程&#34; title=&#34;流水线异步化的日志提交流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientA和clientB分别提交了两条日志数据，但是并没有阻塞等待日志提交成功，而是提交之后就继续别的操作了。&lt;/li&gt;
&lt;li&gt;server将两条日志数据同步出去，达成一致之后再分别通知两个client日志提交成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，client上通知日志提交成功的机制可以有很多，以etcd来说，会给每个提交的日志对应一个channel，提交成功之后会通过这个channel进行通知，也会给这个日志加一个定时器，超过时间仍未收到通知则认为提交失败。&lt;/p&gt;
&lt;h1 id=&#34;etcd-raft的实现&#34;&gt;etcd raft的实现&lt;/h1&gt;
&lt;p&gt;有了上面对一致性算法库的大体了解，下面可以详细看看etcd raft的实现了。&lt;/p&gt;
&lt;h2 id=&#34;概述-1&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;前面提到过，etcd raft库的实现中，并不自己实现网络数据收发、提交成功的数据持久化等工作，这些工作留给了应用层来自己实现，所以需要一个机制来通知应用层。etcd raft中将需要通知给应用层的数据封装在&lt;code&gt;Ready&lt;/code&gt;结构体中，其中包括如下的成员：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员名称&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于读一致性的数据，后续会详细介绍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在向其他集群发送消息之前需要先写入持久化存储的日志数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;pb.Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要写入持久化存储中的快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CommittedEntries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Messages&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要发送出去的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有了数据，还需要raft线程与上面的应用层线程交互的机制，这部分封装在&lt;code&gt;node&lt;/code&gt;结构体中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node&lt;/code&gt;结构体实现&lt;code&gt;Node&lt;/code&gt;接口，该接口用于表示Raft集群中的一个节点。在&lt;code&gt;node&lt;/code&gt;结构体中，实现了以下几个核心的channel，由于与外界进行通信：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;propc chan pb.Message：用于本地提交日志数据的channel。&lt;/li&gt;
&lt;li&gt;recvc chan pb.Message：用于接收来自集群中其他节点日志数据的channel。&lt;/li&gt;
&lt;li&gt;readyc chan Ready：用于本地Raft库通知应用层哪些数据已经准备好了，因此应用层需要关注readyc这个channel才能获得从Raft线程中提交的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去掉一些不太重要的接口，&lt;code&gt;Node&lt;/code&gt;接口中有如下的核心函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tick()：应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等，至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了。&lt;/li&gt;
&lt;li&gt;Propose(ctx context.Context, data []byte) error：提议写入数据到日志中，可能会返回错误。&lt;/li&gt;
&lt;li&gt;Step(ctx context.Context, msg pb.Message) error：将消息msg灌入状态机。&lt;/li&gt;
&lt;li&gt;Ready() &amp;lt;-chan Ready：返回通知&lt;code&gt;Ready&lt;/code&gt;结构体变更的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作。&lt;/li&gt;
&lt;li&gt;Advance()：Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;node&lt;/code&gt;结构体的实现中，无论是通过&lt;code&gt;Propose&lt;/code&gt;函数还是&lt;code&gt;Step&lt;/code&gt;函数提交到Raft算法库的消息，最终都是调用内部的&lt;code&gt;step&lt;/code&gt;函数的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/etcd-raft.png&#34; alt=&#34;Etcd Raft与应用层的交互&#34; title=&#34;Etcd Raft与应用层的交互&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上图来说明应用层与raft之间的交互流程，注意：etcd的实现中，raft是一个独立的线程，与应用层之间通过上面介绍的几个channel进行交互。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先看最中间的部分，本地提交的数据通过&lt;code&gt;propc&lt;/code&gt;channel通知raft线程，而应用层从外部网络接收到的日志数据通过&lt;code&gt;recvc&lt;/code&gt;通知raft线程。但是不管是哪个channel，最终都是通过上面提到的&lt;code&gt;step&lt;/code&gt;函数将日志数据灌入raft线程中。&lt;/li&gt;
&lt;li&gt;最右边是raft线程通知应用线程有哪些日志数据已经确认提交完毕等（&lt;code&gt;Ready&lt;/code&gt;结构体中不限于确认提交数据，该类型数据在上面已经列举出来），应用层可以通过&lt;code&gt;Ready&lt;/code&gt;数据来持久化数据等操作。&lt;/li&gt;
&lt;li&gt;最左边表示应用层线程要通过&lt;code&gt;Advance&lt;/code&gt;函数通知raft线程自己已经持久化了某些数据，这时候可以推动raft线程库中的日志缓冲区的变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一个简单的消息流程来继续解释上面的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层收到索引为N的消息，此时通过&lt;code&gt;recvc&lt;/code&gt;channel提交给Raft线程。&lt;/li&gt;
&lt;li&gt;Raft线程验证消息是正确的，于是需要广播给集群中的其他节点，此时会：
&lt;ul&gt;
&lt;li&gt;首先在Raft的日志缓冲区中保存下来这个消息，因为这个日志还未提交成功。&lt;/li&gt;
&lt;li&gt;将日志消息放入&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Messages&lt;/code&gt;成员中，通知应用层，这样应用层就将该成员中的消息转发给集群中的其他节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Raft线程继续获得从应用层下发下来的消息，当发现下发的消息中，索引为N的消息已经被集群中半数以上的节点确认过，此时就可以认为该消息能被持久化了，将日志消息放入&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;CommittedEntries&lt;/code&gt;成员中，以通知应用层该消息可以被持久化了。&lt;/li&gt;
&lt;li&gt;每次应用层持久化了某些消息之后，都会通过&lt;code&gt;Advance&lt;/code&gt;函数通知Raft线程，这样Raft线程可以将这部分已经被持久化的消息从消息缓冲区中删除，因为前面提到过消息缓冲区仅仅是用来保存还未持久化的消息的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个工作流程是pipeline化，即应用层某一次提交了索引为N的消息，并不需要一直等待该消息提交成功，而是可以返回继续做别的事情，当raft线程判断消息可以被提交时，再通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层。&lt;/p&gt;
&lt;p&gt;以上大体描述了etcd中，应用层线程与raft线程的交互流程，下面详细看看raft线程的实现。&lt;/p&gt;
&lt;h2 id=&#34;raft算法&#34;&gt;Raft算法&lt;/h2&gt;
&lt;p&gt;raft算法中，有不同的角色存在：candidate、follower、leader，本质上Raft算法是输入日志数据进行处理，而每种角色对不同类型的日志数据需要有不同的处理。&lt;/p&gt;
&lt;p&gt;所以，etcd raft的实现中，针对三种不同的角色，通过修改函数指针的方式在切换了不同角色时的处理，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/role-algo.png&#34; alt=&#34;不同角色的Raft算法处理&#34; title=&#34;不同角色的Raft算法处理&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的算法细节，不打算在本文中展开，可以回头上上面给出来的几篇文章。&lt;/p&gt;
&lt;h2 id=&#34;数据管理&#34;&gt;数据管理&lt;/h2&gt;
&lt;p&gt;数据管理分为以下几部分阐述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未持久化数据缓冲区&lt;/li&gt;
&lt;li&gt;持久化数据内存映像&lt;/li&gt;
&lt;li&gt;数据的持久化&lt;/li&gt;
&lt;li&gt;数据流动的全流程&lt;/li&gt;
&lt;li&gt;节点进度的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面一一展开。&lt;/p&gt;
&lt;h3 id=&#34;未持久化数据缓冲区&#34;&gt;未持久化数据缓冲区&lt;/h3&gt;
&lt;p&gt;前面提到过，Raft算法中还必须要做的是维护未确认数据的缓冲区数据，每当其中的一部分数据被确认，缓冲区的窗口随之发生移动，这就类似TCP协议算法中的滑动窗口。&lt;/p&gt;
&lt;p&gt;etcd raft中，管理未确认数据放在了&lt;code&gt;unstable&lt;/code&gt;结构体（log_unstable.go）中，其内部维护三个成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;snapshot *pb.Snapshot：保存还没有持久化的快照数据&lt;/li&gt;
&lt;li&gt;entries []pb.Entry：保存还未持久化的日志数据。&lt;/li&gt;
&lt;li&gt;offset uint64：保存快照和日志数组的分界线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，未持久化数据分为两部分：一部分是快照数据snapshot，另一部分就是日志数据数组。两者不会同时存在，快照数据只会在启动时进行快照数据恢复时存在，当应用层使用快照数据进行恢复之后，raft切换为可以接收日志数据的状态，后续的日志数据都会写到&lt;code&gt;entrise&lt;/code&gt;数组中了，而两者的分界线就是&lt;code&gt;offset&lt;/code&gt;变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/unstable.png&#34; alt=&#34;未持久化数据&#34; title=&#34;未持久化数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于是”未持久化数据的缓冲区“，因此这其中的数据可能会发生回滚（rollback）现象，因此&lt;code&gt;unstable&lt;/code&gt;结构体需要支持能回滚的操作，见函数&lt;code&gt;truncateAndAppend&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (u *unstable) truncateAndAppend(ents []pb.Entry) {
	// 先拿到这些数据的第一个索引
	after := ents[0].Index
	switch {
	case after == u.offset+uint64(len(u.entries)):
		// 如果正好是紧接着当前数据的，就直接append
		// after is the next index in the u.entries
		// directly append
		u.entries = append(u.entries, ents...)
	case after &amp;lt;= u.offset:
		u.logger.Infof(&amp;#34;replace the unstable entries from index %d&amp;#34;, after)
		// The log is being truncated to before our current offset
		// portion, so set the offset and replace the entries
		// 如果比当前偏移量小，那用新的数据替换当前数据，需要同时更改offset和entries
		u.offset = after
		u.entries = ents
	default:
		// truncate to after and copy to u.entries
		// then append
		// 到了这里，说明 u.offset &amp;lt; after &amp;lt; u.offset+uint64(len(u.entries))
		// 那么新的entries需要拼接而成
		u.logger.Infof(&amp;#34;truncate the unstable entries before index %d&amp;#34;, after)
		u.entries = append([]pb.Entry{}, u.slice(u.offset, after)...)
		u.entries = append(u.entries, ents...)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数中分为三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果传入的日志数据，刚好跟当前数据紧挨着（after == u.offset+uint64(len(u.entries))），就可以直接进行append操作。&lt;/li&gt;
&lt;li&gt;如果传入的日志数据的第一条数据索引不大于当前的offset（after &amp;lt;= u.offset），说明数据发生了回滚，直接用新的数据替换旧的数据。&lt;/li&gt;
&lt;li&gt;其他情况，说明u.offset &amp;lt; after &amp;lt; u.offset+uint64(len(u.entries))，这是新的未持久化数据由这两部分数据各取其中一部分数据拼装而成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;持久化数据内存映像&#34;&gt;持久化数据内存映像&lt;/h3&gt;
&lt;p&gt;但是，仅仅有未持久化数据还不够，有时候有一些数据已经落盘，但是还需要进行查询、读取等操作。于是，etcd raft又提供了一个&lt;code&gt;Storage&lt;/code&gt;接口，该接口有面对不同的组件有不同的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于Raft库，该接口仅仅只有读操作。（如下图中的黄色函数）&lt;/li&gt;
&lt;li&gt;对于etcd 服务来说，还提供了写操作，包括：增加日志数据、生成快照、压缩数据。（如下图中的蓝色函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，这个接口及其默认实现&lt;code&gt;MemoryStorage&lt;/code&gt;，呈现了稍微不太一样的行为，以致于我最开始没有完全理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/stable.png&#34; alt=&#34;持久化数据的内存映像&#34; title=&#34;持久化数据的内存映像&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为持久化数据的内存映像，提供给Raft库的仅仅只需要读操作，所以&lt;code&gt;Storage&lt;/code&gt;接口就只有读操作，多出来的写操作只会在应用层中才会用到，因此这些写接口并没有放在公用的接口中。&lt;/p&gt;
&lt;p&gt;了解了持久化和未持久化数据的表示之后，etcd raft库将两者统一到&lt;code&gt;raftLog&lt;/code&gt;这个结构体中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/raftlog.png&#34; alt=&#34;不同视角下的raftlog&#34; title=&#34;不同视角下的raftlog&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据的持久化&#34;&gt;数据的持久化&lt;/h3&gt;
&lt;p&gt;以上解释两种缓冲区的作用，数据最终还是需要持久化到磁盘上的，那么，这个持久化数据的时机在哪里？&lt;/p&gt;
&lt;p&gt;答案：当客户端提交数据时，etcd Raft库就通过&lt;code&gt;Ready&lt;/code&gt;结构体的&lt;code&gt;Entries&lt;/code&gt;成员通知应用层，将这些提交的数据进行持久化了。&lt;/p&gt;
&lt;p&gt;有代码为证。&lt;/p&gt;
&lt;p&gt;首先来看&lt;code&gt;raft&lt;/code&gt;中如何生成&lt;code&gt;Ready&lt;/code&gt;数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
	rd := Ready{
		// entries保存的是没有持久化的数据数组
		Entries:          r.raftLog.unstableEntries(),
		// 保存committed但是还没有applied的数据数组
		CommittedEntries: r.raftLog.nextEnts(),
		// 保存待发送的消息
		Messages:         r.msgs,
	}
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，&lt;code&gt;raft&lt;/code&gt;库中将未持久化数据塞到了&lt;code&gt;Entries&lt;/code&gt;数组中，而已经达成一致可以提交的日志数据放入到&lt;code&gt;CommittedEntries&lt;/code&gt;数组中。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;etcd&lt;/code&gt;代码中自带的&lt;code&gt;raftexample&lt;/code&gt;目录中的例子代码来看应用层在收到&lt;code&gt;Ready&lt;/code&gt;数据后的做法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (rc *raftNode) serveChannels() {
		case rd := &amp;lt;-rc.node.Ready():
			// 将HardState，entries写入持久化存储中
			rc.wal.Save(rd.HardState, rd.Entries)
			if !raft.IsEmptySnap(rd.Snapshot) {
				// 如果快照数据不为空，也需要保存快照数据到持久化存储中
				rc.saveSnap(rd.Snapshot)
				rc.raftStorage.ApplySnapshot(rd.Snapshot)
				rc.publishSnapshot(rd.Snapshot)
			}
			rc.raftStorage.Append(rd.Entries)
			rc.transport.Send(rd.Messages)
			if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
				rc.stop()
				return
			}
			rc.maybeTriggerSnapshot()
			rc.node.Advance()
	// ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rc.wal.Save(rd.HardState, rd.Entries)：将客户端提交数据的数据写入wal中。&lt;/li&gt;
&lt;li&gt;rc.raftStorage.Append(rd.Entries)：这里的&lt;code&gt;raftStorage&lt;/code&gt;即前面提到的持久化数据缓冲区的&lt;code&gt;Storage&lt;/code&gt;接口，由&lt;code&gt;MemoryStorage&lt;/code&gt;接口实现，这一步将这些客户端提交的数据也写入持久化缓冲区的内部映像。&lt;/li&gt;
&lt;li&gt;rc.publishEntries(rc.entriesToApply(rd.CommittedEntries))：这个调用分为两步，第一步调用&lt;code&gt;entriesToApply&lt;/code&gt;是要从已达成一致的日志数据中过滤出真正可以进行apply的日志，因为里面的一些日志可能已经被应用层apply过，第二步将第一步过滤出来的日志数据通知给应用层。在&lt;code&gt;raftexample&lt;/code&gt;这个示例代码中，最终这些已经达成一致的数据，会被遍历生成KV内存数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有一个问题：客户端提交过来的数据，还未达成集群内半数节点的一致，这时候就去做落盘操作，如果提交过程中发现出了问题，实际这条数据并不能最终达成一致，那么已落盘的数据怎么办？&lt;/p&gt;
&lt;p&gt;在这里，&lt;code&gt;etcd&lt;/code&gt;落盘客户端提交的数据时，是写入到WAL文件中的，后面发生了错误，如leader变成了follower时，日志需要进行了回滚操作等，也还是将那些正确的日志继续添加到WAL日志后面，服务如果重启，就是把这些日志按照顺序重放（replay）一遍，这里不可避免的会有一些冗余的操作，但是随着快照文件的产生，这个问题已经不大了。&lt;/p&gt;
&lt;p&gt;其次，不论是前面提到的&lt;code&gt;未持久化数据缓冲区&lt;/code&gt;，还是&lt;code&gt;持久化数据缓冲区&lt;/code&gt;，在往缓冲区中添加日志的函数实现中，都会去判断日志是否发生了回滚，会将当前传入的日志按照正确的日志索引放到缓冲区合适的位置。&lt;code&gt;未持久化数据缓冲区&lt;/code&gt;这部分操作在函数&lt;code&gt;unstable.truncateAndAppend&lt;/code&gt;中，&lt;code&gt;持久化数据缓冲区&lt;/code&gt;这部分操作在函数&lt;code&gt;MemoryStorage.Append&lt;/code&gt;中，感兴趣的可以去看看具体的实现，在这里就不再展开了。&lt;/p&gt;
&lt;h3 id=&#34;数据流动的全流程&#34;&gt;数据流动的全流程&lt;/h3&gt;
&lt;p&gt;以上解释了客户端提交的数据在两个缓冲区、持久化存储、以及最终达成一致之后给应用层的过程，下面以例子分别来解释客户端提交数据的流程以及快照数据恢复的流程。&lt;/p&gt;
&lt;h4 id=&#34;客户端提交数据的流程&#34;&gt;客户端提交数据的流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/wal.png&#34; alt=&#34;客户端提交数据的流动&#34; title=&#34;客户端提交数据的流动&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、客户端提交数据给服务器。&lt;/p&gt;
&lt;p&gt;2、接着看这条数据走过的”存储“路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、首先，`raft`库会首先将日志数据写入`未持久化数据缓冲区`。

2、由于`未持久化数据缓冲区`中有新增的数据，会通过`Ready`结构体通知给应用层。

3、应用层收到`Ready`结构体之后，将其中的数据写入WAL持久化存储，然后更新这块数据到`已持久化数据缓冲区`。

4.1、持久化完毕后，应用层通过`Advance`接口通知`Raft`库这些数据已经持久化，于是raft库修改`未持久化数据缓冲区`将客户端刚提交的数据从这个缓冲区中删除。

4.2、持久化完毕之后，除了通知删除`未持久化数据缓冲区`，还讲数据通过网络同步给集群中其他节点。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、集群中半数节点对该提交数据达成了一致，可以应答给客户端了。&lt;/p&gt;
&lt;h4 id=&#34;启动时使用快照数据恢复流程&#34;&gt;启动时使用快照数据恢复流程&lt;/h4&gt;
&lt;p&gt;下面以例子来实际解释etcd raft中数据在未持久化缓存、wal日志、持久化数据内容映像中的流动：&lt;/p&gt;
&lt;p&gt;1、节点N启动，加入到集群中，此时发现N上面没有数据，于是集群中的leader节点会首先通过rpc消息将快照数据发送给节点N。&lt;/p&gt;
&lt;p&gt;2、节点N收到快照数据，首先会保存到未持久化数据缓存中。&lt;/p&gt;
&lt;p&gt;3、Raft通过&lt;code&gt;Ready&lt;/code&gt;结构体通知应用层有快照数据。&lt;/p&gt;
&lt;p&gt;4、应用层（也就是etcdserver）将快照数据写入wal持久化存储中，这一步可以理解为将快照数据落盘。&lt;/p&gt;
&lt;p&gt;5、落盘之后，调用&lt;code&gt;MemoryStorage&lt;/code&gt;结构体的&lt;code&gt;ApplySnapshot&lt;/code&gt;将快照数据保存到持久化数据内存映像中。&lt;/p&gt;
&lt;p&gt;6、（图中未给出）调用Raft库的&lt;code&gt;Advance&lt;/code&gt;接口通知raft库传递过来的&lt;code&gt;Ready&lt;/code&gt;结构体数据已经操作完毕，这时候对应的，raft库就会把第二步中保存到未持久化数据缓存的快照数据给删除了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/snapshot.png&#34; alt=&#34;快照数据的流动&#34; title=&#34;快照数据的流动&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上是快照数据的流动过程，在节点N接收并持久化快照数据后，后面就可以接收正常的日志了，日志数据的流动过程跟快照数据实际是差不多的，就不再阐述了。&lt;/p&gt;
&lt;p&gt;从上面的流程中也可以看出，应用层也就是etcdserver的持久化数据，只有wal日志而已，情况确实是这样的，其接口和实现如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Storage interface {
	// Save function saves ents and state to the underlying stable storage.
	// Save MUST block until st and ents are on stable storage.
	Save(st raftpb.HardState, ents []raftpb.Entry) error
	// SaveSnap function saves snapshot to the underlying stable storage.
	SaveSnap(snap raftpb.Snapshot) error
	// DBFilePath returns the file path of database snapshot saved with given
	// id.
	DBFilePath(id uint64) (string, error)
	// Close closes the Storage and performs finalization.
	Close() error
}

type storage struct {
	*wal.WAL
	*snap.Snapshotter
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Storage&lt;/code&gt;接口是etcdserver持久化数据的接口，其保存的数据有两个接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Save(st raftpb.HardState, ents []raftpb.Entry) error：保存日志数据。&lt;/li&gt;
&lt;li&gt;SaveSnap(snap raftpb.Snapshot) error：保存快照数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而&lt;code&gt;Storage&lt;/code&gt;接口由下面的&lt;code&gt;storage&lt;/code&gt;结构体来实现，其又分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wal：用于实现WAL日志的读写。&lt;/li&gt;
&lt;li&gt;snap：用于实现快照数据的读写。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里就不展开讨论了。&lt;/p&gt;
&lt;h3 id=&#34;节点进度的管理&#34;&gt;节点进度的管理&lt;/h3&gt;
&lt;p&gt;前面提到过，一致性算法与TCP之类的协议，本质上都需要管理未确认数据的缓冲区，但是不同的是，参与一致性算法确认的成员，不会像一般的点对点通信协议那样只有两个，在raft算法中，leader节点除了要维护未持久化缓冲区之外，还需要维护一个数据结构，用于保存集群中其他节点的进度，这部分数据在etcd raft中保存在结构体&lt;code&gt;Progress&lt;/code&gt;中，我将我之前阅读过程中加上的注释一并贴出来：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志
// Progress represents a follower’s progress in the view of the leader. Leader maintains
// progresses of all followers, and sends entries to the follower based on its progress.
type Progress struct {
	// Next保存的是下一次leader发送append消息时传送过来的日志索引
	// 当选举出新的leader时，首先初始化Next为该leader最后一条日志+1
	// 如果向该节点append日志失败，则递减Next回退日志，一直回退到索引匹配为止

	// Match保存在该节点上保存的日志的最大索引，初始化为0
	// 正常情况下，Next = Match + 1
	// 以下情况下不是上面这种情况：
	// 1. 切换到Probe状态时，如果上一个状态是Snapshot状态，即正在接收快照，那么Next = max(pr.Match+1, pendingSnapshot+1)
	// 2. 当该follower不在Replicate状态时，说明不是正常的接收副本状态。
	//    此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被
	//    leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现
	Match, Next uint64
	// State defines how the leader should interact with the follower.
	//
	// When in ProgressStateProbe, leader sends at most one replication message
	// per heartbeat interval. It also probes actual progress of the follower.
	//
	// When in ProgressStateReplicate, leader optimistically increases next
	// to the latest entry sent after sending replication message. This is
	// an optimized state for fast replicating log entries to the follower.
	//
	// When in ProgressStateSnapshot, leader should have sent out snapshot
	// before and stops sending any replication message.

	// ProgressStateProbe：在每次heartbeat消息间隔期最多发一条同步日志消息给该节点
	// ProgressStateReplicate：正常的接受副本数据状态。当处于该状态时，leader在发送副本消息之后，
	// 就修改该节点的next索引为发送消息的最大索引+1
	// ProgressStateSnapshot：接收副本状态
	State ProgressStateType
	// Paused is used in ProgressStateProbe.
	// When Paused is true, raft should pause sending replication message to this peer.
	// 在状态切换到Probe状态以后，该follower就标记为Paused，此时将暂停同步日志到该节点
	Paused bool

	// PendingSnapshot is used in ProgressStateSnapshot.
	// If there is a pending snapshot, the pendingSnapshot will be set to the
	// index of the snapshot. If pendingSnapshot is set, the replication process of
	// this Progress will be paused. raft will not resend snapshot until the pending one
	// is reported to be failed.
	// 如果向该节点发送快照消息，PendingSnapshot用于保存快照消息的索引
	// 当PendingSnapshot不为0时，该节点也被标记为暂停状态。
	// raft只有在这个正在进行中的快照同步失败以后，才会重传快照消息
	PendingSnapshot uint64

	// RecentActive is true if the progress is recently active. Receiving any messages
	// from the corresponding follower indicates the progress is active.
	// RecentActive can be reset to false after an election timeout.
	RecentActive bool

	// inflights is a sliding window for the inflight messages.
	// Each inflight message contains one or more log entries.
	// The max number of entries per message is defined in raft config as MaxSizePerMsg.
	// Thus inflight effectively limits both the number of inflight messages
	// and the bandwidth each Progress can use.
	// When inflights is full, no more message should be sent.
	// When a leader sends out a message, the index of the last
	// entry should be added to inflights. The index MUST be added
	// into inflights in order.
	// When a leader receives a reply, the previous inflights should
	// be freed by calling inflights.freeTo with the index of the last
	// received entry.
	// 用于实现滑动窗口，用来做流量控制
	ins *inflights
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结来说，&lt;code&gt;Progress&lt;/code&gt;结构体做的工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护follower节点的match、next索引，以便知道下一次从哪里开始同步数据。&lt;/li&gt;
&lt;li&gt;维护着follower节点当前的状态。&lt;/li&gt;
&lt;li&gt;同步快照数据的状态。&lt;/li&gt;
&lt;li&gt;流量控制，避免follower节点超载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的算法细节，就不在这里贴出了。&lt;/p&gt;
&lt;h2 id=&#34;网络数据的收发以及日志的持久化&#34;&gt;网络数据的收发以及日志的持久化&lt;/h2&gt;
&lt;p&gt;网络数据的收发以及日志的持久化，这两部分在etcd raft库中，并不是由raft库来实现，而是通过&lt;code&gt;Ready&lt;/code&gt;结构体来通知应用层，由应用层来完成。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;这里将上面的几部分总结如下，有了整体的理解才能更好的了解细节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20210515-raft/summary.png&#34; alt=&#34;Raft算法几要素在etcd raft中的实现&#34; title=&#34;Raft算法几要素在etcd raft中的实现&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Etcd存储的实现</title>
      <link>https://www.codedump.info/post/20181125-etcd-server/</link>
      <pubDate>Sun, 25 Nov 2018 15:13:28 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20181125-etcd-server/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd的raft实现是最接近论文本身的，结合论文原理一起阅读十分酸爽。这个系列文章的索引如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我个人还针对etcd 3.1.10版本的raft相关代码实现做了一些代码的注释笔记，地址在此：&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;etcd-3.1.10-codedump&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;概览&#34;&gt;概览&lt;/h1&gt;
&lt;p&gt;在前面已经分析了Raft算法原理、etcd raft库的实现，接着就可以看etcd如何使用raft实现存储服务的了。&lt;/p&gt;
&lt;p&gt;以下的分析主要针对etcd V3版本的实现。&lt;/p&gt;
&lt;p&gt;下图中展示了etcd如何处理一个客户端请求的涉及到的模块和流程。图中淡紫色的矩形表示etcd，它包括如下几个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etcd server：对外接收客户端的请求，对应etcd代码中的etcdserver目录，其中还有一个raft.go的模块与etcd-raft库进行通信。etcdserver中与存储相关的模块是applierV3，这里封装了V3版本的数据存储，WAL（write ahead log），用于写数据日志，etcd启动时会根据这部分内容进行恢复。&lt;/li&gt;
&lt;li&gt;etcd raft：etcd的raft库，前面的文章已经具体分析过这部分代码。除了与本节点的etcd server通信之外，还与集群中的其他etcd server进行交互做一致性数据同步的工作（在图中集群中其他etcd服务用橙色的椭圆表示）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-server.png&#34; alt=&#34;etcd server&#34; title=&#34;etcd server&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，一个请求与一个etcd集群交互的主要流程分为两大部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写数据到某个etcd server中。&lt;/li&gt;
&lt;li&gt;该etcd server与集群中的其他etcd节点进行交互，当确保数据已经被存储之后应答客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请求流程划分为了以下的子步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.1：etcd server收到客户端请求。&lt;/li&gt;
&lt;li&gt;1.2：etcd server将请求发送给本模块中的raft.go，这里负责与etcd raft模块进行通信。&lt;/li&gt;
&lt;li&gt;1.3：raft.go将数据封装成raft日志的形式提交给raft模块。&lt;/li&gt;
&lt;li&gt;1.4：raft模块会首先保存到raftLog的unstable存储部分。&lt;/li&gt;
&lt;li&gt;1.5：raft模块通过raft协议与集群中其他etcd节点进行交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意在以上流程中，假设这里写入数据的etcd是leader节点，因为在raft协议中，如果提交数据到非leader节点的话需要路由到etcd leader节点去。&lt;/p&gt;
&lt;p&gt;而应答步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.1：集群中其他节点向leader节点应答接收这条日志数据。&lt;/li&gt;
&lt;li&gt;2.2：当超过集群半数以上节点应答接收这条日志数据时，etcd raft通过Ready结构体通知etcd server中的raft该日志数据已经commit。&lt;/li&gt;
&lt;li&gt;2.3：raft.go收到Ready数据将首先将这条日志写入到WAL模块中。&lt;/li&gt;
&lt;li&gt;2.4：通知最上层的etcd server该日志已经commit。&lt;/li&gt;
&lt;li&gt;2.5：etcd server调用applierV3模块将日志写入持久化存储中。&lt;/li&gt;
&lt;li&gt;2.6：etcd server应答客户端该数据写入成功。&lt;/li&gt;
&lt;li&gt;2.7：最后etcd server调用etcd raft，修改其raftLog模块的数据，将这条日志写入到raftLog的storage中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的流程可以看到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etcd raft模块在应答某条日志数据已经commit之后，是首先写入到WAL模块中的，因为这个模块只是添加一条日志，所以速度会很快，即使在后面applierV3写入失败，重启的时候也可以根据WAL模块中的日志数据进行恢复。&lt;/li&gt;
&lt;li&gt;etcd raft中的raftLog，按照前面文章的分析，其中的数据是保存到内存中的，重启即失效，上层应用真实的数据是持久化保存到WAL和applierV3中的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下就来分析etcd server与这部分相关的几个模块。&lt;/p&gt;
&lt;h1 id=&#34;etcd-server与raft的交互&#34;&gt;etcd server与raft的交互&lt;/h1&gt;
&lt;p&gt;EtcdServer结构体，负责对外与客户端进行通信。内部有一个raftNode结构的成员，负责与etcd的raft库进行交互。&lt;/p&gt;
&lt;p&gt;etcd V3版本的API，通过GRPC协议与客户端进行交互，其相关代码在etcdserver/v3_server.go中。以一次Put请求为例，最后将会调用的代码在函数EtcdServer::processInternalRaftRequestOnce中，代码的主要流程分析如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-flowchart.png&#34; alt=&#34;etcd flowchart&#34; title=&#34;etcd flowchart&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拿到当前raft中的apply和commit索引，如果commit索引比apply索引超出太多，说明当前有很多数据都没有apply，返回ErrTooManyRequests错误。&lt;/li&gt;
&lt;li&gt;调用s.reqIDGen.Next()函数生成一个针对当前请求的ID，注意这个ID并不是一个随机数而是一个严格递增的整数。同时将请求序列化为byte数据，这会做为raft的数据进行存储。&lt;/li&gt;
&lt;li&gt;根据第2步中的ID，调用Wait.Register函数进行注册，这会返回一个用于通知结果的channel，后续就通过监听该channel来确定是否成功储存了提交的值。&lt;/li&gt;
&lt;li&gt;调用Raft.Process函数提交数据，这里传入的参数除了前面序列化的数据之外，还有使用超时时间创建的Context。&lt;/li&gt;
&lt;li&gt;监听前面的Channel以及Context对象：
a.  如果context.Done返回，说明数据提交超时，使用s.parseProposeCtxErr函数返回具体的错误。
b.  如果channel返回，说明已经提交成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上的流程可以看出，在调用Raft.Process函数向Raft库提交数据之后，等待被唤醒的Channel才是正常提交数据成功的路径。&lt;/p&gt;
&lt;p&gt;在EtcdServer.run函数中，最终会进入一个死循环中，等待raftNode.apply返回的channel被唤醒，而raftNode继承了raft.Node的实现，从前面分析etcd raft的流程中可以明白，EtcdServer就是在向raft库提交了数据之后，做为其上层消费Ready数据的应用层。&lt;/p&gt;
&lt;p&gt;自此，整体的流程大体已经清晰：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EtcdServer对外通过GRPC协议接收客户端请求，对内有一个raftNode类型的成员，该类型继承了raft.Node的实现。&lt;/li&gt;
&lt;li&gt;客户端通过EtcdServer提交的数据修改都会通过raftNode来提交，而EtcdServer本身通过监听channel与raft库进行通信，由Ready结构体来通过EtcdServer哪些数据已经提交成功。&lt;/li&gt;
&lt;li&gt;由于每个请求都会一个对应的ID，ID绑定了Channel，所以提交成功的请求通过ID找到对应的Channel来唤醒提交流程，最后通知客户端提交数据成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;wal&#34;&gt;WAL&lt;/h1&gt;
&lt;p&gt;以上介绍了EtcdServer的大体流程，接下来看WAL的实现。&lt;/p&gt;
&lt;p&gt;前面已经分析过了，etcd raft提交数据成功之后，将通知上面的应用层（在这里就是EtcdServer），然后再进行持久化数据存储。而数据的持久化可能会花费一些时间，因此在应答应用层之前，EtcdServer中的raftNode会首先将这些数据写入WAL日志中。这样即使在做持久化的时候数据丢失了，启动恢复的时候也可以根据WAL的日志进行数据恢复。&lt;/p&gt;
&lt;p&gt;etcdserver模块中，给raftNode用于写WAL日志的工作，交给了接口Storage来完成，而这个接口由storage来具体实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; storage &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wal.WAL
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;snap.Snapshotter
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，这个结构体组合了WAL和snap.Snapshotter结构，Snapshotter负责的是存储快照数据。&lt;/p&gt;
&lt;p&gt;WAL日志文件中，每条日志记录有以下的类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Type：日志记录类型，下面详细解释都有哪些类型。&lt;/li&gt;
&lt;li&gt;Crc：这一条日志记录的校验数据。&lt;/li&gt;
&lt;li&gt;Data：真正的数据，根据类型不同存储的数据也不同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;日志记录又有如下的类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;metadataType：存储的是元数据（metadata），每个WAL文件开头都有这类型的一条记录数据。&lt;/li&gt;
&lt;li&gt;entryType：保存的是raft的数据，也就是客户端提交上来并且已经commit的数据。&lt;/li&gt;
&lt;li&gt;stateType：保存的是当前集群的状态信息，即前面提到的HardState。&lt;/li&gt;
&lt;li&gt;crcType：校验数据。&lt;/li&gt;
&lt;li&gt;snapshotType：快照数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;etcd使用两个目录分别存放WAL文件以及快照文件。其中，WAL文件的文件名格式是“16位的WAL文件编号-该WAL第一条entry数据的index号.wal”，这样就能从WAL文件名知道该WAL文件中保存的entry数据至少大于什么索引号。而快照文件名的格式则是“16位的快照数据最后一条日志记录任期号-16位的快照数据最后一条记录的索引号.snap”。&lt;/p&gt;
&lt;p&gt;Etcd会管理WAL目录中的所有WAL文件，但是在生成快照文件之后，在快照数据之前的WAL文件将被清除掉，保证磁盘不会一直增长。&lt;/p&gt;
&lt;p&gt;比如当前etcd中有三个WAL文件，可以从这些文件的文件名知道其中存放数据的索引范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-wal1.png&#34; alt=&#34;etcd wal1&#34; title=&#34;etcd wal1&#34;&gt;&lt;/p&gt;
&lt;p&gt;在生成快照文件之后，此时就只剩一个WAL文件和一个快照文件了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-wal2.png&#34; alt=&#34;etcd wal2&#34; title=&#34;etcd wal2&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么，又是在什么情况下生成快照文件呢？Etcdserver在主循环中通过监听channel获知当前raft协议返回的Ready数据，此时会做判断如果当前保存的快照数据索引距离上一次已经超过一个阈值（EtcdServer.snapCount），此时就从raft的存储中生成一份当前的快照数据，写入快照文件成功之后，就可以将这之前的WAL文件释放了。&lt;/p&gt;
&lt;p&gt;以上流程和对应的具体函数见下面的流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-snapshot.png&#34; alt=&#34;etcd snapshot&#34; title=&#34;etcd snapshot&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;backend-store的实现&#34;&gt;backend store的实现&lt;/h1&gt;
&lt;h2 id=&#34;revision概念&#34;&gt;revision概念&lt;/h2&gt;
&lt;p&gt;Etcd存储数据时，并不是像其他的KV存储那样，存放数据的键做为key，而是以数据的revision做为key，键值做为数据来存放。如何理解revision这个概念，以下面的例子来说明。&lt;/p&gt;
&lt;p&gt;比如通过批量接口两次更新两对键值，第一次写入数据时，写入&amp;lt;key1,value1&amp;gt;和&amp;lt;key2,value2&amp;gt;，在Etcd这边的存储看来，存放的数据就是这样的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  revision={1,0}, key=key1, value=value1
  revision={1,1}, key=key2, value=value2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在第二次更新写入数据&amp;lt;key1,update1&amp;gt;和&amp;lt;key2,update2&amp;gt;后，存储中又记录（注意不是覆盖前面的数据）了以下数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  revision={2,0}, key=key1, value=update1
  revision={2,1}, key=key2, value=update2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中revision有两部分组成，第一部分成为main revision，每次事务递增1；第二部分称为sub revision，一个事务内的一次操作递增1。
两者结合，就能保证每次key唯一而且是递增的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-revision.png&#34; alt=&#34;etcd revision&#34; title=&#34;etcd revision&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是，就客户端看来，每次操作的时候是根据Key来进行操作的，所以这里就需要一个Key映射到当前revision的操作了，为了做到这个映射关系，Etcd引入了一个内存中的Btree索引，整个操作过程如下面的流程所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-keyindex.png&#34; alt=&#34;etcd keyindex&#34; title=&#34;etcd keyindex&#34;&gt;&lt;/p&gt;
&lt;p&gt;查询时，先通过内存中的btree索引来查询该key对应的keyIndex结构体，然后再根据这个结构体才能去boltdb中查询真实的数据返回。&lt;/p&gt;
&lt;p&gt;所以，下面先展开讨论这个keyIndex结构体和btree索引。&lt;/p&gt;
&lt;h2 id=&#34;keyindex结构&#34;&gt;keyIndex结构&lt;/h2&gt;
&lt;p&gt;keyIndex结构体有以下成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key：存储数据真实的键。&lt;/li&gt;
&lt;li&gt;modified：最后一次修改该键对应的revision。&lt;/li&gt;
&lt;li&gt;generations：generation数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何理解generation结构呢，可以认为每个generation对应一个数据从创建到删除的过程。每次删除key的操作，都会导致一个generation最后添加一个tombstone记录，然后创建一个新的空generation记录添加到generations数组中。&lt;/p&gt;
&lt;p&gt;generation结构体存放以下数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ver：当前generation中存放了多少次修改，其实就是revs数组的大小-1（因为需要去掉tombstone）。&lt;/li&gt;
&lt;li&gt;created：创建该generation时的revision。&lt;/li&gt;
&lt;li&gt;revs：存放该generation中存放的revision数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下图来说明keyIndex结构体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-keyindex-struct.png&#34; alt=&#34;etcd keyindex struct&#34; title=&#34;etcd keyindex struct&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，存放的键为test的keyIndex结构。&lt;/p&gt;
&lt;p&gt;它的generations数组有两条记录，其中generations[0]在revision 1.0时创建，当revision2.1的时候进行tombstone操作，因此该generation的created是1.0；对应的generations[1]在revision3.3时创建，紧跟着就做了tombstone操作。&lt;/p&gt;
&lt;p&gt;所以该keyIndex.modifiled成员存放的是3.3，因为这是这条数据最后一次被修改的revision。&lt;/p&gt;
&lt;p&gt;一个已经被tombstone的generation是可以被删除的，如果整个generations数组都已经被删除空了，那么整个keyIndex记录也可以被删除了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-generation-compact.png&#34; alt=&#34;etcd generation_compact&#34; title=&#34;etcd generation compact&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，keyIndex.compact(n)函数可以对keyIndex数据进行压缩操作，将删除满足main revision &amp;lt; n的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compact(2)：找到了generations[0]的1.0 revision的数据进行了删除。&lt;/li&gt;
&lt;li&gt;compact(3)：找到了generations[0]的2.1 revision的数据进行了删除，此时由于generations[0]已经没有数据了，所以这一整个generation被删除，原先的generations[1]变成了generations[0]。&lt;/li&gt;
&lt;li&gt;compact(4)：找到了generations[0]的3.3 revision的数据进行了删除。由于所有的generation数据都被删除了，此时这个keyIndex数据可以删除了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;treeindex结构&#34;&gt;treeIndex结构&lt;/h2&gt;
&lt;p&gt;Etcd中使用treeIndex来在内存中存放keyIndex数据信息，这样就可以快速的根据输入的key定位到对应的keyIndex。&lt;/p&gt;
&lt;p&gt;treeIndex使用开源的github.com/google/btree来在内存中存储btree索引信息，因为用的是外部库，所以不打算就这部分做解释。而如果很清楚了前面keyIndex结构，其实这部分很好理解。&lt;/p&gt;
&lt;p&gt;所有的操作都以key做为参数进行操作，treeIndex使用btree根据key查找到对应的keyIndex，再进行相关的操作，最后重新写入到btree中。&lt;/p&gt;
&lt;h2 id=&#34;store&#34;&gt;store&lt;/h2&gt;
&lt;p&gt;前面讲到了WAL数据的存储、内存索引数据的存储，这部分讨论持久化存储数据的模块。&lt;/p&gt;
&lt;p&gt;etcd V3版本中，使用BoltDB来持久化存储数据（etcd V2版本的实现不做讨论）。所以这里先简单解释一下BoltDB中的相关概念。&lt;/p&gt;
&lt;h3 id=&#34;boltdb相关概念&#34;&gt;BoltDB相关概念&lt;/h3&gt;
&lt;p&gt;BoltDB中涉及到的几个数据结构，分别为DB、Bucket、Tx、Cursor、Tx等。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB：表示数据库，类比于Mysql。&lt;/li&gt;
&lt;li&gt;Bucket：数据库中的键值集合，类比于Mysql中的一张数据表。&lt;/li&gt;
&lt;li&gt;键值对：BoltDB中实际存储的数据，类比于Mysql中的一行数据。&lt;/li&gt;
&lt;li&gt;Cursor：迭代器，用于按顺序遍历Bucket中的键值对。&lt;/li&gt;
&lt;li&gt;Tx：表示数据库操作中的一次只读或者读写事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;backend与backendtx接口&#34;&gt;Backend与BackendTx接口&lt;/h3&gt;
&lt;p&gt;Backend和BackendTx内部的实现，封装了BoltDB，太简单就不做分析了。&lt;/p&gt;
&lt;h3 id=&#34;lessor接口&#34;&gt;Lessor接口&lt;/h3&gt;
&lt;p&gt;etcd中没有提供针对数据设置过期时间的操作，通过租约（Lease）来实现数据过期的效果。而Lessor接口就提供了管理租约的相关接口。&lt;/p&gt;
&lt;p&gt;比如，使用etcdctl命令可以创建一个lease：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etcdctl lease grant 10 lease 694d67ed2bfbea03 granted with TTL(10s)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就创建了一个ID为694d67ed2bfbea03的Lease，此时可以将键值与这个lease进行绑定：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etcdctl put --lease=694d67ed2bfbea03 a b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当时间还没超过过期时间10S时，能通过etcd拿到这对键值的数据。如果超时了就获取不到数据了。&lt;/p&gt;
&lt;p&gt;从上面的命令可以看出，一个Lease可以与多个键值对应，由这个Lease通过管理与其绑定的键值数据的生命周期。&lt;/p&gt;
&lt;p&gt;etcd中，将Lease ID存放在名为“lease”的Bucket中，注意在这里只存放Lease相关的数据，其键值为：&amp;lt;Lease ID，序列化后的Lease数据包括TTL、ID&amp;gt;，之所以不存放与Lease绑定的键值，是因为这些键值已经存放到另外的Bucket里了，写入数据的时候也会将这些键值绑定的Lease ID写入，这样在恢复数据的时候就可以将键值与Lease ID绑定的关系写入内存中。&lt;/p&gt;
&lt;p&gt;即：Lease这边需要持久化的数据只有Lease ID与TTL值，而键值对这边会持久化所绑定的Lease ID，这样在启动恢复的时候可以将两者对应的关系恢复到内存中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-lease-store.png&#34; alt=&#34;etcd lease_store&#34; title=&#34;etcd lease store&#34;&gt;&lt;/p&gt;
&lt;p&gt;明白了以上关系再来理解Lessor的实现就很简单了。&lt;/p&gt;
&lt;p&gt;lessor中主要包括以下的成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leaseMap map[LeaseID]*Lease：存储LeaseID与Lease实例之间的对应关系。&lt;/li&gt;
&lt;li&gt;itemMap map[LeaseItem]LeaseID：leaseItem实际存放的是键值，所以这个map管理的就是键值与Lease ID之间的对应关系。&lt;/li&gt;
&lt;li&gt;b backend.Backend：持久化存储，每个Lease的持久化数据会写入名为“lease”的Bucket中。&lt;/li&gt;
&lt;li&gt;minLeaseTTL int64：最小过期时间，设置给每个lease的过期时间不得小于这个数据。&lt;/li&gt;
&lt;li&gt;expiredC chan []*Lease：通过这个channel通知外部有哪些Lease过期了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他的就很简单了:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lessor启动之后会运行一个goroutine协程，在这个协程里定期查询哪些Lease超时，超时的Lease将通过expiredC channel通知外部。&lt;/li&gt;
&lt;li&gt;而针对Lease的CRUD操作，都需要进行加锁才能操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;kv接口&#34;&gt;KV接口&lt;/h2&gt;
&lt;p&gt;有了以上的准备，可以开始分析数据存储相关的内容了。在etcd V3中，所有涉及到数据的存储，都会通过KV接口。&lt;/p&gt;
&lt;p&gt;store结构体实现了KV接口，其中最重要的就是封装了前面提到的几个数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;b backend.Backend：用于将持久化数据写入BoltDB中。&lt;/li&gt;
&lt;li&gt;kvindex index：保存key索引。&lt;/li&gt;
&lt;li&gt;changes []mvccpb.KeyValue：保存每次写操作之后进行了修改的数据，用于通知watch了这些数据变更的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在store结构体初始化时，根据传入的backend.Backend，初始化backend.BatchTx结构，后面的任何涉及到事务的操作，都可以通过这个backend.BatchTx来进行。&lt;/p&gt;
&lt;p&gt;其实有了前面的准备，理解store结构做的事情已经不难，以一次Put操作为例，其流程主要如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-store-put.png&#34; alt=&#34;etcd store_put&#34; title=&#34;etcd store put&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;applierv3&#34;&gt;applierV3&lt;/h1&gt;
&lt;p&gt;EtcdServer内部实现中，实际使用的是applierV3接口来进行持久化数据的操作。&lt;/p&gt;
&lt;p&gt;这个接口有以下几个实现，但是其中applierV3backend的实现是最重要的，其内部使用了前面提到的KV接口来进行数据的处理。&lt;/p&gt;
&lt;p&gt;另外，applierV3接口还有其他几个实现，这里分别列举一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;applierV3backend：基础的applierV3接口实现，其他几个实现都在此实现上做功能扩展。内部调用EtcdServer中的KV接口进行持久化数据读写操作。&lt;/li&gt;
&lt;li&gt;applierV3Capped：磁盘空间不足的情况下，EtcdServer中的applierV3切换到这个实现里面来，这个实现的任何写入操作都会失败，这样保证底层存储的数据量不再增加。&lt;/li&gt;
&lt;li&gt;authApplierV3：在applierV3backend的基础上扩展出权限控制的功能。&lt;/li&gt;
&lt;li&gt;quotaApplierV3：在applierV3backend的基础上加上了限流功能，即底层的存储到了上限的话，会触发限流操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;综述&#34;&gt;综述&lt;/h1&gt;
&lt;p&gt;下图将上面涉及到的关键数据结构串联在一起，看看EtcdServer在收到Raft库通过Ready channel通知的可以持久化数据之后，都做了什么操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20181125-etcd-server/etcd-raft-flow.png&#34; alt=&#34;etcd raft_flow&#34; title=&#34;etcd raft flow&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;raft库通过Ready Channel通知上层的raftNode哪些数据可以进行持久化。&lt;/li&gt;
&lt;li&gt;raftNode启动之后也是会启动一个Goroutine来一直监听这个Ready Channel，以便收到可以持久化数据的通知。&lt;/li&gt;
&lt;li&gt;raftNode在收到Ready数据之后，将首先写入WAL日志中。这里的WAL日志由storage结构体来管理，分为两大部分：WAL日志以及WAL快照文件数据Snapshotter，后者用来避免WAL文件一直增大。&lt;/li&gt;
&lt;li&gt;raftNode在写WAL数据完成之后，通过apply Channel通知EtcdServer。&lt;/li&gt;
&lt;li&gt;EtcdServer启动之后也是启动一个Goroutine来监听这个channel，以便收到可以持久化数据的通知。&lt;/li&gt;
&lt;li&gt;EtcdServer通过调用applierV3接口来持久化数据。applierV3backend结构体实现applierV3接口, applierV3backend结构体实现applierV3接口，内部通过调用KV接口进行持久化操作。而在实现KV接口的store结构体中，treeIndex负责在内存中维护数据键值与revision的对应关系即keyIndex数据，Backend接口负责持久化数据，最后持久化的数据将落盘到BoltDB中。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>etcd Raft库解析</title>
      <link>https://www.codedump.info/post/20180922-etcd-raft/</link>
      <pubDate>Sat, 22 Sep 2018 11:01:02 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20180922-etcd-raft/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd的raft实现是最接近论文本身的，结合论文原理一起阅读十分酸爽。这个系列文章的索引如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我个人还针对etcd 3.1.10版本的raft相关代码实现做了一些代码的注释笔记，地址在此：&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;etcd-3.1.10-codedump&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;序言&#34;&gt;序言&lt;/h1&gt;
&lt;p&gt;今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现也非常精妙，屏蔽了网络、存储等模块，提供接口由上层应用者来实现。&lt;/p&gt;
&lt;p&gt;本篇文章解析etcd的Raft库实现，基于etcd 3.1.10版本。etcd的Raft库，位于其代码目录的Raft中。&lt;/p&gt;
&lt;p&gt;我自己也单独将3.1.10的代码拉出了一个专门添加了我阅读代码注释的版本，目前Raft这部分基本都做了注释，见：
&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;https://github.com/lichuang/etcd-3.1.10-codedump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下在介绍的时候，可能会混用中文和英文术语，这里先列举出来：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;英文&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;选举任期，每次选举之后递增1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Vote&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;选举投票(的ID)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Raft算法的日志数据条目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;candidate&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;候选人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;leader&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;领导者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;follower&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;跟随者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;propose&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提议&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;输入及输出&#34;&gt;输入及输出&lt;/h1&gt;
&lt;p&gt;既然做为一个库使用，就有其确定的输入和输出接口，先来了解这部分再进行后续的展开讨论。&lt;/p&gt;
&lt;p&gt;作为一个一致性算法的库，不难想象使用的一般场景是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用层接收到新的写入数据请求，向该算法库写入一个数据。&lt;/li&gt;
&lt;li&gt;算法库返回是否写入成功。&lt;/li&gt;
&lt;li&gt;应用层根据写入结果进行下一步的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，Raft库却相对而言更复杂一些，因为还有以下的问题存在：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入的数据，可能是集群状态变更的数据，Raft库在执行写入这类数据之后，需要返回新的状态给应用层。&lt;/li&gt;
&lt;li&gt;Raft库中的数据不可能一直以日志的形式存在，这样会导致数据越来越大，所以有可能被压缩成快照（snapshot）的数据形式，这种情况下也需要返回这部分快照数据。&lt;/li&gt;
&lt;li&gt;由于etcd的Raft库不包括持久化数据存储相关的模块，而是由应用层自己来做实现，所以也需要返回在某次写入成功之后，哪些数据可以进行持久化保存了。&lt;/li&gt;
&lt;li&gt;同样的，etcd的Raft库也不自己实现网络传输，所以同样需要返回哪些数据需要进行网络传输给集群中的其他节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的这些，集中在raft/node.go的Ready结构体中，其包括以下成员：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员名称&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;SoftState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;HardState&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]ReadStates&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用于读一致性的数据，后续会详细介绍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在向其他集群发送消息之前需要先写入持久化存储的日志数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;pb.Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要写入持久化存储中的快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CommittedEntries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Entry&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Messages&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;[]pb.Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在entries被写入持久化存储中以后，需要发送出去的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上的成员说明，最开始看不一定能理解其含义和用法，不过在后续会慢慢展开讨论。&lt;/p&gt;
&lt;p&gt;根据上面的分析，应用层在写入一段数据之后，Raft库将返回这样一个Ready结构体，其中可能某些字段是空的，毕竟不是每次改动都会导致Ready结构体中的成员都发生变化，此时使用者就需要根据情况，取出其中不为空的成员进行操作了。&lt;/p&gt;
&lt;p&gt;在etcd项目中，也提供了使用Raft库的demo例子，在contrib/raftexample目录中，这里简单的演示了一下如何根据这个raft库实现一个简单的KV存储服务器，下面根据这里的代码结合着上面的Ready结构体，来分析如何使用etcd的Raft库。&lt;/p&gt;
&lt;p&gt;raft库对外提供一个Node的interface，其实现有raft/node.go中的node结构体实现，这也是应用层唯一需要与这个raft库直接打交道的结构体，简单的来看看Node接口需要实现的函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Tick&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等。至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Campaign&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;调用该函数将驱动节点进入候选人状态，进而将竞争leader。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Propose&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提议写入数据到日志中，可能会返回错误。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ProposeConfChange&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交配置变更&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Step&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;将消息msg灌入状态机中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Ready&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;这里是核心函数，将返回Ready的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Advance&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里大部分函数在这个demo中不需要进行关心，我们只看如何对接Ready结构体就好了。&lt;/p&gt;
&lt;p&gt;raftexample中，首先在main.go中创建了两个channel：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;proposeC：用于提交写入的数据。&lt;/li&gt;
&lt;li&gt;confChangeC：用于提交配置改动数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后分别启动如下核心的协程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动HTTP服务器，用于接收用户的请求数据，最终会将用户请求的数据写入前面的proposeC/confChangeC channel中。&lt;/li&gt;
&lt;li&gt;启动raftNode结构体，该结构体中有上面提到的raft/node.go中的node结构体，也就是通过该结构体实现的Node接口与raft库进行交互。同时，raftNode还会启动协程监听前面的两个channel，收到数据之后通过Node接口的函数调用raft库对应的接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的交互流程就很清楚了，HTTP服务负责接收用户数据，再写入到两个核心channel中，而raftNode负责监听这两个channel：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果收到proposeC channel的消息，说明有数据提交，则调用Node.Propose函数进行数据的提交。&lt;/li&gt;
&lt;li&gt;如果收到confChangeC channel的消息，说明有配置变更，则调用Node.ProposeConfChange函数进行配置变更。&lt;/li&gt;
&lt;li&gt;设置一个定时器tick，每次定时器到时时，调用Node.Tick函数。&lt;/li&gt;
&lt;li&gt;监听Node.Ready函数返回的Ready结构体channel，有数据变更时根据Ready结构体的不同数据类型进行相应的操作，完成了之后需要调用Node.Advance函数进行收尾。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将以上流程用伪代码实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// HTTP server
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;HttpServer主循环:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  接收用户提交的数据&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    如果是PUT请求&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      将数据写入到proposeC中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    如果是POST请求&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      将配置变更数据写入到confChangeC中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// raft Node
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;raftNode结构体主循环&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果proposeC中有数据写入&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Propose向raft库提交数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果confChangeC中有数据写入&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Node.ProposeConfChange向raft库提交配置变更数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果tick定时器到期&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    调用node.Tick函数进行raft库的定时操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  如果node.&lt;span style=&#34;color:#00a000&#34;&gt;Ready&lt;/span&gt;()函数返回的Ready结构体channel有数据变更&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    依次处理Ready结构体中各成员数据
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    处理完毕之后调用node.Advance函数进行收尾处理
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到了这里，已经对raft的使用有一个基本的概念了，即通过node结构体实现的Node接口与raft库进行交互，涉及数据变更的核心数据结构就是Ready结构体，接下来可以进一步来分析该库的实现了。&lt;/p&gt;
&lt;h1 id=&#34;raft库代码结构及核心数据结构&#34;&gt;raft库代码结构及核心数据结构&lt;/h1&gt;
&lt;p&gt;现在可以来看看raft库的代码组织了。&lt;/p&gt;
&lt;p&gt;前面已经看到了raft/node.go文件中，提供出去的是Node接口及其实现node结构体，这是外界与raft库打交道的唯一接口，除此之外该路径下的其他文件并不直接与外界打交道。&lt;/p&gt;
&lt;p&gt;接着是raft算法的实现文件，raft/raft.go文件，其中包含两个核心数据结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Config：与raft算法相关的配置参数都包装在该结构体中。从这个结构体的命名是大写字母开头，就可以知道是提供给外部调用的。&lt;/li&gt;
&lt;li&gt;raft：具体实现raft算法的结构体。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除去以上两个文件之外，raft目录下的其他文件，都是间接给raft结构体服务的，下面的表格做一个总结和罗列：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;结构体/接口&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;所在文件&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Node接口&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;node.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提供raft库与外界交互的接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;node&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;node.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;实现Node接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Config&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;封装raft算法相关配置参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;raft&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft算法的实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ReadState&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;read_only.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;线性一致性读相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;readOnly&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;read_only.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;线性一致性读相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;raftLog&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;log.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;实现raft日志操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Progress&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;progress.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Storage接口&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;storage.go&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提供存储接口，应用层可以按照自己的需求实现该接口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;raft库日志存储相关结构&#34;&gt;raft库日志存储相关结构&lt;/h2&gt;
&lt;h3 id=&#34;unstable&#34;&gt;unstable&lt;/h3&gt;
&lt;p&gt;顾名思义，unstable数据结构用于还没有被用户层持久化的数据，而其中又包括两部分，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/unstable.png&#34; alt=&#34;unstable&#34; title=&#34;unstable&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，前半部分是快照数据，而后半部分是日志条目组成的数组entries，另外unstable.offset成员保存的是entries数组中的第一条数据在raft日志中的索引，即第i条entries数组数据在raft日志中的索引为i + unstable.offset。&lt;/p&gt;
&lt;p&gt;这两个部分，并不同时存在，同一时间只有一个部分存在。其中，快照数据仅当当前节点在接收从leader发送过来的快照数据时存在，在接收快照数据的时候，entries数组中是没有数据的；除了这种情况之外，就只会存在entries数组的数据了。因此，当接收完毕快照数据进入正常的接收日志流程时，快照数据将被置空。&lt;/p&gt;
&lt;p&gt;理解了以上unstable中数据的分布情况，就不难理解unstable各个函数成员的作用了，下面逐一进行解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maybeFirstIndex：返回unstable数据的第一条数据索引。因为只有快照数据在最前面，因此这个函数只有当快照数据存在的时候才能拿到第一条数据索引，其他的情况下已经拿不到了。&lt;/li&gt;
&lt;li&gt;maybeLastIndex：返回最后一条数据的索引。因为是entries数据在后，而快照数据在前，所以取最后一条数据索引是从entries开始查，查不到的情况下才查快照数据。&lt;/li&gt;
&lt;li&gt;maybeTerm：这个函数根据传入的日志数据索引，得到这个日志对应的任期号。前面已经提过，unstable.offset是快照数据和entries数组的分界线，因为在这个函数中，会区分传入的参数与offset的大小关系，小于offset的情况下在快照数据中查询，否则就在entries数组中查询了。&lt;/li&gt;
&lt;li&gt;stableTo：该函数传入一个索引号i和任期号t，表示应用层已经将这个索引之前的数据进行持久化了，此时unstable要做的事情就是在自己的数据中查询，只有在满足任期号相同以及i大于等于offset的情况下，可以将entries中的数据进行缩容，将i之前的数据删除。&lt;/li&gt;
&lt;li&gt;stableSnapTo：该函数传入一个索引i，用于告诉unstable，索引i对应的快照数据已经被应用层持久化了，如果这个索引与当前快照数据对应的上，那么快照数据就可以被置空了。&lt;/li&gt;
&lt;li&gt;restore：从快照数据中恢复，此时unstable将保存快照数据，同时将offset成员设置成这个快照数据索引的下一位。&lt;/li&gt;
&lt;li&gt;truncateAndAppend：传入日志条目数组，这段数据将添加到entries数组中。但是需要注意的是，传入的数据跟现有的entries数据可能有重合的部分，所以需要根据unstable.offset与传入数据的索引大小关系进行处理，有些数据可能会被截断。&lt;/li&gt;
&lt;li&gt;slice：返回索引范围在[lo-u.offset : hi-u.offset]之间的数据。&lt;/li&gt;
&lt;li&gt;mustCheckOutOfBounds：检查传入的数据索引范围是否合理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;storage接口&#34;&gt;Storage接口&lt;/h3&gt;
&lt;p&gt;Storage接口，提供了存储持久化日志相关的接口操作。其提供出来的接口函数说明如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InitialState() (pb.HardState, pb.ConfState, error)：返回当前的初始状态，其中包括硬状态（HardState）以及配置（里面存储了集群中有哪些节点）。&lt;/li&gt;
&lt;li&gt;Entries(lo, hi, maxSize uint64) ([]pb.Entry, error)：传入起始和结束索引值，以及最大的尺寸，返回索引范围在这个传入范围以内并且不超过大小的日志条目数组。&lt;/li&gt;
&lt;li&gt;Term(i uint64) (uint64, error)：传入日志索引i，返回这条日志对应的任期号。找不到的情况下error返回值不为空，其中当返回ErrCompacted表示传入的索引数据已经找不到，说明已经被压缩成快照数据了；返回ErrUnavailable：表示传入的索引值大于当前的最大索引。&lt;/li&gt;
&lt;li&gt;LastIndex() (uint64, error)：返回最后一条数据的索引。&lt;/li&gt;
&lt;li&gt;FirstIndex() (uint64, error)：返回第一条数据的索引。&lt;/li&gt;
&lt;li&gt;Snapshot() (pb.Snapshot, error)：返回最近的快照数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我对这个接口提供出来的接口函数比较有疑问，因为搜索了etcd的代码，该接口只有MemoryStorage一个实现，而实际上MemoryStorage这个结构体还有其他的函数，比如添加日志数据的操作，但是这个操作并没有在Storage接口中声明。&lt;/p&gt;
&lt;p&gt;接下来看看实现了Storage接口的MemoryStorage结构体的实现，其成员主要包括以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hardState pb.HardState：存储硬状态。&lt;/li&gt;
&lt;li&gt;snapshot  pb.Snapshot：存储快照数据。&lt;/li&gt;
&lt;li&gt;ents []pb.Entry：存储紧跟着快照数据的日志条目数组，即ents[i]保存的日志数据索引位置为i + snapshot.Metadata.Index。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;raftlog的实现&#34;&gt;raftLog的实现&lt;/h3&gt;
&lt;p&gt;有了以上的介绍unstable、Storage的准备之后，下面可以来介绍raftLog的实现，这个结构体承担了raft日志相关的操作。&lt;/p&gt;
&lt;p&gt;raftLog由以下成员组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;storage Storage：前面提到的存放已经持久化数据的Storage接口。&lt;/li&gt;
&lt;li&gt;unstable unstable：前面分析过的unstable结构体，用于保存应用层还没有持久化的数据。&lt;/li&gt;
&lt;li&gt;committed uint64：保存当前提交的日志数据索引。&lt;/li&gt;
&lt;li&gt;applied uint64：保存当前传入状态机的数据最高索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，一条日志数据，首先需要被提交（committed）成功，然后才能被应用（applied）到状态机中。因此，以下不等式一直成立：applied &amp;lt;= committed。&lt;/p&gt;
&lt;p&gt;raftLog结构体中，几部分数据的排列如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/raftlog.png&#34; alt=&#34;raftlog&#34; title=&#34;raftlog&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个数据排布的情况，可以从raftLog的初始化函数中看出来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;newLog&lt;/span&gt;(storage Storage, logger Logger) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;raftLog {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; storage &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		log.&lt;span style=&#34;color:#00a000&#34;&gt;Panic&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;storage must not be nil&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;raftLog{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		storage: storage,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		logger:  logger,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	firstIndex, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; storage.&lt;span style=&#34;color:#00a000&#34;&gt;FirstIndex&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f&#34;&gt;panic&lt;/span&gt;(err) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// TODO(bdarnell)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	lastIndex, err &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; storage.&lt;span style=&#34;color:#00a000&#34;&gt;LastIndex&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f&#34;&gt;panic&lt;/span&gt;(err) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// TODO(bdarnell)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// offset从持久化之后的最后一个index的下一个开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	log.unstable.offset = lastIndex &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log.unstable.logger = logger
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Initialize our committed and applied pointers to the time of the last compaction.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// committed和applied从持久化的第一个index的前一个开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;	log.committed = firstIndex &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	log.applied = firstIndex &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;firstIndex：该值取自storage.FirstIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的第一个数据索引，也就是MemoryStorage结构体中快照数据与日志条目数据的分界线。&lt;/li&gt;
&lt;li&gt;lastIndex：该值取自storage.LastIndex()，可以从MemoryStorage的实现看到，该值是MemoryStorage.ents数组的最后一个数据索引。&lt;/li&gt;
&lt;li&gt;unstable.offset：该值为lastIndex索引的下一个位置。&lt;/li&gt;
&lt;li&gt;committed、applied：在初始的情况下，这两个值是firstIndex的上一个索引位置，这是因为在firstIndex之前的数据既然已经是持久化数据了，说明都是已经被提交成功的数据了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，从这里的代码分析可以看出，raftLog的两部分，持久化存储和非持久化存储，它们之间的分界线就是lastIndex，在此之前都是Storage管理的已经持久化的数据，而在此之后都是unstable管理的还没有持久化的数据。&lt;/p&gt;
&lt;p&gt;以上分析中还有一个疑问，为什么并没有初始化unstable.snapshot成员，也就是unstable结构体的快照数据？原因在于，上面这个是初始化函数，也就是节点刚启动的时候调用来初始化存储状态的函数，而unstable.snapshot数据，是在启动之后同步数据的过程中，如果需要同步快照数据时才会去进行赋值修改的数据，因此在这里并没有对它进行操作的地方。&lt;/p&gt;
&lt;h2 id=&#34;raft消息结构体&#34;&gt;raft消息结构体&lt;/h2&gt;
&lt;p&gt;大体而言，raft算法本质上是一个大的状态机，任何的操作例如选举、提交数据等，最后的操作一定是封装成一个消息结构体，输入到raft算法库的状态机中。&lt;/p&gt;
&lt;p&gt;在raft/raftpb/raft.proto文件中，定义了raft算法中传输消息的结构体。熟悉raft论文的都知道，raft算法其实由好几个协议组成，但是在这里，统一定义在了Message这个结构体之中，以下总结了该结构体的成员用途。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MessageType&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息发送者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交日志索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rejectHint&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于这个Message结构体，全部将raft协议相关的数据都定义在了一起，有些协议不是用到其中的全部数据，所以这里的字段都是optinal的，我个人感觉这样不太好，会导致混合在一起显得杂乱无章，所以这里还是将每个协议（即不同的消息类型）中使用的用途做一个记录，如下。&lt;/p&gt;
&lt;h2 id=&#34;msghup消息&#34;&gt;MsgHup消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHup&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不用于节点间通信，仅用于发送给本节点让本节点进行选举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;msgbeat消息&#34;&gt;MsgBeat消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgBeat&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不用于节点间通信，仅用于leader节点在heartbeat定时器到期时向集群中其他节点发送心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;msgprop消息&#34;&gt;MsgProp消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgProp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;raft库使用者提议（propose）数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;raft库的使用者向raft库propose数据时，最后会封装成这个类型的消息来进行提交，不同类型的节点处理还不尽相同。&lt;/p&gt;
&lt;h3 id=&#34;candidate&#34;&gt;candidate&lt;/h3&gt;
&lt;p&gt;由于candidate节点没有处理propose数据的责任，所以忽略这类型消息。&lt;/p&gt;
&lt;h3 id=&#34;follower&#34;&gt;follower&lt;/h3&gt;
&lt;p&gt;首先会检查集群内是否有leader存在，如果当前没有leader存在说明还在选举过程中，这种情况忽略这类消息；否则转发给leader处理。&lt;/p&gt;
&lt;h3 id=&#34;leader&#34;&gt;leader&lt;/h3&gt;
&lt;p&gt;leader的处理在leader的状态机函数针对MsgProp这种case的处理下，大体如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查entries数组是否没有数据，这是一个保护性检查。&lt;/li&gt;
&lt;li&gt;检查本节点是否还在集群之中，如果已经不在了则直接返回不进行下一步处理。什么情况下会出现一个leader节点发现自己不存在集群之中了？这种情况出现在本节点已经通过配置变化被移除出了集群的场景。&lt;/li&gt;
&lt;li&gt;检查raft.leadTransferee字段，当这个字段不为0时说明正在进行leader迁移操作，这种情况下不允许提交数据变更操作，因此此时也是直接返回的。&lt;/li&gt;
&lt;li&gt;检查消息的entries数组，看其中是否带有配置变更的数据。如果其中带有数据变更而raft.pendingConf为true，说明当前有未提交的配置更操作数据，根据raft论文，每次不同同时进行一次以上的配置变更，因此这里会将entries数组中的配置变更数据置为空数据。&lt;/li&gt;
&lt;li&gt;到了这里可以进行真正的数据propose操作了，将调用raft算法库的日志模块写入数据，根据返回的情况向其他节点广播消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgappmsgsnap消息&#34;&gt;MsgApp/MsgSnap消息&lt;/h2&gt;
&lt;h3 id=&#34;msgapp消息&#34;&gt;MsgApp消息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgApp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向集群中其他节点同步数据的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;索引ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;msgsnap消息&#34;&gt;MsgSnap消息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgSnap&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向follower同步数据用的快照消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Snapshot&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;快照数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果说前面的MsgProp消息是集群中的节点向leader转发用户提交的数据，那么MsgApp消息就是相反的，是leader节点用于向集群中其他节点同步数据的。&lt;/p&gt;
&lt;p&gt;在这里把MsgSnap消息和MsgApp消息放在一起，是因为MsgSnap消息做的事情其实跟前面提到的MsgApp消息是一样的：都是用于leader向follower同步数据。实际上对于leader而言，向某个节点同步数据这个操作，都封装在raft.sendAppend函数中，至于具体用的哪种消息类型由这个函数内部实现。&lt;/p&gt;
&lt;p&gt;那么，什么情况下会用到快照数据来同步呢？raft算法中，任何的数据要提交成功，首先leader会在本地写一份日志，再广播出去给集群的其他节点，只有在超过半数以上的节点同意，leader才能进行提交操作，这一个流程在前面讲解MsgAppResp消息流程时做了解释。&lt;/p&gt;
&lt;p&gt;但是，如果这个日志文件不停的增长，显然是不能接受的。因此，在某些时刻，节点会将日志数据进行压缩处理，就是把当前的数据写入到一个快照文件中。而leader在向某一个节点进行数据同步时，是根据该节点上的日志记录进行数据同步的。&lt;/p&gt;
&lt;p&gt;比方说，leader上已经有最大索引为10的日志数据，而节点A的日志索引是2，那么leader将从3开始向节点A同步数据。&lt;/p&gt;
&lt;p&gt;但是如果前面的数据已经进行了压缩处理，转换成了快照数据，而压缩后的快照数据实际上已经没有日志索引相关的信息了。这时候只能将快照数据全部同步给节点了。还是以前面的流程为例，假如leader上日志索引为7之前的数据都已经被压缩成了快照数据，那么这部分数据在同步时是需要整份传输过去的，只有当同步完成节点赶上了leader上的日志进度时，才开始正常的日志同步流程。
而同步数据时，需要区分两种情况：&lt;/p&gt;
&lt;h2 id=&#34;msgappresp消息&#34;&gt;MsgAppResp消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgAppResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;集群中其他节点针对leader的MsgApp/MsgSnap消息的应答消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝同步日志的请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;rejectHint&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;拒绝同步日志请求时返回的当前节点日志ID，用于被拒绝方快速定位到下一次合适的同步日志位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在节点收到leader的MsgApp/MsgSnap消息时，可能出现leader上的数据与自身节点数据不一致的情况，这种情况下会返回reject为true的MsgAppResp消息，同时rejectHint字段是本节点raft最后一条日志的索引ID。&lt;/p&gt;
&lt;p&gt;而index字段则返回的是当前节点的日志索引ID，用于向leader汇报自己已经commit的日志数据ID，这样leader就知道下一次同步数据给这个节点时，从哪条日志数据继续同步了。&lt;/p&gt;
&lt;p&gt;leader节点在收到MsgAppResp消息的处理流程大体如下（stepLeader函数中MsgAppResp case的处理流程）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，收到节点的MsgAppResp消息，说明该节点是活跃的，因此保存节点状态的RecentActive成员置为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来，再根据msg.Reject的返回值，即节点是否拒绝了这次数据同步，来区分两种情况进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;msgreject为true的情况&#34;&gt;msg.Reject为true的情况&lt;/h3&gt;
&lt;p&gt;如果msg.Reject为true，说明节点拒绝了前面的MsgApp/MsgSnap消息，根据msg.RejectHint成员回退leader上保存的关于该节点的日志记录状态。比如leader前面认为从日志索引为10的位置开始向节点A同步数据，但是节点A拒绝了这次数据同步，同时返回RejectHint为2，说明节点A告知leader在它上面保存的最大日志索引ID为2，这样下一次leader就可以直接从索引为2的日志数据开始同步数据到节点A。而如果没有这个RejectHint成员，leader只能在每次被拒绝数据同步后都递减1进行下一次数据同步，显然这样是低效的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为上面节点拒绝了这次数据同步，所以节点的状态可能存在一些异常，此时如果leader上保存的节点状态为ProgressStateReplicate，那么将切换到ProgressStateProbe状态（关于这几种状态，下面会谈到）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前面已经按照msg.RejectHint修改了leader上关于该节点日志状态的索引数据，接着再次尝试按照这个新的索引数据向该节点再次同步数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;msgreject为false的情况&#34;&gt;msg.Reject为false的情况&lt;/h3&gt;
&lt;p&gt;这种情况说明这个节点通过了leader的这一次数据同步请求，这种情况下根据msg.Index来判断在leader中保存的该节点日志数据索引是否发生了更新，如果发生了更新那么就说明这个节点通过了新的数据，这种情况下会做以下的几个操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改节点状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果该节点之前在ProgressStateProbe状态，说明之前处于探测状态，此时可以切换到ProgressStateReplicate，开始正常的接收leader的同步数据了。&lt;/li&gt;
&lt;li&gt;如果之前处于ProgressStateSnapshot状态，即还在同步副本，说明节点之前可能落后leader数据比较多才采用了接收副本的状态。这里还需要多做一点解释，因为在节点落后leader数据很多的情况下，可能leader会多次通过snapshot同步数据给节点，而当 pr.Match &amp;gt;= pr.PendingSnapshot的时候，说明通过快照来同步数据的流程完成了，这时可以进入正常的接收同步数据状态了，这就是函数Progress.needSnapshotAbort要做的判断。&lt;/li&gt;
&lt;li&gt;如果之前处于ProgressStateReplicate状态，此时可以修改leader关于这个节点的滑动窗口索引，释放掉这部分数据索引，好让节点可以接收新的数据了。关于这个滑动窗口设计，见下面详细解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;判断是否有新的数据可以提交（commit）了。因为raft的提交数据的流程是这样的：首先节点将数据提议（propose）给leader，leader在将数据写入到自己的日志成功之后，再通过MsgApp把这些提议的数据广播给集群中的其他节点，在某一条日志数据收到超过半数（qurom）的节点同意之后，才认为是可以提交（commit）的。因此每次leader节点在收到一条MsgAppResp类型消息，同时msg.Reject又是false的情况下，都需要去检查当前有哪些日志是超过半数的节点同意的，再将这些可以提交（commit）的数据广播出去。而在没有数据可以提交的情况下，如果之前节点处于暂停状态，那么将继续向该节点同步数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后还要做一个跟leader迁移相关的操作。如果该消息节点是准备迁移过去的新leader节点（raft.leadTransferee == msg.From），而且此时该节点上的Match索引已经跟旧的leader的日志最大索引一致，说明新旧节点的日志数据已经同步，可以正式进行集群leader迁移操作了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgvotemsgprevote消息以及msgvoterespmsgprevoteresp消息&#34;&gt;MsgVote/MsgPreVote消息以及MsgVoteResp/MsgPreVoteResp消息&lt;/h2&gt;
&lt;p&gt;这里把这四种消息放在一起了，因为不论是Vote还是PreVote流程，其请求和应答时传输的数据都是一样的。&lt;/p&gt;
&lt;p&gt;先看请求数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgVote/MsgPreVote&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点投票给自己以进行新一轮的选举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;term&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志索引ID，用于节点向leader汇报自己已经commit的日志数据ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;logTerm&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志所处的任期ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;应答数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgVoteResp/MsgPreVoteResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;投票应答消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;节点调用raft.campaign函数进行投票给自己进行一次新的选举，其中的参数CampaignType有以下几种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;campaignPreElection：对应PreVote的场景。&lt;/li&gt;
&lt;li&gt;campaignElection：正常的选举场景。&lt;/li&gt;
&lt;li&gt;campaignTransfer：由于leader迁移发生的选举。如果是这种类型的选举，那么msg.Context字段保存的是“CampaignTransfer”`字符串，这种情况下会强制进行leader的迁移。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MsgVote还需要带上几个与本节点日志相关的数据（Index、LogTerm），因为raft算法要求，一个节点要成为leader的一个必要条件之一就是这个节点上的日志数据是最新的。&lt;/p&gt;
&lt;h3 id=&#34;prevote&#34;&gt;PreVote&lt;/h3&gt;
&lt;p&gt;这里需要特别解释一下PreVote的场景。&lt;/p&gt;
&lt;p&gt;考虑到一种情况：当出现网络分区的时候，A、B、C、D、E五个节点被划分成了两个网络分区，A、B、C组成的分区和D、E组成的分区，其中的D节点，如果在选举超时到来时，都没有收到来自leader节点A的消息（因为网络已经分区），那么D节点认为需要开始一次新的选举了。&lt;/p&gt;
&lt;p&gt;正常的情况下，节点D应该把自己的任期号term递增1，然后发起一次新的选举。由于网络分区的存在，节点D肯定不会获得超过半数以上的的投票，因为A、B、C三个节点组成的分区不会收到它的消息，这会导致节点D不停的由于选举超时而开始一次新的选举，而每次选举又会递增任期号。&lt;/p&gt;
&lt;p&gt;在网络分区还没恢复的情况下，这样做问题不大。但是当网络分区恢复时，由于节点D的任期号大于当前leader节点的任期号，这会导致集群进行一次新的选举，即使节点D肯定不会获得选举成功的情况下（因为节点D的日志落后当前集群太多，不能赢得选举成功）。&lt;/p&gt;
&lt;p&gt;为了避免这种无意义的选举流程，节点可以有一种PreVote的状态，在这种状态下，想要参与选举的节点会首先连接集群的其他节点，只有在超过半数以上的节点连接成功时，才能真正发起一次新的选举。&lt;/p&gt;
&lt;p&gt;所以，在PreVote状态下发起选举时，并不会导致节点本身的任期号递增1，而只有在进行正常选举时才会将任期号加1进行选举。&lt;/p&gt;
&lt;h3 id=&#34;msgvotemsgprevote的处理流程&#34;&gt;MsgVote/MsgPreVote的处理流程&lt;/h3&gt;
&lt;p&gt;来看看节点对于投票消息的处理，这些处理有两处，但是都在raft.Step函数中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先该函数会判断msg.Term是否大于本节点的Term，如果消息的任期号更大则说明是一次新的选举。这种情况下将根据msg.Context是否等于“CampaignTransfer”字符串来确定是不是一次由于leader迁移导致的强制选举过程。同时也会根据当前的electionElapsed是否小于electionTimeout来确定是否还在租约期以内。如果既不是强制leader选举又在租约期以内，那么节点将忽略该消息的处理，在论文4.2.3部分论述这样做的原因，是为了避免已经离开集群的节点在不知道自己已经不在集群内的情况下，仍然频繁的向集群内节点发起选举导致耗时在这种无效的选举流程中。如果以上检查流程通过了，说明可以进行选举了，如果消息类型还不是MsgPreVote类型，那么此时节点会切换到follower状态且认为发送消息过来的节点msg.From是新的leader。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	case m.Term &amp;gt; r.Term:
		// 消息的Term大于节点当前的Term
		lead := m.From
		if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
			// 如果收到的是投票类消息

			// 当context为campaignTransfer时表示强制要求进行竞选
			force := bytes.Equal(m.Context, []byte(campaignTransfer))
			// 是否在租约期以内
			inLease := r.checkQuorum &amp;amp;&amp;amp; r.lead != None &amp;amp;&amp;amp; r.electionElapsed &amp;lt; r.electionTimeout
			if !force &amp;amp;&amp;amp; inLease {
				// 如果非强制，而且又在租约期以内，就不做任何处理
				// 非强制又在租约期内可以忽略选举消息，见论文的4.2.3，这是为了阻止已经离开集群的节点再次发起投票请求
				// If a server receives a RequestVote request within the minimum election timeout
				// of hearing from a current leader, it does not update its term or grant its vote
				r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)&amp;#34;,
					r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)
				return nil
			}
			// 否则将lead置为空
			lead = None
		}
		switch {
		// 注意Go的switch case不做处理的话是不会默认走到default情况的
		case m.Type == pb.MsgPreVote:
			// Never change our term in response to a PreVote
			// 在应答一个prevote消息时不对任期term做修改
		case m.Type == pb.MsgPreVoteResp &amp;amp;&amp;amp; !m.Reject:
			// We send pre-vote requests with a term in our future. If the
			// pre-vote is granted, we will increment our term when we get a
			// quorum. If it is not, the term comes from the node that
			// rejected our vote so we should become a follower at the new
			// term.
		default:
			r.logger.Infof(&amp;#34;%x [term: %d] received a %s message with higher term from %x [term: %d]&amp;#34;,
				r.id, r.Term, m.Type, m.From, m.Term)
			// 变成follower状态
			r.becomeFollower(m.Term, lead)
		}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在raft.Step函数的后面，会判断消息类型是MsgVote或者MsgPreVote来进一步进行处理。其判断条件是以下两个条件同时成立：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;当前没有给任何节点进行过投票（r.Vote == None ），或者消息的任期号更大（m.Term &amp;gt; r.Term ），或者是之前已经投过票的节点（r.Vote == m.From)）。这个条件是检查是否可以还能给该节点投票。&lt;/li&gt;
&lt;li&gt;同时该节点的日志数据是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm) ）。这个条件是检查这个节点上的日志数据是否足够的新。
只有在满足以上两个条件的情况下，节点才投票给这个消息节点，将修改raft.Vote为消息发送者ID。如果不满足条件，将应答msg.Reject=true，拒绝该节点的投票消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	case pb.MsgVote, pb.MsgPreVote:
		// 收到投票类的消息
		// The m.Term &amp;gt; r.Term clause is for MsgPreVote. For MsgVote m.Term should
		// always equal r.Term.
		if (r.Vote == None || m.Term &amp;gt; r.Term || r.Vote == m.From) &amp;amp;&amp;amp; r.raftLog.isUpToDate(m.Index, m.LogTerm) {
			// 如果当前没有给任何节点投票（r.Vote == None）或者投票的节点term大于本节点的（m.Term &amp;gt; r.Term）
			// 或者是之前已经投票的节点（r.Vote == m.From）
			// 同时还满足该节点的消息是最新的（r.raftLog.isUpToDate(m.Index, m.LogTerm)），那么就接收这个节点的投票
			r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d&amp;#34;,
				r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
			r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type)})
			if m.Type == pb.MsgVote {
				// Only record real votes.
				// 保存下来给哪个节点投票了
				r.electionElapsed = 0
				r.Vote = m.From
			}
		} else {
			// 否则拒绝投票
			r.logger.Infof(&amp;#34;%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d&amp;#34;,
				r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
			r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type), Reject: true})
		}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;msgvoterespmsgprevoteresp的处理流程&#34;&gt;MsgVoteResp/MsgPreVoteResp的处理流程&lt;/h3&gt;
&lt;p&gt;来看节点收到投票应答数据之后的处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点调用raft.poll函数，其中传入msg.Reject参数表示发送者是否同意这次选举，根据这些来计算当前集群中有多少节点给这次选举投了同意票。&lt;/li&gt;
&lt;li&gt;如果有半数的节点同意了，如果选举类型是PreVote，那么进行Vote状态正式进行一轮选举；否则该节点就成为了新的leader，调用raft.becomeLeader函数切换状态，然后开始同步日志数据给集群中其他节点了。&lt;/li&gt;
&lt;li&gt;而如果半数以上的节点没有同意，那么重新切换到follower状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; myVoteRespType:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 计算当前集群中有多少节点给自己投了票
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		gr &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; r.&lt;span style=&#34;color:#00a000&#34;&gt;poll&lt;/span&gt;(m.From, m.Type, !m.Reject)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [quorum:%d] has received %d %s votes and %d vote rejections&amp;#34;&lt;/span&gt;, r.id, r.&lt;span style=&#34;color:#00a000&#34;&gt;quorum&lt;/span&gt;(), gr, m.Type, &lt;span style=&#34;color:#a2f&#34;&gt;len&lt;/span&gt;(r.votes)&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;gr)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt; r.&lt;span style=&#34;color:#00a000&#34;&gt;quorum&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; gr:	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果进行投票的节点数量正好是半数以上节点数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; r.state &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; StatePreCandidate {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;campaign&lt;/span&gt;(campaignElection)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			} &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 变成leader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;becomeLeader&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				r.&lt;span style=&#34;color:#00a000&#34;&gt;bcastAppend&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;len&lt;/span&gt;(r.votes) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; gr:	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果是半数以上节点拒绝了投票
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 变成follower
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;			r.&lt;span style=&#34;color:#00a000&#34;&gt;becomeFollower&lt;/span&gt;(r.Term, None)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;msgheartbeatmsgheartbeatresp消息&#34;&gt;MsgHeartbeat/MsgHeartbeatResp消息&lt;/h2&gt;
&lt;p&gt;心跳请求消息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHeartbeat&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader向follower发送心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;commit&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;提交日志索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据，在这里保存一致性读相关的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;心跳请求应答消息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgHeartbeatResp&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于follower向leader应答心跳消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;本节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;context&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bytes&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;上下文数据，在这里保存一致性读相关的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;leader中会定时向集群中其他节点发送心跳消息，该消息的作用除了探测节点的存活情况之外，还包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;commit成员：leader选择min[节点上的Match，leader日志最大提交索引]，用于告知节点哪些日志可以进行提交（commit）。&lt;/li&gt;
&lt;li&gt;context：与线性一致性读相关，后面会进行解释。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgunreachable消息&#34;&gt;MsgUnreachable消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgUnreachable&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于应用层向raft库汇报某个节点当前已不可达&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;不可用的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;仅leader才处理这类消息，leader如果判断该节点此时处于正常接收数据的状态（ProgressStateReplicate），那么就切换到探测状态。&lt;/p&gt;
&lt;h2 id=&#34;msgsnapstatus消息&#34;&gt;MsgSnapStatus消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgSnapStatus&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于应用层向raft库汇报某个节点当前接收快照状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;reject&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;bool&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;是否拒绝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;仅leader处理这类消息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果reject为false：表示接收快照成功，将切换该节点状态到探测状态。&lt;/li&gt;
&lt;li&gt;否则接收失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;msgcheckquorum消息&#34;&gt;MsgCheckQuorum消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgCheckQuorum&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于leader检查集群可用性的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;leader的定时器函数，在超过选举时间时，如果当前打开了raft.checkQuorum开关，那么leader将给自己发送一条MsgCheckQuorum消息，对该消息的处理是：检查集群中所有节点的状态，如果超过半数的节点都不活跃了，那么leader也切换到follower状态。&lt;/p&gt;
&lt;h2 id=&#34;msgtransferleader消息&#34;&gt;MsgTransferLeader消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgTransferLeader&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于迁移leader&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;消息接收者的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;注意这里不是发送者的ID了，而是准备迁移过去成为新leader的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这类消息follower将转发给leader处理，因为follower并没有修改集群配置状态的权限。&lt;/p&gt;
&lt;p&gt;leader在收到这类消息时，是以下的处理流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果当前的raft.leadTransferee成员不为空，说明有正在进行的leader迁移流程。此时会判断是否与这次迁移是同样的新leader ID，如果是则忽略该消息直接返回；否则将终止前面还没有完毕的迁移流程。&lt;/li&gt;
&lt;li&gt;如果这次迁移过去的新节点，就是当前的leader ID，也直接返回不进行处理。&lt;/li&gt;
&lt;li&gt;到了这一步就是正式开始这一次的迁移leader流程了，一个节点能成为一个集群的leader，其必要条件是上面的日志与当前leader的一样多，所以这里会判断是否满足这个条件，如果满足那么发送MsgTimeoutNow消息给新的leader通知该节点进行leader迁移，否则就先进行日志同步操作让新的leader追上旧leader的日志数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; pb.MsgTransferLeader:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  leadTransferee &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; m.From
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; r.leadTransferee
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; None {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 判断是否已经有相同节点的leader转让流程在进行中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; lastLeadTransferee &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; leadTransferee {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r.id, r.Term, leadTransferee, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果是，直接返回
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 否则中断之前的转让流程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;abortLeaderTransfer&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] abort previous transferring leadership to %x&amp;#34;&lt;/span&gt;, r.id, r.Term, lastLeadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 判断是否转让过来的leader是否本节点，如果是也直接返回，因为本节点已经是leader了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; leadTransferee &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; r.id {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Debugf&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x is already leader. Ignored transferring leadership to self&amp;#34;&lt;/span&gt;, r.id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Transfer leadership to third party.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x [term %d] starts to transfer leadership to %x&amp;#34;&lt;/span&gt;, r.id, r.Term, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  r.electionElapsed = &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  r.leadTransferee = leadTransferee
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; pr.Match &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; r.raftLog.&lt;span style=&#34;color:#00a000&#34;&gt;lastIndex&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果日志已经匹配了，那么就发送timeoutnow协议过去
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;sendTimeoutNow&lt;/span&gt;(leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r.logger.&lt;span style=&#34;color:#00a000&#34;&gt;Infof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log&amp;#34;&lt;/span&gt;, r.id, leadTransferee, leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 否则继续追加日志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r.&lt;span style=&#34;color:#00a000&#34;&gt;sendAppend&lt;/span&gt;(leadTransferee)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;msgtimeoutnow消息&#34;&gt;MsgTimeoutNow消息&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgTimeoutNow&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;leader迁移时，当新旧leader的日志数据同步后，旧leader向新leader发送该消息通知可以进行迁移了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;新的leader ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;旧的leader的节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;新的leader节点，在还未迁移之前仍然是follower，在收到这条消息后，就可以进行迁移了，此时会调用前面分析MsgVote时说过的campaign函数，传入的参数是campaignTransfer，表示这是一次由于迁移leader导致的选举流程。&lt;/p&gt;
&lt;h2 id=&#34;msgreadindex和msgreadindexresp消息&#34;&gt;MsgReadIndex和MsgReadIndexResp消息&lt;/h2&gt;
&lt;p&gt;这两个消息一一对应，使用的成员也一样，在后面分析读一致性的时候再详细解释。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;type&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;MsgReadIndex&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;用于读一致性的消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;to&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;接收者节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;from&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;发送者节点ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;entries&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;Entry&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;日志条目数组&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，entries数组只会有一条数据，带上的是应用层此次请求的标识数据，在follower收到MsgReadIndex消息进行应答时，同样需要把这个数据原样带回返回给leader，详细的线性读一致性的实现在后面展开分析。&lt;/p&gt;
&lt;h1 id=&#34;节点状态&#34;&gt;节点状态&lt;/h1&gt;
&lt;p&gt;每个raft的节点，分为以下三种状态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;candidate：候选人状态，节点切换到这个状态时，意味着将进行一次新的选举。&lt;/li&gt;
&lt;li&gt;follower：跟随者状态，节点切换到这个状态时，意味着选举结束。&lt;/li&gt;
&lt;li&gt;leader：领导者状态，所有数据提交都必须先提交到leader上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个状态都有其对应的状态机，每次收到一条提交的数据时，都会根据其不同的状态将消息输入到不同状态的状态机中。同时，在进行tick操作时，每种状态对应的处理函数也是不一样的。&lt;/p&gt;
&lt;p&gt;所以raft结构体中将不同的状态，及其不同的处理函数独立出来几个成员变量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;成员&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;state&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;保存当前节点状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tick函数&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;tick函数，每个状态对应的tick函数不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;step函数&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;状态机函数，同样每个状态对应的状态机也不相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;raft库中提供几个成员函数becomeCandidate、becomeFollower、becomeLeader分别进入这几种状态的，这些函数中做的事情，概况起来就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;切换raft.state成员到对应状态。&lt;/li&gt;
&lt;li&gt;切换raft.tick函数到对应状态的处理函数。&lt;/li&gt;
&lt;li&gt;切换raft.step函数到对应状态的状态机。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;选举流程&#34;&gt;选举流程&lt;/h1&gt;
&lt;p&gt;raft算法的第一步是首先选举出一个leader出来，在没有产生leader的情况下，其他数据提交等操作都无从谈起，所以这里首先从选举的流程开始谈起。&lt;/p&gt;
&lt;h2 id=&#34;发起选举的节点&#34;&gt;发起选举的节点&lt;/h2&gt;
&lt;p&gt;只有在candidate或者follower状态下的节点，才有可能发起一个选举流程，而这两种状态的节点，其对应的tick函数都是raft.tickElection函数，这个函数的主要流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将选举超时递增1。&lt;/li&gt;
&lt;li&gt;当选举超时到期，同时该节点又在集群中时，说明此时可以进行一轮新的选举。此时会向本节点发送HUP消息，这个消息最终会走到状态机函数raft.Step中进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明白了raft.tickElection函数的作用，可以来看选举流程了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;节点启动时都以follower状态启动，同时随机选择自己的选举超时时间。之所以每个节点随机选择自己的超时时间，是为了避免同时有两个节点同时进行选举，这种情况下会出现没有任何一个节点赢得半数以上的投票从而这一轮选举失败，继续再进行下一轮选举&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在follower的tick函数tickElection函数中，当选举超时到时，节点向自己发送HUP消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在状态机函数raft.Step函数中，在收到HUP消息之后，节点首先判断当前有没有没有apply的配置变更消息，如果有就忽略该消息。其原因在于，当有配置更新的情况下不能进行选举操作，即要保证每一次集群成员变化时只能同时变化一个，不能同时有多个集群成员的状态发生变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则进入campaign函数中进行选举：首先将任期号+1，然后广播给其他节点选举消息，带上的其它字段包括：节点当前的最后一条日志索引（Index字段），最后一条日志对应的任期号（LogTerm字段），选举任期号（Term字段，即前面已经进行+1之后的任期号），Context字段（目的是为了告知这一次是否是leader转让类需要强制进行选举的消息）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在一个选举超时之内，该发起新的选举流程的节点，得到了超过半数的节点投票，那么状态就切换到leader状态，成为leader的同时，leader将发送一条dummy的append消息，目的是为了提交该节点上在此任期之前的值（见疑问部分如何提交之前任期的值）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;收到选举消息的节点&#34;&gt;收到选举消息的节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当收到任期号大于当前节点任期号的消息，同时该消息类型如果是选举类的消息（类型为prevote或者vote）时，会做以下判断：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先会判断一下该消息是否为强制要求进行选举的类型（context为campaignTransfer，context为这种类型时表示在进行leader转让，流程见下面的leader转让流程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断当前是否在租约期以内，判断的条件包括：checkQuorum为true，当前节点保存的leader不为空，没有到选举超时，前面这三个条件同时满足。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不是强制要求选举，同时又在租约期以内，那么就忽略该选举消息返回不进行处理，这么做是为了避免出现那些离开集群的节点，频繁发起新的选举请求（见论文4.2.3）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不是前面的忽略选举消息的情况，那么除非是prevote类的选举消息，在收到其他消息的情况下，该节点都切换为follower状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时需要针对投票类型中带来的其他字段进行处理了，需要同时满足以下两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有在没有给其他节点进行过投票，或者消息的term任期号大于当前节点的任期号，或者之前的投票给的就是这个发出消息的节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行选举的节点，它的日志是更新的，条件为：logterm比本节点最新日志的任期号大，在两者相同的情况下，消息的index大于等于当前节点最新日志的index，即总要保证该选举节点的日志比自己的大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在同时满足以上两个条件的情况下，才能同意该节点的选举，否则都会被拒绝。这么做的原因是：保证最后能胜出来当新的leader的节点，它上面的日志都是最新的。&lt;/p&gt;
&lt;h1 id=&#34;集群成员变化流程&#34;&gt;集群成员变化流程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;大原则是不能同时进行两个以上的成员变更&lt;/strong&gt;，因为同时进行两个以上的成员变更，可能会出现集群中有两个leader即导致了集群分裂的情况出现。&lt;/p&gt;
&lt;p&gt;成员变化分为以下几种情况：成员删减、leader转让，下面分开讲解。&lt;/p&gt;
&lt;h2 id=&#34;一般的成员删减&#34;&gt;一般的成员删减&lt;/h2&gt;
&lt;p&gt;成员变化操作做为日志的特殊类型，当可以进行commit的情况下，各个节点拿出该消息进行节点内部的成员删减操作。&lt;/p&gt;
&lt;h2 id=&#34;leader转让&#34;&gt;leader转让&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;旧leader在接收到转让leader消息之后，会做如下的判断：
a.  如果新的leader上的日志，已经跟当前leader上的日志同步了，那么发送timeout消息。
b.  否则继续发append消息到新的leader上，目的为了让其能够与旧leader日志同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当旧leader处于转让leader状态时，将停止接收新的prop消息，这样就避免出现在转让过程中新旧leader一直日志不能同步的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当旧leader收到append消息应答时，如果当前处于leader转让状态，那么会判断新的leader日志是否已经与当前leader同步，如果是将发送timeout消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的leader当收到timeout消息时，将使用context为campaignTransfer的选举消息发起新一轮选举，当context为该类型时，此时的选举是强制进行的（见前面的选举流程）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;如何做到线性一致性&#34;&gt;如何做到线性一致性？&lt;/h1&gt;
&lt;p&gt;线性一致性（Linearizable Read）通俗来讲，就是读请求需要读到最新的已经commit的数据，不会读到老数据。&lt;/p&gt;
&lt;p&gt;由于所有的leader和follower都能处理客户端的读请求，所以存在可能造成返回读出的旧数据的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;leader和follower之间存在状态差，因为follower总是由leader同步过去的，可能会返回同步之前的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发生了网络分区，某个leader实际上已经被隔离出了集群之外，但是该leader并不知道，如果还继续响应客户端的读请求，也可能会返回旧的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在接收到客户端的读请求时，需要保证返回的数据都是当前最新的。&lt;/p&gt;
&lt;h2 id=&#34;readonlysafe方式&#34;&gt;ReadOnlySafe方式&lt;/h2&gt;
&lt;p&gt;leader在接收到读请求时，需要向集群中的超半数server确认自己仍然是当前的leader，这样它返回的就是最新的数据。&lt;/p&gt;
&lt;p&gt;在etcd-raft中，为了实现ReadOnlySafe，有如下的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; ReadState &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Index &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RequestCtx []&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;byte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Index：接收到该读请求时，当前节点的commit索引。&lt;/li&gt;
&lt;li&gt;RequestCtx：客户端读请求的唯一标识。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ReadState结构体用于保存读请求到来时的节点状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; readIndexStatus &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; req pb.Message
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; index &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; acks &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;uint64&lt;/span&gt;]&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;readIndexStatus数据结构用于追踪leader向follower发送的心跳信息，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;req：保存原始的readIndex请求。&lt;/li&gt;
&lt;li&gt;index：leader当前的commit日志索引。&lt;/li&gt;
&lt;li&gt;acks：存放该readIndex请求有哪些节点进行了应答，当超过半数应答时，leader就可以确认自己还是当前集群的leader。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;type&lt;/span&gt; readOnly &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; option ReadOnlyOption
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; pendingReadIndex &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;readIndexStatus
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; readIndexQueue []&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;readOnly用于管理全局的readIndx数据，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;option：readOnly选项。&lt;/li&gt;
&lt;li&gt;pendingReadIndex：当前所有待处理的readIndex请求，其中key为客户端读请求的唯一标识。&lt;/li&gt;
&lt;li&gt;readIndexQueue：保存所有readIndex请求的请求唯一标识数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了以上的数据结构介绍，后面是流程介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;server收到客户端的读请求，此时会调用raft.ReadIndex函数发起一个MsgReadIndex的请求，带上的参数是客户端读请求的唯一标识（此时可以对照前面分析的MsgReadIndex及其对应应答消息的格式）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower将向leader直接转发MsgReadIndex消息，而leader收到不论是本节点还是由其他server发来的MsgReadIndex消息，其处理都是：&lt;/p&gt;
&lt;p&gt;a. 首先如果该leader在成为新的leader之后没有提交过任何值，那么会直接返回不做处理。&lt;/p&gt;
&lt;p&gt;b. 调用r.readOnly.addRequest(r.raftLog.committed, m)保存该MsgreadIndex请求到来时的commit索引。&lt;/p&gt;
&lt;p&gt;c. r.bcastHeartbeatWithCtx(m.Entries[0].Data)，向集群中所有其他节点广播一个心跳消息MsgHeartbeat，并且在其中带上该读请求的唯一标识。&lt;/p&gt;
&lt;p&gt;d. follower在收到leader发送过来的MsgHeartbeat，将应答MsgHeartbeatResp消息，并且如果MsgHeartbeat消息中有ctx数据，MsgHeartbeatResp消息将原样返回这个ctx数据。&lt;/p&gt;
&lt;p&gt;e. leader在接收到MsgHeartbeatResp消息后，如果其中有ctx字段，说明该MsgHeartbeatResp消息对应的MsgHeartbeat消息，是收到ReadIndex时leader消息为了确认自己还是集群leader发送的心跳消息。首先会调用r.readOnly.recvAck(m)函数，根据消息中的ctx字段，到全局的pendingReadIndex中查找是否有保存该ctx的带处理的readIndex请求，如果有就在acks map中记录下该follower已经进行了应答。&lt;/p&gt;
&lt;p&gt;f. 当ack数量超过了集群半数时，意味着该leader仍然还是集群的leader，此时调用r.readOnly.advance(m)函数，将该readIndex之前的所有readIndex请求都认为是已经成功进行确认的了，所有成功确认的readIndex请求，将会加入到readStates数组中，同时leader也会向follower发送MsgReadIndexResp。&lt;/p&gt;
&lt;p&gt;g. follower收到MsgReadIndexResp消息时，同样也会更新自己的readStates数组信息。&lt;/p&gt;
&lt;p&gt;h. readStates数组的信息，将做为ready结构体的信息更新给上层的raft协议库的使用者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要特别说明的是，处理读请求时，实际上leader需要确保当前自己是不是leader、该读请求对应的commit索引是否得到了半数投票，而当一个节点刚成为leader的时候，如果没有提交过任何数据，那么在它所在的这个任期（term）内的commit索引当时是并不知道的，因此在成为leader之后，需要马上提交一个no-op的空日志，这样拿到该任期的第一个commit索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/msgreadindex-1.png&#34; alt=&#34;msgreadindex-1&#34; title=&#34;msgreadindex-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，在leader收到MsgReadIndex后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向readOnly中添加与这次请求ctx相关的数据：
&lt;ul&gt;
&lt;li&gt;向pendingReadIndex中添加以ctx为key的readIndexStatus，其中保存了当前的commitIndex、原始的MsgReadIndex消息、以及用于存放有哪些节点应答了该消息的acks数组。&lt;/li&gt;
&lt;li&gt;向readIndexQueue数组中添加ctx。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leader向集群中其他节点广播MsgHeartbeat消息，其中带上这次MsgReadIndex的ctx。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这之后，follower应答leader的MsgHeartbeat消息，如果消息中存在ctx字段都会带上应答，于是leader中的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到MsgHeartbeatResp消息之后，如果发现其中有ctx，就去计算应答有没有超过半数，没有超过半数则返回。&lt;/li&gt;
&lt;li&gt;走到这里就是超过半数应答了，此时拿到新的readIndexStatus数组。&lt;/li&gt;
&lt;li&gt;遍历前面拿到的readIndexStatus数组，生成新的readStates数组。&lt;/li&gt;
&lt;li&gt;放到Ready中下一次给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，分为四步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader检查自己在当前任期有没有commit过一条entry，没有提交过则不允许处理readIndex请求。&lt;/li&gt;
&lt;li&gt;leader记录下来收到readIndex请求时候的commit index，然后leader向集群中所有节点发心跳广播，其中带上readIndex相关的ctx字段。&lt;/li&gt;
&lt;li&gt;当超过半数的节点应答了第二部的心跳消息，说明此时leader还是集群的leader。&lt;/li&gt;
&lt;li&gt;生成新的readStates数组放入Ready结构体中，等待下一次客户端来获取该数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;杂项&#34;&gt;杂项&lt;/h1&gt;
&lt;h2 id=&#34;节点的几种状态&#34;&gt;节点的几种状态&lt;/h2&gt;
&lt;p&gt;一个节点在leader上保存的状态有:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateProbe ProgressStateType = &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;iota&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateReplicate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ProgressStateSnapshot
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以下来分开解释这几种状态。&lt;/p&gt;
&lt;h3 id=&#34;progressstateprobe&#34;&gt;ProgressStateProbe&lt;/h3&gt;
&lt;p&gt;探测状态，当节点拒绝了最近的append消息时，那么就会进入探测状态，此时leader会试图继续往前追述该节点的日志从哪里开始丢失的，让该节点的日志能跟leader同步上。在probe状态时，只能向它发送一次append消息，此后除非状态发生变化，否则就暂停向该节点发送新的append消息了。&lt;/p&gt;
&lt;p&gt;只有在以下情况才会恢复取消暂停状态（调用Progress的resume函数）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到该节点的心跳消息。&lt;/li&gt;
&lt;li&gt;该节点成功应答了前面的最后一条append消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于Probe状态，只有在该节点成功应答了Append消息之后，在leader上保存的索引值发生了变化，才会修改其状态切换到Replicate状态。&lt;/p&gt;
&lt;h3 id=&#34;progressstatereplicate&#34;&gt;ProgressStateReplicate&lt;/h3&gt;
&lt;p&gt;正常接收副本数据的状态，当处于该状态时，leader在发送副本消息之后，就修改该节点的next索引为发送消息的最大索引+1&lt;/p&gt;
&lt;h3 id=&#34;progressstatesnapshot&#34;&gt;ProgressStateSnapshot&lt;/h3&gt;
&lt;p&gt;接收快照状态。
当leader向某个follower发送append消息，试图让该follower状态跟上leader时，发现此时leader上保存的索引数据已经对不上了，比如leader在index为10之前的数据都已经写入快照中了，但是该follower需要的是10之前的数据，此时就会切换到该状态下，发送快照给该follower。&lt;/p&gt;
&lt;p&gt;因为快照数据可能很多，不知道会同步多久，所以单独把这个状态抽象出来。&lt;/p&gt;
&lt;p&gt;当快照数据同步追上之后，并不是直接切换到Replicate状态，而是首先切换到Probe状态。&lt;/p&gt;
&lt;h2 id=&#34;progress上的数据索引&#34;&gt;Progress上的数据索引&lt;/h2&gt;
&lt;p&gt;Progress结构体中有两个保存该follower节点日志索引的数据，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Next：保存下一次leader发送append消息给该follower时的日志索引。&lt;/li&gt;
&lt;li&gt;Match：保存该follower节点上的最大日志索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在正常情况下，Next = Match + 1，也就是Next总是节点当前保存最大日志索引的下一条索引。&lt;/p&gt;
&lt;p&gt;有两种情况除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收快照状态：此时Next = max(pr.Match+1, pendingSnapshot+1)&lt;/li&gt;
&lt;li&gt;当该follower不在Replicate状态时，说明不是正常的接收副本状态。此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180922-etcd-raft/next-match.jpg&#34; alt=&#34;next-match&#34; title=&#34;next-match&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，节点s1上最大日志索引为2，即Match = 2，Next = 3。
但是，由于新选出来的leader s2，其最大日志索引为3，此时s3需要同步日志到s1上，发现s1上的日志与自己的不匹配，所以会一直找到两者最开始匹配的索引位置，即最终找到索引1，因此会保存s1的Next索引为1，而Match还是2（因为此时还没有修改s1上的日志）。当最终s1上的数据与s2同步时，此时Next = 4，Match=3。&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;Progress结构体中，使用另一个inflights的数据结构用于流量控制。
该结构体使用一个固定大小的循环缓冲区来控制给一个节点同步数据的流量控制，每当给该follower发送同步消息时，就占用该缓冲区的一个空间；反之，当收到该follower的成功接收了该同步消息的应答之后，就释放缓冲区的空间。&lt;/p&gt;
&lt;p&gt;当该缓冲区数据饱和时，将暂停继续同步数据到该follower。&lt;/p&gt;
&lt;p&gt;##快照、日志的存储&lt;/p&gt;
&lt;h1 id=&#34;疑问采集&#34;&gt;疑问采集&lt;/h1&gt;
</description>
      
    </item>
    
    <item>
      <title>Raft算法原理</title>
      <link>https://www.codedump.info/post/20180921-raft/</link>
      <pubDate>Fri, 21 Sep 2018 20:15:32 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20180921-raft/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd的raft实现是最接近论文本身的，结合论文原理一起阅读十分酸爽。这个系列文章的索引如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我个人还针对etcd 3.1.10版本的raft相关代码实现做了一些代码的注释笔记，地址在此：&lt;a href=&#34;https://github.com/lichuang/etcd-3.1.10-codedump&#34;&gt;etcd-3.1.10-codedump&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;关于Raft算法，有两篇经典的论文，一篇是《In search of an Understandable Consensus Algorithm》，这是作者最开始讲述Raft算法原理的论文，但是这篇论文太简单了，很多算法的细节没有涉及到。更详细的论文是《Consensus: Bridging Theory and Practice》，除了包括第一篇论文的内容以外，还加上了很多细节的描述。在我阅读完etcd raft算法库的实现之后，发现这个库的代码基本就是按照后一篇论文来写的，甚至有部分测试用例的注释里也写明了是针对这篇论文的某一个小节的情况做验证。&lt;/p&gt;
&lt;p&gt;这篇文章做为我后续分析etcd raft算法的前导文章，将结合后一篇论文加上一些自己的演绎和理解来讲解Raft算法的原理。&lt;/p&gt;
&lt;h1 id=&#34;算法的基本流程&#34;&gt;算法的基本流程&lt;/h1&gt;
&lt;h2 id=&#34;raft算法概述&#34;&gt;Raft算法概述&lt;/h2&gt;
&lt;p&gt;Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。&lt;/p&gt;
&lt;p&gt;通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader选举：集群中必须存在一个leader节点。&lt;/li&gt;
&lt;li&gt;日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。&lt;/li&gt;
&lt;li&gt;安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引
的另一条日志数据输入到raft状态机中执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Raft算法需要一直保持的几个属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选举安全性（Election Safety）：在一个任期内只能存在最多一个leader节点。&lt;/li&gt;
&lt;li&gt;Leader节点上的日志为只添加（Leader Append-Only）：leader节点永远不会删除或者覆盖本节点上面的日志数据，leader节点上写日志的操作只可能是添加操作。&lt;/li&gt;
&lt;li&gt;日志匹配性（Log Matching）：如果两个节点上的日志，在日志的某个索引上的日志数据其对应的任期号相同，那么在两个节点在这条日志之前的日志数据完全匹配。&lt;/li&gt;
&lt;li&gt;leader完备性（Leader Completeness）：如果一条日志在某个任期被提交，那么这条日志数据在leader节点上更高任期号的日志数据中都存在。&lt;/li&gt;
&lt;li&gt;状态机安全性（State Machine Safety）：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引的另一条日志数据输入到raft状态机中执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/raft-propertities.png&#34; alt=&#34;raft-propertities&#34; title=&#34;raft-propertities&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;raft算法基础&#34;&gt;Raft算法基础&lt;/h2&gt;
&lt;p&gt;在Raft算法中，一个集群里面的所有节点有以下三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader：领导者，一个集群里只能存在一个Leader。&lt;/li&gt;
&lt;li&gt;Follower：跟随者，follower是被动的，一个客户端的修改数据请求如果发送到Follower上面时，会首先由Follower重定向到Leader上，&lt;/li&gt;
&lt;li&gt;Candidate：参与者，一个节点切换到这个状态时，将开始进行一次新的选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一次开始一次新的选举时，称为一个“任期”。每个任期都有一个对应的整数与之关联，称为“任期号”，任期号用单词“Term”表示，这个值是一个严格递增的整数值。&lt;/p&gt;
&lt;p&gt;节点的状态切换状态机如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/raft-states.jpg&#34; alt=&#34;raft states&#34; title=&#34;raft states&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中标记了状态切换的6种路径，下面做一个简单介绍，后续都会展开来详细讨论。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;start up：起始状态，节点刚启动的时候自动进入的是follower状态。&lt;/li&gt;
&lt;li&gt;times out, starts election：follower在启动之后，将开启一个选举超时的定时器，当这个定时器到期时，将切换到candidate状态发起选举。&lt;/li&gt;
&lt;li&gt;times out, new election：进入candidate 状态之后就开始进行选举，但是如果在下一次选举超时到来之前，都还没有选出一个新的leade，那么还会保持在candidate状态重新开始一次新的选举。&lt;/li&gt;
&lt;li&gt;receives votes from majority of servers：当candidate状态的节点，收到了超过半数的节点选票，那么将切换状态成为新的leader。&lt;/li&gt;
&lt;li&gt;discovers current leader or new term：candidate状态的节点，如果收到了来自leader的消息，或者更高任期号的消息，都表示已经有leader了，将切换回到follower状态。&lt;/li&gt;
&lt;li&gt;discovers server with higher term：leader状态下如果收到来自更高任期号的消息，将切换到follower状态。这种情况大多数发生在有网络分区的状态下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个candidate在一次选举中赢得leader，那么这个节点将在这个任期中担任leader的角色。但并不是每个任期号都一定对应有一个leader的，比如上面的情况3中，可能在选举超时到来之前都没有产生一个新的leader，那么此时将递增任期号开始一次新的选举。&lt;/p&gt;
&lt;p&gt;从以上的描述可以看出，任期号在raft算法中更像一个“逻辑时钟（logic clock）”的作用，有了这个值，集群可以发现有哪些节点的状态已经过期了。每一个节点状态中都保存一个当前任期号（current term），节点在进行通信时都会带上本节点的当前任期号。如果一个节点的当前任期号小于其他节点的当前任期号，将更新其当前任期号到最新的任期号。如果一个candidate或者leader状态的节点发现自己的当前任期号已经小于其他节点了，那么将切换到follower状态。反之，如果一个节点收到的消息中带上的发送者的任期号已经过期，将拒绝这个请求。&lt;/p&gt;
&lt;p&gt;raft节点之间通过RPC请求来互相通信，主要有以下两类RPC请求。RequestVote RPC用于candidate状态的节点进行选举之用，而AppendEntries RPC由leader节点向其他节点复制日志数据以及同步心跳数据的。&lt;/p&gt;
&lt;h2 id=&#34;leader选举&#34;&gt;leader选举&lt;/h2&gt;
&lt;p&gt;现在来讲解leader选举的流程。&lt;/p&gt;
&lt;p&gt;raft算法是使用心跳机制来触发leader选举的。&lt;/p&gt;
&lt;p&gt;在节点刚开始启动时，初始状态是follower状态。一个follower状态的节点，只要一直收到来自leader或者candidate的正确RPC消息的话，将一直保持在follower状态。leader节点通过周期性的发送心跳请求（一般使用带有空数据的AppendEntries RPC来进行心跳）来维持着leader节点状态。每个follower同时还有一个选举超时（election timeout）定时器，如果在这个定时器超时之前都没有收到来自leader的心跳请求，那么follower将认为当前集群中没有leader了，将发起一次新的选举。&lt;/p&gt;
&lt;p&gt;发起选举时，follower将递增它的任期号然后切换到candidate状态。然后通过向集群中其它节点发送RequestVote RPC请求来发起一次新的选举。一个节点将保持在该任期内的candidate状态下，直到以下情况之一发生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该candidate节点赢得选举，即收到超过半数以上集群中其它节点的投票。&lt;/li&gt;
&lt;li&gt;另一个节点成为了leader。&lt;/li&gt;
&lt;li&gt;选举超时到来时没有任何一个节点成为leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面来逐个分析以上几种情况。&lt;/p&gt;
&lt;p&gt;第一种情况，如果收到了集群中半数以上节点的投票，那么此时candidate节点将成为新的leader。每个节点在一个任期中只能给一个节点投票，而且遵守“先来后到”的原则。这样就保证了，每个任期最多只有一个节点会赢得选举成为leader。但并不是每个进行选举的candidate节点都会给它投票，在后续的“选举安全性”一节中将展开讨论这个问题。当一个candidate节点赢得选举成为leader后，它将发送心跳消息给其他节点来宣告它的权威性以阻止其它节点再发起新的选举。&lt;/p&gt;
&lt;p&gt;第二种情况，当candidate节点等待其他节点时，如果收到了来自其它节点的AppendEntries RPC请求，同时做个请求中带上的任期号不比candidate节点的小，那么说明集群中已经存在leader了，此时candidate节点将切换到follower状态；但是，如果该RPC请求的任期号比candidate节点的小，那么将拒绝该RPC请求继续保持在candidate状态。&lt;/p&gt;
&lt;p&gt;第三种情况，一个candidate节点在选举超时到来的时候，既没有赢得也没有输掉这次选举。这种情况发生在集群节点数量为偶数个，同时有两个candidate节点进行选举，而两个节点获得的选票数量都是一样时。当选举超时到来时，如果集群中还没有一个leader存在，那么candidate节点将继续递增任期号再次发起一次新的选举。这种情况理论上可以一直无限发生下去。&lt;/p&gt;
&lt;p&gt;为了减少第三种情况发生的概率，每个节点的选举超时时间都是随机决定的，一般在150~300毫秒之间，这样两个节点同时超时的情况就很罕见了。&lt;/p&gt;
&lt;p&gt;以上过程用伪代码来表示如下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;节点刚启动，进入follower状态，同时创建一个超时时间在150-300毫秒之间的选举超时定时器。

follower状态节点主循环：
  如果收到leader节点心跳：
    心跳标志位置1

  如果选举超时到期：
    没有收到leader节点心跳：
      任期号term+1，换到candidate状态。
    如果收到leader节点心跳：
      心跳标志位置空

  如果收到选举消息：
    如果当前没有给任何节点投票过 或者 消息的任期号大于当前任期号：
      投票给该节点
    否则：
      拒绝投票给该节点

candidate状态节点主循环：
  向集群中其他节点发送RequestVote请求，请求中带上当前任期号term

  收到AppendEntries消息：
    如果该消息的任期号 &amp;gt;= 本节点任期号term：
      说明已经有leader，切换到follower状态
    否则：
      拒绝该消息

  收到其他节点应答RequestVote消息：
    如果数量超过集群半数以上，切换到leader状态
    
  如果选举超时到期：
    term+1，进行下一次的选举
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;日志复制&#34;&gt;日志复制&lt;/h2&gt;
&lt;p&gt;日志复制的流程大体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个客户端的请求都会被重定向发送给leader，这些请求最后都会被输入到raft算法状态机中去执行。&lt;/li&gt;
&lt;li&gt;leader在收到这些请求之后，会首先在自己的日志中添加一条新的日志条目。&lt;/li&gt;
&lt;li&gt;在本地添加完日志之后，leader将向集群中其他节点发送AppendEntries RPC请求同步这个日志条目，当这个日志条目被成功复制之后（什么是成功复制，下面会谈到），leader节点将会将这条日志输入到raft状态机中，然后应答客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Raft日志的组织形式如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/raftlog.jpg&#34; alt=&#34;raftlog&#34; title=&#34;raft log&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个日志条目包含以下成员。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;index：日志索引号，即图中最上方的数字，是严格递增的。&lt;/li&gt;
&lt;li&gt;term：日志任期号，就是在每个日志条目中上方的数字，表示这条日志在哪个任期生成的。&lt;/li&gt;
&lt;li&gt;command：日志条目中对数据进行修改的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一条日志如果被leader同步到集群中超过半数的节点，那么被称为“成功复制”，leader节点在收到半数以上的节点应答某条日志之后，就会提交该日志，此时日志这个日志条目就是“已被提交（committed）”。如果一条日志已被提交，那么在这条日志之前的所有日志条目也是被提交的，包括之前其他任期内的leader提交的日志。如上图中索引为7的日志条目之前的所有日志都是已被提交的日志。&lt;/p&gt;
&lt;p&gt;以下面的图示来说明日志复制的流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/log-replication-1.png&#34; alt=&#34;log-replication-1&#34; title=&#34;log replication 1&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，一个请求有以下步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送SET a=1的命令到leader节点上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;leader节点在本地添加一条日志，其对应的命令为SET a=1。这里涉及到两个索引值，committedIndex存储的最后一条提交（commit）日志的索引，appliedIndex存储的是最后一条应用到状态机中的日志索引值，一条日志只有被提交了才能应用到状态机中，因此总有 committedIndex &amp;gt;= appliedIndex不等式成立。在这里只是添加一条日志还并没有提交，两个索引值还指向上一条日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;leader节点向集群中其他节点广播AppendEntries消息，带上SET a=1命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/log-replication-2.png&#34; alt=&#34;log-replication-2&#34; title=&#34;log replication 2&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来继续看，上图中经历了以下步骤。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;收到AppendEntries请求的follower节点，同样在本地添加了一条新的日志，也还并没有提交。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;follower节点向leader节点应答AppendEntries消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;当leader节点收到集群半数以上节点的AppendEntries请求的应答消息时，认为SET a=1命令成功复制，可以进行提交，于是修改了本地committed日志的索引指向最新的存储SET a=1的日志，而appliedIndex还是保持着上一次的值，因为还没有应用该命令到状态机中。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/log-replication-3.png&#34; alt=&#34;log-replication-3&#34; title=&#34;log replication 3&#34;&gt;&lt;/p&gt;
&lt;p&gt;当这个命令提交完成了之后，命令就可以提交给应用层了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;提交命令完成，给应用层说明这条命令已经提交。此时修改appliedIndex与committedIndex一样了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;leader节点在下一次给follower的AppendEntries请求中，会带上当前最新的committedIndex索引值，follower收到之后同样会修改本地日志的committedIndex索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，7和8这两个操作并没有严格的先后顺序，谁在前在后都没关系。&lt;/p&gt;
&lt;p&gt;leader上保存着已被提交的最大日志索引信息，这个索引值被称为“nextIndex”，在每次向follower节点发送的AppendEntries RPC请求中都会带上这个索引信息，这样follower节点就知道哪个日志已经被提交了，被提交的日志将会输入Raft状态机中执行。&lt;/p&gt;
&lt;p&gt;Raft算法保持着以下两个属性，这两个属性共同作用满足前面提到的日志匹配（LogMatch）属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果两个日志条目有相同的索引号和任期号，那么这两条日志存储的是同一个指令。&lt;/li&gt;
&lt;li&gt;如果在两个不同的日志数据中，包含有相同索引和任期号的日志条目，那么在这两个不同的日志中，位于这条日志之前的日志数据是相同的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新leader与follower同步数据&#34;&gt;新leader与follower同步数据&lt;/h2&gt;
&lt;p&gt;在正常的情况下，follower节点和leader节点的日志一直保持一致，此时AppendEntries RPC请求将不会失败。但是，当leader节点宕机时日志就可能出现不一致的情况，比如在这个leader节点宕机之前同步的数据并没有得到超过半数以上节点都复制成功了。如下图所示就是一种出现前后日志不一致的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/inconsistentlog.jpg&#34; alt=&#34;inconsistent logs&#34; title=&#34;inconsistent logs&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，最上面的一排数字是日志的索引，盒子中的数据是该日志对应的任期号，左边的字母表示的是a-f这几个不同的节点。图中演示了好几种节点日志与leader节点日志不一致的情况，下面说明中以二元组&amp;lt;任期号，索引号&amp;gt;来说明各个节点的日志数据情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader节点：&amp;lt;6, 10&amp;gt;。&lt;/li&gt;
&lt;li&gt;a节点：&amp;lt;6,9&amp;gt;，缺少日志。&lt;/li&gt;
&lt;li&gt;b节点：&amp;lt;4,4&amp;gt;，任期号比leader小，因此缺少日志。&lt;/li&gt;
&lt;li&gt;c节点：&amp;lt;6,11&amp;gt;，任期号与leader相同，但是有比leader日志索引更大的日志，这部分日志是未提交的日志。&lt;/li&gt;
&lt;li&gt;d节点：&amp;lt;7,12&amp;gt;，任期号比leader大，这部分日志是未提交的日志。&lt;/li&gt;
&lt;li&gt;e节点：&amp;lt;4,7&amp;gt;，任期号与索引都比leader小，因此既缺少日志，也有未提交的日志。&lt;/li&gt;
&lt;li&gt;f节点：&amp;lt;3,11&amp;gt;，任期号比leader小，所以缺少日志，而索引比leader大，这部分日志又是未提交的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Raft算法中，解决日志数据不一致的方式是Leader节点同步日志数据到follower上，覆盖follower上与leader不一致的数据。&lt;/p&gt;
&lt;p&gt;为了解决与follower节点同步日志的问题，leader节点中存储着两个与每个follower节点日志相关的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nextIndex存储的是下一次给该节点同步日志时的日志索引。&lt;/li&gt;
&lt;li&gt;matchIndex存储的是该节点的最大日志索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从以上两个索引的定义可知，在follower与leader节点之间日志复制正常的情况下，nextIndex = matchIndex + 1。但是如果出现不一致的情况，则这个等式可能不成立。每个leader节点被选举出来时，将做如下初始化操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nextIndex为leader节点最后一条日志。&lt;/li&gt;
&lt;li&gt;matchIndex为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这么做的原因在于：leader节点将从后往前探索follower节点当前存储的日志位置，而在不知道follower节点日志位置的情况下只能置空matchIndex了。&lt;/p&gt;
&lt;p&gt;leader节点通过AppendEntries消息来与follower之间进行日志同步的，每次给follower带过去的日志就是以nextIndex来决定，其可能有两种结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果follower节点的日志与这个值匹配，将返回成功；&lt;/li&gt;
&lt;li&gt;否则将返回失败，同时带上本节点当前的最大日志ID（假设这个索引为hintIndex），方便leader节点快速定位到follower的日志位置以下一次同步正确的日志数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而leader节点在收到返回失败的情况下，将置&lt;code&gt;nextIndex = min(hintIndex+1,上一次append消息的索引)&lt;/code&gt;，再次发出添加日志请求。&lt;/p&gt;
&lt;p&gt;以上图的几个节点为例来说明情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始状态下，leader节点将存储每个folower节点的nextIndex为10，matchIndex为0。因此在成为leader节点之后首次向follower节点同步日志数据时，将复制索引位置在10以后的日志数据，同时带上日志二元组&amp;lt;6,10&amp;gt;告知follower节点当前leader保存的follower日志状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a节点：由于节点的最大日志数据二元组是&amp;lt;6,9&amp;gt;，正好与leader发过来的日志&amp;lt;6,10&amp;gt;紧挨着，因此返回复制成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（注：在下面解释每个follower与leader同步流程的示意图中，follower节点回应的消息，格式是&amp;lt;append消息的索引,当前follower当前的最大消息索引&amp;gt;，比如&amp;lt;10,4&amp;gt;表示接收到leader发过来的append消息索引是10，而当前该follower最大消息索引是4。）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-a.png&#34; alt=&#34;leader-to-a&#34; title=&#34;leader-to-a&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;b节点：由于节点的最大日志数据二元组是&amp;lt;4,4&amp;gt;，与leader发送过来的日志数据&amp;lt;6,10&amp;gt;不匹配，将返回失败同时带上自己最后的日志索引4（即hintIndex=4），leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为min(10,4+1)=5，所以下一次leader节点将同步从索引5到10的数据给b节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-b.png&#34; alt=&#34;leader-to-b&#34; title=&#34;leader-to-b&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c节点：由于节点的最大日志数据二元组是&amp;lt;6,11&amp;gt;，与leader发送过来的日志数据&amp;lt;6,10&amp;gt;不匹配，由于两者任期号相同，节点C知道自己的索引11的数据需要删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-c.png&#34; alt=&#34;leader-to-c&#34; title=&#34;leader-to-c&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d节点：由于节点的最大日志数据二元组是&amp;lt;7,12&amp;gt;，与leader发送过来的日志数据&amp;lt;6,10&amp;gt;不匹配，索引11、12的数据将被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-d.png&#34; alt=&#34;leader-to-d&#34; title=&#34;leader-to-d&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e节点：由于节点的最大日志数据二元组是&amp;lt;4,7&amp;gt;，与leader发送过来的日志数据&amp;lt;6,10&amp;gt;不匹配，将返回最后一个与节点数据一致的索引5给leader，于是leader从min(5+1,10)=6开始同步数据给节点e，最终e节点上索引7的数据被覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-e.png&#34; alt=&#34;leader-to-e&#34; title=&#34;leader-to-e&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;f节点：由于节点的最大日志数据二元组是&amp;lt;3,11&amp;gt;，与leader发送过来的日志数据&amp;lt;6,10&amp;gt;不匹配，将返回最后一个与节点数据一致的索引3给leader，于是leader从min(3+1,10)=4开始同步数据给节点f，最终f节点上索引4之后的数据被覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/leader-to-f.png&#34; alt=&#34;leader-to-f&#34; title=&#34;leader-to-f&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;
&lt;p&gt;前面章节已经将leader选举以及日志同步的机制介绍了，这一小节讲解安全性相关的内容。&lt;/p&gt;
&lt;h3 id=&#34;选举限制&#34;&gt;选举限制&lt;/h3&gt;
&lt;p&gt;raft算法中，并不是所有节点都能成为leader。一个节点要成为leader，需要得到集群中半数以上节点的投票，而一个节点会投票给一个节点，其中一个充分条件是：这个进行选举的节点的日志，比本节点的日志更新。之所以要求这个条件，是为了保证每个当选的节点都有当前最新的数据。为了达到这个检查日志的目的，RequestVote RPC请求中需要带上参加选举节点的日志信息，如果节点发现选举节点的日志信息并不比自己更新，将拒绝给这个节点投票。&lt;/p&gt;
&lt;p&gt;如果判断日志的新旧？这通过对比日志的最后一个日志条目数据来决定，首先将对比条目的任期号，任期号更大的日志数据更新；如果任期号相同，那么索引号更大的数据更新。&lt;/p&gt;
&lt;p&gt;以上处理RequestVote请求的流程伪代码表示如下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;follower节点收到RequestVote请求：
  对比RequestVote请求中带上的最后一条日志数据：
    如果任期号比节点的最后一条数据任期号小：
      拒绝投票给该节点
    如果索引号比节点的最后一条数据索引小：
      拒绝投票给该节点
    其他情况：
      说明选举节点的日志信息比本节点更新，投票给该节点。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;提交前面任期的日志条目&#34;&gt;提交前面任期的日志条目&lt;/h3&gt;
&lt;p&gt;如果leader在写入但是还没有提交一条日志之前崩溃，那么这条没有提交的日志是否能提交？有几种情况需要考虑，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/preterm-log.jpeg&#34; alt=&#34;pre term log&#34; title=&#34;pre term log&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，有以下的场景变更。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;情况a：s1是leader，index 2位置写入了数据2，该值只写在了s1，s2上，但是还没有被提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况b: s1崩溃，s5成为新的leader，该节点在index 2上面提交了另外一个值3，但是这个值只写在了s5上面，并没有被提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情况c: s5崩溃，s1重新成为leader，这一次，index 2的值2写到了集群的大多数节点上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时可能存在以下两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况d1: s1崩溃，s5重新成为leader（投票给s5的是s4，s2和s5自身），那么index 2上的值3这一次成功的写入到集群的半数以上节点之上，并成功提交。&lt;/li&gt;
&lt;li&gt;情况d2: s1不崩溃，而是将index 2为2的值成功提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从情况d的两种场景可以看出，在index 2值为2，且已经被写入到半数以上节点的情况下，同样存在被新的leader覆盖的可能性。&lt;/p&gt;
&lt;p&gt;由于以上的原因，对于当前任期之前任期提交的日志，并不通过判断是否已经在半数以上集群节点写入成功来作为能否提交的依据。只有当前leader任期内的日志是通过比较写入数量是否超过半数来决定是否可以提交的。&lt;/p&gt;
&lt;p&gt;对于任期之前的日志，Raft采用的方式，是只要提交成功了当前任期的日志，那么在日志之前的日志就认为提交成功了。这也是为什么etcd-Raft代码中，在成为leader之后，需要再提交一条dummy的日志的原因&amp;ndash;只要该日志提交成功，leader上该日志之前的日志就可以提交成功。&lt;/p&gt;
&lt;h1 id=&#34;集群成员变更&#34;&gt;集群成员变更&lt;/h1&gt;
&lt;p&gt;在上面描述Raft基本算法流程中，都假设集群中的节点是稳定不变的。但是在某些情况下，需要手动改变集群的配置。&lt;/p&gt;
&lt;h2 id=&#34;安全性-1&#34;&gt;安全性&lt;/h2&gt;
&lt;p&gt;安全性是变更集群成员时首先需要考虑到的问题，任何时候都不能出现集群中存在一个以上leader的情况。为了避免出现这种情况，每次变更成员时不能一次添加或者修改超过一个节点，集群不能直接切换到新的状态，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/disjoint-majorities.jpg&#34; alt=&#34;disjoint majorities&#34; title=&#34;disjoint majorities&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，server 1、2、3组成的是旧集群，server 4、5是准备新加入集群的节点。注意到如果直接尝试切换到新的状态，在某些时间点里，如图中所示，由于server 1、2上的配置还是旧的集群配置，那么可能这两个节点已经选定了一个leader；而server 3、4、5又是新的配置，它们也可能选定了一个leader，而这两个leader不是同一个，这就出现了集群中存在一个以上leader的情况了。&lt;/p&gt;
&lt;p&gt;反之，下图所示是分别往奇数个以及偶数个集群节点中添加删除单个节点的场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/change-single-server.jpg&#34; alt=&#34;change single server&#34; title=&#34;change single server&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，不论旧集群节点数量是奇数还是偶数个，都不会出现同时有两个超过半数以上子集群的存在，也就不可能选出超过一个leader。&lt;/p&gt;
&lt;p&gt;raft采用将修改集群配置的命令放在日志条目中来处理，这样做的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以继续沿用原来的AppendEntries命令来同步日志数据，只要把修改集群的命令做为一种特殊的命令就可以了。&lt;/li&gt;
&lt;li&gt;在这个过程中，可以继续处理客户端请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可用性&#34;&gt;可用性&lt;/h2&gt;
&lt;h3 id=&#34;添加新节点到集群中&#34;&gt;添加新节点到集群中&lt;/h3&gt;
&lt;p&gt;添加一个新的节点到集群时，需要考虑一种情况，即新节点可能落后当前集群日志很多的情况，在这种情况下集群出现故障的概率会大大提高，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/add-new-server.jpg&#34; alt=&#34;add-new-server&#34; title=&#34;add-new-server&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中的情况a中，s1、s2、s3是原有的集群节点，这时把节点s4添加进来，而s4上又什么数据都没有。如果此时s3发生故障，在集群中原来有三个节点的情况下，本来可以容忍一个节点的失败的；但是当变成四个节点的集群时，s3和s4同时不可用整个集群就不可用了。&lt;/p&gt;
&lt;p&gt;因此Raft算法针对这种新添加进来的节点，是如下处理的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加进来的新节点首先将不加入到集群中，而是等待数据追上集群的进度。&lt;/li&gt;
&lt;li&gt;leader同步数据给新节点的流程是，划分为多个轮次，每一轮同步一部分数据，而在同步的时候，leader仍然可以写入新的数据，只要等新的轮次到来继续同步就好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下图来说明同步数据的流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/new-server-sync-logs.jpg&#34; alt=&#34;new-server-sync-logs&#34; title=&#34;new-server-sync-logs&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中，划分为多个轮次来同步数据。比如，在第一轮同步数据时，leader的最大数据索引为10，那么第一轮就同步10之前的数据。而在同步第一轮数据的同时，leader还能继续接收新的数据，假设当同步第一轮完毕时，最大数据索引变成了20，那么第二轮将继续同步从10到20的数据。以此类推。&lt;/p&gt;
&lt;p&gt;这个同步的轮次并不能一直持续下去，一般会有一个限制的轮次数量，比如最多同步10轮。&lt;/p&gt;
&lt;h3 id=&#34;删除当前集群的leader节点&#34;&gt;删除当前集群的leader节点&lt;/h3&gt;
&lt;p&gt;当需要下线当前集群的leader节点时，leader节点将发出一个变更节点配置的命令，只有在该命令被提交之后，原先的leader节点才下线，然后集群会自然有一个节点选举超时而进行新的一轮选举。&lt;/p&gt;
&lt;h3 id=&#34;处理移出集群的节点&#34;&gt;处理移出集群的节点&lt;/h3&gt;
&lt;p&gt;如果某个节点在一次配置更新之后，被移出了新的集群，但是这个节点又不知道这个情况，那么按照前面描述的Raft算法流程来说，它应该在选举超时之后，将任期号递增1，发起一次新的选举。虽然最终这个节点不会赢得选举，但是毕竟对集群运行的状态造成了干扰。而且如果这个节点一直不下线，那么上面这个发起新选举的流程就会一直持续下去。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Raft引入了一个成为“PreVote”的流程，在这个流程中，如果一个节点要发起一次新的选举，那么首先会广播给集群中的其它所有节点，询问下当前该节点上的日志是否足以赢下选举。只有在这个PreVote阶段赢得超过半数节点肯定的情况下，才真正发起一次新的选举。&lt;/p&gt;
&lt;p&gt;然而，PreVote并不能解决所有的问题，因为很有可能该被移除节点上的日志也是最新的。&lt;/p&gt;
&lt;p&gt;由于以上的原因，所以不能完全依靠判断日志的方式来决定是否允许一个节点发起新一轮的选举。&lt;/p&gt;
&lt;p&gt;Raft采用了另一种机制。如果leader节点一直保持着与其它节点的心跳消息，那么就认为leader节点是存活的，此时不允许发起一轮新的选举。这样follower节点处理RequestVote请求时，就需要加上判断，除了判断请求进行选举的节点日志是否最新以外，如果当前在一段时间内还收到过来自leader节点的心跳消息，那么也不允许发起新的选举。然而这种情况与前面描述的leader迁移的情况相悖，在leader迁移时是强制要求发起新的选举的，因此RequestVote请求的处理还要加上这种情况的判断。&lt;/p&gt;
&lt;p&gt;总结来说，RequestVote请求的处理逻辑大致是这样的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;follower处理RequestVote请求：
  如果请求节点的日志不是最新的：
    拒绝该请求，返回

  如果此时是leader迁移的情况：
    接收该请求，返回

  如果最近一段时间还有收到来自leader节点的心跳消息：
    拒绝该请求，返回

  接收该请求    
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;日志压缩&#34;&gt;日志压缩&lt;/h1&gt;
&lt;p&gt;日志数据如果不进行压缩处理掉的话，会一直增长下去。为此Raft使用快照数据来进行日志压缩，比如针对键值a的几次操作日志a=1、删除a、a=3最后可以被压缩成为最后的结果数据即a=3。&lt;/p&gt;
&lt;p&gt;快照数据和日志数据的组织形式如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20180921-raft/snapshot.png&#34; alt=&#34;snapshot&#34; title=&#34;snapshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未压缩日志前，日志数据保存到了&amp;lt;3,5&amp;gt;的位置，而在&amp;lt;2,3&amp;gt;的位置之前的数据都已经进行提交了，所以可以针对这部分数据进行压缩。&lt;/li&gt;
&lt;li&gt;压缩日志之后，快照文件中存放了几个值：压缩时最后一条日志的二元数据是&amp;lt;2,3&amp;gt;，而针对a的几次操作最后的值为a=3，b的值为2。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;杂项&#34;&gt;杂项&lt;/h1&gt;
&lt;h2 id=&#34;高效处理只读请求&#34;&gt;高效处理只读请求&lt;/h2&gt;
&lt;p&gt;前面已经提到过，处理一个命令时，需要经历以下流程：leader向集群中其它节点广播日志，在日志被超过半数节点应答之后，leader提交该日志，最后才应答客户端。这样的流程对于一个只读请求而言太久了，而且还涉及到日志落盘的操作，对于只读请求而言这些操作是不必要的。&lt;/p&gt;
&lt;p&gt;但是如果不经过上面的流程，leader节点在收到一个只读请求时就直接将本节点上保存的数据应答客户端，也是不安全的，因为这可能返回已经过期的数据。一方面leader节点可能已经发生了变化，只是这个节点并不知道；另一方面可能数据也发生了改变。返回过期的数据不符合一致性要求，因此这样的做法也是不允许的。&lt;/p&gt;
&lt;p&gt;Raft中针对只读请求是这样做处理的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;leader节点需要有当前已提交日志的信息。在前面提到过不能提交前面任期的日志条目，因此一个新leader产生之后，需要提交一条空日志，这样来确保上一个任期内的日志全部提交。&lt;/li&gt;
&lt;li&gt;leader节点保存该只读请求到来时的commit日志索引为readIndex，&lt;/li&gt;
&lt;li&gt;leader需要确认自己当前还是集群的leader，因为可能会由于有网络分区的原因导致leader已经被隔离出集群而不自知。为了达到这个目的，leader节点将广播一个heartbeat心跳消息给集群中其它节点，当收到半数以上节点的应答时，leader节点知道自己当前还是leader，同时readIndex索引也是当前集群日志提交的最大索引。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
  </channel>
</rss>
