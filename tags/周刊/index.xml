<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>周刊 on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/%E5%91%A8%E5%88%8A/</link>
    <description>Recent content in 周刊 on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 17 Apr 2022 15:16:30 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/%E5%91%A8%E5%88%8A/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>周刊（第13期）：重读Raft论文中的集群成员变更算法（一）：理论篇</title>
      <link>https://www.codedump.info/post/20220417-weekly-13/</link>
      <pubDate>Sun, 17 Apr 2022 15:16:30 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220417-weekly-13/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：以前阅读Raft大论文的时候，对“集群变更”这部分内容似懂非懂。于是最近又重读了大论文这部分的内容，以下是重读时做的一些记录。这部分内容打算分为两篇文章，上篇讲解成员变更流程的理论基础，下篇讲解实践中存在的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;重读raft论文中的集群成员变更算法一理论篇&#34;&gt;重读Raft论文中的集群成员变更算法（一）：理论篇&lt;/h1&gt;
&lt;p&gt;“集群成员变更（cluster membership change）”意指一个集群内节点的增、删操作，这在一个分布式系统中是必不可少的操作，因为并不能保证一个集群的所有节点都一直能工作的很好。Raft大论文《&lt;a href=&#34;https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf&#34;&gt;Consensus: Bridging Theory and Practice&lt;/a&gt;》中有专门的一节来讲解这部分内容。&lt;/p&gt;
&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;
&lt;p&gt;首先，Raft算法中要求所有操作都需要保证安全性（safety），即：任何时候都不能在集群中同时存在两个leader节点。“集群成员变更”算法也必须保证安全性这个大前提不能被破坏，于是论文中阐述了为什么直接变更多个节点是不被允许的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.2.png&#34; alt=&#34;4.2&#34; title=&#34;4.2&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图的图示中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧集群有1、2、3这三个节点，而需要将这个三节点的集群新增节点4、5变更到5节点集群去。&lt;/li&gt;
&lt;li&gt;如果直接如图中这样变更，由于每个节点的时间窗口并不一致，可能就会出现这种情况：
&lt;ul&gt;
&lt;li&gt;在某一时刻，节点1、2还使用的是旧集群（只含有{1,2,3}）的成员配置，而3、4、5已经是新集群（含有{1,2,3,4,5}）的成员配置了。&lt;/li&gt;
&lt;li&gt;这样就可能出现还使用旧集群节点配置的1、2选出了一个leader，以及已经使用了新集群配置的节点3、4、5选出了另一个leader的情况，于是违反了上面阐述的“安全性”要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，在上面这个错误的示例中，是由于有两类行为同时出现才导致的错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性变更多个节点。在例子中，就是一次性把4、5两个节点加入到集群中。&lt;/li&gt;
&lt;li&gt;直接（directly）变更。直接变更由于集群中不同节点的步子不一样，而不一样的节点如果出现了两个不同的集群，那么就可能导致选出两个不同的leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/cluster-membership-change.png&#34; alt=&#34;cluster-membership-change&#34; title=&#34;cluster-membership-change&#34;&gt;&lt;/p&gt;
&lt;p&gt;于是，由于这两个错误操作是一起发生才会导致错误，论文中给出了两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要么一次性严格限制只变更一个节点。&lt;/li&gt;
&lt;li&gt;如果实在想一次变更多个节点，那就不能直接变更，需要经过一个中间状态的过渡之后才能完成同时变更多个节点的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下分别来阐述这两种不同的实现。&lt;/p&gt;
&lt;h2 id=&#34;一次变更单个节点&#34;&gt;一次变更单个节点&lt;/h2&gt;
&lt;p&gt;如果限制每次只变更一个节点，那么就能保证“新、旧集合的quorum集合是有重合的”，由于有重合，这样就能保证新旧两个集群的集合不会选出不同的leader，就能间接保证安全性。&lt;/p&gt;
&lt;p&gt;论文中以下面几个例子来说明这样操作的正确性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.3.png&#34; alt=&#34;4.3&#34; title=&#34;4.3&#34;&gt;&lt;/p&gt;
&lt;p&gt;这几个图，是在两个维度上做示范的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增、删操作。&lt;/li&gt;
&lt;li&gt;原集群节点数量是奇数还是偶数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个维度的组合一共就是上面的4中情况，但是无论哪一种情况，由于都保证了“新、旧集合的quorum集合是有重合的”这个条件，于是不会选出不一样的leader来。&lt;/p&gt;
&lt;h2 id=&#34;一次变更多个节点&#34;&gt;一次变更多个节点&lt;/h2&gt;
&lt;p&gt;从上面的例子中可以看到：只要能保证一次只变更一个节点，是可以直接（directly）变更的。即：无需中间状态，直接从A集合变更到A+1集合，因为这两个集合的quorum肯定有重合。&lt;/p&gt;
&lt;p&gt;但是，在一次需要变更多个节点的情况下，就不能这样直接变更，因为会出现最开始示例的那样同时选出两个leader的情况。于是，为了解决这个问题，需要引入一个中间状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设原先的集群节点集合为C_Old，新的集群节点集合为C_New，那么首先变更配置到{C_Old,C_New}，也就是新旧集群节点集合的并集。&lt;/li&gt;
&lt;li&gt;上面这次变更提交之后，再向集群变更配置到C_New。在这次变更提交之后，那些不在C_New节点集合中的节点，收到这个变更时，自动下线退出集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以证明：上面两个步骤中，都不会出现“同时存在两个leader”的情况。&lt;/p&gt;
&lt;p&gt;从本质上来说，这种变更算法，属于一种两阶段的成员变更算法，Raft大论文中称之为“Joint Consensus（联合共识）”算法。下图中演示了Joint Consensus算法这两个阶段的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.8.png&#34; alt=&#34;4.8&#34; title=&#34;4.8&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;failover&#34;&gt;Failover&lt;/h3&gt;
&lt;p&gt;我们来看看Joint Consensus算法，在变更过程中如果出错，是如何failover选出新leader的。&lt;/p&gt;
&lt;p&gt;第一阶段，这时候选出来的leader只有可能有两种情况，还是旧的C_Old节点集合，或者已经收到了{C_Old,C_New}节点集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有C_Old节点集合的节点：由于这时候这个leader并没有第一阶段提交的{C_Old,C_New}节点集合变更，因此那些已有{C_Old,C_New}节点集合的follower这部分的日志将被截断，成员变更失败，回退回C_Old集合。&lt;/li&gt;
&lt;li&gt;有{C_Old,C_New}节点集合的节点：这意味这个leader已经有第一阶段提交的{C_Old,C_New}节点集合变更，可以继续将未完成的成员变更流程走完。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似的，也可以去推导一下在第二阶段出现leader宕机时，选出来的leader只可能具备两种情况，但是这两种情况都不可能选出多个leader。&lt;/p&gt;
&lt;h2 id=&#34;集群变更何时生效&#34;&gt;集群变更何时生效？&lt;/h2&gt;
&lt;p&gt;以上讲解完毕两种不同的集群变更方式，下面来聊一聊集群变更何时生效。&lt;/p&gt;
&lt;p&gt;在Raft、Paxos这类状态机模型的一致性算法中，将任何变更操作都认为是一个命令（Command），命令的处理流程是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态机收到命令，首先在自己本地将命令持久化。&lt;/li&gt;
&lt;li&gt;然后广播给集群中的其他节点。&lt;/li&gt;
&lt;li&gt;当收到集群半数以上节点的应答时，认为命令是可以被提交（commit）的，于是可以生效将这些已经被提交的日志传给应用层的状态机使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上流程可以看到：一条命令，只有在“提交（commit）”之后才能“生效（apply）”。&lt;/p&gt;
&lt;p&gt;在Raft中，“成员变更”这个操作，也是一类命令，即：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Command&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;LogEntry,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;MembershipChange,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;};&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样设计的好处在于：处理成员变更操作，和一般的日志并没有区别，于是不存在一个特定的时间被称为“处理成员变更的时间”，在这个时间里停止响应一般的命令。&lt;/p&gt;
&lt;p&gt;但是与一般命令不同的是，“成员变更”操作并不需要等到多数通过才能生效。注意，对于一般命令而言，要“生效”必须首先“提交”，而集群变更类命令的生效没有这个依赖关系。&lt;/p&gt;
&lt;p&gt;即，在Raft的成员变更流程中，节点在收到一个新集群节点配置之后，是马上生效的，无需等待半数以上通过。&lt;/p&gt;
&lt;p&gt;这是在阅读Raft论文这一部分内容时，经常被忽略的部分。为什么集群变更类指令，可以这么做，以及这样做会不会出问题？&lt;/p&gt;
&lt;p&gt;为了安全性，Raft在进行集群变更操作时，无论是“单次变更一个节点”还是“一次变更多个节点”，在不同的阶段都不能有重叠（overlap）的情况出现，因为重叠意味着可能违反前面提到的安全性。比如将一个集群节点集合从{1,2,3}变更为{1,4,5}，如果使用这两种方式，步骤分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次变更一个节点：{1,2,3}-&amp;gt;{1,2,3,4} （增加节点4）-&amp;gt;{1,2,3,4,5} （增加节点5）-&amp;gt;{1,3,4,5} （删除节点2）-&amp;gt; {1,4,5} （删除节点3）。&lt;/li&gt;
&lt;li&gt;单次变更多个节点：{1,2,3}（C_Old）-&amp;gt; {1,2,3,4,5}（{C_Old,C_New}）-&amp;gt; {1,4,5}（C_Old,C_New）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，无论采用哪一种方式，都会有多个步骤。由leader来决定当前的步骤，其判断的标准是：前一步修改的日志，是否已经被提交（半数以上同意）。所以，如果成员变更类的日志在提交之后才生效的话，leader就需要再多一个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确认日志已经被提交到半数以上节点。&lt;/li&gt;
&lt;li&gt;在这之后，再确认这个成员变更已经在节点上生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而后面的这个确认，是可以避免的。因为根据前面&lt;code&gt;failover&lt;/code&gt;部分的分析，无论哪一种情况出现，即便在变更的过程中leader宕机，也不会出现选出多个leader的情况。&lt;/p&gt;
&lt;p&gt;于是，对于成员变更类的日志来说，Raft的规则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多次提交不能重叠（overlap），即如果当前已经有还未提交的成员变更日志，在它提交之前不允许提交新的成员变更修改。&lt;/li&gt;
&lt;li&gt;成员变更的生效，无需等待提交，每个节点在收到这类日志的时候，就能马上修改本节点上的成员为最新的这个配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raft算法要求任何时候都要保证安全性（safety）：不能在同一时间在集群中存在两个不同的leader节点。&lt;/li&gt;
&lt;li&gt;如果以下两个操作同时发生，就有可能违反安全性：
&lt;ul&gt;
&lt;li&gt;一次变更多个节点。&lt;/li&gt;
&lt;li&gt;直接变更集群的节点集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由这两个限制出发，分别有以下两种实现成员变更的算法：
&lt;ul&gt;
&lt;li&gt;限制每次只变更一个节点，这种情况下可以直接变更成员。&lt;/li&gt;
&lt;li&gt;每次可以变更任意数量的节点，但是必须通过两阶段提交完成才能生效：第一次从C_Old变成{C_Old,C_New}节点集合，第二次从{C_Old,C_New}变成C_New。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“成员变更”类命令，在Raft算法看来也是一条日志。但是与普通日志命令不同的是，成员变更类日志的生效，无需等待这条日志提交了才能生效，可以在收到之后马上生效。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第12期）：Page oriented类存储引擎里可能同时存在多种结构</title>
      <link>https://www.codedump.info/post/20220410-weekly-12/</link>
      <pubDate>Sun, 10 Apr 2022 11:38:16 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220410-weekly-12/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊Page oriented类存储引擎内的数据结构组织。在满足“向磁盘读写的基本单位是物理页面”这个大前提下，这类存储引擎的可能同时存在多种结构。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;page-oriented类存储引擎里可能同时存在多种树形结构&#34;&gt;page oriented类存储引擎里可能同时存在多种树形结构&lt;/h1&gt;
&lt;h2 id=&#34;存储引擎的分类&#34;&gt;存储引擎的分类&lt;/h2&gt;
&lt;p&gt;目前接触到的存储引擎，以向磁盘读写方式来分类的话，大体可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LSM-Tree结构。&lt;/li&gt;
&lt;li&gt;Page oriented类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LSM-Tree是“Log-Structured Merge-Tree”的简称，这类存储引擎写入一条数据的流程大体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向内存以及WAL日志中写入完成，即可认为写入成功。&lt;/li&gt;
&lt;li&gt;内存中的数据写满之后，将落盘到所谓的sstable中。&lt;/li&gt;
&lt;li&gt;sstable分为多层，随着写入进行，不同层次的sstable数据将进行合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220410-weekly-12/LSM.jpeg&#34; alt=&#34;LSM&#34; title=&#34;LSM&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片引用自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/181498475&#34;&gt;LSM树详解 - 知乎&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;从上面简单的写入LSM的流程可以看到：无论是写入内存还是磁盘，这类存储引擎在写入新数据时（不是合并sstable流程），磁盘操作的单位是一条记录。而一条记录的长度，是不定长的。&lt;/p&gt;
&lt;p&gt;与LSM-Tree类的结构不同的是，Page oriented类的存储引擎，向磁盘发起读写操作的基本单位是页面（page），一个页面通常的大小是2的次方，最小一般是1024字节，比如sqlite的存储，其页面大小为4K（可以修改编译选项配置页面大小）。&lt;/p&gt;
&lt;p&gt;以一个物理页面为读写磁盘的基本单位，这也是这一类存储引擎之所以被称为”Page oriented类存储引擎“的原因。本文重点是介绍Page oriented类存储引擎的结构。&lt;/p&gt;
&lt;h2 id=&#34;page-oriented存储引擎的结构&#34;&gt;Page oriented存储引擎的结构&lt;/h2&gt;
&lt;p&gt;还是以之前介绍过的sqlite的架构图来开头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个架构由下往上依次是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统层：提供不同系统级API的封装，比如文件读写、加解锁操作等。&lt;/li&gt;
&lt;li&gt;物理页面管理层：提供物理页面读写、缓存等功能。&lt;/li&gt;
&lt;li&gt;树形结构的实现：根据具体的树形算法，组织物理页面之间的逻辑关系（比如父子页面、兄弟页面），以及单个物理页面之内的数据的组织。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的重点是页面管理层和树形结构的实现这两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理页面管理相当于是磁盘文件的”原材料供应商“，负责对它的客户也就是各种不同结构的实现提供物理页面这一”原材料“的读写、缓存管理，而它对这些材料被客户拿去做成了什么，一无所知。&lt;/li&gt;
&lt;li&gt;树形结构的实现，从页面管理器拿到了”物理页面“这个原材料之后，可以按照自己的算法和数据结构任意塑造成任何合理的结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/database-file.png&#34; alt=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; title=&#34;数据库文件的物理页面组织和逻辑页面结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Page oriented存储引擎，在满足“向磁盘读写的基本单位是物理页面”这个大前提下，这类存储引擎的可能同时存在多种结构：可能只有B-Tree，也可能只有B+Tree。还有另一种情况是：这类存储引擎内部同时存在多种结构。&lt;/p&gt;
&lt;p&gt;以sqlite为例，内部其实就存在两种结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储索引的index tree：结构为B-Tree，键为表索引，值为这一行数据的&lt;code&gt;rowid&lt;/code&gt;，其中&lt;code&gt;rowid&lt;/code&gt;为隐藏列，创建数据表时自动生成，这一列是自增整数。&lt;/li&gt;
&lt;li&gt;存储数据的table tree：结构为B+Tree，键为&lt;code&gt;rowid&lt;/code&gt;，值为一行数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两类存储引擎，由于同属于“Page oriented类存储引擎”，因此可以共用同一个物理页面管理器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/btree-rowid.png&#34; alt=&#34;数据库文件的rowid全量数据表和索引表&#34; title=&#34;数据库文件的rowid全量数据表和索引表&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面，以sqlite中的一个表为例来解释上面这个流程。&lt;/p&gt;
&lt;p&gt;首先，创建一个表以及索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;&#34;&gt;创建数据库&lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY(&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;ID&lt;span style=&#34;color:#bbb&#34;&gt;             &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;NAME&lt;span style=&#34;color:#bbb&#34;&gt;           &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;TEXT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;AGE&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;&#34;&gt;创建索引&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;id_index&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(id);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这个建表以及创建索引之后，对应的在这个数据文件中就有了两个树形结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储&lt;code&gt;COMPANY&lt;/code&gt;表数据的table-tree。&lt;/li&gt;
&lt;li&gt;存储索引&lt;code&gt;id&lt;/code&gt;到&lt;code&gt;rowid&lt;/code&gt;关系的index-tree。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果向这个表插入数据，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INSERT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INTO&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(ID,NAME,AGE)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Paul&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，这个插入操作背后实际对应了向这两棵树的插入操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将这一行数据插入到table-tree中，同时得到&lt;code&gt;rowid&lt;/code&gt;以及插入时候的&lt;code&gt;id&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再将第一步得到的&lt;code&gt;rowid&lt;/code&gt;以及&lt;code&gt;id&lt;/code&gt;插入到index-tree中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用&lt;code&gt;id_index&lt;/code&gt;索引来查询&lt;code&gt;COMPANY&lt;/code&gt;表，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;select&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;where&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;id&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个查询操作也实际上经过了上面这两个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过存储&lt;code&gt;id_index&lt;/code&gt;到&lt;code&gt;rowid&lt;/code&gt;关系的index-tree，找到&lt;code&gt;id=1&lt;/code&gt;对应的&lt;code&gt;rowid&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后，再根据第一步得到的&lt;code&gt;rowid&lt;/code&gt;到table-tree中查询到这一行数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储引擎，按照对磁盘读写方式的不同，大体可以分为以下两类：
&lt;ul&gt;
&lt;li&gt;LSM-Tree：写磁盘的基本单位是一条记录，而一条记录大小是不定长的。&lt;/li&gt;
&lt;li&gt;Page oriented：读写磁盘的基本单位是页面，页面大小为2的次方。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“Page oriented”类存储引擎的核心模块是页面管理器和树形结构的实现，前者提供物理页面这一“原材料”的读写操作，对页面内部的结构一无所知；后者组织管理物理页面间的逻辑关系，以及物理页面内部的数据。&lt;/li&gt;
&lt;li&gt;在满足“读写磁盘的基本单位是页面”的大前提下，“Page oriented”类存储引擎可以使用各种树形结构，还可能在同一个存储引擎中同时存在多种树形结构。&lt;/li&gt;
&lt;li&gt;sqlite的实现，内部存在两种不同的树形结构：使用B-Tree来管理索引数据，以B+Tree来管理表数据。这是因为：
&lt;ul&gt;
&lt;li&gt;索引数据的值只有&lt;code&gt;rowid&lt;/code&gt;这样的整型数据，所以单个物理页面内能存储更多的索引数据，适合使用B-Tree这样“高而瘦”的结构来管理这类单条数据很小的数据。&lt;/li&gt;
&lt;li&gt;而B+Tree的树形结构是“矮而胖”的结构，更适合存储管理多种不定长的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;git的第一版&#34;&gt;Git的第一版&lt;/h2&gt;
&lt;p&gt;2005年4月6日，Git发布了第一版。Git无疑是最伟大的开源软件之一，它的出现极大改变了开源软件的协作、开发方式。&lt;/p&gt;
&lt;p&gt;根据这里的“史料”（ &lt;a href=&#34;https://www.ithome.com.tw/news/95088&#34;&gt;Git十歲了！Git之父Linus Torvalds說古，大談Git開發秘辛 | iThome&lt;/a&gt; ）记载：Linus最初只花了10天就写出了第一版可以跑的Git了。&lt;/p&gt;
&lt;h2 id=&#34;使用rust编写grpc服务的初学者指南&#34;&gt;使用Rust编写gRPC服务的初学者指南&lt;/h2&gt;
&lt;p&gt;最近在使用Rust编写gRPC服务，这篇教程讲解了这部分内容，包括一应一答模式、单向stream模式、双向stream模式都有对应的代码例子，见：&lt;a href=&#34;https://dev.to/anshulgoyal15/a-beginners-guide-to-grpc-with-rust-3c7o&#34;&gt;Rust gRPC: A beginners guide to gRPC with Rust&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;在大公司工作的吐槽&#34;&gt;在大公司工作的吐槽&lt;/h2&gt;
&lt;p&gt;一位在美国工作的工程师写的国外大公司（文中是亚马逊）晋升的一些槽点，看起来和国内大公司也差不多，见：&lt;a href=&#34;https://yorotoo.medium.com/%E5%85%B3%E4%BA%8E%E5%8D%87%E8%81%8C-55dbe62ebaf&#34;&gt;关于升职 - Yang Letu - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外文中还推荐了一个推特上的吐槽：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/kantrn/status/1511791378497384454&#34;&gt;Noah Kantrowitz on Twitter: &amp;ldquo;FAANG promo committees are killing Kubernetes: A Short Thread 🧵&amp;rdquo; / Twitter&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于威尔史密斯打人一位台湾老师的社会课引导思考&#34;&gt;《关于威尔史密斯打人，一位台湾老师的社会课引导思考》&lt;/h2&gt;
&lt;p&gt;关于威尔史密斯打人，一位台湾老师的社会课引导思考，见：https://www.facebook.com/hhsleo/posts/5543635368999794&lt;/p&gt;
&lt;p&gt;（上面的文章可能需要FB权限才能打开，也可以看这篇微信公众号的转发：&lt;a href=&#34;https://mp.weixin.qq.com/s/lGJpnq89gxTPxj_KUA2ZCg&#34;&gt;关于威尔史密斯打人，一位台湾老师的社会课引导思考&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我告訴學生，我今天扮演的角色，就像是政治人物或媒體，我蓄意餵養你片面的、我想要你知道的資訊，而有超過7成的人，在這個過程中，被我操弄了，你因為我每次餵養的資訊不同，而產生立場反覆的狀況！明明政治人物應該考慮的是公益，媒體應該報導的是真相，但我若故意要操弄輿論，我只要給你我要你知道的訊息就好，對我不利的，我一概不提。慢慢的，我就可以透過這種愚弄的手法，讓民眾變成對我死忠而深信不疑的禁臠而不自知，我要你膜拜你就膜拜，我要你打砸殺你就打砸殺，我要你剷除異己你就剷除異己，我要你上刀山下油鍋，你還會爭先恐後想要身先士卒。而這樣的現象，正在世界各地上演”&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第11期）：mmap适用于存储引擎吗？</title>
      <link>https://www.codedump.info/post/20220327-weekly-11/</link>
      <pubDate>Sun, 27 Mar 2022 15:06:38 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220327-weekly-11/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊mmap技术在存储引擎中的应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mmap适用于存储引擎吗&#34;&gt;mmap适用于存储引擎吗？&lt;/h1&gt;
&lt;p&gt;想写这篇文章，主要源于两篇文章（论文）中的对mmap在存储引擎中使用的两种截然不同的观点讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反方（mmap不应该用于存储引擎）：&lt;a href=&#34;https://db.cs.cmu.edu/mmap-cidr2022/&#34;&gt;Are You Sure You Want to Use MMAP in Your Database Management System? (CIDR 2022)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;正方（mmap可以用于存储引擎）：&lt;a href=&#34;https://ayende.com/blog/196161-C/re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system&#34;&gt;re: Are You Sure You Want to Use MMAP in Your Database Management System? - Ayende @ Rahien&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于刚好看过这两种方式的btree存储引擎：sqlite的btree实现以及boltdb，所以可以结合我的认知来聊一聊这个问题。这两个存储引擎的实现都已经整理成了系列博客，这两个系列的第一篇分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200625-boltdb-1/&#34;&gt;boltdb 1.3.0实现分析（一） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先来看看一个存储引擎实现时的大体分层，以sqlite为例分为三层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;自下而上，这三个层次分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;os层：封装系统级API实现文件的读写等操作。&lt;/li&gt;
&lt;li&gt;页面管理层：提供以页面为单位的读、写、加载、缓存等操作。&lt;/li&gt;
&lt;li&gt;btree实现：btree以物理页面为单位向下一层的页面管理层来读写页面，而物理页面内部的逻辑组织（比如父子关系），以及页面内的数据组织（比如一个页面中管理的数据）由这一层负责。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以这样来简单区别理解“页面管理”模块和btree模块的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页面管理：顾名思义，页面管理模块的最基本单位是”页面“，页面的读、写、缓存、落盘、恢复、回滚等，都由页面模块负责。上一层依赖页面管理模块的btree模块，不需要关心一个页面何时缓存、何时落盘等细节。即：&lt;strong&gt;页面模块负责页面的物理级别的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;btree：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责按照btree算法，来组织页面，即负责的是页面之间逻辑关系维护。&lt;/li&gt;
&lt;li&gt;除此以外，一个页面内部的数据的物理、逻辑组织，也是btree模块来负责的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即：&lt;strong&gt;btree负责维护页面间的逻辑关系，以及一个页面内数据的组织。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/page-module.png&#34; alt=&#34;以页面物理、逻辑关系的维护看模块划分&#34; title=&#34;以页面物理、逻辑关系的维护看模块划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;在数据库文件中，通常按照页面为单位来划分文件，比如sqlite一般是4KB大小为一个物理页面，所以一个数据库文件可以看做是一个大的“物理页面数组”，这样的话每个物理页面都有一个对应的编号（从1开始），这个编号通常简称为PID（page id）。&lt;/p&gt;
&lt;p&gt;从上面的功能划分可以看到，“页面管理器（也被称为“buffer pool）”的功能是非常复杂的，这里列举几个最关键的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读页面：上层的btree要读一个数据库文件中的页面时，通常传入一个PID，由页面管理器去加载这个页面的数据。而页面数据并不是每次都会到数据库文件中一次磁盘IO读出来，也很可能在内存中，此时就不需要读磁盘操作了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写页面：当一个页面被修改后，就被称为“脏页面（dirty page）”，需要落盘；但并不是每一次修改了一个页面的内容之后就马上落盘，其原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次写事务可能修改了不止一个页面，需要以事务为单位去落盘脏页面。&lt;/li&gt;
&lt;li&gt;即便是落盘脏页面，由于涉及到写磁盘操作，所以还会用其他方式减少写磁盘的次数。比如sqlite的wal备份文件机制中，脏页面的内容是首先写入wal文件的，由于写wal文件是一次append操作而不是随机写，所以效率会更高，如果一个脏页面的内容被写入wal文件的话，那么这部分页面内容是不急于马上写入数据库文件的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存页面：由于页面缓存的功能，所以还需要一个页面缓存管理的功能，主要负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用缓存控制算法（sqlite中是LRU）将经常读到的页面缓存在内存中，这样不必每次都读磁盘加载数据。&lt;/li&gt;
&lt;li&gt;当缓存大小不够时，将脏页面落盘，空出来空间加载要读的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看了上面对页面管理器这个模块功能的描述，可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于有页面缓存的作用，所以能够精准的控制页面缓存的大小。&lt;/li&gt;
&lt;li&gt;将“脏页面落盘”这个操作，是与具体的事务有关，并不是修改完毕就能直接落盘，否则的话可能会涉及到脏写等问题。比如一个事务修改了1、2、3三个PID的页面，修改页面1之后并不能马上落盘这个修改，需要等到三个页面都改完了才行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看看如果使用mmap技术来代替上面的“页面管理器”会面对什么问题。&lt;/p&gt;
&lt;p&gt;首先，无法做到对内存容量的精准控制。&lt;/p&gt;
&lt;p&gt;其次，写事务如何处理，因为当使用mmap技术修改了一个页面时，实际上这个被修改的页面内容何时被OS内核落到硬盘，已经不由使用者来控制了，那么如何解决上面提到的一个事务修改了多个页面需要同时落盘的问题？&lt;/p&gt;
&lt;p&gt;以boltdb为例，它使用的是类似COW的机制来解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220327-weekly-11/boltdb-write.png&#34; alt=&#34;boltdb实现写事务&#34; title=&#34;boltdb实现写事务&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boltdb的数据库文件中，前面三个页面依次是：meta1页面、meta2页面、freelist页面，前两者是存储数据库元信息的页面，freelist页面可以认为是存储当前空闲页面数据。之所以需要两个meta页面，是为了保存写信息：即便一次写操作失败，因为还有另一个meta页面，这样就还能恢复回来。每个meta页面都有一个单调递增的事务id，事务id越大说明是越近的写操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图中紧跟着前面三个元页面的是页面1、2、3，假设这里的写事务就修改了这三个页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进行修改时，首先拿到当前保存较大事务id的meta页面，这里假设是meta1页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后进行写事务的页面修改，此时的修改还只是在内存中进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写事务完成之后，需要将修改落盘，将按照如下的顺序来进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，数据库文件中新增三个页面保存修改后的内容，而原来的三个页面内容不动。&lt;/li&gt;
&lt;li&gt;然后，将原先的三个页面加入freelist空闲页面链表中，这样下一次就可以回收利用了。&lt;/li&gt;
&lt;li&gt;最后，将meta1页面的修改落地。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个修改的顺序必须严格遵守，否则中间一个过程失败整个数据库文件就损坏了。只有当完成meta页面的修改，才认为这次修改完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是boltdb这个使用了mmap来做页面管理的存储引擎，应对写事务操作的手段，本质上算一个COW的做法。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“页面管理器”在整个存储引擎的架构里，处于承上启下的作用：对上提供物理页面级别的读、写、缓存控制等功能，对下使用OS系统API来实现文件读写操作。&lt;/li&gt;
&lt;li&gt;其缓存功能，能够达到精准控制页面缓存这部分内容容量的作用；另外，由于一次写事务通常不止修改了一个页面，所以还需要精准控制脏页面的落盘的时机，否则会出现写坏数据库的情况。&lt;/li&gt;
&lt;li&gt;使用mmap来替代自实现的页面管理器最大的就是这两个问题：
&lt;ul&gt;
&lt;li&gt;无法做到精准控制页面缓存容量。&lt;/li&gt;
&lt;li&gt;采用类COW的做法来解决写事务问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上面的第二个问题有解决方案，但是问题一貌似没有。所以一个存储引擎如果使用mmap来实现页面管理，可以说这个存储引擎可能只适用于“内存不敏感”的业务场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;类notepad的编辑器&#34;&gt;类notepad++的编辑器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dail8859/NotepadNext&#34;&gt;dail8859/NotepadNext: A cross-platform, reimplementation of Notepad++&lt;/a&gt;是一款基于qt编写的编辑器，仅看作者提供的软件截图可以说很像notepad++了，但是目前为止好像还只有Linux、Win版本，希望以后能有Mac版本。&lt;/p&gt;
&lt;h2 id=&#34;etcd中的红黑树实现&#34;&gt;etcd中的红黑树实现&lt;/h2&gt;
&lt;p&gt;最近在看etcd的watcher机制的实现，看着看着，发现etcd还自带了一个叫adt的包，里面手写了一个红黑树的实现：&lt;a href=&#34;https://github.com/etcd-io/etcd/tree/main/pkg/adt&#34;&gt;etcd/pkg/adt&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;一条豆瓣动态引发的疫情文学复兴&#34;&gt;一条豆瓣动态引发的“疫情文学”复兴&lt;/h2&gt;
&lt;p&gt;疫情时期的豆瓣网络文学大赛，由一条豆瓣引发的网友评论回复：&lt;a href=&#34;https://www.douban.com/note/827837123/?_dtcc=1&amp;amp;_i=7741611DTua3Gc,8390080DTua3Gc&#34;&gt;一条豆瓣动态引发的“疫情文学”复兴&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;你最好的一条职业建议是什么&#34;&gt;你最好的一条职业建议是什么？&lt;/h2&gt;
&lt;p&gt;Twitter上有人发了一个推，说他之前问过一个问题：“你最好的一条职业建议是什么？”，他得到了1300多个答案，最后他整理了12条最好的建议。这些建议，也被人整理成了中文发到了微博：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&#34;https://twitter.com/chrishlad/status/1502650707274608644&#34;&gt;Chris Hladczuk on Twitter: &amp;ldquo;So I asked &amp;ldquo;What&amp;rsquo;s your single best piece of career advice&amp;rdquo;? I got 1,300+ answers. Here are the 12 best you wish you knew yesterday👇&amp;rdquo; / Twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&#34;https://weibo.com/1727858283/Ljvv75q62&#34;&gt;宝玉xp的微博 - 微博&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第10期）：“忘记目标，专注于体系”</title>
      <link>https://www.codedump.info/post/20220319-weekly-10/</link>
      <pubDate>Sat, 19 Mar 2022 13:50:46 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220319-weekly-10/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊《掌控习惯》这本书里提到的养成习惯的方法论。我读下来一个最深的感受是：越不需要“坚持”就能做下去的事情，才越能长久做下去。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;忘记目标专注于体系&#34;&gt;“忘记目标，专注于体系”&lt;/h1&gt;
&lt;p&gt;“忘记目标，专注于体系（Forget About Setting Goals, Focus on the system Instead）”是出自《&lt;a href=&#34;https://jamesclear.com/atomic-habits&#34;&gt;Atomic Habits&lt;/a&gt;》（中文名&lt;a href=&#34;https://book.douban.com/subject/34326931//&#34;&gt;《掌控习惯 》&lt;/a&gt;）一书的一句话，个人认为这是本书最重要的一个观点。&lt;/p&gt;
&lt;p&gt;要做成一件事情，只是依靠简单的设定目标，是远远不够的，更重要的是建立一套体系，促进事情的良性循环，最终让事情发生；反之，如果一件不好的事情，经常重蹈覆辙，其根本原因也是从未改变导致这种状况一再发生的体系。如果没有建立一套体系，所做的一切只是治标不治本。&lt;/p&gt;
&lt;p&gt;这里说的“体系”，在作者的话语中就是“习惯”，作者列出了培养良好习惯的四个步骤（提示、渴求、反应和奖励）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、提示：让它显而易见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、渴求：让它有吸引力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、反应：让它简便易行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、奖励：让它令人愉悦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者将这四个步骤，总结在&lt;code&gt;习惯循环（habit-loop）&lt;/code&gt;里，如下图：&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/habit-cycle.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;习惯循环&#34; align=center /&gt;
&lt;/div&gt;
&lt;p&gt;这四个步骤缺一不可，任何一个环节做的不够的话，就难以形成习惯：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除提示，习惯形成循环永远也不会开始。&lt;/li&gt;
&lt;li&gt;降低渴求，就不会有足够的动力去行动。&lt;/li&gt;
&lt;li&gt;让行动变得困难，将无法付诸实施。&lt;/li&gt;
&lt;li&gt;如果奖励不能满足欲望，那么未来就没有理由再这样做了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有前三步，就不会有任何行为发生。没有这四个步骤，任何一种行为都不会得以重复。&lt;/p&gt;
&lt;h2 id=&#34;1提示让它显而易见&#34;&gt;1、提示：让它显而易见&lt;/h2&gt;
&lt;p&gt;在日常行为中，“原动力经常被高估，而环境的作用往往被低估”，比如经常会认为树立一个远大的目标，坚持做下去就好；而现实的情况是，行为是环境中人的函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B（行为）=f（函数）[P（人），E（环境）]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即有怎样的行为，除了和人有关系之外，还和环境有重要的关系。&lt;/p&gt;
&lt;p&gt;环境函数中，常见的两个提示是时间和地点。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样摆放在超市的东西，更容易被接触到、更显眼的商品，被购买的概率会更高。&lt;/li&gt;
&lt;li&gt;据书中列举的越战士兵的统计显示，在离开越南战场之后，毒瘾戒除率大大提高，因为生活环境发生了彻底的改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一定理给的提示是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假如不需要经常自我克制的话，做起来就会更容易。所以，没错，毅力、勇气和意志力是取得成功的要素，但是增强这些品质的途径不是期望你自己成为一个自律的人，而是创造一个有纪律的环境。&lt;/li&gt;
&lt;li&gt;消除坏习惯的最实用的方法之一是避免接触引起它的提示，比如要少玩手机就想办法远离手机；反过来，想养成好习惯比如多喝水，就把水杯放在易接触的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2渴求让它有吸引力&#34;&gt;2、渴求：让它有吸引力&lt;/h2&gt;
&lt;p&gt;习惯是多巴胺驱动的反馈回路。每一种极可能形成习惯的行为——吃垃圾食品、玩电子游戏、浏览社交媒体——都与较高浓度的多巴胺有关。每当你预测一个机会会有回报时，你体内的多巴胺浓度就会随着这种预期飙升。当你获得奖励时，大脑中激活的奖励系统，与你期待奖励时激活的系统是同一个。这就是对一种体验的期待往往比体验本身，更令人感到愉悦的原因之一。&lt;/p&gt;
&lt;p&gt;这就引出了“喜好绑定”的原理：把你需要做的事与愿意做的事绑定。比如想培养健身的习惯，那么可以让自己在健身的时候同时看喜欢看的视频做为奖励。&lt;/p&gt;
&lt;h2 id=&#34;3反应让它简便易行&#34;&gt;3、反应：让它简便易行&lt;/h2&gt;
&lt;p&gt;《精益求精》一书里举过这样的例子：“日本公司强调为人所知的‘精益生产’理念，坚持不懈地努力寻求从生产流程中去除各种浪费，直至重新设计工作环境，使得工人们的身体不必转来转去，从而避免为拿工具而浪费时间。结果是日本工厂比美国工厂效率更高，产品更可靠。“&lt;/p&gt;
&lt;p&gt;作者将这样的策略称为”因减而加“：寻找生产线上的每一个阻力点，予以清除。这样减少了无用功，反过来就增加了效率。&lt;/p&gt;
&lt;p&gt;与之类似的，有”两分钟法则”：当你开始培养一种新习惯时，它所用时间不应超过两分钟。这样的策略也有另一个原因：它们强化着你想要建立的身份。如果你连续五天现身健身房，哪怕只在那里停留两分钟，你就是在为你的新身份投赞同票。&lt;/p&gt;
&lt;h2 id=&#34;4奖励让它令人愉悦&#34;&gt;4、奖励：让它令人愉悦&lt;/h2&gt;
&lt;p&gt;保持习惯的关键是要有成就感，哪怕只是细微的感受。成就感是一个信号，它表明你的习惯有了回报，你为此付出的努力是值得的。比如，把要做的事情列成一个todo列表，完成一件划掉一项，看到todo上的事情全部划掉就是一种“奖励”。&lt;/p&gt;
&lt;p&gt;取得进步令人满意，借助于视觉量度，如移动曲别针、发夹或弹珠，你能清晰地看到自己的进步。这样做的结果是，它们强化着你的行为，并为任何活动增加一些即时满足感。视觉量度有多种形式：食物日志、健身日志、打孔忠诚卡、软件下载进度条，甚至书籍中的页码等等。&lt;/p&gt;
&lt;h2 id=&#34;作者做的总结表格&#34;&gt;作者做的总结表格&lt;/h2&gt;
&lt;p&gt;作者将根据以上四个步骤如何养成好习惯以及戒除坏习惯的方法，总结在下面的表格里。&lt;/p&gt;
&lt;h3 id=&#34;怎样养成好习惯&#34;&gt;怎样养成好习惯&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/habit-table.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;养成好习惯&#34; align=center /&gt;
&lt;/div&gt;
&lt;h3 id=&#34;怎样戒除坏习惯&#34;&gt;怎样戒除坏习惯&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/drop-habit-table.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;戒掉坏习惯&#34; align=center /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;我的实践&#34;&gt;我的实践&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为了减少睡觉前看手机，以及睡醒之后看手机的时间，我的做法是睡觉前把手机放在远离床头的地方。（避免坏习惯就让它难以被接触）。&lt;/li&gt;
&lt;li&gt;跑步时使用&lt;a href=&#34;https://github.com/yihong0618/running_page&#34;&gt;running_page&lt;/a&gt;这个项目来记录、展示我的跑步数据，一目了然也会带来更多的成就感。（奖励习惯）。&lt;/li&gt;
&lt;li&gt;年纪越大，越发现需要“坚持”去做的事情，很难做得长久。因为一提到需要“坚持”，很大原因是因为其中有阻碍、没有正反馈等等，这些都可以在上面四个步骤里找到答案。越不需要“坚持”就能做下去的事情，才越能长久做下去。所以，以后再遇到事情发现做不下去时，第一反应不应该再是什么意志力不够等原因，而是要从上面几个步骤里找到是哪里出了问题。是不够显而易见？不够有吸引力？不够简便？奖励不够？不够愉悦？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;有关sre和devops的两篇文章&#34;&gt;有关SRE和Devops的两篇文章&lt;/h2&gt;
&lt;p&gt;推荐&lt;a href=&#34;https://twitter.com/laixintao&#34;&gt;@laixintao&lt;/a&gt;有关SRE和Devops的两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kawabangga.com/posts/4145&#34;&gt;Devops 中的 Overfitting | 卡瓦邦噶！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kawabangga.com/posts/4481&#34;&gt;SRE 的工作介绍 | 卡瓦邦噶！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;flomo和刘少楠&#34;&gt;flomo和刘少楠&lt;/h2&gt;
&lt;p&gt;这周偶然在有知有行app里听到对刘少楠的采访：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/60b0dcd6e273a1e20b43dc1e&#34;&gt;E13 专访 flomo 少楠：宇宙希望我们成为普通的人，创造是我们反抗的手段 - 知行小酒馆&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;听下来感觉这个人真诚、有意思，于是又找来了几个另外的采访和文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/617f781f82dbcd91978df9da&#34;&gt;#92：一个产品人的妄念与懦弱（flomo 创始人刘少楠） - UX Coffee 设计咖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xueqiu.com/2684655177/196666266&#34;&gt;35 岁再创业，我学会了“认怂” &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/6227d4809d2fcf46aa36aea4&#34;&gt;E25｜flomo少楠：如果你没有观点，你就不值得被关注 - 组织进化论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.notion.so/pmthinking/ProductThinking-a601a12335044f349a22caf57f274c27&#34;&gt;产品沉思录（精选） ProductThinking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些听下来、看下来，对&lt;a href=&#34;https://flomoapp.com&#34;&gt;flomo&lt;/a&gt;产生了极大的兴趣，后面找一期专门聊聊我知识整理、输入的实践。&lt;/p&gt;
&lt;p&gt;这周flomo用了几天下来，初步感觉就是“个人可见的微博”，且有“标签”和“批注”功能建立碎片信息之间的联系。于是，随着在flomo上记录的东西变多，相应地，发微博、推特就会变少。&lt;/p&gt;
&lt;p&gt;这又来到以前听过的一个有意思的结论了：打败某个领域顶尖产品的，很可能并不是另一个同类产品。比如马化腾就说过：打败QQ的，可能并不会是另一个IM。&lt;/p&gt;
&lt;p&gt;消灭产品使用的场景，这个产品自然就死了，不一定非得是同类产品取而代之。&lt;/p&gt;
&lt;p&gt;所以产品为什么需要“进化”？就是为了适应不同的场景变化。比如在PC互联网时代取得统治地位的QQ，如果没有跟上移动互联网的变化，腾讯如果没有微信，可能现在也凉了。&lt;/p&gt;
&lt;h2 id=&#34;rust-语言备忘清单&#34;&gt;Rust 语言备忘清单&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中文版：&lt;a href=&#34;https://cheats.rs.kingfree.moe/&#34;&gt;Rust 语言备忘清单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文版：&lt;a href=&#34;https://cheats.rs/&#34;&gt;Rust Language Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第9期）：Mozilla rr使用简介</title>
      <link>https://www.codedump.info/post/20220313-weekly-9/</link>
      <pubDate>Sun, 13 Mar 2022 11:20:59 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220313-weekly-9/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：在之前的&lt;a href=&#34;https://www.codedump.info/post/20220227-weekly-7/&#34;&gt;周刊（第7期）：一个C系程序员的Rust初体验&lt;/a&gt;中，简单提到过Mozilla rr这款调试工具，由于这个工具并不是太为人所知，所以本文对该工具做一个简介。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mozilla-rr使用简介&#34;&gt;Mozilla rr使用简介&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://rr-project.org/&#34;&gt;rr&lt;/a&gt;是由Mozilla出品的一款调试工具，用官网的话来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rr aspires to be your primary C/C++ debugging tool for Linux, replacing — well, enhancing — gdb. You record a failure once, then debug the recording, deterministically, as many times as you want. The same execution is replayed every time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即它的特点是：可以记录下来程序运行时的上下文环境，包括线程、堆栈、寄存器等等，这样的好处有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“deterministically”：很多问题问题的产生，都与特定的环境相关，如：
&lt;ul&gt;
&lt;li&gt;线程调度执行的顺序，先执行A线程再B线程，以及反之，可能得到的是不同的结果。&lt;/li&gt;
&lt;li&gt;环境参数，如输入不同的参数，尤其一些边界条件的触发就跟输入不同的参数有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;replay：记录下来程序执行的环境之后，rr除了支持gdb方式的调试之后，还能利用环境来不停的重放程序，甚至反向来执行程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下对&lt;code&gt;rr&lt;/code&gt;的使用做一些简单的介绍。&lt;/p&gt;
&lt;h2 id=&#34;deterministically&#34;&gt;deterministically&lt;/h2&gt;
&lt;p&gt;以下面一个最简单的多线程程序来解释何为&lt;code&gt;deterministically&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;doPrint&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_create(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pid, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;, doPrint, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid = %lu&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, pid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序很简单：创建一个线程之后，打印线程的pid。&lt;/p&gt;
&lt;p&gt;如果多次执行，会发现每次打印出来的pid并不一样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ./a.out
pid = 140301410010880

$ ./a.out
pid = 139804250023680
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个原因自不必多说：每次程序执行的时候，执行环境是有变化的。&lt;/p&gt;
&lt;p&gt;这个简单的结论，对应到bug出现的场景上，有的代码可能正常的情况下没有异常，但是会出现在特定的场景下：特定的输入参数、特定的线程执行顺序，等等。换言之，问题并不是必现的，即&lt;code&gt;un-deterministically&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;的一大功能，就是要解决这个&lt;code&gt;deterministically&lt;/code&gt;问题，即在问题发现的时候，能有一个确定的环境，可以反复重现问题。&lt;/p&gt;
&lt;h2 id=&#34;record-and-replay&#34;&gt;record and replay&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;这个名字里的两个r，意指&lt;code&gt;record and replay&lt;/code&gt;，即“记录及回放”，它的使用也很简单，就是这两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;record：&lt;code&gt;rr record /your/application --args&lt;/code&gt; 记录下来程序的执行环境。&lt;/li&gt;
&lt;li&gt;replay：&lt;code&gt;rr replay&lt;/code&gt;，默认将使用最近保存的记录文件进行回放，回放时可以进入类似gdb那样的调试环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如前面那个多线程程序，使用&lt;code&gt;rr&lt;/code&gt;来记录及回放就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;record：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ rr record ./a.out
Freezing performance counters on SMIs should be turned on for maximum rr
reliability on Comet Lake and later CPUs. Consider putting
&amp;#39;w /sys/devices/cpu/freeze_on_smi - - - - 1&amp;#39; in /etc/tmpfiles.d/10-rr.conf
See &amp;#39;man 5 sysfs&amp;#39;, &amp;#39;man 5 tmpfiles.d&amp;#39; (systemd systems)
rr: Saving execution to trace directory `/home/codedump/.local/share/rr/a.out-0&amp;#39;.
pid = 139837942626048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到记录执行的时候，打印出来的&lt;code&gt;pid&lt;/code&gt;是&lt;code&gt;139837942626048&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replay：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ rr replay

...省略不重要信息...

（进入replay之后第一次执行，是按`c`）

(rr) c
Continuing.
pid = 139837942626048

（前面已经执行完毕，想要第二次执行，按`r`（run））

(rr) r
[Inferior 1 (process 36022) exited normally]
Starting program: /home/codedump/.local/share/rr/a.out-0/mmap_hardlink_4_a.out

Program stopped.
0x00007f2e8f19c100 in ?? () from /lib64/ld-linux-x86-64.so.2
(rr) c
Continuing.
pid = 139837942626048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，前后两次重放执行，打印的&lt;code&gt;pid&lt;/code&gt;都是之前记录的值&lt;code&gt;139837942626048&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就意味着：record下来的程序执行环境，后面可以不停的回放。因为重现问题的场景很重要，有时候还不好复现，那么类似&lt;code&gt;rr&lt;/code&gt;这样能记录下来执行环境并且重放的能力，对于查找问题就特别重要了。&lt;/p&gt;
&lt;h2 id=&#34;高级用法&#34;&gt;高级用法&lt;/h2&gt;
&lt;p&gt;前面提到过，使用&lt;code&gt;rr replay&lt;/code&gt;来重放记录时，实际会进入类似gdb那样的一个调试环境，在这个环境里，常用的gdb命令都可以使用，所以这些不会展开讨论，只说一下&lt;code&gt;rr&lt;/code&gt;在这里具备的一些其他更高级的调试能力。&lt;/p&gt;
&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;
&lt;p&gt;为了能够更加精准的跟进某个问题，&lt;code&gt;rr&lt;/code&gt;提供了事件（event）的概念，每个事件有与之相关的两个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程pid。&lt;/li&gt;
&lt;li&gt;事件编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;在replay的时候，可以带上&lt;code&gt;-M&lt;/code&gt;参数打印出来事件编号，比如前面的实例程序改成这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;doPrint&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;)arg);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;in thread %d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_create(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pid, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;, doPrint, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid = %lu&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, pid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里创建了10个线程，线程中分别打印循环变量，如果使用&lt;code&gt;-M&lt;/code&gt;在输出时就能看到如下的信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(rr) c
Continuing.
[rr 4450 288]pid = 140096584951552
[rr 4450 305]in thread 1
[rr 4450 313]pid = 140096574461696
[rr 4450 330]in thread 2
[rr 4450 337]pid = 140096563971840
[rr 4450 354]in thread 3
[rr 4450 361]pid = 140096555579136
[rr 4450 378]in thread 4
[rr 4450 385]pid = 140096547186432
[rr 4450 402]in thread 5
[rr 4450 409]pid = 140096538793728
[rr 4450 426]in thread 6
[rr 4450 433]pid = 140096530401024
[rr 4450 450]in thread 7
[rr 4450 457]pid = 140096522008320
[rr 4450 474]in thread 8
[rr 4450 481]pid = 140096513615616
[rr 4450 498]in thread 9
[rr 4450 505]pid = 140096505222912
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最左边显示事件的格式为&lt;code&gt;[rr pid 事件id]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;知道了事件对应的&lt;code&gt;(pid,事件id)&lt;/code&gt;二元组之后，在replay的时候，可以指定这两个值，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rr -M replay -g 事件id
或者
rr -M replay -p pid
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;让程序replay的时候迅速到达指定事件发生的场景下。比如上面的例子中，如果使用&lt;code&gt;rr -M replay -g 354&lt;/code&gt;就能马上重放到&lt;code&gt;[rr 4450 354]in thread 3&lt;/code&gt;这一处。&lt;/p&gt;
&lt;p&gt;这种基于事件的调试方式，调试那种代码相同，但是由于输入参数不同导致的问题时，特别管用，因为可以直达问题发生的环境。&lt;/p&gt;
&lt;h3 id=&#34;反向执行reverse-execution&#34;&gt;反向执行（Reverse execution）&lt;/h3&gt;
&lt;p&gt;有了记录的能力之后，&lt;code&gt;rr&lt;/code&gt;除了能正向执行程序，还能反向来执行程序，这点在那种看到程序的环境发生了变化，但是不知道怎么发生，想重试一下的情况下特别管用。&lt;/p&gt;
&lt;p&gt;单向调试执行程序时，用的是&lt;code&gt;step&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;等命令，反向执行就在这些命令前面加上&lt;code&gt;reverse-&lt;/code&gt;前缀，如&lt;code&gt;reverse-cont&lt;/code&gt;（后面的可以简写）。&lt;/p&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;p&gt;前面介绍了&lt;code&gt;rr&lt;/code&gt;要解决的问题，最后聊一下它的缺陷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rr&lt;/code&gt;最开始是由Mozilla开发的工具，看来Mozilla对这类运行时问题也是深恶痛绝，发明了很多工具试图提高效率，Rust是另外一个重要的工具，可以参见之前&lt;a href=&#34;https://www.codedump.info/post/20220227-weekly-7/&#34;&gt;周刊（第7期）：一个C系程序员的Rust初体验&lt;/a&gt;中我对Rust的使用体验。&lt;/li&gt;
&lt;li&gt;很可惜，这个工具貌似只能在Linux上面运行，并没有Win\Mac版本，而且貌似也不怎么更新了。&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;rr&lt;/code&gt;在记录时，需要记录大量的数据来保存程序运行时的场景，这样一来会给程序带来卡顿，二来会有大量的记录数据，所以并不适合直接在生产环境上使用这个工具。更适合的场景是：已经找到了重现问题的办法，此时可以搭建一个环境开启&lt;code&gt;rr&lt;/code&gt;记录下来重现时的环境，即并不适合漫无目的的就打开这个工具使用。&lt;/li&gt;
&lt;li&gt;以上&lt;code&gt;rr&lt;/code&gt;的缺陷，归根到底还是之前提到的：查找运行时的问题太难了，尽量在编译时屏蔽可能出现的问题，真等问题到了运行时再解决的时候，时间、精力、场景复现等等都是不可控的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;番外篇&#34;&gt;番外篇&lt;/h1&gt;
&lt;h2 id=&#34;rr使用的wiki&#34;&gt;rr使用的wiki&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;的github上，有一篇更为详细一些的介绍使用的&lt;a href=&#34;https://github.com/rr-debugger/rr/wiki/Usage&#34;&gt;Usage · rr-debugger/rr Wiki&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;rr视频教程&#34;&gt;rr视频教程&lt;/h2&gt;
&lt;p&gt;油管上有几个视频教程，见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hYsLBcTX00I&#34;&gt;Quick rr Demo - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=61kD3x4Pu8I&#34;&gt;rr 1.2 basic demo - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=H4iNuufAe_8&#34;&gt;Robert O&amp;rsquo;Callahan - Corporation Taming Nondeterminism - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其它文档&#34;&gt;其它文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;介绍了&lt;code&gt;rr&lt;/code&gt;是如何实现的：&lt;a href=&#34;https://arxiv.org/pdf/1705.05937.pdf&#34;&gt;Engineering Record And Replay For Deployability Extended Technical Report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gdb相关文档&#34;&gt;GDB相关文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html&#34;&gt;介绍 | 100个gdb小技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/rkubik/b96c23bd8ed58333de37f2b8cd052c30&#34;&gt;GDB cheat sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022499197&#34;&gt;gdb深入学习手册 - SegmentFault 思否&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;如何在开源项目中做重构&#34;&gt;《如何在开源项目中做重构？》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/JrxNyDKNg9MseQZ7PlG2VQ&#34;&gt;《如何在开源项目中做重构？》&lt;/a&gt;，总结了维护一个开源项目重构的经验。&lt;/p&gt;
&lt;h2 id=&#34;linux-containers-in-500-lines-of-code&#34;&gt;《Linux containers in 500 lines of code》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.lizzie.io/linux-containers-in-500-loc.html&#34;&gt;Linux containers in 500 lines of code&lt;/a&gt;，讲解Linux容器原理的文章。&lt;/p&gt;
&lt;h2 id=&#34;收集整理远程工作相关的资料&#34;&gt;收集整理远程工作相关的资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greatghoul/remote-working&#34;&gt;greatghoul/remote-working: 收集整理远程工作相关的资料&lt;/a&gt;，但是貌似已经不更新了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第8期）：技术配图的一些心得</title>
      <link>https://www.codedump.info/post/20220304-weekly-8/</link>
      <pubDate>Fri, 04 Mar 2022 22:10:11 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220304-weekly-8/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：写过不少技术文章，以及给不少技术思路手绘示例配图之后，在这方面有了一些心得，本文权当个人的一些的总结，抛砖引玉。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;技术配图的一些心得&#34;&gt;技术配图的一些心得&lt;/h1&gt;
&lt;p&gt;我觉得我们理工科出身的，对于可以量化的事情，总是很容易根据量化差异来做出判断，比如一个程序性能优化之后，能比优化之前快出多少，都能有一个量化的数字来说明。&lt;/p&gt;
&lt;p&gt;但是对于那些不能量化的东西，就很难说出具体好在哪里了。&lt;/p&gt;
&lt;p&gt;本文主题要讨论的“技术配图”就属于这种很难量化的领域，很难有一个标准来量化说明两幅图之间差别在哪里。我也是画了很多图，以及看了别人的很多配图之后，才慢慢有一些心得，本文权当个人的一些的总结，抛砖引玉。&lt;/p&gt;
&lt;p&gt;本文并不是一个画图工具的对比说明，尽管现在各种绘图工具已经很多，也各有自己的优缺点以及个人喜好，但是在这里并不讨论具体工具的使用，会把更多的文字放在配图的一些注意事项上。但是，也总有人问我文章的配图使用什么工具做的，在这里再回答一次：&lt;a href=&#34;https://www.omnigroup.com/omnigraffle&#34;&gt;OmniGraffle&lt;/a&gt;，一款目前仅有Mac版本的工具软件。&lt;/p&gt;
&lt;h2 id=&#34;一图胜千言&#34;&gt;一图胜千言&lt;/h2&gt;
&lt;p&gt;在开始交代具体的配图注意事项之前，有必要先说说配图的重要性。&lt;/p&gt;
&lt;p&gt;绘图，某种程度也是辅助自己思考某个技术点的手段之一，以我个人的体会来说，有时候讲不清楚一个技术点的时候，就手绘图出来，比朴素的文字更容易说明问题。其中的原因，有可能是：图片可以有多维的信息，而文字通常只有一维，遇到文字表达能力不太好的人，这仅有的一维能力可能还不好发挥出来。&lt;/p&gt;
&lt;p&gt;所以，在交代技术细节、沟通交流的时候，尽量多画图。反向的，图画多了，也自然慢慢会找到感觉，如何更好的通过图示表达思路。&lt;/p&gt;
&lt;p&gt;顺便一提，还有比朴素的文字表达更差的技术沟通方式，就是简单粗暴的贴一大段代码上去。这种做法，其实更多时候是没有对作者的思路有太多个人的整理，想偷懒的方式，最后回头再看写过的文字，可能连自己都看不懂了。&lt;/p&gt;
&lt;p&gt;个人的一个体会：如果产出某些输出的时候，能假设自己未来就是这些输出的读者、维护者，那么输出起来会更“友善”一些。比如写的代码、文章、甚至于提交代码时候的信息，如果能考虑是写给未来的自己看的，会更清晰、尽可能留下更多的信息。我最开始要在文章里大量配图，也是为了将来自己回看的时候能看懂。&lt;/p&gt;
&lt;p&gt;扯远了，总之，尽可能多画图来表达技术思路。&lt;/p&gt;
&lt;p&gt;下面开始正题，以下会以简单的几个原则及示例来说明。&lt;/p&gt;
&lt;h2 id=&#34;区分联系组合&#34;&gt;区分、联系、组合&lt;/h2&gt;
&lt;p&gt;配图中，应该尽量将不同的模块、组件等区分开来，“区分”的方式有很多，常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用不同的颜色。&lt;/li&gt;
&lt;li&gt;使用不同的形状。&lt;/li&gt;
&lt;li&gt;使用箭头、曲线等表示数据的走向、趋势。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，所有的这些手段，概括起来就是尽量在图中，将不同的元素区分开来，“有区分”意味着至少有一个维度的不同，这样能给读者更加清晰的感觉。可以结合下面的例子来理解区分、联系和组合的绘图表达。&lt;/p&gt;
&lt;h2 id=&#34;分组&#34;&gt;分组&lt;/h2&gt;
&lt;p&gt;一个模块里，可能由多个组件构成，可以把这些组件分组到一个更大的模块中。&lt;/p&gt;
&lt;p&gt;分组是非常常见的一种手段，这里多举几个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/cpu.jpeg&#34; alt=&#34;cpu&#34; title=&#34;cpu&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，每个CPU Core中有L1、L2缓存，于是把这些组件合并在一起放在Core组件中，周围使用一个正方形包裹起来，同时这个正方形左上角有一个&lt;code&gt;Core&lt;/code&gt;的说明文字，这样一目了然：Core模块，由L1、L2缓存构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/raft-log.png&#34; alt=&#34;meituan&#34; title=&#34;meituan&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图出自Raft论文，整体上划分为了Client、Server这两大部分。而每个Server又有以下三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性算法模块。&lt;/li&gt;
&lt;li&gt;状态机。&lt;/li&gt;
&lt;li&gt;持久化的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，图示中将这三部分合在一起放在同一个矩形里，表示一个Server有这三个组件。&lt;/p&gt;
&lt;p&gt;另外还需注意的是，一般这种分组中外围的矩形，有这样的讲究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般使用斜面矩形，即四个角是圆角的矩形，这样圆润一些的边角看起来会更舒服一些，如上图。&lt;/li&gt;
&lt;li&gt;如果这个组合，是一种逻辑上的组合，那么线的形状一般用虚线；否则就一般用的实线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在分组时，有时候可以将相同类型的模块层叠起来，这样会更加简洁，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/raft.png&#34; alt=&#34;raft&#34; title=&#34;raft&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是出自Raft论文中的状态机模型，其中想要表达的一个点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有多个client向server发起请求。&lt;/li&gt;
&lt;li&gt;server要达成一致，需要将日志在server之间同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是上图中，并没有把这些同类型的组件分开表达，而是巧妙的使用层叠的方式，简洁得表达了有多个client、多个server的情况。&lt;/p&gt;
&lt;h2 id=&#34;趋势&#34;&gt;趋势&lt;/h2&gt;
&lt;p&gt;如果不同的组件之间，有不同的趋势，可以在图中使用类似箭头这样的符号表达出来。&lt;/p&gt;
&lt;p&gt;下图是描述不同层次存储的访问速度，于是用了两个方式来表达访问速度的变化趋势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边的箭头表达速度和成本的变化。&lt;/li&gt;
&lt;li&gt;不同大小的多边形表达了这些存储空间的变化：越往上访问速度越快，但是对应的存储空间也更小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/cache.png&#34; alt=&#34;cache&#34; title=&#34;cache&#34;&gt;&lt;/p&gt;
&lt;p&gt;再比如，下图中，是说明sqlite中btree页面的数据组织的。其中的两部分内容，&lt;code&gt;Cell地址数组&lt;/code&gt;以及&lt;code&gt;Cell内容区&lt;/code&gt;为变长大小，前者从地址低位向高位生长，后者反之，于是在图中，就用箭头示例出地址的高低位区别，以及两者的增长方向：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/page-format.png&#34; alt=&#34;页面内数组的组织&#34; title=&#34;页面内数组的组织&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;联系&#34;&gt;联系&lt;/h2&gt;
&lt;p&gt;用箭头等表示数据、状态等的走向，或者模块之间的联系。&lt;/p&gt;
&lt;p&gt;这在涉及：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态切换。&lt;/li&gt;
&lt;li&gt;数据流向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等场景下是非常常见的手段，比如经典的TCP状态机切换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png&#34; alt=&#34;TCP状态机&#34; title=&#34;TCP状态机&#34;&gt;&lt;/p&gt;
&lt;p&gt;以及TCP三次握手流程，也是典型的“状态切换”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;TCP三次握手&#34; title=&#34;TCP三次握手&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是，以上的图示中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;箭头代表的状态切换走向中，同时也配以文字说明是什么动作导致的状态切换，这样这个图示就更清晰了。&lt;/li&gt;
&lt;li&gt;箭头也分为实线和虚线，一般而言，虚线表示数据的走向，实线表示状态的走向。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;禁止&#34;&gt;禁止&lt;/h2&gt;
&lt;p&gt;需要禁止或者错误的行为，可以用特殊的符号，如带颜色的“×”符号示意出来；反之，可以用带颜色的“√”符号示意出来，而且表示禁止的时候，一般用红色会更显眼，下图就是一个示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/memory-barriers-in-dot-net-5.png&#34; alt=&#34;meituan&#34; title=&#34;meituan&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自 &lt;a href=&#34;https://afana.me/archive/2015/07/10/memory-barriers-in-dot-net.aspx/&#34;&gt;Memory Barriers in .NET · Nadeem Afana&amp;rsquo;s Blog&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;如果不好说明问题，可以在图示中搭配简短的说明文字。注意：这类型文字一定要足够的简短，否则可能会喧宾夺主。&lt;/p&gt;
&lt;p&gt;比如下图中，有两部分蓝色注解的文字来说明不同的表类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/btree-rowid.png&#34; alt=&#34;数据库文件的rowid全量数据表和索引表&#34; title=&#34;数据库文件的rowid全量数据表和索引表&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;再比如下图中，使用注解文字来说明查找数据的两步流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/find-key.png&#34; alt=&#34;查找key的流程&#34; title=&#34;查找key的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;有时候需要使用类似&lt;code&gt;{&lt;/code&gt;这样的符号，对一类元素做一些说明，例如：&lt;/p&gt;
&lt;p&gt;下图中，是说明sqlite中btree页面的数据组织的，最右边的以&lt;code&gt;{&lt;/code&gt;包起来的文字，对每部分做了简要的说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/page-format.png&#34; alt=&#34;页面内数组的组织&#34; title=&#34;页面内数组的组织&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;下图中，将页面划分为不同的部分，这些不同的组成部分，既使用了颜色进行区分，也使用了向下的&lt;code&gt;{&lt;/code&gt;辅以文字说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/freelist.png&#34; alt=&#34;空闲区链表&#34; title=&#34;空闲区链表&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;
&lt;p&gt;如果配图是需要讲解某个操作的步骤的，可以配以数字来辅助理解整个流程。&lt;/p&gt;
&lt;p&gt;下图中，表达的是根据帧数查找页面编号的两个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/frame-pageno.png&#34; alt=&#34;添加帧数与页面编号对应关系的流程&#34; title=&#34;添加帧数与页面编号对应关系的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;下图中的步骤就更多了，并没有显得很乱，大概原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最左边表达了每一步的步骤。&lt;/li&gt;
&lt;li&gt;每一步写入数据之后，显示WAL文件在写入之后的内容。&lt;/li&gt;
&lt;li&gt;最右边使用&lt;code&gt;{&lt;/code&gt;表达修改之后的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/write-wal.png&#34; alt=&#34;写事务修改WAL文件和WAL索引数据&#34; title=&#34;写事务修改WAL文件和WAL索引数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;展开&#34;&gt;展开&lt;/h2&gt;
&lt;p&gt;在讲解例如文件格式，或者协议格式等内容的时候，格式由多个部分划分组成，其中又可以针对其中的某些内容展开说明。&lt;/p&gt;
&lt;p&gt;如下图中，是用于展示wal index索引文件格式的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边示例每部分内容的大小，想说明的是，那个索引块大小为32KB，而第一块的头136字节为索引文件头。&lt;/li&gt;
&lt;li&gt;于是，在右边图中，将左边不同模块的具体格式继续展开说明。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-index-format.png&#34; alt=&#34;WAL-Index索引文件结构图&#34; title=&#34;WAL-Index索引文件结构图&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;以上简单总结了一下个人技术配图的一些心得，总的大原则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分：将组件、流程、趋势等之间的”区分“尽可能在图示中通过各种手段（如不同的颜色、形状、箭头）表达出来。&lt;/li&gt;
&lt;li&gt;联系：组件之间的数据流动、状态切换等，都是它们之间的联系，也需要通过各种手段表达出来。&lt;/li&gt;
&lt;li&gt;说明：可能的话，要在图中加上一些说明文字，如步骤说明、分类说明，等等。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第7期）：一个C系程序员的Rust初体验</title>
      <link>https://www.codedump.info/post/20220227-weekly-7/</link>
      <pubDate>Sun, 27 Feb 2022 11:25:33 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220227-weekly-7/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：在工作里使用Rust已经有两个多月的时间了，谈谈我做为一名多年的C系（C、C++）程序员，对Rust的初体验。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;一个c系程序员的rust初体验&#34;&gt;一个C系程序员的Rust初体验&lt;/h1&gt;
&lt;p&gt;最近由于工作的原因，使用上了Rust语言，在此之前我有多年的C、C++编码经验（以下将C、C++简称C系语言）。&lt;/p&gt;
&lt;p&gt;使用C系语言编码时，最经常面对的问题就是内存问题，诸如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;野指针（Wild Pointer）：使用了不可知的指针变量，如已经被释放、未初始化、随机，等等。&lt;/li&gt;
&lt;li&gt;内存地址由于访问越界等原因被覆盖（overflow），这不但是可能出错的问题，还有可能成为程序的内存漏洞被利用。&lt;/li&gt;
&lt;li&gt;内存分配后未回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连Chrome的报告都指出，Chrome中大约70%的安全漏洞都是内存问题，见：&lt;a href=&#34;https://www.chromium.org/Home/chromium-security/memory-safety/&#34;&gt;Memory safety&lt;/a&gt;。（不仅如此，微软的文章也显示在微软的产品中70%的安全漏洞也是内存问题，见：&lt;a href=&#34;https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/&#34;&gt;Microsoft: 70 percent of all security bugs are memory safety issues | ZDNet&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;C系语言发展到今天，已经有不少可以用于内存问题检测的利器了，其中最好用的莫过于&lt;a href=&#34;https://en.wikipedia.org/wiki/AddressSanitizer&#34;&gt;AddressSanitizer&lt;/a&gt;，它的原理是在编译时给程序加上一些信息，一旦发生内存越界访问、野指针等错误都会自动检测出来。&lt;/p&gt;
&lt;p&gt;但是即便有这些工具，内存问题也不好解决，其核心的原因在于：这些问题绝大部分都是运行时（Runtime）问题，即要在程序跑到特定场景的时候才会暴露出来，诸如上面提到的AddressSanitizer就是这样。&lt;/p&gt;
&lt;p&gt;都知道解决问题的第一步是能复现问题，而如果一个问题是运行时问题，这就意味着：复现问题可能会是一件很麻烦的事情，有时候还可能到生产环境去复现。&lt;/p&gt;
&lt;p&gt;以我之前经历的一个Bug来看这类工作的复杂度，见&lt;a href=&#34;https://www.codedump.info/post/20190413-problem-fix/&#34;&gt;线上存储服务崩溃问题分析记录 - codedump的网络日志&lt;/a&gt;，这是一个很典型的发生在生产环境上由于内存错误导致的崩溃问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不好复现，因为跟特定的请求相关，还跟线程的调度有关；&lt;/li&gt;
&lt;li&gt;本质是由于使用了被释放的内存导致的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个线上问题，记得当时花了一周时间来复现问题解决。&lt;/p&gt;
&lt;p&gt;换言之，如果一个问题要等到运行时才能发现，那么可以预见的是：一旦出现问题，要复现问题可能要花费大量的精力，以及需要很多经验才行。如果一个问题还是在特定场景，或者用户现场才出现的，那就更麻烦了，C系程序员以往一般都是这样来保存“现场”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出现崩溃的时候保存core文件来查看调用堆栈、变量等信息。&lt;/li&gt;
&lt;li&gt;发明了各种复制流量重放的工具，比如&lt;a href=&#34;https://github.com/session-replay-tools/tcpcopy&#34;&gt;tcpcopy&lt;/a&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，运行时问题一旦出现是很麻烦的，而解决这类问题的时间是难以预期的。&lt;/p&gt;
&lt;p&gt;Rust给这类内存问题的解决提供了另一个解决思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个内存地址同时只能被一个变量使用。&lt;/li&gt;
&lt;li&gt;不能使用未初始化的变量。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简而言之，凡是可能出现内存错误的地方，都在语言的语法层面给予禁止，换来的就是更多的编译时间，因为要做这么多检查嘛，而需要更多的编译时间反过来就需要更好的硬件。我想这也是Rust到了最近几年才开始慢慢流行开来的原因之一，毕竟即便是现在，一些大型的Rust项目普通的机器编译起来也还是很耗时。&lt;/p&gt;
&lt;p&gt;“编译时间（compile time）”是一个可以预期的固定时间，能通过增加硬件性能（比如买更好的机器来写Rust）来解决；而“运行时问题”一旦出现，查找起来的时间、精力、场景（比如出现在用户现场、几百万次才能重现一次等）不确定性可就很高了。&lt;/p&gt;
&lt;p&gt;两者权衡，我选择解决“编译时间”问题。而且，在我意识到有这样的工具能够在编译期解决大部分内存问题时，反过来再看使用C系语言的项目，几乎可以预期的是：只要代码和复杂度上了一定规模，那么这类项目都要花上相当的一段时间才能稳定下来。原因在于：类似内存问题这样的运行时问题，是需要场景去积累，才能暴露出来的，而场景的积累，就需要很多的小白鼠和运行时间了。&lt;/p&gt;
&lt;p&gt;总结一下我的观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C系语言最多的问题就是各类内存问题，而这些问题大多是运行时问题。即便现在已经有了各种工具，解决其运行时问题也很困难。&lt;/li&gt;
&lt;li&gt;Rust解决这类问题的思路，是在语法层面禁止一切可能出现内存问题的操作，换来的代价就是更多的编译时间。&lt;/li&gt;
&lt;li&gt;解决可预期的“编译时间”和难预期的“运行时问题”，我选择前者。人生苦短，浪费时间在解决运行时的各种内存问题太不值当了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;番外篇&#34;&gt;番外篇&lt;/h1&gt;
&lt;h2 id=&#34;rr&#34;&gt;rr&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://rr-project.org/&#34;&gt;rr: lightweight recording &amp;amp; deterministic debugging&lt;/a&gt;也是出自Mozilla的另一款调试C系程序的利器，&lt;code&gt;rr&lt;/code&gt;是&lt;code&gt;Record and Replay&lt;/code&gt;的简称，目的还是为了解决各种运行时问题，由于运行时问题中存在着各种不确定的因素，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量值。&lt;/li&gt;
&lt;li&gt;进程、线程环境，比如不同的线程调度顺序可能导致了不同的结果。&lt;/li&gt;
&lt;li&gt;输入不同的数据，能得到不同的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，&lt;code&gt;rr&lt;/code&gt;要解决的核心问题，就是让一个程序在运行时有一个固定的环境，它可以抓取程序运行的环境保存下来。这样在出现问题之后，就能使用它可以记录下来程序运行时的环境，不停的重放来调试解决问题。&lt;/p&gt;
&lt;p&gt;但是，即便是这样，&lt;code&gt;rr&lt;/code&gt;可能更适合于明确知道问题的情况下去抓取环境，不可能在线上直接打开这个工具。所以又回到前面的结论了：调试运行时问题可能面对的困难，包括场景、时间、用户现场等等不确定因素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;和&lt;code&gt;Rust&lt;/code&gt;一样，都出自Mozilla，我想不是偶然的。Mozilla和chrome等一样，都是使用C++编码的超大型项目，而这里一定遇到了各种运行时问题，不止于内存问题，所以才要使用各种工具来辅助解决这类问题。&lt;/p&gt;
&lt;h2 id=&#34;吃上硬件升级的红利了吗&#34;&gt;吃上硬件升级的红利了吗？&lt;/h2&gt;
&lt;p&gt;前面提到过，Rust目前较大的问题是编译时间过长，这可能是导致它最近几年才开始逐渐流行开来的原因。其实反过来说，在硬件升级之后，应该能尽量利用上硬件，在编译期尽量多检查出错误来，减少运行时发现问题的数量。这样，才能吃上硬件升级的红利，利用硬件来减少自己的犯错。&lt;/p&gt;
&lt;p&gt;一方面硬件升级给了编程语言能施展更大、更快的的“舞台”，随着舞台的更新，就会有更新、更好的工具出现；另一方面做为从业者，也应该与时俱进，多学习跟进这些工具的演进。&lt;/p&gt;
&lt;p&gt;我看到有一些人，强调自己多早就已经用C语言写代码了，但是查内存问题还在用慢的不行的&lt;code&gt;Valgrind&lt;/code&gt;，没听过更不知道怎么用&lt;code&gt;Address Sanitizer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;想说如果技能点都已经不更新了，强调多早学的有什么意义？好比1950年就会打算盘，有意义吗？强调多早就用C语言类似的言论，在我看来就是“倚老卖老”，但是技术日新月异的领域，卖老的意义不大。&lt;/p&gt;
&lt;h1 id=&#34;推荐&#34;&gt;推荐&lt;/h1&gt;
&lt;h2 id=&#34;rust-for-rustaceans&#34;&gt;《Rust for Rustaceans》&lt;/h2&gt;
&lt;p&gt;推荐&lt;a href=&#34;https://rust-for-rustaceans.com/&#34;&gt;Rust for Rustaceans&lt;/a&gt;作者Jon Gjengset的油管频道：https://www.youtube.com/c/JonGjengset/playlists&lt;/p&gt;
&lt;p&gt;有很多很有深度的Rust分享，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=bzja9fQWzdA&amp;amp;list=PLqbS7AVVErFivDY3iKAQk3_VAm8SXwt1X&#34;&gt;Implementing TCP in Rust (part 1) - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=yQFWmGaFBjk&amp;amp;list=PLqbS7AVVErFj824-6QgnK_Za1187rNfnl&#34;&gt;Porting Java&amp;rsquo;s ConcurrentHashMap to Rust (part 1) - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍rust缘起的文章&#34;&gt;介绍Rust缘起的文章&lt;/h2&gt;
&lt;p&gt;Infoq上的&lt;a href=&#34;https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM&#34;&gt;《想要改变世界的Rust语言》&lt;/a&gt;，是一篇介绍了Rust语言的缘起和设计目标好文章，对于了解Rust的历史、设计哲学等都有帮助。其中谈到的Rust三大设计哲学中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内存安全&lt;/li&gt;
&lt;li&gt;零成本抽象&lt;/li&gt;
&lt;li&gt;实用性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;就把“内存安全”放在了第一位，可见尽量解决运行时的内存问题都是大家很关心的问题。&lt;/p&gt;
&lt;h2 id=&#34;查询rust文档的浏览器插件&#34;&gt;查询Rust文档的浏览器插件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://rust.extension.sh/&#34;&gt;Rust Search Extension - The ultimate search extension for Rust&lt;/a&gt;，是一个方便在浏览器中快速查询Rust文档的插件，提供了各种浏览器的支持。&lt;/p&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;神鞭&#34;&gt;《神鞭》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://movie.douban.com/subject/1464595/&#34;&gt;神鞭&lt;/a&gt;是一部上世纪80年代的老电影，印象里小时候在露天电影院看过，故事的梗概大概是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;故事发生在清朝末年，主角是一个会使辫子神功的人，耍起辫子来能像鞭子一样抽打对手。后来八国联军入侵，加入了义和团，结果可想而知。再后来重新出现在江湖上时，不再是当年那个会耍辫子的高手，而是变成了一个神枪手了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面主角的有一句台词“辫子没了，神还在”，至今印象深刻，我对这句话的解读是：使用的工具，也应该与时俱进的进化，这个观点放在今天这篇对比C系和Rust的文章里，我认为是合适的。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第6期）：《sqlite 3.36 btree实现解析》番外篇</title>
      <link>https://www.codedump.info/post/20220220-weekly-6/</link>
      <pubDate>Sun, 20 Feb 2022 10:53:41 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220220-weekly-6/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：从2021年9月份开始要探索生产级btree存储引擎的实现，到2022年2月整理完毕发布《sqlite 3.36 btree实现解析》的系列文章，我花费了小半年的时间，本期会聊聊整个过程下来我的一些想法。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sqlite-336-btree实现解析番外篇&#34;&gt;《sqlite 3.36 btree实现解析》番外篇&lt;/h1&gt;
&lt;p&gt;时间回到2021年9月份。彼时，因为工作的关系，要研究一下生产级btree存储引擎的实现，在此之前我大体对btree、b+tree的数据结构和算法有个了解，见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，一个生产级的产品，对比教科书的示范型代码，还是有很大的区别的，具体来说，我当时不明白以下这些生产级存储引擎的问题如何解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何存储变长的数据？&lt;/li&gt;
&lt;li&gt;如何存储数据大小超过一个物理页面的数据？&lt;/li&gt;
&lt;li&gt;如何利用被回收的空间？&lt;/li&gt;
&lt;li&gt;如何处理崩溃恢复？&lt;/li&gt;
&lt;li&gt;读写并发如何处理？&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解答这些疑问，先后去翻阅InnodDB、WiredTiger、sqlite的文档，但是这些项目代码量都太大了，以我当时的程度，无法马上找到很具体的解答。&lt;/p&gt;
&lt;p&gt;事情的突破在从网上查找文章时看到的这一篇文章：&lt;a href=&#34;https://dzone.com/articles/database-btree-indexing-in-sqlite&#34;&gt;How Database B-Tree Indexing Works - DZone Database&lt;/a&gt;，这是一篇解释btree工作原理的文章，这篇文章同时还列出了一个项目：&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;madushadhanushka/simple-sqlite: Code reading for sqlite backend&lt;/a&gt;，这个项目的作者，将sqlite2.5版本中btree的实现，单独抽取出来形成了一个独立的KV库，可以编译通过使用。&lt;/p&gt;
&lt;p&gt;看到这个项目的时候，我的感觉就是如获至宝，因为虽然只有几千行的代码量，但是解答了很多上面提到的疑问，“麻雀虽小五脏俱全”，我花了几天的时间整体阅读了解了原理，这个项目给我打开了研究生产级btree存储引擎的突破口。&lt;/p&gt;
&lt;p&gt;在这以后，考虑到2.5版本的sqlite已经是2002年的作品，距离现在时间太久了，还想接着了解后面做了那些改进，又接着阅读了3.6.10版本的实现，找这个版本的原因，是因为这是sqlite官方在github上同步的第一个版本，那时候仍然步子不敢迈得太大。&lt;/p&gt;
&lt;p&gt;又花了一个多月把这个版本的btree实现了解以后，我了解到在这之后的版本里，sqlite做了另一个重大的更新：在页面管理部分引入了WAL机制，加上前面两个版本阅读下来累积的信心，就接着找当时还是最新的3.36版本的实现来阅读，这又花了一个多月的时间。&lt;/p&gt;
&lt;p&gt;这以后，就是逐步将整理的笔记写成文档了，后续的事情不表，都在这几篇文档里。&lt;/p&gt;
&lt;p&gt;回头看这整个流程，我自己的感受是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“问题驱动”可能是效率更高的学习方式，带着问题出发、找到自己疑问的答案，能更快的学习某个知识。&lt;/li&gt;
&lt;li&gt;生产级的实现和教科书的区别很大，后者更多的是讲解原理，而生产级实现考虑更多的是各种实际生产中的边际情况。如果只了解原理，而不去具体做实现，对事情的理解最后只能浮于表面。&lt;/li&gt;
&lt;li&gt;找到那个精简实现是这个过程里的“突破口”，原因在于：如果一上来看的很成熟的版本，而且你在这个领域积累的不深，那么很可能会导致丢失了很多“上下文（context）”情景，给阅读、理解带来很大困难。下次再遇到类似的问题，我会按照这次的经验，先尝试回退到之前的更简单的版本，看看在那里能不能跟上作者的思路，攻克简单的实现之后，再尝试最新的版本。&lt;/li&gt;
&lt;li&gt;除了数据库领域以外，有一些别的领域，在教学的时候会让学生参与实现一个简单的项目。这类型的项目虽然简单，但是五脏俱全，能够让学生了解这个领域的概貌，我把这种流程称为“破解神秘感”。如我最开始提到的那些疑问，如果在这之前做过数据库相关的作业，应该会有个大体的想法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;这篇番外篇的番外篇&#34;&gt;这篇番外篇的番外篇&lt;/h1&gt;
&lt;h2 id=&#34;sqlite的注释&#34;&gt;sqlite的注释&lt;/h2&gt;
&lt;p&gt;除了这些以外，sqlite的代码风格也很好，尤其是注释写的非常详尽。&lt;/p&gt;
&lt;p&gt;有一种说法，“好的代码都是自解释的，无需多做注释”。我对这句话有一些不太一样的看法，因为即便再好的代码，如果只看代码的话，对整个的架构、结构很难了解。这一点sqlite就做的很好，在代码中会写上类似文档一样的注释来解释结构，比如有这么一段解释btree内部结构的注释文档：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; This file implements an external (disk&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;based) database using BTrees.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; For a detailed discussion of BTrees, refer to
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;     &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;Sorting And Searching&amp;#34;&lt;/span&gt;, pages &lt;span style=&#34;color:#666&#34;&gt;473&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;480.&lt;/span&gt; Addison&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;Wesley
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;     Publishing Company, Reading, Massachusetts.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; The basic idea is that each page of the file contains N database
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; entries and N&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; pointers to subpages.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;----------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;  Ptr(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Key(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Ptr(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Key(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; ... &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Key(N&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; Ptr(N) &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;----------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; All of the keys on the page that Ptr(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) points to have values less
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; than Key(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;).  All of the keys on page Ptr(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) and its subpages have
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; values greater than Key(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) and less than Key(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;).  All of the keys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; on Ptr(N) and its subpages have values greater than Key(N&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;).  And
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; so forth.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果不写这些注释，读者想要理解作者的思路的话，仅凭代码是很困难的。&lt;/p&gt;
&lt;p&gt;这里只是抽取了sqlite代码注释中的一小部分，我读代码下来的感觉，sqlite的注释可以说是“保姆级别”的。“写代码是表达自己，读代码是去理解别人”（见&lt;a href=&#34;https://www.zhihu.com/question/21820752/answer/19427754&#34;&gt;为什么说读代码比写代码难？ - 知乎&lt;/a&gt;），可以说sqlite的作者为了让别人更好的理解自己，尽力了。&lt;/p&gt;
&lt;p&gt;对应的，我也看过那种几乎没有注释、变量函数名都是缩写的代码，这样的代码作者，可能就不是很像让别人读懂ta。&lt;/p&gt;
&lt;h2 id=&#34;sqlite几个相关的链接&#34;&gt;sqlite几个相关的链接&lt;/h2&gt;
&lt;p&gt;可以在这里（&lt;a href=&#34;https://sqlite.org/chronology.html&#34;&gt;History Of SQLite Releases&lt;/a&gt;）找到sqlite的release历史，进而下载到对应版本的代码。以2.5版本为例，发布于&lt;a href=&#34;https://www.sqlite.org/src/timeline?c=9baef3e240&amp;amp;y=ci&#34;&gt;2002-06-17&lt;/a&gt;这一天，我用代码统计工具统计了一下，代码量仅有31188行（包括注释）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220220-weekly-6/2.5.png&#34; alt=&#34;sqlite2.5的代码统计&#34; title=&#34;sqlite2.5的代码统计&#34;&gt;&lt;/p&gt;
&lt;p&gt;BTW：不知道sqlite 2.5版本，对比一些数据库实验课程的大作业，复杂度如何，感觉以早期sqlite代码来入门数据库学习也是足够的，前提是有足够的耐心和时间。&lt;/p&gt;
&lt;p&gt;而3.36版本发布于&lt;a href=&#34;https://www.sqlite.org/src/timeline?c=5c9a6c0687&amp;amp;y=ci&#34;&gt;2021-06-18&lt;/a&gt;这一天，代码量已经到了21W行，前后相隔19年：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220220-weekly-6/3.36.png&#34; alt=&#34;sqlite3.36的代码统计&#34; title=&#34;sqlite3.36的代码统计&#34;&gt;&lt;/p&gt;
&lt;p&gt;还可以在&lt;a href=&#34;https://www.sqlite.org/changes.html&#34;&gt;Release History Of SQLite&lt;/a&gt;看到不同版本新增的特性、bug fix等，比如可以看到WAL是在3.7.0版本引入的特性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2010-07-21 (3.7.0)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Added support for write-ahead logging.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sqlite的箴言&#34;&gt;sqlite的箴言&lt;/h2&gt;
&lt;p&gt;在每个sqlite代码文件中，开头都有这么一段注释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;破解神秘感的项目&#34;&gt;破解神秘感的项目&lt;/h2&gt;
&lt;p&gt;前面提到过要破解神秘感，列举几个计算机相关课程的实验大作业或项目。&lt;/p&gt;
&lt;h3 id=&#34;操作系统&#34;&gt;操作系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;哈佛大学的Xv6：&lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2012/xv6.html&#34;&gt;Xv6, a simple Unix-like teaching operating system&lt;/a&gt;， 对应的课程：&lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2021/&#34;&gt;6.S081 / Fall 2021&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;清华的uCore：&lt;a href=&#34;https://github.com/kiukotsu/ucore&#34;&gt;kiukotsu/ucore: 清华大学操作系统课程实验 (OS Kernel Labs)&lt;/a&gt;，实验指导书：&lt;a href=&#34;https://chyyuu.gitbooks.io/ucore_os_docs/content/&#34;&gt;Introduction · ucore_os_docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CMU的15445：&lt;a href=&#34;https://15445.courses.cs.cmu.edu/fall2021/&#34;&gt;CMU 15-445/645 :: Intro to Database Systems (Fall 2021)&lt;/a&gt;，随课程要完成一个大作业项目，之前没有做过，否则应该不至于不了解生产级实现的原理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MIT的6.824：&lt;a href=&#34;https://pdos.csail.mit.edu/6.824/schedule.html&#34;&gt;6.824 Schedule: Spring 2022&lt;/a&gt;，也是有随课程要完成的大作业，以前使用C++实现Paxos，后面改成了Go实现Raft。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux早期内核实现解析&#34;&gt;Linux早期内核实现解析&lt;/h3&gt;
&lt;p&gt;许多年以前，赵炯博士在网上公开过一份文档，基本上&lt;strong&gt;逐行&lt;/strong&gt;讲解了Linux0.11版本内核的实现，那时候的官网oldlinux.org 现在好像已经不能访问，在官网的页面&lt;a href=&#34;http://www.oldlinux.org/book.html&#34;&gt;Early Linux Kernel Analisys and Comments&lt;/a&gt;也提供了这份文档电子版的下载链接：http://www.oldlinux.org/download/clk011c-1.9.5.pdf，也有对应的公开发行物：&lt;a href=&#34;https://book.douban.com/subject/3229243/&#34;&gt;Linux内核完全剖析 (豆瓣)&lt;/a&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第5期）：从存储模型聊一聊时序数据库的应用场景</title>
      <link>https://www.codedump.info/post/20220211-weekly-5/</link>
      <pubDate>Fri, 11 Feb 2022 22:27:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220211-weekly-5/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期介绍时序数据库的存储模型，只有理解了时序数据的存储模型，才能更好的了解时序数据库的优缺点以及其适用场景。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;从存储模型聊一聊时序数据库的应用场景&#34;&gt;从存储模型聊一聊时序数据库的应用场景&lt;/h1&gt;
&lt;p&gt;想写本文，是因为看到了知乎上的一篇文章：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/453556881&#34;&gt;投资数据库领域：2021年总结（NoSQL、图、时序） - 知乎&lt;/a&gt;，里面谈到了时序数据库：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但缺陷是实际的市场空间较小。跟通用型数据库，尤其是OLAP数据库相比，时序数据库最大的差异点在于对于时间维度建立了独特的索引与优化，而其他所谓schemaless等特性在OLAP数据库上都能做到，不存在技术障碍。这也就是为什么其实在公司做时序场景的数据库选型的时候会直接将时序数据库与一些OLAP数据库（比如ClickHouse）做比较。如果要把时序数据库往更宽的场景发展，那就是想好如何与那么多的通用型数据库做竞争了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于之前有过短暂一段时间的时序数据库从业经历，所以想从我的理解聊聊时序数据库的应用场景。&lt;/p&gt;
&lt;p&gt;要了解应用场景，需要首先对时序数据库的存储模型有个大概的了解，在下文中我尽量不涉及到太艰深的技术术语来描述我的理解。由于我从业时序数据库的时间并不长，所以有可能理解会有偏差。&lt;/p&gt;
&lt;p&gt;何谓“时序数据（time-series data）”？就我个人粗浅的理解，就是任何一定会带上时间戳（timestamp）维度的数据。日常生活里，在微博、微信等社交媒体的发现就可以理解时序数据，因为它们肯定都有一个发言时间，所以有时候会把个人看到的微博等称为“时间线（timeline）”。对应到工业领域，比如一个电表每小时上报的用电量也是时序数据，比如服务器监控时每隔15分钟采集的性能数据也是时序数据。&lt;/p&gt;
&lt;p&gt;由于时序数据天然有“时间“这个维度，为了更好的优化其写入性能，通常专门存储时序数据的存储引擎会按照时间分块、按列来存储数据，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220211-weekly-5/time-series-model.png&#34; alt=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; title=&#34;数据库文件的物理页面组织和逻辑页面结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，演示用的数据格式有三列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间戳。&lt;/li&gt;
&lt;li&gt;A指标。&lt;/li&gt;
&lt;li&gt;B指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，时序数据库存储时，会按照时间来划分块（block）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块的大小固定。&lt;/li&gt;
&lt;li&gt;在同一个块时间区的数据，会存储到同一个块中。&lt;/li&gt;
&lt;li&gt;而块内部，将除了时间维度之外的其他的列，将其中相同列的数据存储在一起。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于时序数据的特点，写入的数据也是在时间上连续的，因此通常写入的时候按照上面的设计就能落在同一个块中。&lt;/li&gt;
&lt;li&gt;不同行但是同一列的数据，都是相同类型的，将相同类型的数据紧邻放在一起，更容易进行压缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换言之，这样做换来的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在时序数据的写入场景下，写入速度很快。&lt;/li&gt;
&lt;li&gt;由于同类型数据放在一起，压缩性能也很好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是相对于传统BTree类存储引擎而言的，因为这类型的数据写入更像append操作，这是必然会更快的。&lt;/p&gt;
&lt;p&gt;但是注意到没有，这样存储数据之后，最大的问题是：查询时只有时间这个维度做了索引，而除去时间维度之外的其他列都没有做索引。&lt;/p&gt;
&lt;p&gt;这样导致的问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何查询都要带上时间参数才能管用。比如：“请查询过去一个小时里哪五分钟的CPU最高”这样的查询是可以的，但是更多其他的查询是不知道时间维度，或者说查询者就是不知道具体时间才想来查询的，比如“我是什么时候达成了累计跑步100公里成就的？”这类探索型、且没有时间维度的查询。&lt;/li&gt;
&lt;li&gt;即便是带上了时间维度的查询可行，由于没有对其他维度做索引，所以查询时的处理，更多的是按照时间维度查询出数据、再进行聚合计算，比如上面的“请查询过去一个小时里哪五分钟的CPU最高”这个查询，只能先把过去一小时的CPU数据全部查出来，然后逐个计算才能算出哪5分钟的CPU最高了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结下来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时序数据库根据时序数据的特点设计和优化了时序数据库的存储模型，对比传统的关系数据库存储模型来说，优势是写入速度快、压缩比高。&lt;/li&gt;
&lt;li&gt;但这样的存储只有时间这个维度，换言之由于没有其他维度的索引数据，导致对不带有时间维度或者时间跨度大的查询支持的不够友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回到最开始引用的文章，了解了时序数据库的存储特点，也就能解释为何作者认为纯粹的时序数据库场景不大了。&lt;/p&gt;
&lt;p&gt;好像大部分时候，事情也是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个维度优化到极致，可能其他维度就做的不够好，不存在各个维度都能做得很好的产品，因为不同维度之间也会彼此有制约，更多时候要看使用者自己的场景取舍，并不存在适用于一切场景的产品。&lt;/li&gt;
&lt;li&gt;所谓”优势“，在换了上下文和场景之后，也可能会变成劣势。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;相关推荐&#34;&gt;相关推荐&lt;/h1&gt;
&lt;h2 id=&#34;writing-a-time-series-database-from-scratch--fabian-reinartzhttpsfabxcorgtsdb&#34;&gt;&lt;a href=&#34;https://fabxc.org/tsdb/&#34;&gt;Writing a Time Series Database from Scratch | Fabian Reinartz&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;项目的核心开发者写的文章，介绍了如何从头实现一个时序数据库的存储引擎，可做为上面文章更深入的补充。&lt;/p&gt;
&lt;h2 id=&#34;cmu在2017年时组织的时序数据库系列讲座&#34;&gt;CMU在2017年时组织的时序数据库系列讲座&lt;/h2&gt;
&lt;p&gt;邀请了一系列业内时序数据库的从业人员来分享，见：&lt;a href=&#34;https://db.cs.cmu.edu/seminar2017/&#34;&gt;Time Series Database Lectures – Fall 2017&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;阿里云数据库内核月报分类整理httpsgithubcomtangwzdb-monthly&#34;&gt;&lt;a href=&#34;https://github.com/tangwz/db-monthly&#34;&gt;阿里云数据库内核月报分类整理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;阿里云数据库内核团队的月报提供了很多学习数据库技术的资料、文章，这个github将每个月的月报进行了分类整理，推荐收藏。&lt;/p&gt;
&lt;h2 id=&#34;how-does-a-database-work--lets-build-a-simple-databasehttpscstackgithubiodb_tutorial&#34;&gt;&lt;a href=&#34;https://cstack.github.io/db_tutorial/&#34;&gt;How Does a Database Work? | Let’s Build a Simple Database&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自己动手打造一个简单的数据库，应该有很多地方参考了&lt;a href=&#34;https://sqlite.org/index.html&#34;&gt;SQLite&lt;/a&gt;的实现，本博客也深度解析了sqlite的btree实现，见：&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;上面这个项目是使用C语言实现的，类似的打造简易数据库来学习原理的项目还有其他语言的版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java版本：&lt;a href=&#34;https://github.com/awelm/simpledb&#34;&gt;awelm/simpledb: A simple database built from scratch that has some the basic RDBMS features (SQL query parser, transactions, query optimizer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust版本：&lt;a href=&#34;https://github.com/erikgrinaker/toydb&#34;&gt;erikgrinaker/toydb: Distributed SQL database in Rust, written as a learning project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;河西走廊-httpsmoviedoubancomsubject24736278&#34;&gt;&lt;a href=&#34;https://movie.douban.com/subject/24736278/&#34;&gt;《河西走廊 》&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;非常棒的介绍河西走廊的历史纪录片，2017年在甘肃旅游，就是一路沿着河西走廊过来的，一边旅游一边看这部纪录片。&lt;/p&gt;
&lt;h2 id=&#34;浮生一日httpsspacebilibilicom110930331&#34;&gt;&lt;a href=&#34;https://space.bilibili.com/110930331&#34;&gt;《浮生一日》&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;B站上纯纯甘的节目《浮生一日》是我每期都会看的节目，主题是每次采访跟踪一个不同行业素人的生活。&lt;/p&gt;
&lt;p&gt;最开始知道这个栏目是看了&lt;a href=&#34;https://www.bilibili.com/video/BV1V54y1h7Zr?spm_id_from=333.999.0.0&#34;&gt;【浮生一日】北京国企外卖小哥的真实一天&lt;/a&gt;，背景是这位小哥由于疫情原因失业，所以找了一份国企的工作；媳妇买P2P赔光了积蓄，赶上老人得病要治疗，所以晚上得出来兼职跑跑外卖。&lt;/p&gt;
&lt;p&gt;里面有句话让我感动：“结婚时面对自己媳妇儿最漂亮的时候，你说我愿意和你同甘共苦，然后现在又开始责怪她，那当初又何必说这四个字呢？”&lt;/p&gt;
&lt;p&gt;这个栏目里还有各色不同职业的人：程序员、投资者、早餐摊位主人&amp;hellip;等等。&lt;/p&gt;
&lt;p&gt;不同的职业，都有各自不同的生活轨道和选择。&lt;/p&gt;
&lt;p&gt;油管上有&lt;a href=&#34;https://www.youtube.com/channel/UCIs3-LcOCdpiGve6yu1-Fug&#34;&gt;同名频道&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;porterio&#34;&gt;porter.io&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;porter.io&#34;&gt;porter.io&lt;/a&gt; 是基于Github关注项目推荐相关文章发送邮件通知的应用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“We analyse your Github footprint, filter Hacker News items according to your taste, and deliver them to your mailbox.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我通过这个应用，还是被推荐才看到了不少有价值的文章的的。&lt;/p&gt;
&lt;h2 id=&#34;独立开发变现周刊httpswwwezindiecomweekly&#34;&gt;&lt;a href=&#34;https://www.ezindie.com/weekly&#34;&gt;独立开发变现周刊&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;每周更新推荐一些独立开发变现的产品。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第4期）：为什么我还在看中国足球</title>
      <link>https://www.codedump.info/post/20220204-weekly-4/</link>
      <pubDate>Fri, 04 Feb 2022 21:55:23 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220204-weekly-4/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：虎年大年初一的晚上，一场脆败发生在世界杯亚洲区预选赛中国客场对越南队的比赛上。如今，“你居然还在看中国男足”，仿佛已成一句骂人的质问。本期从我角度来谈谈，我眼中的中国足球，以及说说我为什么还一直在关注这个领域。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;我为什么还在看中国足球&#34;&gt;我为什么还在看中国足球&lt;/h1&gt;
&lt;p&gt;我从94年开始看球，中国足球绝大部分的重要比赛都看了：94年亚运会决赛输给乌兹别克斯坦、97年大连金州被伊朗逆转、2002年世界杯出线&amp;hellip;太多了，数不过来，算是从我开始看球之后就一直有关注中国足球。&lt;/p&gt;
&lt;p&gt;在看国足比赛二十多年之后，慢慢地从一个参与者、评论者的角色，切换到了近似于第三方视角的观察者角色。切换到这个视角之后，让我能从里面各种情绪里抽离出来，当然高兴的时候也会像个普通球迷那样欢乐，比如2017年世界杯预选赛击败韩国这样的比赛。&lt;/p&gt;
&lt;p&gt;我国虽然在奥运会上取得了看似很好的成绩，金牌数总是保持前列，但是有一说一，并不算是体育大国，更别提强国了。&lt;/p&gt;
&lt;p&gt;只看我们占优势、能取得好成绩的项目，大多有这样的特点：小众、冷门，这样的特点直接导致这样的项目，实际是商业化程度很低的领域。这样的领域，国外参与的人不会太多，也因此可以继续沿用以前我们擅长的打法：集中力量办大事，换到体育这个领域，就是所谓的“举国体制”。&lt;/p&gt;
&lt;p&gt;这样做的好处是，能用较少的资源拿到不错的效果，因为大部分人只关注金银牌这些数字，并不关心你怎么拿到的。这个策略，用知乎上一个回答的话来说叫“田忌赛马”，见：&lt;a href=&#34;https://www.zhihu.com/question/414037344/answer/1713991758&#34;&gt;为什么中国的其他运动项目那么强，到了男足这里就不行呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在商业化、职业化很好的体育项目，比如足球、篮球、网球等等领域，我们的成绩就不这么好了，李娜、姚明、刘翔是少数在这些领域拿得出手的世界级运动员。（后面会专门谈谈女足）&lt;/p&gt;
&lt;p&gt;一言以蔽之：举国体制从目前的成绩来看，并不适合职业化、商业化很好的体育项目。&lt;/p&gt;
&lt;p&gt;“足球是体育工业化的集大成者”（见&lt;a href=&#34;https://www.zhihu.com/question/310636566/answer/1720809481&#34;&gt;(为什么整个中国都知道中国足球的问题，为什么还是没有办法解决？ - 知乎&lt;/a&gt;），所以它不像其他领域那样，需要长期的积累和基础。&lt;/p&gt;
&lt;p&gt;所以，男足的存在，在我看来更多像是一个“大型的社会实验”，我在这个实验中，看到不同的政策、体制、行政干预、市场行为等对这个运动的影响，看到各方参与者、评论者、媒体的所作所为，从中能看到某些我们社会的缩影。&lt;/p&gt;
&lt;p&gt;男足也是“客观规律”的具象化代言人（见&lt;a href=&#34;https://weibo.com/1573046985/Ldz5zvYdY&#34;&gt;中国男足挺好的，理直&amp;hellip; - @祝佳音的微博 - 微博&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;男足不跟你讲这些虚的，不按科学规律办事就是不行。给钱诱惑也不行，立规矩骂人也不行，做思想工作说服不行，临时加班加练也不行。富贵不能淫威武不能屈，不行就是不行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相对其他很多领域，足球的成绩更透明、公开，足球运动一直在提醒我要尊重“客观规律”。&lt;/p&gt;
&lt;p&gt;足球在中国，属于“参与度很低，但是关注度高”的体育项目。在这样的领域：看起来中超火爆的时候现场能有几万球迷现场观赛，看起来花了很多钱、投入了很多人力，但是只要没有按照足球的“客观规律”办事，成绩马上就能打脸，公开透明。&lt;/p&gt;
&lt;p&gt;规则透明、结果公开，等等这些都是我一直还在关注这个“大型社会实验”的原因。&lt;/p&gt;
&lt;h2 id=&#34;番外&#34;&gt;番外&lt;/h2&gt;
&lt;p&gt;番外篇里，试图简单科普关于中国足球相关的几个常见问题。&lt;/p&gt;
&lt;h3 id=&#34;14亿人里为什么就选不出11个能踢球的人&#34;&gt;“14亿人里为什么就选不出11个能踢球的人？”&lt;/h3&gt;
&lt;p&gt;这是最常见的问题了，用类比的方式试图回答一下，这就好比问：“这么大一块沙漠为什么就种不出几棵树来？”。显然很多人并没有意识到，我国在足球从业人员领域属于“沙漠”，只是看起来热闹，仅此而已。&lt;/p&gt;
&lt;p&gt;我们的选材不是从14亿里选，而是足球注册球员里面选（中国好像只有几万足球从业人口），这个基数对比足球发达国家差的很多。&lt;/p&gt;
&lt;h3 id=&#34;怎么看待女足的成绩比男足好这么多&#34;&gt;怎么看待女足的成绩比男足好这么多？&lt;/h3&gt;
&lt;p&gt;女足有过比男足更光辉的历史：奥运会银牌、世界杯亚军。但是需要认识到，这些成绩的取得，已经年代久远，距离现在有20多年了。&lt;/p&gt;
&lt;p&gt;取得这些成绩很大的原因是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于宗教、妇女地位等原因，参与女足运动的国家并不多。&lt;/li&gt;
&lt;li&gt;当时职业化的女足并不多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如在亚洲，男足要打世界杯预选赛、亚洲杯决赛这样的比赛，都要先进行一轮预选赛，因为有50多个国家参与；而女足对应的比赛，则无需预选赛，因为参与的队伍实在不多，比如一大批相对落后的国家派不出女足，比如阿拉伯国家也不让女足参赛（这次女足亚洲杯伊朗倒是参赛了）。&lt;/p&gt;
&lt;p&gt;另外，说到女足职业化。随着欧美女足职业联赛的发展，她们的水平提高了很多，此消彼长，这就是后来北京奥运会、东京奥运会大比分输球，以及世界排名一路滑到19名的原因。&lt;/p&gt;
&lt;p&gt;做一个可能不正确的类比：10个人参加的比赛里，取得第3名的成绩，确实比50个人参加的比赛里取得第10名，看起来好看一些。&lt;/p&gt;
&lt;p&gt;但是，即便抛开职业化、商业化、参赛队伍基数等因素，有一说一，女足的精气神确实比男足要高出一大截来，尤其在春节密集得看了几场男足、女足的比赛对比就更明显了。&lt;/p&gt;
&lt;p&gt;豆瓣上有人整理了本届女足亚洲杯现役国家队成员的介绍：&lt;a href=&#34;https://www.douban.com/group/topic/258215115/?_dtcc=1&amp;amp;_i=4158490DTua3Gc&#34;&gt;中国女足现役国家队队员介绍（亚洲杯来了）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;是否一定要搞好足球&#34;&gt;是否一定要“搞好足球”？&lt;/h3&gt;
&lt;p&gt;这个问题见仁见智，我不认为一定有“搞好足球”的必要，毕竟比这个事情重要的事情还有很多，“足球”也并不能代表一个国家的综合国力。&lt;/p&gt;
&lt;p&gt;我比较同意知乎这个回答里的几段话：&lt;a href=&#34;https://www.zhihu.com/question/310636566/answer/1830192531&#34;&gt;为什么整个中国都知道中国足球的问题，为什么还是没有办法解决？ - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为和整个国家要解决的问题来比，中国足球不重要。&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;有基建重要吗？有国防重要吗？有教育重要吗？有医疗重要吗？有扶贫攻坚重要吗？有抗击疫情重要吗？……三百六十行，至少得有三百行排在竞技体育前面好不好？&lt;/p&gt;
&lt;p&gt;中国人喜欢足球吗？中国人只喜欢看足球，而且是可有可无的那种喜欢。真喜欢踢，投身足球事业的不会只有这么点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是不同意回答里的这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中国足球的问题不是没有办法解决，要解决中国足球的问题，集国家力量有一万种办法解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毕竟我们还从来没有解决过，实事求是。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结一下我的观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;足球属于商业化、职业化程度很高的竞技体育项目，“举国体制”从目前来看不适用于这样的领域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;足球在中国属于“参与度低、关注度高”的项目，看着很热闹，实际真正参与、从业的人并不多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为早期我们只关注奥运会的金银牌，所以集中力量发展冷门项目更容易出成绩。大部分人只关注简单的数字、金银牌，不会关注背后的难易程度，“10个人参加的比赛里，取得第3名的成绩，确实比50个人参加的比赛里取得第10名，看起来好看一些。”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我并不认为，有一定要“搞好足球”的必要性，至少现在没有，因为还有更重要的事情需要做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;足球在我看来是“大型社会实验”，是“客观规律的具象代言人”，规则透明、结果公开，所以我一直关注这个领域。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;只此青绿千里江山图和王希孟&#34;&gt;《只此青绿》、《千里江山图》和王希孟&lt;/h1&gt;
&lt;p&gt;虎年春晚个人认为最好的节目是脱胎于传世名画&lt;a href=&#34;https://baike.baidu.com/item/%E5%8D%83%E9%87%8C%E6%B1%9F%E5%B1%B1%E5%9B%BE/386355&#34;&gt;《千里江山图》&lt;/a&gt;的舞剧&lt;a href=&#34;https://www.youtube.com/watch?v=OZlUvIV50Ww&#34;&gt;《只此青绿》&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;最近几年看了好几个讲述《千里江山图》的纪录片，比如&lt;a href=&#34;https://www.youtube.com/watch?v=UYz1njDuqr4&#34;&gt;[国家宝藏]王希孟《千里江山图》卷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;宋徽宗赵佶固然是一个糟糕的皇帝，历史惨案“靖康之耻”大半的锅都是他的。但是也不能否认他在艺术上的成就，发掘、培养了天才少年王希孟，才能最后让《千里江山图》传世千年。可惜的是，王希孟就这一幅作品，后世再没有关于这个人的更多资料了。&lt;/p&gt;
&lt;p&gt;赵佶后来把这幅画赏赐给了蔡京，蔡京跋里能勉强看到一些王希孟作画时的信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此卷政和三年閏四月一日賜。希孟年十八嵗，昔在畫學為生徒，召入禁中文書庫，數以畫獻，未甚工。上知其性可教，遂誨諭之，親授其法，不踰半嵗，乃以此圖進，上嘉之，因以賜臣京，謂天下士在作之而已。今希孟已死，展卷深為悼惜。政和五年季春望太師魯國公臣京謹記&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这几句话里交代了几个信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;王希孟作画的时候才18岁。&lt;/li&gt;
&lt;li&gt;最开始，王希孟并不出色，但是赵佶看他潜力不错，于是亲自传授技法。&lt;/li&gt;
&lt;li&gt;王希孟完成这幅画，只用了不到半年的时间。要知道，《千里江山图》可是长达20米的巨幅画作。&lt;/li&gt;
&lt;li&gt;蔡京题跋的时候，王希孟已经死了。（&lt;code&gt;今希孟已死，展卷深為悼惜&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我特别喜欢陈丹青在&lt;a href=&#34;https://v.youku.com/v_show/id_XMTI2MDk4MTA5Ng==.html?spm=a2h0c.8166622.PhoneSokuProgram_1.dselectbutton_16&amp;amp;showid=cc117696c7cb11e4b432&#34;&gt;局部 第一季 千里江山图&lt;/a&gt;里评价十八岁王希孟的这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常成年的老熟的大师，喜欢做减法，也就是所谓取舍和概括，可十八岁英年的王希孟呢，他是忙着做加法。人在十八岁年纪，才会有这股子雄心和细心，一点不乱。不枝蔓，不繁杂，通篇贵气，清秀逼人。那就是他的天赋了。&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;十八岁干的事，多半其实是不自知的，他好也好在不自知。照西洋人的说法，那是上帝让他干了这件事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我回想起来我在这个岁数的时候，也是在“做加法”，天地广阔任我遨游；年纪大了，慢慢知道自己的边界在哪里，于是慢慢“做减法”，减掉自己做不到的事情。&lt;/p&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;武侠风格的滑雪创意短片&#34;&gt;武侠风格的滑雪创意短片&lt;/h2&gt;
&lt;p&gt;冬奥会正在进行中，B站上看到一个很有意思的武侠风格的滑雪创意短片：&lt;a href=&#34;https://www.bilibili.com/video/BV16q4y1h7v7&#34;&gt;我悍刀愿称你为最行&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;置身事内&#34;&gt;《置身事内》&lt;/h2&gt;
&lt;p&gt;一本讲解中国政经体制的好书，强烈推荐，看完之后能对国家层面宏观的很多政策等有更好的理解，比如城市化、土地财政政策、城市化等等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/35546622/&#34;&gt;置身事内 (豆瓣)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;paxos原理的直观解释&#34;&gt;Paxos原理的直观解释&lt;/h2&gt;
&lt;p&gt;这是目前看到这么多的Paxos原理解释的文章里写的最清晰的一篇了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.openacid.com/algo/paxos/&#34;&gt;可靠分布式系统-paxos的直观解释 - OpenACID Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他很多文章多是囫囵吞枣式的论文翻译，这篇文章有作者自己的理解和解释（图示、例子）。&lt;/p&gt;
&lt;h2 id=&#34;testing-distributed-systems&#34;&gt;Testing Distributed Systems&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://asatarin.github.io/testing-distributed-systems/&#34;&gt;Testing Distributed Systems | Curated list of resources on testing distributed systems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列举了各种分布式系统、数据库的测试方案。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
</description>
      
    </item>
    
  </channel>
</rss>
