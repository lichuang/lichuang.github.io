<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>btree on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/btree/</link>
    <description>Recent content in btree on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 01 Feb 2022 15:55:40 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/btree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>sqlite3.36版本 btree实现（五）- Btree的实现</title>
      <link>https://www.codedump.info/post/20220201-sqlite-btree-5-btree/</link>
      <pubDate>Tue, 01 Feb 2022 15:55:40 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220201-sqlite-btree-5-btree/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;前面的内容里，详细介绍了页面管理器部分的内容，回顾一下页面管理器和Btree模块的分工：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面管理器：提供页面级别的物理管理，如缓存、读取、写入、页面备份等。&lt;/li&gt;
&lt;li&gt;Btree：根据btree数据结构提供页面在逻辑上的组织，以及单个页面内的划分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还记得最开始，研究生产级别btree实现时的几个疑问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库教科书中，演示btree算法时，使用的都是定长的简单数据。实际应用中，存储的数据都是变长的，那么应该如何存储变长的数据呢？&lt;/li&gt;
&lt;li&gt;如果一行数据的大小，超过了一个物理页面的大小，又该如何处理？&lt;/li&gt;
&lt;li&gt;删除一行数据之后，它留下的空间如何回收利用？而回收利用时，不可避免的会出现碎片的问题，比如原先10字节的数据被回收，用来存储9字节的数据，多出来的1字节数据就被浪费了，碎片问题应该如何解决？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题，都与“一个物理页面内数据如何组织”这个核心问题息息相关，带着这些问题展开btree实现的讨论。&lt;/p&gt;
&lt;p&gt;在下文中，不会讨论btree算法的细节，这部分不熟悉的，可以回看之前的文章或者教科书：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;物理页面的数据组织&#34;&gt;物理页面的数据组织&lt;/h1&gt;
&lt;h2 id=&#34;数据表的逻辑组织和页面类型&#34;&gt;数据表的逻辑组织和页面类型&lt;/h2&gt;
&lt;p&gt;在展开具体的格式讨论之前，有必要先了解一下数据库文件的大体结构，已经不同的页面类型。&lt;/p&gt;
&lt;p&gt;sqlite中所谓的&lt;code&gt;数据库文件&lt;/code&gt;是单一文件，按照物理页面（2的次方）的大小来划分为多个页面。其中，每个表在数据库文件中是一棵btree的结构来组织，而不同类型的btree还区分了不同的页面。&lt;/p&gt;
&lt;p&gt;比如下图中，将平面的数据库文件，按照颜色划分成存储两个表的btree：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/database-file.png&#34; alt=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; title=&#34;数据库文件的物理页面组织和逻辑页面结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上半部分表示，在物理的组织上，一个数据库文件以一个物理页面为基本单位来存储。&lt;/li&gt;
&lt;li&gt;下半部分表示，在逻辑的组织上，不同的表都有自己的btree树形结构，这是物理页面在逻辑上的组织方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为每个表都有自己的btree树形结构，如果每个表都有一个对应的根页面编号，比如图中的两个表，对应的树形结构中，根节点所在的页面分别是1和2。&lt;/p&gt;
&lt;p&gt;接着来看不同的页面类型，以及存储上的差异。&lt;/p&gt;
&lt;p&gt;以一个例子来说明，创建以下的数据库，插入数据，以及索引：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 创建数据库COMPANY
CREATE TABLE COMPANY(
   ID             INT      NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

// 创建索引
CREATE INDEX id_index ON COMPANY (id);

// 插入2条数据
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, &amp;#39;Paul&amp;#39;, 32, &amp;#39;California&amp;#39;, 20000.00 );
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (2, &amp;#39;Allen&amp;#39;, 25, &amp;#39;Texas&amp;#39;, 15000.00 );

// 查询数据
sqlite&amp;gt; select * from COMPANY;
1|Paul|32|California|20000.0
2|Allen|25|Texas|15000.0

// 查询rowid和数据
sqlite&amp;gt; select rowid,* from COMPANY;
1|1|Paul|32|California|20000.0
2|2|Allen|25|Texas|15000.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面的流程里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个表&lt;code&gt;COMPANY&lt;/code&gt;，注意这个表在最开始是没有任何索引的。&lt;/li&gt;
&lt;li&gt;接下来，以字段&lt;code&gt;id&lt;/code&gt;来创建一个索引，插入2条数据。&lt;/li&gt;
&lt;li&gt;接下来，分别作了两次查询：一次查询全量的数据，第二次出现了一个在上面没有出现的一个字段&lt;code&gt;rowid&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了这里，问题就来了，&lt;code&gt;rowid&lt;/code&gt;是什么？为什么会自动存在这个字段，起了什么作用？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rowid&lt;/code&gt;是sqlite中的一个隐藏列：整数类型，自增。&lt;/p&gt;
&lt;p&gt;为什么需要这个隐藏列？有以下两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;rowid&lt;/code&gt;为键，来存储一行数据的全量数据。&lt;/li&gt;
&lt;li&gt;有了&lt;code&gt;rowid&lt;/code&gt;做为一行数据的键，其它索引存储的值就可以是这行数据的&lt;code&gt;rowid&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;即：&lt;code&gt;rowid&lt;/code&gt;在sqlite中是做为&lt;code&gt;聚簇索引（cluster index）&lt;/code&gt;出现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上面为例，在sqlite的btree中大体就是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/btree-rowid.png&#34; alt=&#34;数据库文件的rowid全量数据表和索引表&#34; title=&#34;数据库文件的rowid全量数据表和索引表&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中存在两个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以&lt;code&gt;rowid&lt;/code&gt;为键的全量数据表，在sqlite中存储这类型数据的btree被称为“table tree”。&lt;/li&gt;
&lt;li&gt;存储id索引的索引表，这类btree被称为“index tree”，因此存储的是索引数据。这个表的键是&lt;code&gt;id&lt;/code&gt;，而值是&lt;code&gt;rowid&lt;/code&gt;，这样根据&lt;code&gt;id&lt;/code&gt;索引来查询数据时，其实就是两步：
&lt;ul&gt;
&lt;li&gt;首先，根据&lt;code&gt;id&lt;/code&gt;找到对应的&lt;code&gt;rowid&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再根据&lt;code&gt;rowid&lt;/code&gt;到全量数据表里查询具体的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的这个例子里也可以看出，“逻辑意义”上的一个数据表，与实际存储时在btree中的表并不是一一对应的，由于索引表的存在，可能是一对多的关系。&lt;/p&gt;
&lt;p&gt;有了前面的对&lt;code&gt;rowid&lt;/code&gt;以及索引表、全量数据表的理解，就可以展开讨论不同的页面类型了。&lt;/p&gt;
&lt;p&gt;sqlite中分为几类页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以整数为键的页面：这类页面是以&lt;code&gt;b+tree&lt;/code&gt;模式来组织的。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部节点都只有键。&lt;/li&gt;
&lt;li&gt;数据部分都存储在叶子页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显然，全量数据表的页面就是这类页面，即全量数据表更准确的是&lt;code&gt;b+tree&lt;/code&gt;结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他类型的页面：其他表都是以整数为值，这类型的页面都是&lt;code&gt;btree&lt;/code&gt;类型，即内部节点、叶子节点都一样存储着键和值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了表示这些页面，有如下几种页面标志位：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;** Page type flags.  An ORed combination of these flags appear as the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;** first byte of on-disk image of every BTree page.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define PTF_INTKEY    0x01
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define PTF_ZERODATA  0x02
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define PTF_LEAFDATA  0x04
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define PTF_LEAF      0x08
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;PTF_INTKEY（1）：表示key为int类型数据，一般是rowid，即前面的&lt;code&gt;全量数据表&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;PTF_ZERODATA（2）：表示这是索引表的页面。&lt;/li&gt;
&lt;li&gt;PTF_LEAFDATA（4）：数据存储在叶子节点，这个标志位要和PTF_INTKEY一起作用。即：key为int类型数据的时候，有两种页面：一种只存储int类型的key，一种只存储数据。&lt;/li&gt;
&lt;li&gt;PTF_LEAF（8）：仅用于表示该页面是否叶子页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页面标志位只可能是以下几种组合，其余组合都认为文件损坏了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PTF_ZERODATA：表示这是索引表的内部页面。&lt;/li&gt;
&lt;li&gt;PTF_ZERODATA | PTF_LEAF：表示这是索引表的叶子页面。&lt;/li&gt;
&lt;li&gt;PTF_LEAFDATA | PTF_INTKEY：表示数据表的内部页面。&lt;/li&gt;
&lt;li&gt;PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF：表示数据表的叶子页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明，其实以上就是分成了两组&lt;code&gt;PTF_ZERODATA&lt;/code&gt;和&lt;code&gt;PTF_LEAFDATA | PTF_INTKEY&lt;/code&gt;与&lt;code&gt;PTF_LEAF&lt;/code&gt;的组合（见函数&lt;code&gt;decodeFlags&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PTF_ZERODATA：肯定没有数据（&lt;code&gt;hasData&lt;/code&gt;一定为0）。&lt;/li&gt;
&lt;li&gt;PTF_LEAFDATA | PTF_INTKEY：是否有数据，取决于是否有&lt;code&gt;PTF_LEAF&lt;/code&gt;标志位（&lt;code&gt;hasData&lt;/code&gt;取决于leaf ）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;物理页面的大体划分&#34;&gt;物理页面的大体划分&lt;/h2&gt;
&lt;p&gt;来看看sqlite代码中&lt;code&gt;btreeInt.h&lt;/code&gt;文件里对btree一个物理页面内数据组织的注释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; Each btree pages is divided into three &lt;span style=&#34;color:#a0a000&#34;&gt;sections&lt;/span&gt;:  The header, the
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; cell pointer array, and the cell content area.  Page &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; also has a &lt;span style=&#34;color:#666&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;byte
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt; file header that occurs before the page header.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; file header    &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;100&lt;/span&gt; bytes.  Page &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt; only.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; page header    &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt; bytes &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; leaves.  &lt;span style=&#34;color:#666&#34;&gt;12&lt;/span&gt; bytes &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; interior nodes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; cell pointer   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt; bytes per cell.  Sorted order.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; array          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;  Grows downward
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;                &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   v
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; unallocated    &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; space          &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;  Grows upwards
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; cell content   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;  Arbitrary order interspersed with freeblocks.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt; area           &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;   &lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;  and free space fragments.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;      &lt;span style=&#34;color:#666&#34;&gt;|----------------|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/page-format.png&#34; alt=&#34;页面内数组的组织&#34; title=&#34;页面内数组的组织&#34;&gt;&lt;/p&gt;
&lt;p&gt;按照这里的说法，一个物理页面在btree中划分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件头（file header）：100字节，但是只有第一个页面才会存在文件头。&lt;/li&gt;
&lt;li&gt;页面头（page header）：每个页面都会有页面头，根据页面的类型区分，如果是叶子页面就是8字节大小，如果是内部节点就是12字节大小。&lt;/li&gt;
&lt;li&gt;存储cell指针的数组（cell pointer array）：每个cell指针大小为2字节，按照存储的cell地址大小排序，这个数组不定长，因此是从低位往高位地址增长的。至于什么是&lt;code&gt;cell&lt;/code&gt;，后面展开说。&lt;/li&gt;
&lt;li&gt;cell内容空间（cell content area）：存储cell数据的空间，从一个物理页面的最高位置往低位增长。&lt;/li&gt;
&lt;li&gt;未分配空间（unallocated space）：上面两部分内容，一部分从从高往低增长，另一部分反之，而未分配空间就夹在这两者中间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这里大体的划分，我们来展开看看具体的内容。&lt;/p&gt;
&lt;h2 id=&#34;file-header文件头&#34;&gt;file header（文件头）&lt;/h2&gt;
&lt;p&gt;其中，file header部分只有第一页才有，固定长度100字节，存储整个数据库文件的元信息。&lt;/p&gt;
&lt;p&gt;页面1是一个特殊的页面，其前100个字节是整个数据库的header部分，内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;**   OFFSET   SIZE    DESCRIPTION
**      0      16     Header string: &amp;#34;SQLite format 3\000&amp;#34;
**     16       2     Page size in bytes.  
**     18       1     File format write version
**     19       1     File format read version
**     20       1     Bytes of unused space at the end of each page
**     21       1     Max embedded payload fraction
**     22       1     Min embedded payload fraction
**     23       1     Min leaf payload fraction
**     24       4     File change counter
**     28       4     Reserved for future use
**     32       4     First freelist page
**     36       4     Number of freelist pages in the file
**     40      60     15 4-byte meta values passed to higher layers
**
** All of the integer values are big-endian (most significant byte first).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逐个解析这个header里的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-16字节：magic string。&lt;/li&gt;
&lt;li&gt;16-18字节：页面大小，不能小于512或者大于32768，同时需要是8位对齐。&lt;/li&gt;
&lt;li&gt;18-19：大于1表示数据库只读。&lt;/li&gt;
&lt;li&gt;19-20：必须大于1。&lt;/li&gt;
&lt;li&gt;20-21：每个页面最后无用空间的大小。即可用空间=页面大小-无用空间，这部分空间不得小于500字节。&lt;/li&gt;
&lt;li&gt;21-23：写死了必须是&amp;quot;\100\040\040&amp;quot;。其中：
&lt;ul&gt;
&lt;li&gt;21：Max embedded payload fraction，写死了是64。&lt;/li&gt;
&lt;li&gt;22：Min embedded payload fraction，写死了是32。&lt;/li&gt;
&lt;li&gt;23：Min leaf payload fraction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;24-28：File change counter&lt;/li&gt;
&lt;li&gt;32-36：第一个空闲页面编号。&lt;/li&gt;
&lt;li&gt;36-40：空闲页面数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;page-header页面头&#34;&gt;page header（页面头）&lt;/h2&gt;
&lt;p&gt;除了第一页以外，其他情况下页面头在页面的开始位置（即偏移量为0开始），第一页从偏移量100开始。&lt;/p&gt;
&lt;p&gt;其内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;** The page headers looks like this:
**
**   OFFSET   SIZE     DESCRIPTION
**      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
**      1       2      byte offset to the first freeblock
**      3       2      number of cells on this page
**      5       2      first byte of the cell content area
**      7       1      number of fragmented free bytes
**      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-1：表示页面类型的标志位，至于页面的类型上面已经有阐述。&lt;/li&gt;
&lt;li&gt;1-2：首个空闲block在页面内的偏移量。&lt;/li&gt;
&lt;li&gt;3-5：cell数组的大小。&lt;/li&gt;
&lt;li&gt;5-7：cell content的第一个字节。&lt;/li&gt;
&lt;li&gt;7-8：碎片空间总大小（注意不是空闲空间），sqlite中将小于4字节的空闲空间称为&lt;code&gt;碎片空间&lt;/code&gt;，一旦碎片空间大小累积到一定程度，就需要进行碎片整理，这在下面展开说明。&lt;/li&gt;
&lt;li&gt;8-12（叶子页面没有这部分内容）：右子树页面的页面编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重点解释其中的几部分：&lt;/p&gt;
&lt;h3 id=&#34;cell数组&#34;&gt;cell数组&lt;/h3&gt;
&lt;p&gt;cell数组中，每个元素大小为2字节，指向对应cell内容在页面中的位置。由于一个页面不会超过65535字节大小，所以2字节是足够表示这个页面内的偏移量的。&lt;/p&gt;
&lt;p&gt;另外，cell数组中的元素，是按照key的大小有小到大按顺序排列的，这样才能方便查找。&lt;/p&gt;
&lt;p&gt;有了对物理页面内数据组织的了解，可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找数据时，首先按照按照btree的算法，定位到数据所在的页面。&lt;/li&gt;
&lt;li&gt;再在页面内的cell数组中，根据key大小进行二分查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/find-key.png&#34; alt=&#34;查找key的流程&#34; title=&#34;查找key的流程&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;空闲空间链表&#34;&gt;空闲空间链表&lt;/h3&gt;
&lt;p&gt;所谓的“空闲空间”，就是夹在&lt;code&gt;cell数组&lt;/code&gt;和&lt;code&gt;cell内容数组&lt;/code&gt;中间的部分，最开始是一大整块的空间。&lt;/p&gt;
&lt;p&gt;但是随着写入操作进行，比如一行数据被删除之后，回收的空间就会放到空闲空间链表上。空闲空间链表就是用来组织现在空闲空间的数据的，其中的每个元素为4字节，其内容是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   **    SIZE    DESCRIPTION
   **      2     Byte offset of the next freeblock
   **      2     Bytes in this freeblock
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-2字节：下一块空闲空间链表的页内偏移量。&lt;/li&gt;
&lt;li&gt;3-4字节：当前这块空闲空间的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，空闲空间链表是按照起始地址递增进行排序的，这样才能在从空闲空间中分配空间时高效查找最合适的空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/freelist.png&#34; alt=&#34;空闲区链表&#34; title=&#34;空闲区链表&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;碎片空间总大小&#34;&gt;碎片空间总大小&lt;/h3&gt;
&lt;p&gt;如前所述，表示一个空闲空间至少需要4字节，因此如果一个空闲空间不足4字节时，显然是不划算的。所以，将所有空闲的、且小于4字节的空间，称为“碎片空间”，其总大小记录在头的7-8字节处，当这个值超过某个阈值时将进行页面碎片空间整理。&lt;/p&gt;
&lt;h3 id=&#34;页面标志位&#34;&gt;页面标志位&lt;/h3&gt;
&lt;p&gt;见前面&lt;code&gt;页面类型&lt;/code&gt;部分的解释。&lt;/p&gt;
&lt;h2 id=&#34;cell的结构&#34;&gt;cell的结构&lt;/h2&gt;
&lt;p&gt;一个&lt;code&gt;cell&lt;/code&gt;，就是存储一行数据的单位，由于要考虑一行数据有不同的长度，因此&lt;code&gt;cell&lt;/code&gt;里面就要有应对变长数据的准备，来看&lt;code&gt;cell&lt;/code&gt;的结构。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;** The content of a cell looks like this:
**
**    SIZE    DESCRIPTION
**      4     Page number of the left child. Omitted if leaf flag is set.
**     var    Number of bytes of data. Omitted if the zerodata flag is set.
**     var    Number of bytes of key. Or the key itself if intkey flag is set.
**      *     Payload
**      4     First page of the overflow chain.  Omitted if no overflow
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逐个解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-4：左子树的页面编号（如果是叶子页面这部分没有）。&lt;/li&gt;
&lt;li&gt;变长：数据部分的大小。&lt;/li&gt;
&lt;li&gt;变长：key部分的大小。但是如果这个页面是&lt;code&gt;intkey&lt;/code&gt;页面，这部分直接用来保存int类型的key，即这种情况下int类型key不会出现在后面的payload部分，而是直接存在在key部分大小的位置。&lt;/li&gt;
&lt;li&gt;变长：payload。&lt;/li&gt;
&lt;li&gt;4字节：如果存在overflow页面的话，这里存储第一个overflow页面的页面编号，何为溢出页面下面再做解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为叶子页面没有左子树，所以不需要存储&lt;code&gt;左子树页面编号&lt;/code&gt;，因为如果是叶子页面的话，页面头的大小就只有8字节，反之如果是内部节点就需要12字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/cell-content-format.png&#34; alt=&#34;cell结构&#34; title=&#34;cell结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中，根据表类型的不同，key、data、payload部分的大小关系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int类型的key（即table tree）：nPayload 与 nData恒相等，因为int类型的表，由于key就是一个整型数，所以不浪费空间存储这个整型数的值，而是直接放在key大小部分。区分是否有数据，有以下两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无数据（即内部节点）：因为nPayload 与 nData恒相等，所以这时候nData = nPayload = 0。（分析这类型页面cell数据的入口函数是&lt;code&gt;btreeParseCellPtrNoPayload&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;有数据（即叶子页面）：nData = nPayload = 变长数据的大小。（分析这类型页面cell数据的入口函数是&lt;code&gt;btreeParseCellPtr&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非int类型的表（即index tree）：&lt;/p&gt;
&lt;p&gt;这种类型的页面，肯定没有数据部分，只有key部分，所以这时候nPayload = nKey。（分析这类型页面cell数据的入口函数是&lt;code&gt;btreeParseCellPtrIndex&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么非int类型的表，会没有数据部分？这是因为，完整的数据，都以rowid为key的情况，存储在了int类型的表中；而非int类型的表，只要存储这个表的键值整数即可。&lt;/p&gt;
&lt;p&gt;而溢出页面的结构如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;** Overflow pages form a linked list.  Each page except the last is completely
** filled with data (pagesize - 4 bytes).  The last page can have as little
** as 1 byte of data.
**
**    SIZE    DESCRIPTION
**      4     Page number of next overflow page
**      *     Data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：对于存储溢出数据的页面而言，头部的4字节存储下一个溢出页面的页面编号（如果还有溢出页面的话），而剩余则存储数据。&lt;/p&gt;
&lt;p&gt;结合起来，一个存储了溢出数据（即当前页面不足以存储这个cell的所有数据）的结构大体是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/cell-overflow.png&#34; alt=&#34;有溢出页面的cell结构&#34; title=&#34;有溢出页面的cell结构&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;空间利用和碎片整理&#34;&gt;空间利用和碎片整理&lt;/h1&gt;
&lt;p&gt;了解了一个物理页面内部的结构，接下来看碎片整理的实现。&lt;/p&gt;
&lt;p&gt;虽然有空闲链表用于组织已被回收的空间，但是随着分配的进行，还是会产生各种大小的碎片。可能会出现这样的情况：虽然空闲空间的总大小够用，但是由于散落在各块碎片空间里，以至于无法分配成功。&lt;/p&gt;
&lt;p&gt;这种情况下，就需要&lt;code&gt;碎片整理&lt;/code&gt;流程，这个流程做完之后，要达到这样的目的：空闲链表上只有一块大的整空间。&lt;/p&gt;
&lt;p&gt;来看看&lt;code&gt;碎片整理&lt;/code&gt;的触发条件和过程。&lt;/p&gt;
&lt;h2 id=&#34;碎片整理的触发条件&#34;&gt;碎片整理的触发条件&lt;/h2&gt;
&lt;p&gt;分配空间的入口函数是&lt;code&gt;allocateSpace&lt;/code&gt;，其入参&lt;code&gt;nByte&lt;/code&gt;表示需要从页面中分配大小为&lt;code&gt;nByte&lt;/code&gt;的空间返回。进入这个函数时，都会首先判断：页面剩余的空闲空间是足够满足&lt;code&gt;nByte&lt;/code&gt;的，但是即便如此也可能由于碎片太多导致不能再分配了。&lt;/p&gt;
&lt;p&gt;这个函数的大体逻辑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试在空闲链表中找到合适的空间分配。（函数&lt;code&gt;pageFindSlot&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;如果上面分配不成功，且当前甚至在cell指针数组中都分配不出2字节来存储新分配出来的cell地址，那么就需要进行碎片整理。（函数&lt;code&gt;defragmentPage&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;碎片整理结束之后，划出足够的空间（2字节的cell指针+对应大小的cell大小）返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，分别来看上面两个条件。&lt;/p&gt;
&lt;p&gt;首先来看什么情况下在空闲链表中分配不出适合的空间，入口函数是&lt;code&gt;pageFindSlot&lt;/code&gt;，有两种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为空闲链表是按照空闲块大小从小到大排列的，因此首先按序找到第一块满足&lt;code&gt;nByte&lt;/code&gt;大小的空闲块，假设这个空闲块划掉&lt;code&gt;nByte&lt;/code&gt;大小之后为&lt;code&gt;x&lt;/code&gt;，若这个&lt;code&gt;x&lt;/code&gt;小于4字节那么认为是一个&lt;code&gt;碎片&lt;/code&gt;，假如当前的碎片累加起来超过60字节了，那么认为碎片过多，这时候即便能满足分配也不能继续分配。&lt;/p&gt;
&lt;p&gt;至于为什么小于4字节认为是碎片，以及为什么碎片总大小超过60字节就认为碎片过多，可能是作者的经验值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种情况，就是遍历了整个链表都没有找到满足&lt;code&gt;nByte&lt;/code&gt;大小的空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，如果当前cell数组结束位置，距离cell内容区域不足2字节，即无法再分配一个cell指针出来，这时候就需要进行碎片整理了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/defragment.png&#34; alt=&#34;触发碎片整理的条件&#34; title=&#34;触发碎片整理的条件&#34;&gt;&lt;/p&gt;
&lt;p&gt;总结一下触发碎片整理的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从空闲链表中分配空间失败。&lt;/li&gt;
&lt;li&gt;且，在&lt;code&gt;cell指针数组&lt;/code&gt;以及&lt;code&gt;cell内容区域&lt;/code&gt;的空间，已经不足2字节，即连对应的cell指针都无法分配出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;碎片整理的流程&#34;&gt;碎片整理的流程&lt;/h2&gt;
&lt;p&gt;碎片整理的流程，其实相对简单，简而言之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把各块cell内容，全部整理到从页面结尾开始的空间。&lt;/li&gt;
&lt;li&gt;这样，就能把散落在各处的空闲空间重新合并在一起形成一大块的空闲空间了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/defragmentPage.png&#34; alt=&#34;碎片整理前后&#34; title=&#34;碎片整理前后&#34;&gt;&lt;/p&gt;
&lt;p&gt;碎片整理的整体流程在函数&lt;code&gt;defragmentPage&lt;/code&gt;中，读者可以自行阅读。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;sqlite中分为table tree（存储全量数据）和index tree（存储任意索引到rowid的对应关系），table tree本质是一棵b+tree，而index tree是一棵btree。&lt;/li&gt;
&lt;li&gt;在物理页面内部，有根据key大小排序的cell数组，查找数据时分为两步：
&lt;ul&gt;
&lt;li&gt;首先根据btree算法定位到数据所在的物理页面。&lt;/li&gt;
&lt;li&gt;然后在该物理页面内部的cell数组中，二分查找定位key的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物理页面内的空闲空间使用链表维护起来，小于4字节的空闲空间被称为“碎片空间”，当碎片空间累计大小超过60字节时，就会进行碎片整理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sqlite.org/btreemodule.html&#34;&gt;SQLite B-Tree Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/fileformat.html&#34;&gt;Database File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://barbra-coco.dyndns.org/sqlite/fileformat.html&#34;&gt;SQLite Database File Format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（四）- WAL的实现</title>
      <link>https://www.codedump.info/post/20220106-sqlite-btree-4-wal/</link>
      <pubDate>Thu, 06 Jan 2022 21:48:18 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220106-sqlite-btree-4-wal/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;前面两节，分别讲解了sqlite中写入事务时的并发控制框架，以及journal备份文件的实现机制。&lt;/p&gt;
&lt;p&gt;回忆一下journal备份文件的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次一个新的写事务开始之前，要首先写journal文件的文件头。&lt;/li&gt;
&lt;li&gt;写事务过程中，如果修改了哪个页面，在修改之前需要首先将这个页面的内容写入到journal文件中。&lt;/li&gt;
&lt;li&gt;写事务完成后，在同步所有缓存中被修改的页面到数据库文件之前，要首先将journal文件中的所有修改同步到磁盘，然后再修改数据库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，journal备份的整个流程都较为原始，性能不高，所以在sqlite 3.7.0版本（&lt;a href=&#34;https://www.sqlite.org/releaselog/3_7_0.html&#34;&gt;SQLite Release 3.7.0 On 2010-07-21&lt;/a&gt;，2010-07-21）中，引入了另一种备份机制：WAL（Write Ahead Log）。&lt;/p&gt;
&lt;p&gt;本节首先介绍WAL的实现原理，然后再展开其具体的实现。&lt;/p&gt;
&lt;h1 id=&#34;wal工作原理&#34;&gt;WAL工作原理&lt;/h1&gt;
&lt;p&gt;从前面journal的实现中可以看到，写入journal文件中的内容，是待修改页面修改之前的内容，而WAL则相反：被修改的页面内容首先写入到WAL中。&lt;/p&gt;
&lt;p&gt;用sqlite官网的文字来说，WAL文件的定义是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The write-ahead log or &amp;ldquo;wal&amp;rdquo; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即WAL文件中存储的是被修改但是还没有写入数据库文件的页面内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/page-backup.png&#34; alt=&#34;两种页面备份机制&#34; title=&#34;两种页面备份机制&#34;&gt;&lt;/p&gt;
&lt;p&gt;WAL整体的实现机制，分为以下几个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对页面的修改，可以只写入到WAL文件中就认为完成，不必一定要落盘到数据库文件才能算完成，这个设定保证了WAL的修改操作比journal性能有很大的提升。&lt;/li&gt;
&lt;li&gt;由于上面的这一点保证，同一时间的并发读操作，能继续读数据库中未修改的内容，极大提升了读并发的性能。&lt;/li&gt;
&lt;li&gt;当然WAL也不能无限制的一直写下去，必须有一个机制，触发将保存在WAL中的页面内容写入回到数据库文件中，这个流程被称为&lt;code&gt;checkpoint&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wal相关文件结构&#34;&gt;WAL相关文件结构&lt;/h2&gt;
&lt;p&gt;在工作原理部分，只会简单讲解WAL相关文件结构，具体的格式等细节留待下面的实现部分详细讲解。&lt;/p&gt;
&lt;p&gt;WAL文件本身的格式很简单，有如下两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WAL文件头。&lt;/li&gt;
&lt;li&gt;紧跟着文件头之后的，就是由修改之后的页面内容组成的页面内容数组。&lt;/li&gt;
&lt;li&gt;最后，当事务被提交时，还会有一个特殊的WAL日志，标记这个事务提交了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换言之，一个WAL中，可能先后存储了多个事务的写入。&lt;/p&gt;
&lt;p&gt;由于WAL文件保存的&lt;strong&gt;修改页面&lt;/strong&gt;的内容，同一个页面，可能在一次事务中被多次修改，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-and-index.png&#34; alt=&#34;WAL及WAL页面索引数据&#34; title=&#34;WAL及WAL页面索引数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;WAL存储了四个页面数据，其中页面编号1被修改了两次。&lt;/p&gt;
&lt;p&gt;如果在这个写操作完成之后，需要读这些页面的内容，都需要读到最新的内容。所以，WAL还有一个对应的&lt;code&gt;WAL页面索引&lt;/code&gt;数据，这部分索引数据存储在内存中，作用是根据页面编号，知道该页面编号对应的最新内容，存储在WAL文件中的具体位置，以取得某个页面的最新页面内容；如果在这个内存索引中查不到的数据，都需要到数据库文件中读取。&lt;/p&gt;
&lt;h2 id=&#34;checkpoint&#34;&gt;checkpoint&lt;/h2&gt;
&lt;p&gt;随着WAL文件的增长，终究要将里面修改的内容同步到数据库文件中，这个流程被称为“checkpoint”。只要WAL文件被“checkpoint”，就可以从头开始写这个文件，避免文件的无限增大。&lt;/p&gt;
&lt;p&gt;对于journal备份机制而言，只有两种操作：读和写；而对于WAL机制而言，实际有三种操作：读、写、checkpoint。这也是两种机制的主要区别之一。&lt;/p&gt;
&lt;h2 id=&#34;并发的实现&#34;&gt;并发的实现&lt;/h2&gt;
&lt;p&gt;前面提到了，WAL机制的一个优势在于：在写未完成之前，可以允许同时并发多个读操作，来看看这一点是如何做到的。&lt;/p&gt;
&lt;p&gt;在每次读操作开始之前，都会记录下来当前最后提交事务的提交记录，这条记录被称为“end mark”。因为WAL会随着写操作的进行不断增加，通过读操作的“end mark”，就能知道对于这个读操作而言，页面内容应该以当前WAL内容为准，还是以数据库文件为准。&lt;/p&gt;
&lt;p&gt;以下图为例来做个说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/read-concurrency.png&#34; alt=&#34;读并发的实现&#34; title=&#34;读并发的实现&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WAL文件中先后记录了两个写事务，其中第一个写事务修改了页面编号1、2，已经提交完成；还有一个在进行还未完成的写事务，修改了页面编号1。&lt;/li&gt;
&lt;li&gt;这时候，如果来了一个读事务，那么将记录下来最后一个完成事务的提交记录做为自己的“end mark”，即图中的浅蓝色的那个提交记录。&lt;/li&gt;
&lt;li&gt;假设现在这个读事务，依次要读取页面编号1和2的页面，那么：
&lt;ul&gt;
&lt;li&gt;到页面索引中查询页面1的位置，发现位置比自己的“end marker”更大，也就是说这个页面在上一次完成写事务之后，被当前还未完成的写事务修改了，于是并不能读WAL的内容，因为这部分内容对这个读操作来说还是未提交的，所以页面1需要到数据库文件中读取。&lt;/li&gt;
&lt;li&gt;到页面索引中查询页面2的位置，发现位置比自己的“end marker”更小，也就是在自己标记的写事务完成之后并未被修改过，于是可以读WAL中这个页面的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，有了“end mark”这一标记位置之后，加上页面索引，任意数量的读操作都能快速判断自己应该读WAL文件还是数据库文件，写操作可以继续写，读和写之间并不会冲突，极大提升了读并发的性能。&lt;/p&gt;
&lt;p&gt;同样要看到的是，由于只有一个WAL文件，同一时间之内，只能有一个写操作。即：&lt;strong&gt;sqlite的WAL模式，只能支持单写多读的模式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;读操作和checkpoint的联系&#34;&gt;读操作和checkpoint的联系&lt;/h2&gt;
&lt;p&gt;前面讲到了checkpoint以及读并发的实现，两者可以并发一起执行，但是某些时刻会有一些关联，影响系统的性能。&lt;/p&gt;
&lt;p&gt;因为超过读操作“end mark”的页面，读操作需要到数据库文件中读取该页面内容，那么反过来，当checkpoint操作要将一个超过当前并发的&lt;strong&gt;任意读操作&lt;/strong&gt;“end mark”的页面落到数据库文件中时，就必须等待这个读操作完成才能进行。&lt;/p&gt;
&lt;p&gt;仍然以前面读并发的示意图来解释这个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;checkpoint 页面编号2的内容到数据库文件时，该页面最后在WAL文件中的位置，并不比当前的任意读操作的“end mark“更大，所以checkpoint这个页面的内容到数据库文件时无需等待即可完成。&lt;/li&gt;
&lt;li&gt;反过来，checkpoint 页面编号1的内容到数据库文件时，该页面最后在WAL文件中的位置，大于当前读操作的”end mark“，所以这个页面的内容就需要等待读操作完成才能进行下去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换言之：一个执行很久的读操作，可能会影响同时在进行的checkpoint操作的执行。&lt;/p&gt;
&lt;p&gt;被阻塞的checkpoint必须等待读操作完成才能继续执行，因此需要一些额外的信息来维护当前checkpoint执行的状态，这些具体的实现细节都会在下面实现环节的分析中涉及。&lt;/p&gt;
&lt;p&gt;现在已经大体清楚WAL的原理了，下面来看具体的实现。&lt;/p&gt;
&lt;h1 id=&#34;wal的实现&#34;&gt;WAL的实现&lt;/h1&gt;
&lt;p&gt;sqlite中，可以使用&lt;code&gt;PRAGMA journal_mode=wal&lt;/code&gt;设置页面备份机制为wal，这时候就会有三个与数据库相关的文件在同一个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库文件，假设名字为X。&lt;/li&gt;
&lt;li&gt;WAL文件，名字为“X-wal”。&lt;/li&gt;
&lt;li&gt;wal索引文件，名字为“X-shm”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wal的文件格式&#34;&gt;WAL的文件格式&lt;/h2&gt;
&lt;p&gt;首先来看WAL文件的格式，分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WAL文件头：一次写事务，对应一个WAL文件头。&lt;/li&gt;
&lt;li&gt;除去文件头，每一页数据都是存储在“帧（frame）”里，每一帧又包括两部分数据：
&lt;ul&gt;
&lt;li&gt;帧头部：描述存储的这一页数据的信息。&lt;/li&gt;
&lt;li&gt;页面数据：存储页面数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WAL文件头，只会在每次写事务中写入一次，而帧可能在一次写事务中多多个，取决于这一次写事务修改了多少页面。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-format.png&#34; alt=&#34;WAL文件结构&#34; title=&#34;WAL文件结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，依次存储了两次写事务的数据，其中第一次写了两帧数据，第二次写了一帧数据。&lt;/p&gt;
&lt;p&gt;有了以上的概念，下面详细看WAL文件的结构。&lt;/p&gt;
&lt;h3 id=&#34;wal文件头格式&#34;&gt;WAL文件头格式&lt;/h3&gt;
&lt;p&gt;（引用自 &lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt; section 4.1）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Offset&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Size&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Magic number. 0x377f0682 or 0x377f0683&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;File format version. Currently 3007000.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Database page size. Example: 1024&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checkpoint sequence number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Salt-1: random integer incremented with each checkpoint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Salt-2: a different random number for each checkpoint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;24&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checksum-1: First part of a checksum on the first 24 bytes of header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;28&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checksum-2: Second part of the checksum on the first 24 bytes of header&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中的很多字段自有解释，其中多数涉及到页面内容的校验，后面再展开说。&lt;/p&gt;
&lt;h3 id=&#34;wal帧头部格式&#34;&gt;WAL帧头部格式&lt;/h3&gt;
&lt;p&gt;（引用自 &lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt; section 4.1）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Offset&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Size&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;For commit records, the size of the database file in pages after the commit. For all other records, zero.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Salt-1 copied from the WAL header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Salt-2 copied from the WAL header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checksum-1: Cumulative checksum up through and including this page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checksum-2: Second half of the cumulative checksum.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;帧头部需要存储如下的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-4字节：页面编号。&lt;/li&gt;
&lt;li&gt;4-8字节：对于提交记录而言，这4字节存储的是该事务提交之后，数据库文件的最大页面编号；其它的时候，这4字节为0。也就是说，这4字节大于0的时候，表示是一次事务的最后一次页面修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它的字段，都跟页面的校验有关，接下来就看看这部分的实现。&lt;/p&gt;
&lt;h3 id=&#34;页面内容校验算法&#34;&gt;页面内容校验算法&lt;/h3&gt;
&lt;p&gt;前面的格式中，无论是WAL文件头，还是WAL帧头部，都有以下的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8字节的salt数据。&lt;/li&gt;
&lt;li&gt;两组4字节的checksum数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;校验时，只有满足以下条件的情况下才认为是正确的帧数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帧头部中的8字节的salt数据，和WAL头部的salt数据相同。&lt;/li&gt;
&lt;li&gt;根据校验算法遍历页面数据计算出来的checksum，和帧头部的checksum数据相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一部分salt数据，每次写事务生成一次，所以校验这个值可以认为校验这一帧数据是否和这次事务匹配；而第二部分的checksum数据，则会用来依次串起一次写事务的所有页面修改。&lt;/p&gt;
&lt;p&gt;比如下面这个写事务流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次写页面，由于之前这个写事务没有写过页面，所以初始的checksum为0，以这个初始的checksum来计算这第一个页面的checksum，计算之后的值记录到这个页面的checksum，记为&lt;code&gt;checksum_1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第二次写页面，取上一次计算的checksum即&lt;code&gt;checksum_1&lt;/code&gt;，来计算这第二个页面的checksum，记为&lt;code&gt;checksum_2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;类似的，第N次写页面时，以上一次计算的checksum即&lt;code&gt;checksum_n-1&lt;/code&gt;来做为计算的初始值计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，相邻页面之间的校验值就有了关联。&lt;/p&gt;
&lt;p&gt;总结起来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;salt：每次事务算一次随机值。&lt;/li&gt;
&lt;li&gt;checksum：满足以下以下条件：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;checksum_0 = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checksum_n = F(checksum_n-1, 页面数据) &lt;/code&gt;，其中函数F是根据初始校验值和页面数据计算出新校验值的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;校验页面的函数实现在&lt;code&gt;walDecodeFrame&lt;/code&gt;中，而计算页面校验值的函数实现在&lt;code&gt;walChecksumBytes&lt;/code&gt;中。&lt;/p&gt;
&lt;h2 id=&#34;wal页面索引&#34;&gt;WAL页面索引&lt;/h2&gt;
&lt;h3 id=&#34;结构&#34;&gt;结构&lt;/h3&gt;
&lt;p&gt;前面分析WAL文件结构的时候，提到保存一页数据的内容被称为“帧（frame）”，帧的编号从1开始顺序递增，每一帧内容存储的页面内容可能会发生变化，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-frame.png&#34; alt=&#34;帧与页面的对应关系&#34; title=&#34;帧与页面的对应关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中，依次有四帧页面数据，帧数与页面的对应关系依次是：(1,1)，(2,3)，(3,5)，(4,4)。假设随着运行，第一帧对应的页面1被写入了数据库，那么第一帧的空间就会被复用来存储别的页面的内容。&lt;/p&gt;
&lt;p&gt;所以，WAL页面索引中，需要存储帧数与页面编号之间的对应关系，这样就能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问一帧的内容时，知道保存的是哪个页面的内容；&lt;/li&gt;
&lt;li&gt;根据页面编号，能查到这个页面的最新数据保存在哪一帧中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据需要的这两份数据，定义了用于保存wal索引的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; WalHashLoc {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt; ht_slot &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;aHash;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Start of the wal-index hash table */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;volatile&lt;/span&gt; u32 &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;aPgno;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* aPgno[1] is the page of first frame indexed */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 iZero;                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* One less than the frame number of first indexed*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aHash：保存了根据页面编号查找iFrame帧数的hash数组数据。&lt;/li&gt;
&lt;li&gt;aPgno：保存了根据帧数查找页面编号的数据。&lt;/li&gt;
&lt;li&gt;iZero：保存了当前索引页面第一帧的帧数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这么看来有一些抽象，我们以下图来做解释wal-index文件的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-index-format.png&#34; alt=&#34;WAL-Index索引文件结构图&#34; title=&#34;WAL-Index索引文件结构图&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wal索引文件一页大小为32KB，需要注意的是：不要把wal索引文件的一页与数据库文件的一页搞混，两者并不一定相同，但是都为2的次方，数据库文件的一页可以编译期修改，但是wal索引文件的一页大小写死为32KB。&lt;/li&gt;
&lt;li&gt;第一页相对有些特殊，因为最开始的136字节是wal索引文件头，所以相对的，剩下用来存储索引数据的空间就会变少一些。索引文件头的内容，留待后面再详细解释。&lt;/li&gt;
&lt;li&gt;每一页存储的数据中，&lt;code&gt;aPgno&lt;/code&gt;大小为4096（第一页只有4062，因为有头部用到的空间），&lt;code&gt;aHash&lt;/code&gt;的大小为8192。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/WalHashLoc.png&#34; alt=&#34;页面索引数据的构成&#34; title=&#34;页面索引数据的构成&#34;&gt;&lt;/p&gt;
&lt;p&gt;这几个常量，由下面这几个宏来定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 每一页aPgno数组大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define HASHTABLE_NPAGE      4096                 &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Must be power of 2 */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 查询时hash取模时的质数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define HASHTABLE_HASH_1     383                  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Should be prime */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 每一页hash slot数组大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Must be a power of 2 */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 页面1实际能容纳的aPgno大小：HASHTABLE_NPAGE减去WALINDEX_HDR_SIZE使用的大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 一个wal索引页面的大小，为4096*4+8192*2 = 32KB
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WALINDEX_PGSZ   (                                         \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;索引文件头结构&#34;&gt;索引文件头结构&lt;/h4&gt;
&lt;p&gt;来看看索引文件头的结构，其整体大小为136字节，划分为三部分：&lt;/p&gt;
&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt; section 2.1）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Bytes&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0..47&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First copy of the WAL Index Information&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;48..95&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Second copy of the WAL Index Information&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;96..135&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checkpoint Information and Locks&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这总共136字节的数据，一共分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-47字节：WAL索引头部，由结构体&lt;code&gt;WalIndexHdr&lt;/code&gt;来描述。&lt;/li&gt;
&lt;li&gt;48-95字节：还是一个由结构体&lt;code&gt;WalIndexHdr&lt;/code&gt;描述的WAL索引头部。&lt;/li&gt;
&lt;li&gt;96-136字节：由结构体&lt;code&gt;WalCkptInfo&lt;/code&gt;描述的WAL checkpoint信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的表格，详细展示了这136字节中都有哪些字段。&lt;/p&gt;
&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt; section 2.1）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Bytes&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0..3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;iVersion&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;The WAL-index format version number. Always 3007000.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4..7&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unused padding space. Must be zero.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8..11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;iChange&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unsigned integer counter, incremented with each transaction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;isInit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;The &amp;ldquo;isInit&amp;rdquo; flag. 1 when the shm file has been initialized.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bigEndCksum&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;True if the WAL file uses big-ending checksums. 0 if the WAL uses little-endian checksums.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;14..15&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;szPage&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;The database page size in bytes, or 1 if the page size is 65536.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;16..19&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;mxFrame&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Number of valid and committed frames in the WAL file.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;20..23&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nPage&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Size of the database file in pages.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;24..31&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;aFrameCksum&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Checksum of the last frame in the WAL file.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;32..39&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;aSalt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40..47&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;aCksum&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A checksum over bytes 0 through 39 of this header.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;48..95&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;A copy of bytes 0 through 47 of this header.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;96..99&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nBackfill&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Number of WAL frames that have already been backfilled into the database by prior checkpoints&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100..119&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;read-mark[0..4]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Five &amp;ldquo;read marks&amp;rdquo;. Each read mark is a 32-bit unsigned integer (4 bytes).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120..127&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unused space set aside for 8 file locks.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;128..132&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nBackfillAttempted&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;132..136&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unused space reserved for further expansion.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面就这里的一些重点字段做一下介绍。&lt;/p&gt;
&lt;h5 id=&#34;为什么需要两个相同大小的wal索引头部&#34;&gt;为什么需要两个相同大小的WAL索引头部？&lt;/h5&gt;
&lt;p&gt;注意到0-47和48-95这两部分48字节的数据，都是同样类型的数据，都由&lt;code&gt;WalIndexHdr&lt;/code&gt;结构体来描述。&lt;/p&gt;
&lt;p&gt;这样设计的目的，是为了读写的时候数据校验。假设头48字节为&lt;code&gt;h1&lt;/code&gt;，后48字节为&lt;code&gt;h2&lt;/code&gt;。那么读操作的时候是先读&lt;code&gt;h1&lt;/code&gt;再读&lt;code&gt;h2&lt;/code&gt;，而写操作的时候则相反，先写&lt;code&gt;h2&lt;/code&gt;再写&lt;code&gt;h1&lt;/code&gt;。这样，如果在读操作的时候，读到这两部分内容并不一样，说明当前有写操作在进行。&lt;/p&gt;
&lt;p&gt;读头部的实现见函数&lt;code&gt;walIndexTryHdr&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged)
{
  u32 aCksum[2];              /* Checksum on the header content */
  WalIndexHdr h1, h2;         /* Two copies of the header content */
  WalIndexHdr volatile *aHdr; /* Header in shared memory */

  aHdr = walIndexHdr(pWal);
  memcpy(&amp;amp;h1, (void *)&amp;amp;aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */
  walShmBarrier(pWal);
  memcpy(&amp;amp;h2, (void *)&amp;amp;aHdr[1], sizeof(h2));

  // 对比两个header，不相同就返回
  if (memcmp(&amp;amp;h1, &amp;amp;h2, sizeof(h1)) != 0)
  {
    return 1; /* Dirty read */
  }
  if (h1.isInit == 0)
  {
    return 1; /* Malformed header - probably all zeros */
  }
  // 对比校验值
  walChecksumBytes(1, (u8 *)&amp;amp;h1, sizeof(h1) - sizeof(h1.aCksum), 0, aCksum);
  if (aCksum[0] != h1.aCksum[0] || aCksum[1] != h1.aCksum[1])
  {
    return 1; /* Checksum does not match */
  }

  // 到了这里，就是判断是否发生过改变了
  if (memcmp(&amp;amp;pWal-&amp;gt;hdr, &amp;amp;h1, sizeof(WalIndexHdr)))
  {
    *pChanged = 1;
    memcpy(&amp;amp;pWal-&amp;gt;hdr, &amp;amp;h1, sizeof(WalIndexHdr));
    pWal-&amp;gt;szPage = (pWal-&amp;gt;hdr.szPage &amp;amp; 0xfe00) + ((pWal-&amp;gt;hdr.szPage &amp;amp; 0x0001) &amp;lt;&amp;lt; 16);
    testcase(pWal-&amp;gt;szPage &amp;lt;= 32768);
    testcase(pWal-&amp;gt;szPage &amp;gt;= 65536);
  }

  /* The header was successfully read. Return zero. */
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;mxframe和nbackfill&#34;&gt;mxFrame和nBackfill&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;mxFrame&lt;/code&gt;记录着当前WAL文件的最大帧数，而&lt;code&gt;nBackfill&lt;/code&gt;记录着当前&lt;code&gt;checkpoint&lt;/code&gt;操作进行到第几帧，即在&lt;code&gt;nBackfill&lt;/code&gt;之前的帧数都已经被写入数据库文件了。&lt;/p&gt;
&lt;p&gt;显然这两个值有如下关系：&lt;code&gt;nBackfill&amp;lt;=mxFrame&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nBackfill&amp;lt;mxFrame&lt;/code&gt;，&lt;code&gt;checkpoint&lt;/code&gt;过程还未结束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nBackfill==mxFrame&lt;/code&gt;，&lt;code&gt;checkpoint&lt;/code&gt;过程已经结束，这时候：
&lt;ul&gt;
&lt;li&gt;WAL文件中的所有页面已经被回填（backfill）到数据库文件中了；&lt;/li&gt;
&lt;li&gt;所有读页面的操作，都不再需要访问WAL文件，而是直接访问数据库文件；&lt;/li&gt;
&lt;li&gt;下一次再有写操作，可以从WAL的头部开始写。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;有了前面的准备，我们来看看这两种对应关系的查找是怎么做的。&lt;/p&gt;
&lt;h4 id=&#34;索引页面的存储&#34;&gt;索引页面的存储&lt;/h4&gt;
&lt;p&gt;前面分析到，一个wal索引页面的大小为32KB，这些数据是存储在&lt;code&gt;Wal&lt;/code&gt;结构体中的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct Wal {
	// ...
	int nWiData;               /* Size of array apWiData */
	volatile u32 **apWiData;   /* Pointer to wal-index content in memory */
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apWiData：存储页面指针的数组。&lt;/li&gt;
&lt;li&gt;nWiData：页面指针数组的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;根据帧数查询页面编号&#34;&gt;根据帧数查询页面编号&lt;/h4&gt;
&lt;p&gt;首先来看根据帧数查询这一帧存储的是哪个页面的数据，即根据帧数查询页面编号的实现。&lt;/p&gt;
&lt;p&gt;由于wal文件中，到了一定大小之后，就会执行“checkpoint”操作，所以帧数一定是有限的。即帧数满足以下的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从0开始递增。&lt;/li&gt;
&lt;li&gt;不会无限增大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以在&lt;code&gt;aPgno&lt;/code&gt;中，就直接使用帧数来做为这个数组的索引。总结下来，添加一个帧数和页面之间对应关系的大体的步骤如下（函数&lt;code&gt;walIndexAppend&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据帧数，知道在第几个索引页面中，也就是&lt;code&gt;apWiData&lt;/code&gt;数组的第几个元素，这样就拿到这一帧对应在哪个32KB的数据。（函数&lt;code&gt;walHashGet&lt;/code&gt;，另外函数&lt;code&gt;walFramePage&lt;/code&gt;是根据帧数得到&lt;code&gt;apWiData&lt;/code&gt;数组索引）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; walHashGet(pWal, walFramePage(iFrame), &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;sLoc);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;帧数减去这一页的&lt;code&gt;iZero&lt;/code&gt;知道是这一页中的&lt;code&gt;aPgno&lt;/code&gt;数组的索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;idx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; iFrame &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; sLoc.iZero;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在hash数组中找到空位置存储页面编号：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Write the aPgno[] array entry and the hash-table slot. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nCollide &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; idx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(iKey&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;walHash(iPage); sLoc.aHash[iKey]; iKey&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;walNextHash(iKey)){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;( (nCollide&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;)&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; ) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; SQLITE_CORRUPT_BKPT;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将两者的对应关系存储下来，即：向&lt;code&gt;aPgno&lt;/code&gt;中存入页面编号，向&lt;code&gt;aHash&lt;/code&gt;中存储帧数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sLoc.aPgno[idx] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; iPage;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    AtomicStore(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;sLoc.aHash[iKey], (ht_slot)idx);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了这个过程的大体示意：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/frame-pageno.png&#34; alt=&#34;添加帧数与页面编号对应关系的流程&#34; title=&#34;添加帧数与页面编号对应关系的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;举个例子来说明上面的流程，假设要存储的对应关系是帧数5000存储的是页面编号5：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据帧数5000，算出这一帧的索引数据应该存储在第二个索引页面中，由此拿到这个页面的&lt;code&gt;WalHashLoc&lt;/code&gt;指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再根据5000，减去这个页面的帧数起始位置4063，得到帧数偏移量为927，即这个帧在这个&lt;code&gt;WalHashLoc-&amp;gt;aPgno&lt;/code&gt;数组的位置是927，即&lt;code&gt;idx=927&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再到&lt;code&gt;WalHashLoc-&amp;gt;aHash&lt;/code&gt;中，找到一个空的位置，这个空位置假设是&lt;code&gt;iKey=101&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到了这里，位置都找到了，更新数据：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sLoc.aPgno[927] = 5;
AtomicStore(&amp;amp;sLoc.aHash[101], (ht_slot)927);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过帧数找到&lt;code&gt;aPgno&lt;/code&gt;是一个两次索引的过程：第一次根据帧数找到32KB页面，第二次再根据帧数找到在这一页中的帧数偏移量。&lt;/li&gt;
&lt;li&gt;最后修改&lt;code&gt;aHash&lt;/code&gt;是一次原子操作，因为其它地方可能同时在查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;根据页面编号查询所在帧&#34;&gt;根据页面编号查询所在帧&lt;/h4&gt;
&lt;p&gt;前面分析了如何存储帧数到页面编号的对应关系，可以看到这一次更新是把两个对应关系一起更新的。也可以看到，根据帧数查找的流程实际还是相对简单的，就是两次索引：一次找到页面，再一次就是页面内的查找，原因在于：帧数是有限的。&lt;/p&gt;
&lt;p&gt;但是页面就不是这样了，因为这里要存储的页面编号是数据库文件中的页面编号，并不知道当前数据库到底变到多大了，这样就不能按照前面的方式来两次索引。&lt;/p&gt;
&lt;p&gt;我们来看看如何根据页面编号，知道这一页面是存储在哪一帧里的，即wal文件的帧数，这个过程在函数&lt;code&gt;sqlite3WalFindFrame&lt;/code&gt;中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿到该读操作当前最大和最小帧数，根据这两个帧数得到对应的索引32KB页面。&lt;/li&gt;
&lt;li&gt;从后往前遍历这些页面，每个页面中到&lt;code&gt;WalHashLoc-&amp;gt;aHash&lt;/code&gt;中，根据页面编号的hash值来查找。&lt;/li&gt;
&lt;li&gt;这个流程一直到找到页面，或者全部遍历完毕为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/sqlite3WalFindFrame.png&#34; alt=&#34;根据页面编号查找帧的流程&#34; title=&#34;根据页面编号查找帧的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程可以看到：查找页面对应帧数的流程，最坏的情况下可能遍历了所有索引页面，虽然其中的查找过程会根据页面编号的hash值来查找。于是一个重要的结论就出来了：&lt;strong&gt;WAL的实现，其中有一个缺点是，当WAL文件很大时，对应的索引页面也会很大，在索引中查找页面编号的流程就会变久。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;锁的实现&#34;&gt;锁的实现&lt;/h2&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;wal模式提供了以下4种锁，这4种锁从wal索引文件头部120字节处开始，每种锁占一个字节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WAL_WRITE_LOCK：写锁，写操作之前必须拿到写锁。&lt;/li&gt;
&lt;li&gt;WAL_CKPT_LOCK：checkpoint锁，在做checkpoint之前需要拿到这个锁。&lt;/li&gt;
&lt;li&gt;WAL_RECOVER_LOCK：恢复锁，在进行恢复操作之前要拿到这个锁。&lt;/li&gt;
&lt;li&gt;WAL_READ_LOCK：读锁，一共有五个读锁，但是作用不尽相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这四种锁，其中有五个读锁，一共加起来就是8个锁，定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// wal索引文件中锁的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define SQLITE_SHM_NLOCK        8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 写锁在所有锁中的偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_WRITE_LOCK 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 除了写锁以外的其他所有锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_ALL_BUT_WRITE 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// checkpoint锁在所有锁中的偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_CKPT_LOCK 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 恢复锁在所有锁中的偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_RECOVER_LOCK 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 输入读锁索引，返回对应读锁在所有锁中的偏移量，因为读锁从3开始，所以+3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_READ_LOCK(I) (3 + (I))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 读索引的数量 = 所有锁数量 - 读锁起始位置3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WAL_NREADER (SQLITE_SHM_NLOCK - 3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;问题来了，为什么是索引文件头部120字节处开始的呢？从上面对wal索引文件的格式分析可知：索引文件开始是两个&lt;code&gt;WalIndexHdr&lt;/code&gt; + 一个&lt;code&gt;WalCkptInfo&lt;/code&gt;，而&lt;code&gt;WalCkptInfo&lt;/code&gt;结构体定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; WalCkptInfo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 nBackfill;              &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Number of WAL frames backfilled into DB */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 aReadMark[WAL_NREADER]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Reader marks */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u8 aLock[SQLITE_SHM_NLOCK]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Reserved space for locks */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 nBackfillAttempted;     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* WAL frames perhaps written, or maybe not */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 notUsed0;               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Available for future enhancements */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中的&lt;code&gt;aLock&lt;/code&gt;字段就是存储上面的这些锁的数组，把前面这些数据的大小加起来，一直到这个字段就正好是120，有宏定义为证：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* A block of WALINDEX_LOCK_RESERVED bytes beginning at
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systems
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;** only support mandatory file-locks, we do not read or write data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;** from the region of the file on which locks are applied.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr) * 2 + offsetof(WalCkptInfo, aLock))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt;）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Offset&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;xShmLock&lt;/td&gt;
&lt;td&gt;File&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_WRITE_LOCK&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_CKPT_LOCK&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td&gt;121&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_RECOVER_LOCK&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2&lt;/td&gt;
&lt;td&gt;122&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_READ_LOCK(0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_READ_LOCK(1)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td&gt;124&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_READ_LOCK(2)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5&lt;/td&gt;
&lt;td&gt;125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_READ_LOCK(3)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;6&lt;/td&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;WAL_READ_LOCK(4)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;7&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;加解锁操作&#34;&gt;加解锁操作&lt;/h3&gt;
&lt;p&gt;wal与前面的journal相比，少了很多其他类型的锁，wal只有两种类型的锁：shared共享锁，以及exclusive排它锁。对应的API有下面四个：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;walLockShared&lt;/span&gt;(Wal &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pWal, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; lockIdx);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;walUnlockShared&lt;/span&gt;(Wal &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pWal, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; lockIdx);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;walLockExclusive&lt;/span&gt;(Wal &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pWal, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; lockIdx, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;walUnlockExclusive&lt;/span&gt;(Wal &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pWal, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; lockIdx, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有几个细节，需要交待一下。&lt;/p&gt;
&lt;p&gt;首先，其中传入的参数&lt;code&gt;lockIdx&lt;/code&gt;，就是上面提到的几种锁的类型索引。&lt;/p&gt;
&lt;p&gt;其次，代码中有&lt;code&gt;walLockShared(pWal, WAL_WRITE_LOCK)&lt;/code&gt;这样的操作。对一个写锁加共享锁应该怎么理解？需要纠正的是，类似&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;这样的宏，只是表示这一字节用于什么操作，比如&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;用于写操作，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要拒绝其他写请求的情况下读数据时，就应该对&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;类型的锁加共享锁。&lt;/li&gt;
&lt;li&gt;要开始写操作时，就应该对&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;类型的锁加排它锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他类型的锁依次类推，即&lt;code&gt;WAL_*_LOCK&lt;/code&gt;这类宏只是表示这一个字节的用途。&lt;/p&gt;
&lt;p&gt;最后一个细节是，加共享锁时只能传入锁类型索引，而加排它锁的时候还能传入一个参数n，这是什么意思？&lt;/p&gt;
&lt;p&gt;因为这些不同类型的锁，本质上就是wal索引共享文件上连续的字节，所以区别在于，共享锁一次只能对一个锁进行操作；而排它锁则可以一次多对多个锁进行操作。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;walLockExclusive(pWal, WAL_READ_LOCK(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;), WAL_NREADER &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就能把从1号读锁开始的所有读锁都加上排它锁。&lt;/p&gt;
&lt;p&gt;再比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  iLock &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; WAL_ALL_BUT_WRITE &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; pWal&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ckptLock;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; walLockExclusive(pWal, iLock, WAL_READ_LOCK(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; iLock);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的几个常量取值如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ckptLock&lt;/code&gt;取值为0或者1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_ALL_BUT_WRITE&lt;/code&gt;为1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define WAL_READ_LOCK(I) (3 + (I))&lt;/code&gt;，所以&lt;code&gt;WAL_READ_LOCK(0)&lt;/code&gt;为3。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;ckptLock&lt;/code&gt;取值为0，表示这时候还没有加上了checkpoint的排它锁：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iLock&lt;/code&gt;为1，1为&lt;code&gt;WAL_CKPT_LOCK&lt;/code&gt;这个类型的锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_READ_LOCK(0) - iLock&lt;/code&gt;为2。&lt;/li&gt;
&lt;li&gt;这样，&lt;code&gt;walLockExclusive(pWal, iLock, WAL_READ_LOCK(0) - iLock);&lt;/code&gt;就能把checkpoint和0号读锁都加上排它锁，这样就不会其他checkpoint操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;ckptLock&lt;/code&gt;取值为1，表示这时候已经加上了checkpoint的排它锁：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iLock&lt;/code&gt;为2，2为&lt;code&gt;WAL_RECOVER_LOCK&lt;/code&gt;这个类型的锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_READ_LOCK(0) - iLock&lt;/code&gt;为1。&lt;/li&gt;
&lt;li&gt;这样，&lt;code&gt;walLockExclusive(pWal, iLock, WAL_READ_LOCK(0) - iLock);&lt;/code&gt;就能把恢复加上排它锁，这样能进行恢复操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;特殊的0号读锁&#34;&gt;特殊的0号读锁&lt;/h3&gt;
&lt;p&gt;除此以外，还需要注意0号读锁很特殊，它表示读事务申请的共享锁，和WAL_WRITE_LOCK不冲突，读写可以完全并发进行，互不影响，但是不能和数据库同步操作和WAL-index文件恢复并发进行。0号读锁表示只从数据库读取页。&lt;/p&gt;
&lt;p&gt;有了对锁的了解，可以接下来看各种操作的具体实现了。&lt;/p&gt;
&lt;h2 id=&#34;读操作&#34;&gt;读操作&lt;/h2&gt;
&lt;p&gt;进行读操作时，大体需要以下两个操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存当前的&lt;code&gt;aReadMark&lt;/code&gt;，因为这涉及到读页面的时候数据从哪里来的问题。&lt;/li&gt;
&lt;li&gt;拿到对应的读锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论这两方面的内容。&lt;/p&gt;
&lt;h3 id=&#34;readmark&#34;&gt;readMark&lt;/h3&gt;
&lt;p&gt;首先来了解一下什么叫&lt;code&gt;readMark&lt;/code&gt;，以及有什么作用。&lt;/p&gt;
&lt;p&gt;回顾之前谈到wal文件以及wal索引文件的格式，有这么几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同一个页面编号的页面，可能会在wal文件存在不同时间的多次写入结果。这些多次写入结果里，如果所在的事务还未提交，那么这个修改应该对读操作还处于不可见的状态。wal文件头中使用&lt;code&gt;mxFrame&lt;/code&gt;这个字段来存储当前最后完成的写事务的帧数，超过这个帧数的修改都认为还没有完成。&lt;/li&gt;
&lt;li&gt;wal索引保存着页面的最新修改的位置信息，这“最新修改”指的是已经提交的事务，并不包括还未提交的事务的修改。&lt;/li&gt;
&lt;li&gt;读操作时，以页面编号先从wal索引中尝试读这个页面在wal中的位置信息：
&lt;ul&gt;
&lt;li&gt;如果读成功，根据这个wal的位置信息，到wal文件中读取该页面。&lt;/li&gt;
&lt;li&gt;否则，该页面没有在wal中，到数据库文件中读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下图为例来说明情况，为了简化说明，一个页面存储的一对KV的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/read-wal.png&#34; alt=&#34;读操作看到的数据库文件和wal&#34; title=&#34;读操作看到的数据库文件和wal&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有三个写事务，其中：
&lt;ul&gt;
&lt;li&gt;第一个事务已经完成，修改了值&lt;code&gt;y=20&lt;/code&gt;，这个修改存在第一帧中。&lt;/li&gt;
&lt;li&gt;第二个事务也已经完成，修改了值&lt;code&gt;x=1&lt;/code&gt;和&lt;code&gt;y=2&lt;/code&gt;，这两个修改存在第二和第三帧中。&lt;/li&gt;
&lt;li&gt;第三个事务还在进行中，目前修改了值&lt;code&gt;x=3&lt;/code&gt;，这个修改存在第四帧中，其余修改还在进行中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据上面的描述，那么wal索引中这几个维护位置信息的内容就是：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mxFrame=3&lt;/code&gt;，因为这是最后一个完成的写事务的最大帧数。&lt;/li&gt;
&lt;li&gt;wal索引中：
&lt;ul&gt;
&lt;li&gt;x的位置在第四帧，但是需要注意这个值还并未提交，所以要区分不能读到未提交的值（read uncommitted），这在下面会展开说明。&lt;/li&gt;
&lt;li&gt;y的位置在第三帧。注意到y有两个数据，但是取了已提交事务中最新的那次数据。&lt;/li&gt;
&lt;li&gt;z在wal中没有，即在wal当前保存的所有事务中都没有修改到z，于是如果需要读取z的值，需要到数据库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在数据库文件中，x、y、z又是另外的三个值，因为这个时候，已提交事务的修改还在WAL文件中，并未写入数据库文件里面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，当一个新的读操作开始的时候，会记录下来当时的&lt;code&gt;mxFrame&lt;/code&gt;，这个值对于读操作而言，被称为&lt;code&gt;readMark&lt;/code&gt;，保存在&lt;code&gt;WalCkptInfo&lt;/code&gt;结构体的成员&lt;code&gt;aReadMark&lt;/code&gt;数组中。有了这个值，当进行checkpoint操作的时候，就能判断当前是否需要等待读操作完成。这部分将在下面结合checkpoint流程继续讲解。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;readMark&lt;/code&gt;还有另一层含义：即当前已完成事务的最大帧数，所以当读事务去读一个页面的内容时，会首先到wal索引中，根据该页面的编号查询这个页面对应的帧数，有这几种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有找到：这说明当前wal文件中没有该页面的内容，要到数据库文件中查询。&lt;/li&gt;
&lt;li&gt;找到了，假设这个帧数为&lt;code&gt;iFrame&lt;/code&gt;，这又分为两种情况：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iFrame&amp;gt;readMark&lt;/code&gt;：这说明是这个读事务之后才进行的写操作，于是这个页面的内容还是不能从WAL文件中读取，仍然到数据库文件中读。这是因为如果从WAL中读取，可能读到的是还未提交的事务的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iFrame&amp;lt;=readMark&lt;/code&gt;：这说明是在这个读事务之前的写操作，可以从WAL文件读这个页面的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仍然以前面的图为例来说明情况，假设在上图的第三个写事务还在进行的时候，来了一个读事务，按照前面的解释，此时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个读事务的&lt;code&gt;readMark=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;假如这个读事务分别读了x、y、z这三个值，它需要到wal索引中查询这几个值是否在wal文件中，那么：
&lt;ul&gt;
&lt;li&gt;x：x的最新值在第四帧，大于&lt;code&gt;readMark=3&lt;/code&gt;，说明是个发起读操作之后还未提交的写事务更新的，这就不能读wal的最新值，而要读数据库文件中的值，此时读出来的值为&lt;code&gt;x=100&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y：y的最新值在第三帧，并不大于&lt;code&gt;readMark=3&lt;/code&gt;，所以可以以wal的值为准，读出来&lt;code&gt;y=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;z：在wal索引中没有找到z，只能去数据库文件中查，读出来&lt;code&gt;z=300&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次说明的是，为了问题描述的简化，这里假设一个页面只存储了一对KV的值。&lt;/p&gt;
&lt;p&gt;有了对&lt;code&gt;readMark&lt;/code&gt;的初步了解，继续看读操作如何获得读锁。&lt;/p&gt;
&lt;h3 id=&#34;读锁&#34;&gt;读锁&lt;/h3&gt;
&lt;p&gt;前面已经提到，读锁的信息保存在&lt;code&gt;WalCkptInfo&lt;/code&gt;的&lt;code&gt;aLock&lt;/code&gt;成员中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; WalCkptInfo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  u32 aReadMark[WAL_NREADER]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Reader marks */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u8 aLock[SQLITE_SHM_NLOCK]; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Reserved space for locks */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aReadMark&lt;/code&gt;：用于存储每个读操作的&lt;code&gt;readMark&lt;/code&gt;值，这个值已经在上面做了解释，这个数组的大小为&lt;code&gt;WAL_NREADER&lt;/code&gt;，即每个reader一个readMark值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aLock&lt;/code&gt;：存储锁类型的数组，这些锁类型也在上面做了诠释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个读操作来的时候，需要获得一个读锁，才能继续往下进行它的读操作，这个获得锁的流程，在函数&lt;code&gt;walTryBeginRead&lt;/code&gt;中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;walIndexReadHdr&lt;/code&gt;函数读取wal的索引文件头。&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;WalCkptInfo&lt;/code&gt;信息存储在索引文件头中，于是可以接下来调用&lt;code&gt;walCkptInfo&lt;/code&gt;函数拿到这部分信息。&lt;/li&gt;
&lt;li&gt;寻找当前可用的读锁，分为以下几步：
&lt;ol&gt;
&lt;li&gt;有了当前的&lt;code&gt;WalCkptInfo&lt;/code&gt;信息，遍历其中的&lt;code&gt;aReadMark&lt;/code&gt;数组，选出其中&lt;code&gt;readMark&lt;/code&gt;最小的那个值，并且记录下这个最小值的索引&lt;code&gt;i&lt;/code&gt;。这是因为&lt;code&gt;readMark&lt;/code&gt;小的读操作，更有可能已经完成了读操作。&lt;/li&gt;
&lt;li&gt;尝试调用&lt;code&gt;walLockExclusive(pWal, WAL_READ_LOCK(i), 1)&lt;/code&gt;对上一步拿到的&lt;code&gt;readMark&lt;/code&gt;数组索引加排他锁：
&lt;ol&gt;
&lt;li&gt;如果成功，说明这个读锁当前没有其它进程在用，可以退出循环了。&lt;/li&gt;
&lt;li&gt;否则，就递增&lt;code&gt;i&lt;/code&gt;索引对下一个读锁进行尝试，直到遍历完毕所有读锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;到了这里，已经拿到一个可用的读锁了，调用&lt;code&gt;walLockShared&lt;/code&gt;对这个读锁加共享锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在前面的过程中，很可能有写操作在进行，所以在返回之前，最后判断一下wal 索引头数据是否发生了变化，如果发生了变化，前面的步骤就得重新来过，返回重试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要补充说明的是，函数&lt;code&gt;walTryBeginRead&lt;/code&gt;在调用时，如果返回重试（&lt;code&gt;WAL_RETRY&lt;/code&gt;）的话，调用者会将调用计数递增，当这个调用计数超过一个阈值时，再次调用时&lt;code&gt;walTryBeginRead&lt;/code&gt;会休眠一下，超过100次则会报错不再尝试。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 尝试超过5次的情况下，要休眠一下
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cnt &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nDelay &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Pause time in microseconds */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cnt &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;100&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 超过100次了，退出报错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;      VVA_ONLY(pWal&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;lockError &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; SQLITE_PROTOCOL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cnt &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      nDelay &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (cnt &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;9&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; (cnt &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;9&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;39&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sqlite3OsSleep(pWal&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pVfs, nDelay);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/walTryBeginRead.png&#34; alt=&#34;walTryBeginRead函数流程&#34; title=&#34;walTryBeginRead函数流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以从加读锁的流程看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sqlite的WAL机制，最大只能支持同时有&lt;code&gt;WAL_NREADER&lt;/code&gt;个读操作并发。&lt;/li&gt;
&lt;li&gt;加读锁的时候，如果因为写操作导致wal索引文件头发生了变化，将前功尽弃再次尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写操作&#34;&gt;写操作&lt;/h2&gt;
&lt;h3 id=&#34;写锁&#34;&gt;写锁&lt;/h3&gt;
&lt;p&gt;拿到写锁的流程，对比上面拿到读锁的流程来说，就简单很多了，在函数&lt;code&gt;sqlite3WalBeginWriteTransaction&lt;/code&gt;中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;walLockExclusive(pWal, WAL_WRITE_LOCK, 1)&lt;/code&gt;拿到写锁的排它锁。&lt;/li&gt;
&lt;li&gt;同样也是检查是否wal索引头发生了变化，如果是则需要再次尝试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而解写锁操作就在函数&lt;code&gt;sqlite3WalBeginWriteTransaction&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个函数的实现都挺简单，就不展开阐述了。&lt;/p&gt;
&lt;h3 id=&#34;写操作-1&#34;&gt;写操作&lt;/h3&gt;
&lt;p&gt;真正将脏页面写入wal文件中的操作在函数&lt;code&gt;sqlite3WalFrames&lt;/code&gt;中，该函数有几个比较重要的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PgHdr *pList：脏页面链表。&lt;/li&gt;
&lt;li&gt;int isCommit：为1的情况下，表示这是提交操作，即这个写事务的最后一次调用&lt;code&gt;sqlite3WalFrames&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sqlite3WalFrames&lt;/code&gt;函数的实现也并不复杂，有这么几个事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿到当前写wal的起始位置，从这个位置开始，遍历脏页面写入wal文件中。而这个起始位置，就是前面提到的&lt;code&gt;mxFrame+1&lt;/code&gt;帧。
&lt;ul&gt;
&lt;li&gt;但是这个过程中需要考虑到可能出现的覆盖情况，即：同一次写事务，对同一个页面有多次写操作，这种情况下，后面对同一个页面的写操作，不应该写到wal后面，而是覆盖前面的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历脏页面链表，将脏页面写入wal文件之后，就需要根据最新的页面编号和wal文件帧数的对应关系，更新wal索引的内容。&lt;/li&gt;
&lt;li&gt;最后，更新&lt;code&gt;mxFrame&lt;/code&gt;的值为WAL文件当前的最大帧数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是以一个例子来说明这个流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/write-wal.png&#34; alt=&#34;写事务修改WAL文件和WAL索引数据&#34; title=&#34;写事务修改WAL文件和WAL索引数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，精简了很多情况，假设从WAL文件的开头开始写脏页面了，图中的写事务一共写了三次页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入&lt;code&gt;y=200&lt;/code&gt;：这时候将这个内容写入WAL文件中的第一帧，更新wal索引中y页面的帧数为1，而此时x还没有内容。写完毕之后，更新&lt;code&gt;mxFrame=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;x=100&lt;/code&gt;：这时候将这个内容写入WAL文件中的第二帧，更新wal索引中x页面的帧数为2。写完毕之后，更新&lt;code&gt;mxFrame=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;y=101&lt;/code&gt;：写入时发现，同一个事务之前已经修改过y页面了，于是这一次并不把&lt;code&gt;y=101&lt;/code&gt;的修改继续写到WAL文件结尾，而是覆盖第一帧中已经存在的y页面内容，同时索引数据也不需要更新：因为是覆盖操作，y页面的帧数并没有发生变化。同样的，由于没有修改WAL文件的最大帧数，&lt;code&gt;mxFrame&lt;/code&gt;也没有修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;页面校验值的计算&#34;&gt;页面校验值的计算&lt;/h3&gt;
&lt;h2 id=&#34;checkpoint-1&#34;&gt;checkpoint&lt;/h2&gt;
&lt;h3 id=&#34;总体流程&#34;&gt;总体流程&lt;/h3&gt;
&lt;p&gt;有了前面读、写操作的了解，接着来了解一下checkpoint操作是如何实现的。&lt;/p&gt;
&lt;p&gt;我们回顾一下&lt;code&gt;checkpoint&lt;/code&gt;操作要完成的事情：由于wal日志中存储的，都是每次写事务被修改的页面，因此&lt;code&gt;checkpoint&lt;/code&gt;操作就是将wal日志中被修改的页面写入数据库文件中。也是因为这个原因，因此&lt;code&gt;checkpoint&lt;/code&gt;也被称为&lt;code&gt;backfill（回填）&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/checkpoint.png&#34; alt=&#34;checkpoint操作&#34; title=&#34;checkpoint操作&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上面的读写流程的分析里看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时能支持多个读事务，每个读事务都有一个&lt;code&gt;readMark&lt;/code&gt;值，用来区分这个读操作读到在WAL中存储的某个页面时，是以wal的页面为准，还是应该到数据库文件中读取这个页面。&lt;/li&gt;
&lt;li&gt;同时只能存在一个写事务，这个写事务没有完成之前，任何读事务不能读到它的数据，因为是未提交（uncommitted）的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在做&lt;code&gt;checkpoint&lt;/code&gt;的时候，需要保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能将未提交写事务的修改，回填到数据库文件中。&lt;/li&gt;
&lt;li&gt;对于正在进行的读操作，不能将超过该读操作的&lt;code&gt;readMark&lt;/code&gt;值的帧，回填到数据库文件中，需要等待读操作完成才能回填这部分数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/checkpoint-readmark.png&#34; alt=&#34;checkpoint操作&#34; title=&#34;checkpoint操作&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一点很好理解，因为未提交的写事务，可能只修改了一部分，如果在未提交这个写事务之前，就把这一部分回填到数据库文件中，会造成读出来的这部分数据驴头不对马嘴。比如一个写事务的修改，是将A账号的100转账到B账号上，于是这个写事务就涉及两个修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：扣除100。&lt;/li&gt;
&lt;li&gt;B：加上100。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果这个事务当前只完成了上面的第一步修改，这个修改马上被回填到数据库文件中，这时候看到的就是A少了100，而B没有变化，这显然是不可接受的。&lt;/p&gt;
&lt;p&gt;第二点的理解，要回到前面对&lt;code&gt;readMark&lt;/code&gt;值的解释上：一个读操作开始之前，会记录一下当前已完成写事务的最大修改帧数做为自己的&lt;code&gt;readMark&lt;/code&gt;，在后续的读操作中，从wal索引中查询一个页面编号，有以下几种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有找到，说明需要到数据库文件中查找该页面内容。&lt;/li&gt;
&lt;li&gt;找到了，又需要区分两种情况：
&lt;ul&gt;
&lt;li&gt;这个页面所在的帧数&amp;lt;&lt;code&gt;readMark&lt;/code&gt;：说明这个页面在读操作开始之后再没有被修改了，可以以wal的内容为准。&lt;/li&gt;
&lt;li&gt;否则：说明这个页面在读操作之后被修改了，需要到数据库文件中查询被修改之前的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：上面的”这个页面在读操作之后被修改“条件，不仅包括这个修改对应的写事务没有被提交，也包括写事务已提交的情况。&lt;/p&gt;
&lt;p&gt;即：&lt;code&gt;readMark&lt;/code&gt;保证了，一个读事务绝对不能读到在这个读事务之后的任何修改。&lt;/p&gt;
&lt;p&gt;由这个解释可以看到，当一个读操作判断一个页面的内容需要到数据库文件中读取时，需要读到的是这个读事务之前的修改。因此，&lt;code&gt;checkpoint&lt;/code&gt;需要保证：不能将超过当前任何读操作的&lt;code&gt;readMark&lt;/code&gt;值的帧数，回填其保存的页面到数据库文件中。&lt;/p&gt;
&lt;p&gt;到了这里，基本可以确定一个&lt;code&gt;checkpoint&lt;/code&gt;操作的流程了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加&lt;code&gt;checkpoint&lt;/code&gt;的排它锁，保证同时只能有一个&lt;code&gt;checkpoint&lt;/code&gt;操作在进行。&lt;/li&gt;
&lt;li&gt;算出当前最大可以回填到第几帧的数据，假设这个值保存在变量&lt;code&gt;mxSafeFrame&lt;/code&gt;中，流程如下：
&lt;ul&gt;
&lt;li&gt;初始时，取&lt;code&gt;mxSafeFrame=mxFrame&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历当前所有还在进行的读操作，取&lt;code&gt;mxSafeFrame=min(mxSafeFrame, aReadMark)&lt;/code&gt;，即不能超过任何一个在进行的读操作的&lt;code&gt;readMark&lt;/code&gt;值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算出来了最大回填帧数，可以实际进行回填操作了：遍历当前的wal文件，将所有帧数小于等于&lt;code&gt;mxSafeFrame&lt;/code&gt;的修改都回填到数据库文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是&lt;code&gt;checkpoint&lt;/code&gt;流程的总体描述，其中涉及的主要函数是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sqlite3WalCheckpoint&lt;/code&gt;：&lt;code&gt;checkpoint&lt;/code&gt;操作的入口函数，负责加&lt;code&gt;checkpoint&lt;/code&gt;排它锁，然后继续调用下面的&lt;code&gt;walCheckpoint&lt;/code&gt;进行实际的回填操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;walCheckpoint&lt;/code&gt;：执行&lt;code&gt;checkpoint&lt;/code&gt;操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;想了解更多细节的读者可以自行阅读。&lt;/p&gt;
&lt;h3 id=&#34;不同的checkpoint模式&#34;&gt;不同的checkpoint模式&lt;/h3&gt;
&lt;p&gt;上面只是了解了&lt;code&gt;checkpoint&lt;/code&gt;的大体流程，但是不同的checkpoint模式又有区别，有如下的宏来进行区分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define SQLITE_CHECKPOINT_PASSIVE  0  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Do as much as possible w/o blocking */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define SQLITE_CHECKPOINT_FULL     1  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Wait for writers, then checkpoint */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define SQLITE_CHECKPOINT_RESTART  2  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Like FULL but wait for for readers */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define SQLITE_CHECKPOINT_TRUNCATE 3  &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Like RESTART but also truncate WAL */&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;sqlite_checkpoint_passive&#34;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/h4&gt;
&lt;p&gt;这个模式下，不会等待读写操作完成，而是基于现有的数据，尽可能将安全的帧回填到数据库文件中。&lt;/p&gt;
&lt;p&gt;可以看到，这种模式更接近于一种”步进（step）“的模式：每次回填一部分数据，回填不完就直接返回不再进行。所以，需要某些变量来保存当前的回填进度，这个值保存在&lt;code&gt;WalCkptInfo.nBackfill&lt;/code&gt;，所以回填还没有结束的条件也就是：&lt;code&gt;pInfo-&amp;gt;nBackfill &amp;lt; pWal-&amp;gt;hdr.mxFrame&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;sqlite_checkpoint_full&#34;&gt;SQLITE_CHECKPOINT_FULL&lt;/h4&gt;
&lt;p&gt;这个模式下，&lt;code&gt;checkpoint&lt;/code&gt;操作会等待写操作完成，才继续进行回填操作，而在回填过程中也不再允许有新的写操作进行。&lt;/p&gt;
&lt;h4 id=&#34;sqlite_checkpoint_restart&#34;&gt;SQLITE_CHECKPOINT_RESTART&lt;/h4&gt;
&lt;p&gt;对比&lt;code&gt;SQLITE_CHECKPOINT_FULL&lt;/code&gt;模式，这一个模式更进了一步：等待所有读操作完成才开始回填操作，同样的，在&lt;code&gt;checkpoint&lt;/code&gt;过程中除了不能有写操作还不能有读操作。&lt;/p&gt;
&lt;h4 id=&#34;sqlite_checkpoint_truncate&#34;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/h4&gt;
&lt;p&gt;这一个模式对比&lt;code&gt;SQLITE_CHECKPOINT_RESTART&lt;/code&gt;又更近了一步，在回填完毕之后，将截断WAL文件，这样后面新来的wal的写操作，将从wal文件的开始位置开始写。我们前面提到，在wal文件中查找一个页面时，跟wal文件的大小成正比，所以回填完毕截断wal文件重新开始写，会加速后面的查询操作。&lt;/p&gt;
&lt;h2 id=&#34;错误恢复&#34;&gt;错误恢复&lt;/h2&gt;
&lt;p&gt;以上已经把wal的读、写、checkpoint流程都了解了，最后了解一下wal的错误恢复是如何实现的。&lt;/p&gt;
&lt;p&gt;区分几种情况下面的出错崩溃，以及这些情况下都如何恢复的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写事务进行时出错崩溃：这种情况下，显然wal中存储了一部分这个写事务的修改，崩溃恢复时校验后会发现这部分的修改不完全，于是会将这部分修改截断，而数据库文件，根据前面&lt;code&gt;checkpoint&lt;/code&gt;流程的讲解，并不会回填还未提交的写事务的修改，所以数据库文件并未损坏。&lt;/li&gt;
&lt;li&gt;当前没有任何写事务，在进行&lt;code&gt;checkpoint&lt;/code&gt;过程中崩溃：在进行&lt;code&gt;checkpoint&lt;/code&gt;时，不允许同时并发有写操作。于是这种情况下，wal文件中保存的数据，都是完整的写事务修改数据。启动后校验wal文件发现内容都是对的，于是遍历wal文件，首先将当前wal文件中的内容全部回填至数据库文件中再启动即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;最后对wal机制做一个简短的总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与journal备份机制不同的是：journal备份的是修改之前的页面内容，而wal存储的是修改后的内容。&lt;/li&gt;
&lt;li&gt;于是，wal中可能存储了同一个页面的多次修改结果，因为不同的事务、甚至相同的事务，都有可能修改了同一个页面，而每一次修改都要将修改结果存储wal文件。&lt;/li&gt;
&lt;li&gt;wal文件中，存储一个页面内容的单位是”帧（frame）“，一帧存储一个页面，而反过来一个页面可能先后被存储在不同帧的内容中。于是就需要wal索引数据：&lt;/li&gt;
&lt;li&gt;wal索引需要存储两类数据：一个帧存储的是哪个页面的数据，以及某个页面最新的数据存储在哪一帧。&lt;/li&gt;
&lt;li&gt;完成一次写操作，wal只需一次sync操作（sync wal文件），journal需要两次（sync journal文件一次，将页面缓存写入数据库文件之后sync数据库文件一次），因此wal的写性能更高。&lt;/li&gt;
&lt;li&gt;wal支持一写多读的并发，但是journal在写的时候不支持同时读数据。&lt;/li&gt;
&lt;li&gt;有两个重要的变量来保证并发读时不会读到读操作开始之后的修改：&lt;code&gt;mxFrame&lt;/code&gt;保存的是当前最提交的写事务写的最大帧数；每个读操作还保存了一个&lt;code&gt;readMark&lt;/code&gt;值，存储的是读操作开始时的&lt;code&gt;mxFrame&lt;/code&gt;值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkpoint&lt;/code&gt;操作，又称为&lt;code&gt;回填（backfill）&lt;/code&gt;操作，用于将wal文件的内容同步到数据库文件中，它需要前面的&lt;code&gt;mxFrame&lt;/code&gt;和&lt;code&gt;readMark&lt;/code&gt;来保证回填操作的正确性。回填操作会影响同时在进行的读、写操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/wal.html&#34;&gt;Write-Ahead Logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WAL文件格式见：&lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt;中“4. The Write-Ahead Log”这一小节内容。&lt;/li&gt;
&lt;li&gt;checkpoint中几种模式的解释：&lt;a href=&#34;https://sqlite.org/c3ref/wal_checkpoint_v2.html&#34;&gt;Checkpoint a database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zearot/article/details/51039593&#34;&gt;SQLite分析之WAL机制_岩之痕-CSDN博客_sqlite wal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/pfysw/article/details/80531495&#34;&gt;SQLite3源码学习（31） WAL日志的锁机制_test-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（三）- journal文件备份机制</title>
      <link>https://www.codedump.info/post/20211222-sqlite-btree-3-journal/</link>
      <pubDate>Wed, 22 Dec 2021 19:15:31 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211222-sqlite-btree-3-journal/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;在上一节中（&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;），已经讲解了sqlite中的并发控制机制，里面会涉及到一个“备份页面”的模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;备份所有在一个事务中会修改到的页面。&lt;/li&gt;
&lt;li&gt;出错时回滚页面内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;里面也提到，有两种备份文件的机制：journal文件，以及WAL文件。今天首先讲解journal文件的实现，它的效率会更低一些，也正是因为这个原因后续推出了更优的WAL机制。&lt;/p&gt;
&lt;h2 id=&#34;相关命令&#34;&gt;相关命令&lt;/h2&gt;
&lt;p&gt;sqlite中，可以使用&lt;code&gt;PRAGMA journal_mode&lt;/code&gt;来修改备份文件机制，包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete：默认模式。在该模式下，在事务结束时，备份文件将被删除。&lt;/li&gt;
&lt;li&gt;truncate：日志文件被截断为零字节长度。&lt;/li&gt;
&lt;li&gt;persist：日志文件被留在原地，但头部被重写，表明日志不再有效。&lt;/li&gt;
&lt;li&gt;memory：日志记录保留在内存中，而不是磁盘上。&lt;/li&gt;
&lt;li&gt;off：不保留任何备份记录。&lt;/li&gt;
&lt;li&gt;wal：采用wal形式的备份文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，前面三种delete、truncate、persist都是使用journal文件来实现的备份，区别在于事务结束之后的对备份文件的处理罢了。&lt;/p&gt;
&lt;p&gt;本节首先讲解journal文件，下一节讲解wal备份文件。&lt;/p&gt;
&lt;h1 id=&#34;journal文件格式&#34;&gt;journal文件格式&lt;/h1&gt;
&lt;p&gt;journal文件的文件名规则是：与同目录的数据库文件同名，但是多了字符串“-journal”为后缀。比如数据库文件是“test.db”，那么对应的journal文件名为“test.db-journal”。&lt;/p&gt;
&lt;h2 id=&#34;文件头&#34;&gt;文件头&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;文件头的magic number: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;journal文件中的页面数量，如果为-1表示一直到journal文件尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;每次计算校验值时算出来的随机数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;在开始备份前数据库文件的页面数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;磁盘扇区大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;journal文件中的页面大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里大部分的字段都自解释了，不必多做解释，唯一需要注意的是随机数，因为这是用来后续校验备份页面的字段，这将在后面结合流程来说明。&lt;/p&gt;
&lt;h2 id=&#34;页面内容&#34;&gt;页面内容&lt;/h2&gt;
&lt;p&gt;紧跟着文件头之后，journal文件还有一系列页面数据组成的内容，其中每部分的结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;页面编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;备份的页面内容，N以页面大小为准，其中每页面大小在文件头中定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N+4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;页面的校验值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由上面分析可见，整个journal文件是这样来组织的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;28字节的文件头。&lt;/li&gt;
&lt;li&gt;页面数据组成的数组，其中数组每个元素的大小为：4+页面大小（N）+4。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal.png&#34; alt=&#34;journal文件结构&#34; title=&#34;journal文件结构&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;流程&#34;&gt;流程&lt;/h1&gt;
&lt;h2 id=&#34;判断页面是否已经备份&#34;&gt;判断页面是否已经备份&lt;/h2&gt;
&lt;p&gt;启动一个写事务的时候，可能会修改多个页面，但是这其中可能有些修改，修改的是同一个页面的内容，因此这种情况下只需要对这个页面备份一次即可。&lt;/p&gt;
&lt;p&gt;如何知道页面是否已经被备份过？页面管理器通过一个位图数据结构来保存这个信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bitvec *pInJournal;         /* One bit for each page in the database file */
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;计算页面校验值&#34;&gt;计算页面校验值&lt;/h2&gt;
&lt;p&gt;计算一个页面校验码的流程在函数&lt;code&gt;pager_cksum&lt;/code&gt;中实现，其核心逻辑是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以随机算出的校验值为初始值，这个初始值就是存在journal文件头中偏移量为[12,16]的数据。&lt;/li&gt;
&lt;li&gt;从后往前遍历页面数据，每隔200字节取一个u32类型的值，累加起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这样的关联，进行数据恢复时就能马上通过文件头存储的随机数，计算出来页面的数据是否准确。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; u32 &lt;span style=&#34;color:#00a000&#34;&gt;pager_cksum&lt;/span&gt;(Pager &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;pPager, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;const&lt;/span&gt; u8 &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;aData){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u32 cksum &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; pPager&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cksumInit;         &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Checksum value to return */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; pPager&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pageSize&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;200&lt;/span&gt;;          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* Loop counter */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 每隔200字节算一个值累加起来
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;( i&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt; ){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cksum &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; aData[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#666&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;200&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; cksum;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;备份页面&#34;&gt;备份页面&lt;/h2&gt;
&lt;p&gt;有了前面计算校验值、以位图来判断页面是否已经备份过的了解，现在开始将备份页面的流程。&lt;/p&gt;
&lt;p&gt;每一次需要修改一个页面之前，都会调用函数&lt;code&gt;pager_write&lt;/code&gt;，这样就能在修改之前首先备份这个页面的内容。&lt;/p&gt;
&lt;p&gt;要区分两种不同的页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果页面编号比当前数据库文件的页面数量小，说明是已有页面，需要走备份页面的流程。&lt;/li&gt;
&lt;li&gt;否则，说明是新增页面，新增的页面不需要备份，只需要修改该页面的标志位是需要落盘（&lt;code&gt;PGHDR_NEED_SYNC&lt;/code&gt;），并且放入脏页面链表即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二种情况是新增页面，没有备份的需求，这里就不做解释。&lt;/p&gt;
&lt;p&gt;这里具体解释第一种情况，即备份已有页面的流程，其主要逻辑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先根据前面的&lt;code&gt;pInJournal&lt;/code&gt;位图数据，传入页面编号，判断这个页面是否备份过，如果已经备份过，不做任何操作。&lt;/li&gt;
&lt;li&gt;否则说明需要备份页面，将进入函数&lt;code&gt;pagerAddPageToRollbackJournal&lt;/code&gt;中将该页面内容备份写入journal文件：
&lt;ul&gt;
&lt;li&gt;调用前面提到的&lt;code&gt;pager_cksum&lt;/code&gt;函数，计算页面的校验值。&lt;/li&gt;
&lt;li&gt;按照上面解释的journal文件格式，依次写入页面编号、页面内容、第一步计算出来的校验值。&lt;/li&gt;
&lt;li&gt;由于备份了页面，所以要把这个新增的备份页面编号写入&lt;code&gt;pInJournal&lt;/code&gt;位图数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备份页面的例子&#34;&gt;备份页面的例子&lt;/h3&gt;
&lt;p&gt;我们以一个例子来说明备份页面的流程，假设写事务执行时，情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当时数据库的页面数量为2，即有2个页面，其中页面的内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面一：保存了&lt;code&gt;x=0&lt;/code&gt;和&lt;code&gt;y=1&lt;/code&gt;的数据。&lt;/li&gt;
&lt;li&gt;页面二：保存了&lt;code&gt;z=2&lt;/code&gt;的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写事务执行时，依次做了如下的修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改页面1的一处内容：&lt;code&gt;x=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;修改页面2的一处内容：&lt;code&gt;z=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;修改页面1的一处内容：&lt;code&gt;y=2&lt;/code&gt;，注意这里跟第一次修改属于同一个页面的不同位置。&lt;/li&gt;
&lt;li&gt;新增页面3：&lt;code&gt;p=4&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，对照上面的流程，这四次页面修改在调用函数&lt;code&gt;pager_write&lt;/code&gt;时，情况是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改页面1的一处内容&lt;code&gt;x=1&lt;/code&gt;：由于在备份页面位图中查不到页面编号为1的页面，且页面1小于当前数据库文件的页面数量2，因此属于修改当前已有页面，于是将这个页面备份到journal文件，即将页面一的未修改之前的内容&lt;code&gt;x=0,y=1&lt;/code&gt;写入journal备份文件中，完事了之后将这个页面编号1加入位图，表示已经备份了这个页面的未修改之前的内容。&lt;/li&gt;
&lt;li&gt;修改页面2的一处内容：类似的，也是备份了页面2的内容&lt;code&gt;z=2&lt;/code&gt;，同时将页面2加入位图，表示已经备份了这个页面的未修改之前的内容。&lt;/li&gt;
&lt;li&gt;修改页面1的一处内容&lt;code&gt;y=2&lt;/code&gt;：这一次虽然也是要修改已有页面，但是由于在位图中找到这个页面编号，说明在这一次事务中已经备份过这个页面了，于是不再需要备份操作，直接返回。&lt;/li&gt;
&lt;li&gt;新增页面3&lt;code&gt;p=4&lt;/code&gt;：发现该页面的编号3，大于当前数据库页面数量2，属于新增页面，于是不进行备份，只是加入到脏页面链表中同时标记需要落盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即：在这一次写事务执行的过程中，虽然需要修改4处内容，实际修改备份文件两次，新增数据库页面页面一次。&lt;/p&gt;
&lt;p&gt;这个例子前后数据库文件以及备份文件内容的对比见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal-example.png&#34; alt=&#34;journal备份页面例子&#34; title=&#34;journal备份页面例子&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;何时落盘&#34;&gt;何时落盘&lt;/h2&gt;
&lt;p&gt;前面备份待修改页面的流程中，备份的页面内容只是写到了备份文件里，实际还并没有执行&lt;code&gt;sync&lt;/code&gt;操作强制落盘，只要没有落盘就还是存在备份数据损坏的情况。&lt;/p&gt;
&lt;p&gt;在上一节的（&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;），备份文件内容落盘是放在第七步做的，此时对用户空间的页面内容的修改已经完成了，不清楚这一流程的可以回头再看看上一节的内容。&lt;/p&gt;
&lt;p&gt;具体到journal文件的机制，这一步是放在函数&lt;code&gt;pager_end_transaction&lt;/code&gt;进行的，&lt;code&gt;pager_end_transaction&lt;/code&gt;函数就是上面介绍的：在事务修改完毕用户空间的页面之后，被调用。&lt;/p&gt;
&lt;h2 id=&#34;错误恢复&#34;&gt;错误恢复&lt;/h2&gt;
&lt;p&gt;继续以上面的例子来解释一下使用journal备份文件机制下的错误恢复的流程。&lt;/p&gt;
&lt;p&gt;从上面的流程里，我们可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;journal备份文件备份的是未修改之前的页面内容，如果一个页面在一次修改中会被多次修改，也只会备份一次（如上面例子中的页面1）。&lt;/li&gt;
&lt;li&gt;写事务完成之后，首先会将journal备份文件中的内容首先sync到磁盘，才开始将页面缓存中的内容落到数据库文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次来回顾一下之前&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;中的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库文件：任何写操作的修改最终都将落到数据库文件中。&lt;/li&gt;
&lt;li&gt;页面缓存：暂存每次写操作过程中修改的内容。&lt;/li&gt;
&lt;li&gt;journal备份文件：备份页面被修改之前的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的例子，加上页面缓存之后如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal-backup.png&#34; alt=&#34;journal恢复流程例子&#34; title=&#34;journal恢复流程例子&#34;&gt;&lt;/p&gt;
&lt;p&gt;对应这个流程，这一次写操作只可能在以下这几个阶段中发生错误宕机，其对应的恢复机制如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写操作开始之前：这个没有太多可以说的，由于还没有开始真正的写操作，数据库文件中的内容还是完整的，且journal备份文件中没有内容，于是可以直接以数据库文件内容来启动即可。&lt;/li&gt;
&lt;li&gt;写操作流程中：即写了一部分数据，还没有完成整个写事务的时候发生错误。这个场景中，之前写入的数据都在页面缓存里，备份修改页面的内容在备份文件中，而数据库文件还未发生任何改动。所以在错误重新启动的时候，页面缓存中已经没有任何内容了，然后会去校验一下备份文件，由于只写了一部分数据而已，所以备份文件是不完整即损坏的，此时备份文件的内容不能算数。于是和上面的场景一样，以数据库文件来启动即可，即这次不完整的写操作，之前写入的部分内容会被全部丢弃了。&lt;/li&gt;
&lt;li&gt;写操作完成之后：这个阶段是写操作完成，修改的页面在修改之前的内容已经全部写入备份文件，但是页面缓存中的内容还没有全部落盘到数据库文件时，发生了错误崩溃。这种情况下重启，那么数据库文件可能是错乱的，因为只有部分内容落盘了，如这里的页面1，初始内容是&lt;code&gt;x=0,y=1&lt;/code&gt;，完整的修改应该是&lt;code&gt;x=1,y=2&lt;/code&gt;，如果只修改了一部分则是&lt;code&gt;x=1,y=1&lt;/code&gt;。这种情况下重启时，检查到备份文件中的内容是完整的，这就会以备份文件中的内容，来覆盖数据库文件中的内容，即将数据库文件恢复到这次写事务开始之前的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个恢复流程可以看到：使用页面备份机制，在完成写操作、但是还未完全将页面缓存的内容落盘到数据库文件之前，任何出错都会导致这个写事务的修改（不管是部分修改还是全部修改）被丢掉。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;本节讲解了journal文件的实现机制，从最早的sqlite btree实现时，备份页面的机制就一直使用journal机制，从这里的分析可以看到，这种机制很“朴素”，性能也并不好，所以后续在3.7版本的sqlite中引入了更优的WAL实现机制。&lt;/p&gt;
&lt;p&gt;本节也并没有把所有journal文件实现机制都详细描述，只是把最核心的文件结构以及备份流程做了讲解，因为并不想在这个性能不高的机制上着墨更多，有兴趣的读者可以自行阅读相关代码。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/fileformat.html&#34;&gt;Database File Format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（二）- 并发控制框架</title>
      <link>https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/</link>
      <pubDate>Sat, 18 Dec 2021 15:25:05 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;按照之前起步阶段对sqlite btree整体架构的分析，“页面管理模块”分为以下几个子模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面缓存管理。&lt;/li&gt;
&lt;li&gt;页面备份，又分为以下两种实现：
&lt;ul&gt;
&lt;li&gt;journal文件。&lt;/li&gt;
&lt;li&gt;WAL文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页面管理模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面一节讲完了“页面缓存管理”的实现，按照自下往上的顺序，就应该到“页面备份”了。“页面备份”核心的工作是：在真正修改页面内容之前，将还未修改的页面内容备份，这样一旦系统在事务过程中宕机崩溃，就可以用这部分内容回滚还未落盘的事务修改，让系统回到一个正确的状态。&lt;/p&gt;
&lt;p&gt;“页面备份”有两种实现方式，在早期使用的journal文件，这种方式性能不高；在3.7版本之后，sqlite引入了WAL文件来保存页面内容，这样做的效率更高。&lt;/p&gt;
&lt;p&gt;本节就讲解这部分内容，在对这部分内容有一个总体的了解之后，继续讲解页面备份的总体流程。后面的章节再具体分析journal以及WAL的实现。&lt;/p&gt;
&lt;h1 id=&#34;写事务的流程&#34;&gt;写事务的流程&lt;/h1&gt;
&lt;p&gt;（以下流程分析，按照sqlite官网中的文档&lt;a href=&#34;https://sqlite.org/atomiccommit.html&#34;&gt;Atomic Commit In SQLite&lt;/a&gt;进行讲解，图例也全部引用自官网。）&lt;/p&gt;
&lt;p&gt;sqlite的写事务，分为以下几个流程：&lt;/p&gt;
&lt;h2 id=&#34;1初始化阶段initial-state&#34;&gt;1、初始化阶段（Initial State）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-0.gif&#34; alt=&#34;初始化&#34; title=&#34;初始化&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图中，从右到左即是系统的磁盘、操作系统缓冲区、用户空间三部分，其中磁盘和操作系统缓冲区有划分为多块的空间，每一块在sqlite里被称为一个&lt;code&gt;sector&lt;/code&gt;，蓝色部分表示是修改之前的数据。&lt;/p&gt;
&lt;p&gt;这是系统初始时的样子。&lt;/p&gt;
&lt;h2 id=&#34;2拿到读锁acquiring-a-read-lock&#34;&gt;2、拿到读锁（Acquiring A Read Lock）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-1.gif&#34; alt=&#34;拿到读锁&#34; title=&#34;拿到读锁&#34;&gt;&lt;/p&gt;
&lt;p&gt;在开始进行写操作之前，sqlite必须先把待修改的页面加载内存中（这就是上一节“页面缓存管理器”做的事情），后续的修改其实也是首先修改这部分加载到内存中的页面内容，因为可能一次提交会修改同一个页面中的多处内容，最后才把页面内容落盘。&lt;/p&gt;
&lt;p&gt;所以，这一步所要做的，是首先拿到数据库文件的读锁（shared lock），需要说明的是，这个读锁是数据库级别的锁。同一时间，系统中可以存在多个读锁，但是只要系统中还存在读锁，就不再允许分配出新的写锁（write lock）。&lt;/p&gt;
&lt;h2 id=&#34;3读出页面的内容到页面缓存&#34;&gt;3、读出页面的内容到页面缓存&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-2.gif&#34; alt=&#34;读出页面内容&#34; title=&#34;读出页面内容&#34;&gt;&lt;/p&gt;
&lt;p&gt;拿到读锁之后，就可以把需要进行修改的页面读出来到用户空间的页面缓存了。从上图来看，读了三个页面的内容出来，也就是例子中的写操作要修改三个页面的内容。&lt;/p&gt;
&lt;h2 id=&#34;4拿到保留锁obtaining-a-reserved-lock&#34;&gt;4、拿到保留锁（Obtaining A Reserved Lock）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-3.gif&#34; alt=&#34;拿到保留锁&#34; title=&#34;拿到保留锁&#34;&gt;&lt;/p&gt;
&lt;p&gt;在进行修改之前，还需要首先将前面拿到的读锁（shared lock）升级为保留锁（reserved lock）。同一时间，系统中保留锁可以和多个读锁并存，但是只能存在最多一个保留锁。这个机制，保证了同一时间只能有一个进程对数据库进行写操作。&lt;/p&gt;
&lt;p&gt;需要说明的是，拿到保留锁的进程，还并没有真正进行数据的修改操作，只是用这个锁，挡住了其它打算进行写操作的进程。&lt;/p&gt;
&lt;h2 id=&#34;5创建回滚用的备份文件creating-a-rollback-journal-file&#34;&gt;5、创建回滚用的备份文件（Creating A Rollback Journal File）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-4.gif&#34; alt=&#34;创建回滚用的备份文件&#34; title=&#34;创建回滚用的备份文件&#34;&gt;&lt;/p&gt;
&lt;p&gt;到了这一步，首先将待修改的页面内容备份。官网原文写的是备份到回滚用的journal文件中，我们上面提到备份机制除了journal文件还有wal文件，所以这里的“journal文件”应该更泛化的理解为“保存到备份文件中”，这种备份文件可能是journal文件，也可能是wal文件，视机制而定。&lt;/p&gt;
&lt;p&gt;上图中，用户空间的页面写入到了备份文件中，注意到备份文件上面有一小块绿色的部分，理解为备份文件的meta信息即可。&lt;/p&gt;
&lt;p&gt;另外还需要特别说明的是，从上图中可以看到，备份工作也仅仅到了操作系统缓冲区，即图中的中间部分，而磁盘部分还是空的。即到了这一步，即便是备份页面的内容，也还并没有sync到磁盘中，即只进行了备份的写操作，并没有强制落盘。&lt;/p&gt;
&lt;h2 id=&#34;6修改用户空间的页面内容changing-database-pages-in-user-space&#34;&gt;6、修改用户空间的页面内容（Changing Database Pages In User Space）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-5.gif&#34; alt=&#34;修改用户空间的页面内容&#34; title=&#34;修改用户空间的页面内容&#34;&gt;&lt;/p&gt;
&lt;p&gt;到了这一步，修改进程用户空间的页面内容，即上图中的橙色部分，就是修改后的用户空间数据。由于每个进程都有自己的用户空间（即便是同一个进程下的不同线程，对sqlite而言，只要使用的是不同的连接（connection），那么连接背后的页面缓冲区就不一样），所以这些修改并不被其它进程所见。这样，写进程做自己的修改，其它读进程读到的还是修改之前的页面数据。&lt;/p&gt;
&lt;h2 id=&#34;7将备份文件的内容落盘flushing-the-rollback-journal-file-to-mass-storage&#34;&gt;7、将备份文件的内容落盘（Flushing The Rollback Journal File To Mass Storage）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-6.gif&#34; alt=&#34;将备份文件的内容落盘&#34; title=&#34;将备份文件的内容落盘&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的第5步提到，当时还只是写页面内容到备份文件中，这一步接在修改页面内容之后，将修改之前的页面内容sync到磁盘中。&lt;/p&gt;
&lt;h2 id=&#34;8拿到排他锁obtaining-an-exclusive-lock&#34;&gt;8、拿到排他锁（Obtaining An Exclusive Lock）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-7.gif&#34; alt=&#34;拿到排他锁&#34; title=&#34;拿到排他锁&#34;&gt;&lt;/p&gt;
&lt;p&gt;前面的步骤做完，达到了这样的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于待修改页面，修改之前的内容已经保存到了备份文件中。&lt;/li&gt;
&lt;li&gt;需要修改的内容，已经体现在了进程的用户空间的页面缓存里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，需要将页面修改的内容写到数据库文件中。在修改数据库文件之前，还需要首先拿到排他锁（exclusive lock）。拿到排他锁，又分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先拿到悬锁（pending lock）。&lt;/li&gt;
&lt;li&gt;将悬锁升级为排他锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要首先拿到悬锁？同一时间内，悬锁和前面的保留锁一样，只能存在最多一个；但是不同的是，悬锁不允许再分配新的读锁（shared lock），而保留锁没有这样的机制。换言之，在悬锁之前的所有读锁，可以继续读操作，悬锁会等待它们完成，再升级为排他锁；同时，只要系统中有悬锁，就不再允许有新的读操作，必须等待修改数据库完成才可以有新的读操作。&lt;/p&gt;
&lt;p&gt;这样的机制，避免了读操作时，读到了未提交的事务写到一半的数据。&lt;/p&gt;
&lt;h2 id=&#34;9保存修改到数据库文件中writing-changes-to-the-database-file&#34;&gt;9、保存修改到数据库文件中（Writing Changes To The Database File）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-8.gif&#34; alt=&#34;拿到排他锁&#34; title=&#34;拿到排他锁&#34;&gt;&lt;/p&gt;
&lt;p&gt;拿到了排他锁之后，意味着此时系统中没有读操作、没有其他写操作，这时候可以放心将页面缓存中的内容落盘到数据库文件中了。&lt;/p&gt;
&lt;p&gt;同样需要注意的是，这一步的修改，还还只是到了操作系统的缓冲区，并不保证落盘到数据库文件中。&lt;/p&gt;
&lt;h2 id=&#34;10落盘数据库文件修改flushing-changes-to-mass-storage&#34;&gt;10、落盘数据库文件修改（Flushing Changes To Mass Storage）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-9.gif&#34; alt=&#34;落盘数据库文件修改&#34; title=&#34;落盘数据库文件修改&#34;&gt;&lt;/p&gt;
&lt;p&gt;这一步，将对数据库文件的修改落盘。&lt;/p&gt;
&lt;h2 id=&#34;11删除备份文件deleting-the-rollback-journal&#34;&gt;11、删除备份文件（Deleting The Rollback Journal）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-A.gif&#34; alt=&#34;删除备份文件&#34; title=&#34;删除备份文件&#34;&gt;&lt;/p&gt;
&lt;p&gt;至此，这一次写操作已经落盘到了数据库文件中，前面保存到备份文件中的数据可以清除了。清除备份文件内容，是一个比较费时的操作，具体实现由不同的机制去优化，后面讲到journal文件以及wal的实现时再展开描述。&lt;/p&gt;
&lt;h2 id=&#34;12释放锁releasing-the-lock&#34;&gt;12、释放锁（Releasing The Lock）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-B.gif&#34; alt=&#34;释放锁&#34; title=&#34;释放锁&#34;&gt;&lt;/p&gt;
&lt;p&gt;写操作全部完成，备份文件也清除了，到了这一步就可以释放锁，以便后面其他的读写操作进来。&lt;/p&gt;
&lt;h1 id=&#34;写事务中涉及到的锁&#34;&gt;写事务中涉及到的锁&lt;/h1&gt;
&lt;p&gt;上面写事务流程中，依次会拿到以下类型的锁，下图中做一个简单的总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/write_lock.png&#34; alt=&#34;写操作中涉及到的锁&#34; title=&#34;写操作中涉及到的锁&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;崩溃恢复流程&#34;&gt;崩溃恢复流程&lt;/h1&gt;
&lt;p&gt;上面的流程中，随时都可能因为系统崩溃而导致数据错乱的，因此一个写事务如果还未完成，重启时存储引擎需要识别出来，将还没有完成的事务进行回滚操作（rollback）。&lt;/p&gt;
&lt;p&gt;分为以下几种情况来处理：&lt;/p&gt;
&lt;h2 id=&#34;写备份数据之前失败&#34;&gt;写备份数据之前失败&lt;/h2&gt;
&lt;p&gt;如果系统在落盘备份数据之前失败，即前面的流程7之前失败，按照上面的流程来看，情况是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写事务的数据还停留在用户空间的页面缓存中，未落盘到数据库文件上（流程6）。&lt;/li&gt;
&lt;li&gt;在流程5，只是将数据写到备份文件，还没有强制刷盘，所以这时候崩溃，可能备份文件中的数据是损坏的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以在这种情况下重启，面对的是这样的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库文件：还在写事务之前的状态，因为写事务还未落盘。&lt;/li&gt;
&lt;li&gt;备份文件：可能损坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，启动之后将校验备份文件是否完整，如果完整将重放一遍备份文件中的页面到数据库文件中；否则，只是简单的删除备份文件中的数据即可。&lt;/p&gt;
&lt;h2 id=&#34;写数据库文件时失败&#34;&gt;写数据库文件时失败&lt;/h2&gt;
&lt;p&gt;如果已经过了流程7，而在将页面缓存中的修改落盘到数据库文件的过程中，系统崩溃了，那么面临的是这样的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库文件肯定损坏了。&lt;/li&gt;
&lt;li&gt;写事务中被修改页面之前的内容，已经落盘到备份文件中了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，启动恢复的时候，只需要将备份文件中的页面重放一遍到数据库文件即可将数据库文件恢复到写事务修改前的状态了。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;以上，就是sqlite中写事务的总体流程，以及重启恢复的流程，这里还并没有涉及到具体的代码细节，有了对总体流程的理解，后面再来分析具体的两种备份机制：journal以及wal的实现。&lt;/p&gt;
&lt;p&gt;另外，需要看到的是：sqlite中锁的粒度，都还是数据库级别的，现在我还不知道其它更高效的数据库所谓行锁的实现，留待以后吧。&lt;/p&gt;
&lt;h1 id=&#34;参考文档&#34;&gt;参考文档&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sqlite.org/atomiccommit.html&#34;&gt;Atomic Commit In SQLite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/lockingv3.html&#34;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（一）- 管理页面缓存</title>
      <link>https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/</link>
      <pubDate>Fri, 17 Dec 2021 14:22:06 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;页面管理&lt;/code&gt;模块中，很重要的一个功能是缓存页面的内容在内存中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读页面：如果页面已经在内存，就不需要到文件中读出页面内容。&lt;/li&gt;
&lt;li&gt;写页面：如果页面已经在内存，那么对页面的修改就只需要修改页面在内存中的数据即可，被修改了但是还没有落盘的页面，被称为“脏页面（dirty page）“。这样，多次对某个页面的修改，可能最后只需要一次落盘即可。当然，对页面的修改，如果在还没有落盘之前，系统就崩溃了，这种情况下应该如何处理，这就是“崩溃恢复”模块做的事情了。本节中，将专注在“页面缓存”这个子模块的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然要将页面缓存在内存中，就会涉及到几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何知道哪些页面已经被缓存在内存里了？&lt;/li&gt;
&lt;li&gt;缓存在内存中的页面如何组织管理？&lt;/li&gt;
&lt;li&gt;缓存页面使用的内存不够用时，应该如何处理？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们首先来了解一下“页面缓存”模块的总体划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/pagecache.png&#34; alt=&#34;页面缓存功能的模块划分&#34; title=&#34;页面缓存功能的模块划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;按照上图的划分，页面缓存模块分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面缓存管理器：实现了页面缓存的总体算法流程，以及提供对外的接口，但是具体到“页面缓存算法”的实现，则有赖于下面这个可用户定制的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;。这部分功能在代码&lt;code&gt;pcache.c&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;页面缓存算法：用户可自己定制，只要实现&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中的接口即可。系统中的默认实现，在文件&lt;code&gt;pcache1.c&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;除此以外，还需要快速根据页面编号就能知道哪些页面已经被缓存的功能，这部分sqlite使用位图数据结构来实现，在文件&lt;code&gt;bitvec.c&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;页面缓存管理器，核心功能就是维护脏页面链表，缓存页面的管理，诸如根据页面编号查找页面、淘汰页面算法等，都由“页面缓存算法”来维护。可以这样来简单的理解上面的功能划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“页面缓存管理器”：定义了管理页面缓存的接口、总体流程，维护管理目前在用的脏页面。&lt;/li&gt;
&lt;li&gt;“页面缓存算法”：维护其它不在使用但还在内存中的页面，负责其淘汰、回收等实现。由“sqlite3_pcache_methods2”结构体实现，用户可以定制自己实现的“sqlite3_pcache_methods2”，系统也提供默认的实现。当内存不足以分配时，需要淘汰不常用的页面，这时候需要使用“页面缓存管理器”注册的回调函数来淘汰页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/pagecache_module.png&#34; alt=&#34;页面缓存两个模块的功能划分&#34; title=&#34;页面缓存两个模块的功能划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;简而言之，如果把当前在内存中的页面划分为以下两类，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前在使用的页面：即与页面编号对应的页面，由“页面缓存管理器”维护。&lt;/li&gt;
&lt;li&gt;当前还未使用、但也在内存中的页面：即随时准备拿出来存储从磁盘中读出来的数据的页面，由“页面缓存算法”维护，比如淘汰、回收、复用等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/page_cache_memory.png&#34; alt=&#34;两种页面的划分&#34; title=&#34;两种页面的划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面，就开始“页面缓存”这几部分功能的具体讲解。&lt;/p&gt;
&lt;h1 id=&#34;管理页面&#34;&gt;管理页面&lt;/h1&gt;
&lt;h2 id=&#34;页面相关的数据数据结构&#34;&gt;页面相关的数据数据结构&lt;/h2&gt;
&lt;p&gt;首先来看页面相关的数据结构，sqlite中使用&lt;code&gt;PgHdr&lt;/code&gt;结构体来在内存中描述一个页面：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
** Every page in the cache is controlled by an instance of the following
** structure.
*/
struct PgHdr {
  sqlite3_pcache_page *pPage;    /* Pcache object page handle */
  void *pData;                   /* Page data */
  void *pExtra;                  /* Extra content */
  PCache *pCache;                /* PRIVATE: Cache that owns this page */
  PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */
  Pager *pPager;                 /* The pager this page is part of */
  Pgno pgno;                     /* Page number for this page */
#ifdef SQLITE_CHECK_PAGES
  u32 pageHash;                  /* Hash of page content */
#endif
  u16 flags;                     /* PGHDR flags defined below */

  /**********************************************************************
  ** Elements above, except pCache, are public.  All that follow are 
  ** private to pcache.c and should not be accessed by other modules.
  ** pCache is grouped with the public elements for efficiency.
  */
  i16 nRef;                      /* Number of users of this page */
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的信息，大部分在注释中已经自解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pPage：这个字段稍显复杂，后面展开详细解释。&lt;/li&gt;
&lt;li&gt;pData，pExtra：pData指向了页面实际的内容，pExtra指向页面额外数据，大部分时候，后者的内容可以忽视。&lt;/li&gt;
&lt;li&gt;pCache：页面缓存管理器对象指针。&lt;/li&gt;
&lt;li&gt;pDirty：脏页面链表指针。&lt;/li&gt;
&lt;li&gt;pPager：页面管理器对象指针。（注意和pCache进行区分，pCache是“页面缓存管理器”）。&lt;/li&gt;
&lt;li&gt;pgno：存储该页面的页面编号。&lt;/li&gt;
&lt;li&gt;flags：页面标志位，有如下几种，可以通过位操作来加上多个标志位：
&lt;ul&gt;
&lt;li&gt;PGHDR_CLEAN：干净的页面。&lt;/li&gt;
&lt;li&gt;PGHDR_DIRTY：脏页面。&lt;/li&gt;
&lt;li&gt;PGHDR_WRITEABLE：已经记录下来修改之前的页面内容，所以此时可以对内存中的页面内容进行修改了。&lt;/li&gt;
&lt;li&gt;PGHDR_NEED_SYNC：将该页面内容写入数据库文件之前，需要sync journal文件中的页面内容。&lt;/li&gt;
&lt;li&gt;PGHDR_DONT_WRITE：不需要写页面内容到磁盘。&lt;/li&gt;
&lt;li&gt;PGHDR_MMAP：该页面内容是通过mmap到内存中的。&lt;/li&gt;
&lt;li&gt;PGHDR_WAL_APPEND：页面内容已经添加到WAL文件中了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nRef：页面引用计数。&lt;/li&gt;
&lt;li&gt;pDirtyNext、pDirtyPrev：存储脏页面链表中前、后页面指针，如果该页面不是脏页面，则这两个字段未定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以简略的总结该结构体中的内容，最重要的莫过于以下几项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pData存储的页面内容，所谓的读、写页面内容实际上操作的是这个成员指向的内容。&lt;/li&gt;
&lt;li&gt;pDirty、pDirtyNext、pDirtyPrev这几个成员维护的脏页面相关的指针。&lt;/li&gt;
&lt;li&gt;flags维护的页面标志位，通过这些标志位来区分应该对页面进行什么操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/PgHdr.png&#34; alt=&#34;内存中脏页面的组织&#34; title=&#34;内存中脏页面的组织&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sqlite3_pcache_page数据结构&#34;&gt;sqlite3_pcache_page数据结构&lt;/h3&gt;
&lt;p&gt;上面的&lt;code&gt;PgHdr&lt;/code&gt;结构体中，还有第一个成员，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;类型的pPage指针没有讲解，这里展开解释。&lt;/p&gt;
&lt;p&gt;前面概述部分提到，“页面缓存算法”的实现，是可以交给用户自定义的，这就带来一个问题：每个自定义的实现，内部实现的管理页面的结构体可能并不相同。于是，就要类似C++中的面向对象机制一样，先声明一个“页面”的基类，基类中定义最基础的成员变量，这样做之后有这样的好处：页面管理模块，所有的操作都能针对这个基类来进行，而不需要管具体实现中的差异。&lt;/p&gt;
&lt;p&gt;在这里，这个基类就是成员&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;        /* The content of the page */
  void *pExtra;      /* Extra information associated with the page */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成员中的用途，注释中也写得挺清楚了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pBuf：指向页面内容。&lt;/li&gt;
&lt;li&gt;pExtra：保存页面的额外信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然是“基类”，就要求每个子类都要有该基类的信息，实际上也是这样做的，比如“页面缓存算法”的默认实现中，其管理页面的结构体是&lt;code&gt;PgHdr1&lt;/code&gt;（后面会展开解释这个结构体），其初始定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp;amp; pExtra */
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从注释可以看到，sqlite中要求所有实现页面缓存算法中管理页面的数据结构体，都要以&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体开始做为第一个成员。&lt;/p&gt;
&lt;p&gt;实际上，&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体中，&lt;code&gt;pExtra&lt;/code&gt;成员包括如下两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;额外内容：由系统指定&lt;code&gt;szExtra&lt;/code&gt;大小来指定这部分内容大小，简单起见，目前可以认为这部分为0。&lt;/li&gt;
&lt;li&gt;PgHdr结构体：即前面讲解的&lt;code&gt;页面缓存模块&lt;/code&gt;中描述一个页面的结构体大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读到这里，有可能把读者绕晕了，我们以代码和图示为引子详细看一下。&lt;/p&gt;
&lt;p&gt;首先，创建一个“页面缓存算法”模块时，要调用&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中定义的&lt;code&gt;xCreate&lt;/code&gt;函数指针来完成，其函数定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;传入的第二个参数&lt;code&gt;szExtra&lt;/code&gt;需要指定额外部分的内容大小，实际在调用时，这个参数的大小就是我们上面说的&lt;code&gt;szExtra&lt;/code&gt;和PgHdr结构体大小之和（做了8字节对齐）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    sqlite3_pcache *pNew;
    pNew = sqlite3GlobalConfig.pcache2.xCreate(
                szPage, pCache-&amp;gt;szExtra + ROUND8(sizeof(PgHdr)),
                pCache-&amp;gt;bPurgeable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;于是，“页面缓存模块”中要获取一个页面时，是通过&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中定义的&lt;code&gt;xFetch&lt;/code&gt;函数指针来完成的，这个函数指针的定义是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，这里返回的就是上面说的“基类”，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体指针。而在内部的默认实现中，其实返回的是&lt;code&gt;PgHdr1&lt;/code&gt;指针进行强制转换之后的结果，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;这一基类的子类，之所以能够做，完全是因为在&lt;code&gt;PgHdr1&lt;/code&gt;结构体定义时，把&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体成员放在第一个成员：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp;amp; pExtra */
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到返回的&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;指针之后，就能通过其中的&lt;code&gt;pExtra&lt;/code&gt;指针拿到&lt;code&gt;PgHdr&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PgHdr *sqlite3PcacheFetchFinish(
  PCache *pCache,             /* Obtain the page from this cache */
  Pgno pgno,                  /* Page number obtained */
  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */
){
  PgHdr *pPgHdr;

  pPgHdr = (PgHdr *)pPage-&amp;gt;pExtra;
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结起来，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/sqlite3_pcache_page.png&#34; alt=&#34;sqlite3_pcache_page&#34; title=&#34;sqlite3_pcache_page&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;页面所在的数据结构&#34;&gt;页面所在的数据结构&lt;/h2&gt;
&lt;p&gt;缓存中的页面，可能存在于以下三种数据结构中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏页面链表：该链表维护所有当前在使用的页面，由“页面缓存管理器”维护。&lt;/li&gt;
&lt;li&gt;hash数组：作用是以页面编号为键来查询页面，由默认的“页面缓存算法”来维护。&lt;/li&gt;
&lt;li&gt;LRU链表：越是常被访问的页面，在LRU链表中就越往前，从LRU链表中淘汰数据都是从链表尾部开始的，也是由默认的“页面缓存算法”来维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/page_ds.png&#34; alt=&#34;页面所在的三种数据结构&#34; title=&#34;页面所在的三种数据结构&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;脏页面链表&#34;&gt;脏页面链表&lt;/h3&gt;
&lt;p&gt;这个页面链表叫“脏页面（dirty page）链表”实际上并不十分准确，这会让人误以为这个链表上的页面全都是脏页面，实际上是可能存在干净的页面的。更准确的说法，是当前系统在使用的页面，都维护在这个页面链表中。&lt;/p&gt;
&lt;p&gt;操作这个链表的入口函数是&lt;code&gt;pcacheManageDirtyList&lt;/code&gt;，其传入的参数一个是&lt;code&gt;PgHdr&lt;/code&gt;类型的指针，另一个用于指定行为，有以下三种：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */
#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */
#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;pcacheManageDirtyList&lt;/code&gt;函数实现中，也是根据这个参数进行与操作判断来做不同的行为的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pcacheManageDirtyList实现：
  如果 addRemove &amp;amp; PCACHE_DIRTYLIST_REMOVE:
    从链表上删除
  如果 addRemove &amp;amp; PCACHE_DIRTYLIST_ADD：
    添加到链表头
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要注意的是，参数&lt;code&gt;PCACHE_DIRTYLIST_FRONT&lt;/code&gt;为3，而另外两个参数一个是1（删除）一个是2，所以当传入&lt;code&gt;PCACHE_DIRTYLIST_FRONT&lt;/code&gt;的时候，按照上面的流程，就是首先从链表上删除，再放到链表头。&lt;/p&gt;
&lt;p&gt;由于脏页面链表是由“页面缓存管理器”来管理的，所以描述页面的结构体与这个链表相关的数据结构，都在&lt;code&gt;PgHdr&lt;/code&gt;上：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PgHdr {
  ...
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
}; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hash数组&#34;&gt;hash数组&lt;/h3&gt;
&lt;p&gt;为了快速根据页面编号，查找到该编号的页面是否已经加载到页面中，每个页面的数据还存在于一个hash数组中。&lt;/p&gt;
&lt;p&gt;如前所述，这个数据结构由默认的“页面缓存算法”维护，所以与之相关的数据结构，都在结构体&lt;code&gt;PgHdr1&lt;/code&gt;上：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PgHdr1 {
  ...
  PgHdr1 *pNext;                 /* Next in hash table chain */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hash数组的实现，与一般的实现并没有太大区别，这里就不展开说了。&lt;/p&gt;
&lt;h3 id=&#34;lru链表&#34;&gt;LRU链表&lt;/h3&gt;
&lt;p&gt;当需要加载当前还不在内存中的页面时，需要首先分配出一块空间，用于保存从文件中加载的页面数据。如前所述，“页面缓存管理器”管理的是还在使用的页面，而“页面缓存算法”管理的是当前没有被使用的页面，所以这部分功能也是由默认的“页面缓存算法”来实现的，与之相关的数据结构，和hash数组的实现一样，也在结构体&lt;code&gt;PgHdr1&lt;/code&gt;上：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PgHdr1 {
  ...
  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */
  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */
                                 /* NB: pLruPrev is only valid if pLruNext!=0 */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当需要从“没有被使用的页面”中，分配出来一个页面数据用于保存加载的页面时，就涉及到淘汰问题：如果一个页面虽然当前没有被使用，但是由于经常被访问，所以不应该淘汰这个页面，因为很有可能它马上又会被访问到，应该首先淘汰那些不常被访问的页面，用来加载页面数据。&lt;/p&gt;
&lt;p&gt;维护这些信息的数据结构，就是LRU链表：在链表中越往前的数据，意味着被访问的越频繁；反之，淘汰都是从链表尾部开始。&lt;/p&gt;
&lt;h3 id=&#34;pin和unpin操作&#34;&gt;pin和unpin操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pin&lt;/code&gt;和&lt;code&gt;unpin&lt;/code&gt;操作，在默认的缓存算法中，是针对LRU链表而言的：一个页面数据，如果执行了&lt;code&gt;pin&lt;/code&gt;操作，就是将这个页面从LRU链表上摘下来。而&lt;code&gt;unpin&lt;/code&gt;操作则反之，将页面放入LRU链表。&lt;/p&gt;
&lt;p&gt;为什么需要这两个操作？&lt;/p&gt;
&lt;p&gt;再复习一下前面提到的分工：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面缓存管理器：负责维护在使用的页面。&lt;/li&gt;
&lt;li&gt;页面缓存算法：负责维护未使用的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设一个页面编号为N的页面，被访问时需要加载到内存，此时就会由“页面缓存管理器”加载到内存中，放入脏页面链表；而一旦访问完成，就会调用页面缓存算法的&lt;code&gt;xUnpin&lt;/code&gt;函数指针执行&lt;code&gt;unpin&lt;/code&gt;操作（实现页面缓存算法的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体在后面解释）。&lt;/p&gt;
&lt;p&gt;在默认的缓存算法中，执行&lt;code&gt;unpin&lt;/code&gt;操作，就是将页面放入LRU链表，并不会将页面从hash数组中删除，也就是说：&lt;code&gt;unpin&lt;/code&gt;操作，并不妨碍这个能够以页面编号从hash数组中再次查到该页面的数据。&lt;/p&gt;
&lt;p&gt;换言之，&lt;code&gt;unpin&lt;/code&gt;操作是在“页面缓存算法”使用完毕某个页面时执行的，只是用来通知“页面缓存算法”：这个页面我已经用不上了，后续怎么处理，可以由“页面缓存算法”自行决定。&lt;/p&gt;
&lt;p&gt;于是，对于那些经常被访问的页面，即便当前没有被使用，真正到需要它的时候，只要没有被淘汰出去分配给其他页面，就不再需要再次从文件中加载出来。&lt;/p&gt;
&lt;h2 id=&#34;页面缓存管理器&#34;&gt;页面缓存管理器&lt;/h2&gt;
&lt;h3 id=&#34;页面缓存管理器的数据结构&#34;&gt;页面缓存管理器的数据结构&lt;/h3&gt;
&lt;p&gt;页面缓存管理器，核心功能就是维护脏页面链表，页面缓存管理器的数据结构中最重要的莫过于以下几个成员：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct PCache {
  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */
  PgHdr *pSynced;                     /* Last synced page in dirty page list */
  ...

  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */
  void *pStress;                      /* Argument to xStress */
  sqlite3_pcache *pCache;             /* Pluggable cache module */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，有两个维护页面链表相关的指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏页面链表：由成员pDirty, pDirtyTail指向该链表的一头一尾。脏页面链表中，页面是按照LRU的顺序进行排列的，即：越靠近链表尾的页面最可能被淘汰。&lt;/li&gt;
&lt;li&gt;最后进行sync的页面指针：在脏页面链表中，pSynced始终指向最后一个已经进行sync操作的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么需要多一个&lt;code&gt;pSynced&lt;/code&gt;指针？因为在页面缓存紧张的时候，需要快速知道哪些页面已经sync了，这样的页面淘汰的代价最低，具体可以看函数&lt;code&gt;sqlite3PcacheFetchStress&lt;/code&gt;的实现，该函数的大体流程是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;分为两步寻找可以淘汰的页面：
  首先在pSynced指针开始往前找不需要sync且引用计数为0的页面
  如果找不到就继续在脏页面链表中寻找引用计数为0的页面
  找到之后，调用注册的xStress进行淘汰操作
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了这几个和脏页面链表相关的数据结构之外，上面还列举出来了其他几个成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xStress和pStress：在页面缓存出现压力时，需要将页面淘汰同时进行清理，清理页面的操作最终由&lt;code&gt;xStress&lt;/code&gt;函数指针来完成。&lt;/li&gt;
&lt;li&gt;sqlite3_pcache：下面会提到，实现“页面缓存算法”的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体，其内部的&lt;code&gt;xCreate&lt;/code&gt;函数指针最终会创建出一个&lt;code&gt;sqlite3_pcache&lt;/code&gt;返回，后续调用&lt;code&gt;页面缓存算法&lt;/code&gt;时，传入的都是这个返回的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页面缓存算法结构体&#34;&gt;页面缓存算法结构体&lt;/h2&gt;
&lt;p&gt;页面缓存算法，需要实现&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;接口并且注册到系统中，来看&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;的定义：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, 
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逐个解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iVersion：版本号。&lt;/li&gt;
&lt;li&gt;pArg：参数。&lt;/li&gt;
&lt;li&gt;xInit：初始化模块的函数指针，这在模块初始化时一次性调用即可。&lt;/li&gt;
&lt;li&gt;xShutdown：停止模块的函数指针。&lt;/li&gt;
&lt;li&gt;xCreate：创建一个“页面缓存算法”的指针&lt;code&gt;sqlite3_pcache&lt;/code&gt;返回，注意这个函数里传入了页面大小、额外空间大小，这些都在上面有说明。后续的其他函数指针，传入的第一个参数都是这里返回的&lt;code&gt;sqlite3_pcache&lt;/code&gt;指针。&lt;/li&gt;
&lt;li&gt;xCachesize：返回当前cache大小。&lt;/li&gt;
&lt;li&gt;xPagecount：返回页面数量。&lt;/li&gt;
&lt;li&gt;xFetch：核心函数，根据传入的&lt;code&gt;key&lt;/code&gt;在缓存中查找页面，如果没有找到则按照&lt;code&gt;createFlag&lt;/code&gt;参数来决定后面的行为。&lt;/li&gt;
&lt;li&gt;xUnpin：页面的引用计数为0时就会调用这个函数。&lt;/li&gt;
&lt;li&gt;xRekey：表示把页面的key进行修改，这里key其实就是页面编号。&lt;/li&gt;
&lt;li&gt;xTruncate：将所有页面编号&amp;gt;=iLimit的页面都释放，回收内存。&lt;/li&gt;
&lt;li&gt;xDestroy：销毁前面&lt;code&gt;xCreate&lt;/code&gt;函数返回的&lt;code&gt;sqlite3_pcache&lt;/code&gt;指针。&lt;/li&gt;
&lt;li&gt;xShrink：尽可能的回收内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xInit函数：完成初始化这个模块的工作。&lt;/li&gt;
&lt;li&gt;xCreate：返回创建一个“页面缓存算法”的指针&lt;code&gt;sqlite3_pcache&lt;/code&gt;，后续的所有操作，都使用这个指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而sqlite中，其实并没有定义&lt;code&gt;sqlite3_pcache&lt;/code&gt;的具体结构，仅仅只是声明了这个类型，可以理解为是一个类似于&lt;code&gt;void*&lt;/code&gt;这样的泛型指针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache type is opaque.  It is implemented by
** the pluggable module.  The SQLite core has no knowledge of
** its size or internal structure and never deals with the
** sqlite3_pcache object except by holding and passing pointers
** to the object.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache sqlite3_pcache;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sqlite&lt;/code&gt;里的页面缓存，分为两个大的模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面缓存管理器：主要任务是管理脏页面，以及对外提供根据页面编号查询页面的接口，当某个页面不在内存时，自动将其加载到内存中。&lt;/li&gt;
&lt;li&gt;页面缓存算法：负责实现页面的缓存、淘汰、查询。这是可以由用户自己实现的模块，需要实现对应的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体即可，也提供了默认的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在内存中的页面，在以下几个数据结构中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏页面链表，由&lt;code&gt;页面缓存管理器&lt;/code&gt;维护。&lt;/li&gt;
&lt;li&gt;Hash数组：根据页面编号查询到页面数据的指针，由默认的&lt;code&gt;页面缓存算法&lt;/code&gt;维护。&lt;/li&gt;
&lt;li&gt;LRU链表：负责淘汰页面，由默认的&lt;code&gt;页面缓存算法&lt;/code&gt;维护。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（零）- 起步及概述</title>
      <link>https://www.codedump.info/post/20211217-sqlite-btree-0/</link>
      <pubDate>Fri, 17 Dec 2021 10:19:05 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211217-sqlite-btree-0/</guid>
      
      <description>&lt;p&gt;《sqlite3.36版本 btree实现》系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;起步&#34;&gt;起步&lt;/h1&gt;
&lt;p&gt;在去年大体把btree以及b+tree算法流程研究了之后，我写了两篇博客：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（鉴于b+tree只是btree的一个特例，下面描述将仅使用“btree”，不再严格区分两者。）&lt;/p&gt;
&lt;p&gt;但是，这两篇文章仅仅只是让我懂得了最基本的原理。懂得原理，只是能做出toy级别的实现，拿btree类的存储引擎来说，要做到生产级产品，至少还有以下几个问题我当时不知道怎么做的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何处理不同大小的数据的存储？&lt;/li&gt;
&lt;li&gt;删除一个数据之后，如何复用其留下的空间？&lt;/li&gt;
&lt;li&gt;错误、崩溃恢复怎么做？&lt;/li&gt;
&lt;li&gt;跟磁盘文件是如何交互的？&lt;/li&gt;
&lt;li&gt;页面缓存模块如何实现？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等等等，还有太多我还没有弄清楚的实现细节。&lt;/p&gt;
&lt;p&gt;（我甚至还在微博上发问，得到了两个质量很高的回答，见本文最后的&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/#%E5%BD%A9%E8%9B%8B&#34;&gt;彩蛋部分&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;对LSM类存储引擎有了解的人都知道，Leveldb这个项目在LSM领域属于入门级别的生产级实现，即这个领域最精简、但是又能放心在某些要求不高的场景下用于生产的项目。在这之后，我一直在找那种btree领域的“leveldb”，很遗憾一直都没有找到，我分别看了目前WiredTiger、innodb、sqlite的对应实现，都太复杂了，看不下去。&lt;/p&gt;
&lt;p&gt;直到有一天，无意间发现了这个项目：&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;madushadhanushka/simple-sqlite: Code reading for sqlite backend&lt;/a&gt;，看介绍，作者把sqlite2.5里b-tree相关的部分代码抽取出来了，我编译运行了一下用例都能正常跑，代码量不过几千行，我只花了几天就看完了。&lt;/p&gt;
&lt;p&gt;虽然按照&lt;a href=&#34;https://www.sqlite.org/changes.html&#34;&gt;Release History Of SQLite&lt;/a&gt;上的记载，sqlite 2.5版本是2002年的版本了，但是这个版本还是某种程度回答了我在上面的疑问。&lt;/p&gt;
&lt;p&gt;趁热打铁，我又找来更新一些的sqlite 3.6.10代码继续看这部分的实现，这次花了更多的时间才看完，但是又增强了我的信心。由于这个版本的sqlite，还未实现btree的wal，还只是用了journal文件来做崩溃恢复（无论wal还是journal，都会在后面文章展开详细讨论），所以在有足够的信心之后，我接下来又继续看当时（2021.10月份）最新的sqlite 3.36版本的实现，这部分的实现对比3.6.10来说，在btree部分最大的变化就是多了wal的实现，在已经清楚3.6.10的前提下，再增加了解这部分的实现，也并不是什么难事了。&lt;/p&gt;
&lt;p&gt;以上，简单描述了我探索一个生产级btree实现的初过程，btree类存储引擎的实现博大精深，更复杂者还有很多（WiredTiger、innodb、tokudb&amp;hellip;），但是无疑从低版本sqlite开始的探索流程，终于让我打开了走上这条路的一扇大门。&lt;/p&gt;
&lt;p&gt;本系列文章就sqlite 3.36版本的btree实现展开描述，希望对那些和我一样对“生产级btree类存储引擎实现”有好奇心的人有一点帮助。&lt;/p&gt;
&lt;p&gt;当然，如果你还是觉得吃力，可以先从&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;madushadhanushka/simple-sqlite: Code reading for sqlite backend&lt;/a&gt;这里看起。这里并不建议对btree原理没有了解的人直接上手sqlite的实现，如果需要了解原理请参考相关文章或者我上面给出的我写的两篇博客。这系列文章中，将不再对btree原理做过多描述，将假设读者已经了解这部分内容。&lt;/p&gt;
&lt;h1 id=&#34;sqlite的btree架构概述&#34;&gt;sqlite的btree架构概述&lt;/h1&gt;
&lt;p&gt;下面简单描述一下sqlite的btree架构，从高往低大体分为以下几个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;这三部分架构，由下往上依次是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统级API的实现：因为sqlite是一个可以在多个平台编译运行的数据库，所以系统级API这一层，需要解决平台相关的文件IO、锁等问题。这部分实现，将不在这系列文章中介绍，因为并不属于数据库实现时的核心问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面管理模块：btree存储引擎，其操作文件的最基本单位就是页面。页面管理模块解决以下的问题：对上层的btree模块，暴露针对页面读、写的接口，内部会缓存页面的内容，何时将修改的页面（所谓脏页面，dirty page）落盘到磁盘，是否需要sync修改，崩溃或者重启时的数据恢复，这些都不需要上层的btree模块关心。为了达到这些效果，内部还有几个子模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页面缓存模块：用于缓存页面的内存有限，何时淘汰缓存中的页面、何时将缓存中的脏页面落盘，等等都由这个模块负责。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面备份：从上面的描述可以看到，因为页面的修改并不一定马上落盘，而是可能只是修改了缓存中的页面，这样在系统发生崩溃的时候，需要做恢复操作，一些没有完成的事务需要回滚，等等。这部分页面管理模块由两种不同的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;journal文件：这是早期，但是效率并不高的实现。&lt;/li&gt;
&lt;li&gt;WAL文件：这是从3.7之后引入的更高效的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务：事务处理也放在了页面管理中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;btree：基于页面管理模块之上，实现了可以存储可变数据的btree模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以这样来简单区别理解“页面管理”模块和btree模块的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页面管理：顾名思义，页面管理模块的最基本单位是”页面“，页面的读、写、缓存、落盘、恢复、回滚等，都由页面模块负责。上一层依赖页面管理模块的btree模块，不需要关心一个页面何时缓存、何时落盘等细节。即：&lt;strong&gt;页面模块负责页面的物理级别的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;btree：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责按照btree算法，来组织页面，即负责的是页面之间逻辑关系维护。&lt;/li&gt;
&lt;li&gt;除此以外，一个页面内部的数据的物理、逻辑组织，也是btree模块来负责的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即：&lt;strong&gt;btree负责维护页面间的逻辑关系，以及一个页面内数据的组织。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/page-module.png&#34; alt=&#34;以页面物理、逻辑关系的维护看模块划分&#34; title=&#34;以页面物理、逻辑关系的维护看模块划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上面的分析可以看出来，“页面管理模块”无疑是这里最大最复杂的部分，Andy Pavlo在CMU 15445课程中提到过：任何用&lt;code&gt;mmap&lt;/code&gt;来做页面管理的做法都是很糟糕的做法（如boltdb、LMDB等）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/mmap.jpeg&#34; alt=&#34;mmap&#34; title=&#34;mmap&#34;&gt;&lt;/p&gt;
&lt;p&gt;这系列的文章，也将按照这个顺序，从下往上逐层分析sqlite的3.36版本的btree实现。&lt;/p&gt;
&lt;h1 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h1&gt;
&lt;p&gt;2021年9月5日，我在微博上就处理崩溃恢复的实现，提了一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些很成熟的存储引擎，都是怎么处理崩溃恢复问题的呢，比如写数据落盘到一半，进程崩了，该如何恢复呢？求资料和指点。 ​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1642628345/KwKqNgScT&#34;&gt;那些很成熟的存储引擎&amp;hellip; - @玩家老C的微博 - 微博&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;得到了两个很不错的指点回复：&lt;/p&gt;
&lt;h2 id=&#34;ba0tiao的回复&#34;&gt;ba0tiao的回复&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;做InnoDB 这块挺久了, 我试试说说 InnoDB 是怎么做的吧..&lt;/p&gt;
&lt;p&gt;其实你这里应该细分成两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;16kb 的page 写入的原子性该如何保证&lt;/li&gt;
&lt;li&gt;Btree 结构的完整性如何保证, 也就是你说的修改了n个页面以后如果修改了父子, 兄弟关系以后, 如果解决中间的crash 的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题1 是通过double write buffer 来解决的, 因为InnoDB 的page 大小是16kb, 很多文件系统只能保证4kb 大小写入的原子性, 因此需要写入前先将page 的内容写入到double write buffer 来保证, 如果写入失败也不会将原有page 的内容覆盖.&lt;/p&gt;
&lt;p&gt;问题2 是通过redo log + mtr(mini transaction) 进行保证.&lt;/p&gt;
&lt;p&gt;InnoDB 里面的redo log 是由mtr 组成, mtr 是修改btree 的最小单位. 每次写入redo log 的时候必须是一个完整的mtr 的内容, 具体实现方式是mtr 会有MULTI_REC_END 标记, 在crash recovery 的时候, 如果读取到mtr 的内容没有MULTI_REC_END 标记, 那么则会认为这个mtr 不完整, 就会把这段mtr 抛弃.&lt;/p&gt;
&lt;p&gt;那么是不是一次insert 操作产生的redo log 都包含在一个mtr 里面呢?&lt;/p&gt;
&lt;p&gt;不是的.&lt;/p&gt;
&lt;p&gt;我们知道在btree 里面对page 的修改都需要对page 加锁, 从fsp 模块分配一个new page 也需要对root page 进行加锁等等. 所以InnoDB 的mtr 里面自然就包含对锁的操作, 因此要修改某一个page 的时候, mtr begin 的时候会对该page 加锁, 然后写入修改的内容, 然后mtr commit 的时候, 对于修改的page 的锁就可以释放了.&lt;/p&gt;
&lt;p&gt;如果整个insert 的过程都放在一个mtr 里面做, 那也是可以的, 也就是对于所有page 的latch 都是一开始持有, 最后的时候在释放, 就算后续这个page 已经不再修改了, 也依然要一直持有. 很容易理解这样并发自然就降低下来的, 因此在InnoDB 设计里面, mtr 的粒度是尽可能小的. 修改完page 就应该尽快的commit, 然后将page lock 释放. 但是又需要保证每一次的mtr 操作前和操作后btree 的完整性.&lt;/p&gt;
&lt;p&gt;体现具体的例子就是, InnoDB里面对于一个简单的insert 操作, 其实是有非常多个mtr 组成, 尽可能减少持有锁的时间.&lt;/p&gt;
&lt;p&gt;但是在做btree 分裂操作的时候, 分配新的page, 将之前page一半的数据迁移到new page 是在一个mtr 里面完成, 但是后续具体的insert 操作是在另外一个mtr 里面完成的. 那么如果在做分裂操作过程中crash, 那么这个分裂操作是不会完成的, 如果在分裂操作完成以后, insert 之前crash, 那么btree 是已经分裂过的, 只是数据没有插入了.&lt;/p&gt;
&lt;p&gt;当然这里会有你说的更复杂的设计的父节点 and 父节点的父节点的分裂, 那么自然持有锁的时间就更长了, 但是在我们在这里是做的一些优化.&lt;/p&gt;
&lt;p&gt;还有一些比如InnoDB redo log 是&amp;quot;physical to a page, logical within a page&amp;quot; 就是解决我们上面说的如果分裂操作成功了, 但是这个事务要回滚, 这个时候该如何处理等等..&lt;/p&gt;
&lt;p&gt;具体的内容其实这些文章里面都有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C. Mohan, Don Handerle. ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging.&lt;/li&gt;
&lt;li&gt;C. Mohan, Frank Levine. ARIES/lM: An Efficient and High Concurrency index Management Method Using Write-Ahead Logging.&lt;/li&gt;
&lt;li&gt;Goetz Graefe. A Survey of B-Tree Logging and Recovery Techniques.&lt;/li&gt;
&lt;li&gt;Goetz Graefe. A Survey of B-Tree Locking Techniques.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对了Goetz Graefe 号称Btree 守护神&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1832563813/KwRpIxunM&#34;&gt;做InnoDB 这块&amp;hellip; - @ba0tiao的微博 - 微博&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ba0tiao&lt;/code&gt;应该是阿里云负责PolarDB开发的资深开发。&lt;/li&gt;
&lt;li&gt;他的博客是：&lt;a href=&#34;http://baotiao.github.io/&#34;&gt;baotiao&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏：&lt;a href=&#34;https://www.zhihu.com/column/360infra&#34;&gt;MySQL内核揭秘 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bohutang的回复&#34;&gt;BohuTANG的回复&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以深入一点：如果每次写的log都在，怎么做到基于这些log做回放的问题？其实就是redo-log +checkpoint+ LSM的机制。redo解决数据不丢，checkpoint解决recovery的时候扫描的redo尽量少，LSM解决每次写入后新的page不会覆盖老的数据，这类实现是比较简单可行，也是目前的主流做法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1691468715/KwT2GdDfu&#34;&gt;可以深入一点：如果每&amp;hellip; - @BohuTANG的微博 - 微博&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;以及：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前大部分理论都参考于这篇 ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging – Mohan et al. 1992&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1691468715/Kx3yAhFKj&#34;&gt;目前大部分理论都参考&amp;hellip; - @BohuTANG的微博 - 微博&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BohuTANG已经在数据库领域沉浸多年，前阿里云数据库内核组早期成员、前青云数据库团队负责人。现在数据库领域创业，公司的项目是：&lt;a href=&#34;https://github.com/datafuselabs/databend&#34;&gt;datafuselabs/databend&lt;/a&gt;，欢迎围观。&lt;/li&gt;
&lt;li&gt;博客地址：&lt;a href=&#34;https://bohutang.me/&#34;&gt;[ 虎哥的博客 ]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
