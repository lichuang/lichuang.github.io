<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nginx on codedump的网络日志</title>
    <link>https://www.codedump.info/tags/nginx/</link>
    <description>Recent content in nginx on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 01 May 2019 15:03:45 +0800</lastBuildDate><atom:link href="https://www.codedump.info/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OpenResty Lua Stream实现分析</title>
      <link>https://www.codedump.info/post/20190501-lua-stream/</link>
      <pubDate>Wed, 01 May 2019 15:03:45 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190501-lua-stream/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;OpenResty（以下简称OR）是Lua应用的典范，其最大的亮点在于，使用Lua协程搭配上异步非阻塞的IO，这样开发者可以使用同步方式来编写代码，而底层IO调度、唤醒等操作留给C编写的引擎层。&lt;/p&gt;
&lt;p&gt;实际上，使用类协程的技术，让异步操作同步化，已经有很多相关的技术了，比如腾讯的libco、百度的brpc都是自己在C层面实现了类协程的机制，不过这一类技术用的最广泛的还是OR。市面上分析OR内部实现的文章并不算很多，所以这段时间研究了一下OR的实现。&lt;/p&gt;
&lt;p&gt;OR内部，其实是分7层HTTP的ngx_lua模块，以及四层TCP的lua_stream实现，两者在很多部分都很相近，以下分析以4层的lua_stream来解释，对应的版本是openresty-1.13.6.1和ngx_stream_lua-0.0.3的实现。&lt;/p&gt;
&lt;p&gt;既然OR在这里选择了使用协程来将用户的异步操作同步化，那么实际上内部其实实现了一个简易版本的操作系统内核的“CPU调度”，其中一个一个的协程就是CPU调度单位，因此在这里分为几部分来分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护协程的数据结构。&lt;/li&gt;
&lt;li&gt;创建新协程的时候如何进行初始化？&lt;/li&gt;
&lt;li&gt;协程调度算法？&lt;/li&gt;
&lt;li&gt;如何将异步操作同步化？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，先列举出来OR中与“调度”相关的核心数据结构和函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;调度相关核心组件&lt;/th&gt;
&lt;th&gt;数据结构或函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;调度单元&lt;/td&gt;
&lt;td&gt;Lua协程（lua_State）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;保存协程信息&lt;/td&gt;
&lt;td&gt;ngx_stream_lua_co_ctx_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当前调度协程信息&lt;/td&gt;
&lt;td&gt;ngx_stream_lua_ctx_t.cur_co_ctx成员，指向一个ngx_stream_lua_co_ctx_t类型指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;调度函数&lt;/td&gt;
&lt;td&gt;ngx_stream_lua_run_thread&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;协程的维护&#34;&gt;协程的维护&lt;/h1&gt;
&lt;p&gt;OR中有以下两种场景能够创建出来一个协程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个tcp请求自动对应一个协程。这种场景用户不能控制，即默认就是这么实现的，当收到一个TCP请求默认创建出来一个协程与之绑定。&lt;/li&gt;
&lt;li&gt;Lua代码内部显示调用thread.spawn函数创建一个用户线程时。与前者不同，这种场景就是用户可以自己控制的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lua stream内部，协程相关的数据结构存储在ngx_stream_lua_co_ctx_t中，既然OR里面使用协程来模拟用户线程，不难想象这个数据结构内部应该有以下的成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护协程内部栈关系的数据。由于OR采用了Lua协程，这部分当然就是留给Lua协程来处理了。&lt;/li&gt;
&lt;li&gt;保存协程状态的数据。&lt;/li&gt;
&lt;li&gt;维护协程之间关系的数据，比如父子协程、僵尸子协程，等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单的看一下其成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void *data：存储用户相关数据。&lt;/li&gt;
&lt;li&gt;lua_State *co：存储Lua协程指针。&lt;/li&gt;
&lt;li&gt;ngx_stream_lua_co_ctx_t *parent_co_ctx：存储父协程指针。&lt;/li&gt;
&lt;li&gt;ngx_stream_lua_posted_thread_t *zombie_child_threads：将该协程管理的僵尸子进程放在这个队列中。&lt;/li&gt;
&lt;li&gt;int co_ref：在Lua的registry表中对应该协程指针的引用值。&lt;/li&gt;
&lt;li&gt;unsigned waited_by_parent：为1的情况下表示该协程的父协程在等待该协程的退出。&lt;/li&gt;
&lt;li&gt;unsigned co_status：当前协程状态。&lt;/li&gt;
&lt;li&gt;unsigned is_uthread：为1的情况下表示该协程是用户线程，即上面提到的场景2创建出来的协程。&lt;/li&gt;
&lt;li&gt;unsigned thread_spawn_yielded：为1的情况下表示当前协程是由于创建了用户线程（前面的场景2）才让出的执行权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/ngx_stream_lua_co_ctx_t.png&#34; alt=&#34;ngx_stream_lua_co_ctx_t&#34; title=&#34;ngx_stream_lua_co_ctx_t&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外，还有一个全局变量ngx_stream_lua_ctx_t，其中的cur_co_ctx指针指向当前被调度执行的ngx_stream_lua_co_ctx_t指针。&lt;/p&gt;
&lt;h1 id=&#34;协程的初始化&#34;&gt;协程的初始化&lt;/h1&gt;
&lt;p&gt;上一部分提到了创建协程的两种场景，这里就来分析这两种场景下面协程的初始化。&lt;/p&gt;
&lt;h2 id=&#34;新建立连接的协程&#34;&gt;新建立连接的协程&lt;/h2&gt;
&lt;p&gt;OR通过在nginx配置文件中填写&amp;quot;content_by_lua_block&amp;quot;等，来配置新建一个连接时对应的Lua脚本，这种场景下OR会默认创建出来一个Lua协程来执行这段脚本代码。&lt;/p&gt;
&lt;p&gt;对应创建Lua协程的代码在函数ngx_stream_lua_new_thread中，下面来分析这个函数的流程。&lt;/p&gt;
&lt;p&gt;OR中需要在Registry表中存储每个创建出来的Lua协程的reference，这个存储协程的表在Registry表中对应的key是全局变量ngx_stream_lua_coroutines_key的指针，因此下面这段代码就是从Registry表中查询这个表返回到栈顶：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lua_pushlightuserdata(L, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_stream_lua_coroutines_key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lua_rawget(L, LUA_REGISTRYINDEX);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着下来就是创建了一个新的协程，同时初始化其全局表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 创建Lua协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;co &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lua_newthread(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 创建该协程的全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_create_new_globals_table(co, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 再创建一个新表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_createtable(co, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_get_globals_table(co);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 全局表的__index指向新创建的表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_setfield(co, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;__index&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 全局表的meta table指向新创建的表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_setmetatable(co, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// set 全局表回去
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_set_globals_table(co);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的代码可以看出，新创建的协程，其全局表目前是一个空表。&lt;/p&gt;
&lt;p&gt;此时的Lua虚拟机栈顶情况如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/ngx_stream_lua_new_thread.png&#34; alt=&#34;ngx_stream_lua_new_thread&#34; title=&#34;ngx_stream_lua_new_thread&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于上面的第一步已经将Registry表中存储Lua协程的表压入了Lua栈顶，而此时新创建的协程也在栈上了，于是下面一步就是在Lua虚拟机中创建一个reference保存这个新创建的协程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ref &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; luaL_ref(L, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ref &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; LUA_NOREF) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    lua_settop(L, base);  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* restore main thread stack */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后恢复堆栈：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lua_settop(L, base);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上这些步骤，还只是创建一个什么都不能做的Lua协程，返回这个协程之后，还需要把入口函数放入到协程中，来看函数ngx_stream_lua_content_by_chunk接下来的工作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将lua虚拟机VM的入口closure move到新创建的协程上面，这样协程就有了虚拟机已经解析完毕的代码了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_xmove(L, co, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_get_globals_table(co);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 入口函数的环境表为全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_setfenv(co, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上工作将在配置中的Lua脚本解析之后的入口函数移动到新创建的Lua协程中，同时还配置了该入口函数的环境表为Lua协程的环境表。&lt;/p&gt;
&lt;p&gt;到了这里，协程已经创建出来并且有入口函数了，下面需要做的就是让它能运行起来，让调度器能够调度它运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存当协程执行环境中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;entry_co_ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; co;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_ref &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; co_ref;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ngxthreadspawn创建的协程&#34;&gt;ngx.thread.spawn创建的协程&lt;/h2&gt;
&lt;p&gt;OR中还有另一种场景也可以创建协程，在OR中这种情况被称为用户线程（user thread），对应的API是ngx.thread.spawn，其调用形式是这样的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ngx.thread.spawn(入口函数，[函数参数])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即第一个参数就是新创建的用户线程的入口函数，接下来如果还有参数的话就是传入到这个线程入口函数中的函数参数。&lt;/p&gt;
&lt;p&gt;ngx.thread.spawn对应的实现是函数ngx_stream_lua_uthread_spawn，接下来看这个函数的实现。&lt;/p&gt;
&lt;h3 id=&#34;ngx_stream_lua_coroutine_create_helper&#34;&gt;ngx_stream_lua_coroutine_create_helper&lt;/h3&gt;
&lt;p&gt;函数首先会调用ngx_stream_lua_coroutine_create_helper函数创建一个新的Lua协程，所以这里先看看这个函数。&lt;/p&gt;
&lt;p&gt;这里需要首先说明一点，前面在接收连接创建协程的场景中，新创建协程的父协程是Lua虚拟机（也就是Lua主线程），而在创建用户线程这个场景中，因为是在Lua代码中调用spawn创建用户线程的，所以在这里新创建的协程其父协程也是一个协程而不是Lua虚拟机。&lt;/p&gt;
&lt;p&gt;因此在ngx_stream_lua_coroutine_create_helper函数中，首先要做的就是拿到Lua虚拟机：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到进程的Lua虚拟机
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;vm &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_stream_lua_get_lua_vm(r, ctx);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是，在本函数中的以下三个lua_State*变量分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vm：进程级别的Lua虚拟机。&lt;/li&gt;
&lt;li&gt;L：父协程指针。&lt;/li&gt;
&lt;li&gt;co：新创建出来的协程指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而同样是因为这个用户线程是有父协程的，所以与前面新创建连接场景还有一点不同的是，它的出生环境并不是完全干净的，而是已经有了父协程的环境，因此紧跟着下来就是要把父协程的环境保存到新创建的协程中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* make new coroutine share globals of the parent coroutine.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * NOTE: globals don&amp;#39;t have to be separated! */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到父协程的全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_get_globals_table(L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 移动到新创建的协程co中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_xmove(L, co, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 写入新协程的全局表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_stream_lua_set_globals_table(co);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于创建新协程是在Lua虚拟机完成的，此时需要把它移动到父协程中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将新创建的协程从进程虚拟机，移动到父协程中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_xmove(vm, L, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* move coroutine from main thread to L */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;紧跟着就是将父协程的入口函数移动到新创建的协程了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将父协程L的入口函数压入栈中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_pushvalue(L, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* copy entry function to top of L*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 移动到新创建的协程中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_xmove(L, co, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* move entry function from L to co */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;初始化uthread&#34;&gt;初始化uthread&lt;/h3&gt;
&lt;p&gt;以上已经分析了ngx_stream_lua_coroutine_create_helper函数的实现了， 可以看到，ngx_stream_lua_coroutine_create_helper调用返回之后，父协程L是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L栈顶是新创建的协程指针。&lt;/li&gt;
&lt;li&gt;协程的入口函数从父协程L中拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着继续分析ngx_stream_lua_uthread_spawn的实现了。&lt;/p&gt;
&lt;p&gt;以上只是创建了协程，同时协程入口函数还是父协程的，而不是ngx.thread.spawn函数传入的，因此接下来就是将真正的用户线程入口函数以及参数传递给协程。&lt;/p&gt;
&lt;p&gt;不过在此之前，仍然是在registry表中保存一个该协程的reference：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* anchor the newly created coroutine into the Lua registry */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 把新创建的协程写入Lua registry表中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将ngx_stream_lua_coroutines_key的地址压入栈中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_pushlightuserdata(L, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_stream_lua_coroutines_key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 从registry表中查询该地址，registry表中该地址对应的一个数组，用于存储coroutine的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lua_rawget(L, LUA_REGISTRYINDEX);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 此时栈顶是查询返回的值，即ngx_stream_lua_coroutines_key对应的数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 栈顶-1位置是新协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 压入协程的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_pushvalue(L, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// -2位置目前是前面那个表了，于是这里得到了这个coroutine在表中的索引值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_ref &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; luaL_ref(L, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 栈顶位置：存储协程的表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 栈顶位置 - 1：协程值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 因此下面的操作弹出这个表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_pop(L, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;紧跟着就是初始化运行环境了：&lt;/p&gt;
&lt;p&gt;下面这一段代码，首先调用lua_replace函数将入口函数移动到栈顶，然后将传入ngx.thread.spawn函数的参数中，除去第一个线程入口函数之外的其他参数移动到新创建协程中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/ngx.thread.spawn.png&#34; alt=&#34;ngx.thread.spawn&#34; title=&#34;ngx.thread.spawn&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 由于lua函数压栈顺序是从左到右
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 因此base位置的就是压入的第一个参数，而spawn的第一个参数就是入口函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 所以这里的工作，就是把线程入口函数移动到栈顶
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    lua_replace(L, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将L栈顶的元素移动到协程中，这一步就是把除去线程入口函数的其他参数移动到新创建的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    lua_xmove(L, coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co, n &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来设置协程上下文之间的父子关系，同时将新创建的协程变成下一步被调度执行的协程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 保存用户线程的父协程上下文为当前协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;parent_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 切换当前协程为新创建的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; coctx;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，由于ngx.thread.spawn函数返回的参数是创建好的协程，因此最后返回创建好的协程:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将原协程的执行权切换出去，这里的参数1是新创建的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 也就是说，这里返回新创建的协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;lua_yield&lt;/span&gt;(L, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;协程的调度&#34;&gt;协程的调度&lt;/h1&gt;
&lt;p&gt;以上讲解了两种创建协程的场景，现在来分析协程的调度，调度集中在函数ngx_stream_lua_run_thread，下面来分析这个函数的实现。&lt;/p&gt;
&lt;p&gt;协程的调度主要依赖于ngx_stream_lua_ctx_t的cur_co_ctx指针，调度时就是从这个指针中拿到待调度的Lua协程，然后执行lua_resume函数来调度协程运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/ngx_stream_lua_run_thread-main.png&#34; alt=&#34;ngx_stream_lua_run_thread-main&#34; title=&#34;ngx_stream_lua_run_thread-main&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;异常保护&#34;&gt;异常保护&lt;/h2&gt;
&lt;p&gt;对于一个“内核”而言，哪怕是再简陋，其也应该做到：无论被调度的程序出现了什么错误，都应该影响整个系统的继续运行，而应该在出错的时候将出错信息打印出来。&lt;/p&gt;
&lt;p&gt;所以在ngx_stream_lua_run_thread内部，就做了这样的异常保护，用一个宏封装的setjmp、longjmp包住了协程的调度执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 注册vm panic回调函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_atpanic(L, ngx_stream_lua_atpanic);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NGX_LUA_EXCEPTION_TRY &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* setjmp保存环境 */&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 调度执行协程代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;} NGX_LUA_EXCEPTION_CATCH {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  dd(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;nginx execution restored&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;vm panic的回调函数ngx_stream_lua_atpanic如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_stream_lua_atpanic&lt;/span&gt;(lua_State &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;L)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#ifdef NGX_LUA_ABORT_AT_PANIC
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;  abort();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;  u_char                  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;s &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  size_t                   len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (lua_type(L, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; LUA_TSTRING) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (u_char &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) lua_tolstring(L, &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (s &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (u_char &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;unknown reason&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;unknown reason&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_log_stderr(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;lua atpanic: Lua VM crashed, reason: %*s&amp;#34;&lt;/span&gt;, len, s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_quit &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*  restore nginx execution */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_LUA_EXCEPTION_THROW(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* impossible to reach here */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，vm panic的回调函数做的事情无非就是两件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打印出错信息。&lt;/li&gt;
&lt;li&gt;调用NGX_LUA_EXCEPTION_THROW恢复异常堆栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，这几个宏的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define NGX_LUA_EXCEPTION_TRY                                               \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;    if (setjmp(ngx_stream_lua_exception) == 0)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define NGX_LUA_EXCEPTION_CATCH                                             \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;    else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define NGX_LUA_EXCEPTION_THROW(x)                                          \
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;    longjmp(ngx_stream_lua_exception, (x))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;调度核心&#34;&gt;调度核心&lt;/h2&gt;
&lt;p&gt;接下来看协程调度的核心代码，也就是前面异常保护包住的那部分代码。&lt;/p&gt;
&lt;p&gt;主要分为如图的几种情况:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/ngx_stream_lua_run_thread.png&#34; alt=&#34;ngx_stream_lua_run_thread&#34; title=&#34;ngx_stream_lua_run_thread&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;lua_yield&#34;&gt;LUA_YIELD&lt;/h3&gt;
&lt;p&gt;lua通过lua_resume函数来执行一个协程的代码，大部分时候这个函数的返回值是LUA_YIELD，即协程让出了执行权。而让出执行权，又有以下几种可能的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待IO，比如要读4字节的数据，而现在并没有这么多数据可读，于是这个协程只能让出执行权，等满足条件之后再被触发调用。&lt;/li&gt;
&lt;li&gt;协程内部调用了ngx.thread.spawn函数，这时候做为父协程也会让出执行权给新创建的子协程执行。&lt;/li&gt;
&lt;li&gt;Lua代码调用了coroutine.resume。&lt;/li&gt;
&lt;li&gt;Lua代码调用了coroutine.yield。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下就这几种情况逐一进行分析。&lt;/p&gt;
&lt;h4 id=&#34;等待io场景&#34;&gt;等待IO场景&lt;/h4&gt;
&lt;p&gt;OR中等待IO的场景很多，不可能逐一分析完毕，但是背后的原理其实差不多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录下来IO被触发的条件，等待被唤醒IO之时判断是否满足条件。&lt;/li&gt;
&lt;li&gt;如果满足条件，将该协程上下文对象保存到ngx_stream_lua_ctx_t-&amp;gt;cur_co_ctx中，等待下一次调用ngx_stream_lua_run_thread时被调度执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以ngx.socker.tcp.receive函数为例，这个函数的实现是ngx_stream_lua_socket_tcp_receive函数。&lt;/p&gt;
&lt;p&gt;由于这个API是创建出一个向后端upstream的连接，所以有一个对应的ngx_stream_lua_socket_tcp_upstream_t与之对应。因此这里的做法就是在这个upstream中记录下来下次被触发时的一些状态参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;input_filter &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_stream_lua_socket_read_chunk;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;length &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (size_t) bytes;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;rest &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;length;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的u就是ngx_stream_lua_socket_tcp_upstream_t指针，在这里设置了input_filter回调函数，在下一次IO被触发回调时自然会走到这个函数，另外rest成员中保存了这次调用receive函数传入的长度，而在ngx_stream_lua_socket_read_chunk函数中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (bytes &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;=&lt;/span&gt; (ssize_t) u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;rest) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;buf_in&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;buf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;last &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;rest;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt; u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;rest;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    u&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;rest &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即只要当前读入缓冲区的数据比上一次保存的rest大，说明满足唤醒这个协程的条件，返回NGX_OK。&lt;/p&gt;
&lt;p&gt;在函数ngx_stream_lua_socket_tcp_read中，当input_filter返回NGX_OK时，会调用ngx_stream_lua_socket_handle_read_success，这里将协程上下文的ngx_stream_lua_co_ctx_t指针保存到ngx_stream_lua_ctx_t-&amp;gt;cur_co_ctx中，这样下一次调用ngx_stream_lua_run_thread就会以这个协程来进行调度。&lt;/p&gt;
&lt;h4 id=&#34;父协程出让执行权场景&#34;&gt;父协程出让执行权场景&lt;/h4&gt;
&lt;p&gt;父协程在调用ngx.thread.spawn创建出子协程之后，就让出了执行权，这一点在前面分析ngx.thread.spawn函数已经提到过了。&lt;/p&gt;
&lt;p&gt;由于ngx.thread.spawn函数的返回值是新创建的协程，因此此时拿到父协程传递进来的线程参数，继续下一次lua_resume执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;NGX_STREAM_LUA_USER_THREAD_RESUME&lt;/span&gt;: &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// lua代码中创建了用户线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_log_debug0(NGX_LOG_DEBUG_STREAM, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;connection&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;log, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;lua user thread resume&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 设置为NGX_STREAM_LUA_USER_CORO_NOP
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_op &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; NGX_STREAM_LUA_USER_CORO_NOP;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 此时的ctx-&amp;gt;cur_co_ctx-&amp;gt;co是由thread.spawn创建的用户线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下这里得到传入这个用户线程的函数参数数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// -1是因为传入thread.spawn的第一个参数是线程入口函数，因此要略过这个参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  nrets &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lua_gettop(ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  dd(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;nrets = %d&amp;#34;&lt;/span&gt;, nrets);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// break意味着下一次循环继续执行resume操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;hook系统协程库&#34;&gt;hook系统协程库&lt;/h4&gt;
&lt;p&gt;OR中为了对协程切换的完全掌控，也将系统的coroutine.resume以及coroutine.yield两个函数进行了hook，换成了自己的实现。&lt;/p&gt;
&lt;h5 id=&#34;luaresume&#34;&gt;lua.resume&lt;/h5&gt;
&lt;p&gt;其中resume函数的实现对应的是函数ngx_stream_lua_coroutine_resume，该函数的核心工作有以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿到协程切换时当前的协程上下文指针p_coctx。&lt;/li&gt;
&lt;li&gt;拿到待切换执行权的协程上下文指针coctx。&lt;/li&gt;
&lt;li&gt;设置两者的父子关系：coctx-&amp;gt;parent_co_ctx = p_coctx;&lt;/li&gt;
&lt;li&gt;修改当前的协程上下文指针为coctx，这样在下一次调度时就会执行该协程。&lt;/li&gt;
&lt;li&gt;让出执行权给主线程，在那里做resume coroutine的操作，注意此时调用lua_yield函数时传入的参数是lua_gettop(L) - 1，是为了跳过栈顶的协程参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到当前协程上下文的指针做为父指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;p_coctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到待resume协程的ngx_stream_lua_co_ctx_t指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_stream_lua_get_co_ctx(co, ctx);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 待resume协程的父协程上下文修改为当前协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;parent_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; p_coctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 待resume协程状态修改为running
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; NGX_STREAM_LUA_CO_RUNNING;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 修改op操作为NGX_STREAM_LUA_USER_CORO_RESUME
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_op &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; NGX_STREAM_LUA_USER_CORO_RESUME;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 修改当前协程上下文指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; coctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* yield and pass args to main thread, and resume target coroutine from
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * there */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 让出执行权给主线程，在那里做resume coroutine的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;lua_yield&lt;/span&gt;(L, lua_gettop(L) &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/lua_resume.png&#34; alt=&#34;lua_resume&#34; title=&#34;lua_resume&#34;&gt;&lt;/p&gt;
&lt;p&gt;而这种由于Lua脚本中调用了lua_resume函数让出执行权的情况，对应的co_op就是NGX_STREAM_LUA_USER_CORO_RESUME，此时在ngx_stream_lua_run_thread函数中的处理就是将父协程的参数移动到子协程中，即将函数参数从上面的p_coctx移动到coctx管理的协程中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nrets &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lua_gettop(old_co);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (nrets) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  dd(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;moving %d return values to parent&amp;#34;&lt;/span&gt;, nrets);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 移动协程resume函数的参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  lua_xmove(old_co, ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co, nrets);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;luayield&#34;&gt;lua.yield&lt;/h5&gt;
&lt;p&gt;lua.yield函数对应的实现是函数ngx_stream_lua_coroutine_yield，该函数的实现相对就简单很多：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到当前运行的协程上下文指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;coctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 修改co_op
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_op &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; NGX_STREAM_LUA_USER_CORO_YIELD;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 让出执行权给主线程，在那里做yield coroutine操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;lua_yield&lt;/span&gt;(L, lua_gettop(L));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况对应的co_op值为NGX_STREAM_LUA_USER_CORO_YIELD，来看ngx_stream_lua_run_thread函数针对这种情况的处理。&lt;/p&gt;
&lt;p&gt;首先判断调用lua.yield让出执行权的是不是用户线程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ngx_stream_lua_is_thread(ctx)) {    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果ctx是用户线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* discard any return values from user
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;     * coroutine.yield()&amp;#39;s arguments */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这里将yield的参数全都抛弃掉
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    lua_settop(ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_stream_lua_probe_info(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;set co running&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co_status &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; NGX_STREAM_LUA_CO_RUNNING;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;posted_threads) {  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果有post线程队列，说明有pending的线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 加入到posted_threads中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        ngx_stream_lua_post_thread(r, ctx, ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 置当前协程上下文指针为NULL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回等待下一次被唤醒调度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* no pending threads, so resume the thread
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;     * immediately */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到了这里说明没有pending的线程，继续下一次调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    nrets &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来处理当前协程不是用户线程的场景：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到了这里意味着当前协程不是用户线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* being a user coroutine that has a parent */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到栈顶数据数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;nrets &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lua_gettop(ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 拿到父协程上下文
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;next_coctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;parent_co_ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;next_co &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; next_coctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * prepare return values for coroutine.resume
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; * (true plus any retvals)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// push到父协程中一个bool数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;lua_pushboolean(next_co, &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (nrets) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dd(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;moving %d return values to next co&amp;#34;&lt;/span&gt;, nrets);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将返回值move到父协程中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    lua_xmove(ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;co, next_co, nrets);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// +1是为了多加上bool值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;nrets&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* add the true boolean value */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 下一次调度切换到父协程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ctx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cur_co_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; next_coctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190501-lua-stream/lua_yield.png&#34; alt=&#34;lua_yield&#34; title=&#34;lua_yield&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;协程执行完毕的情况&#34;&gt;协程执行完毕的情况&lt;/h3&gt;
&lt;p&gt;以上分析了协程执行lua_resume之后返回值为LUA_YIELD的几种情况，如果此时返回值不是LUA_YIELD而是0，这意味着协程已经执行完毕了，下面看这种情况的处理。&lt;/p&gt;
&lt;p&gt;如果当前协程是入口线程，那么将做如下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复Lua栈。&lt;/li&gt;
&lt;li&gt;如果还有待执行的用户线程，那么置当前协程上下文指针cur_co_ctx为NULL，返回NGX_AGAIN，等待下一次被唤醒。&lt;/li&gt;
&lt;li&gt;否则意味着没有可执行的线程了，返回NGX_OK。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而如果当前协程是用户线程，那么做如下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复Lua栈。&lt;/li&gt;
&lt;li&gt;拿到当前协程的父协程，如果父协程还存活的情况下：
&lt;ul&gt;
&lt;li&gt;如果父协程在等待该协程的退出，那么向父协程返回true。&lt;/li&gt;
&lt;li&gt;否则说明该协程变成了僵尸，返回NGX_AGAIN。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;否则就是父协程已经不存活的情况：
&lt;ul&gt;
&lt;li&gt;用户线程数量减一。&lt;/li&gt;
&lt;li&gt;如果用户线程数量在减一之后变成了0，意味着当前已经没有可执行的用户线程了，如果当前入口线程还存活，那么置当前协程上下文指针cur_co_ctx为NULL，返回NGX_AGAIN，等待下一次被唤醒。否则返回NGX_OK。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一种情况就是该协程既不是入口线程也不是用户线程的场景了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿到父协程指针，如果父协程指针为空则报错返回。&lt;/li&gt;
&lt;li&gt;移动参数到父协程中，切换当前协程上下文指针cur_co_ctx指向父协程，继续下一次循环的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;执行出错的情况&#34;&gt;执行出错的情况&lt;/h3&gt;
&lt;p&gt;除了以上几种情况，最后剩下的就是协程代码执行出错的场景了，此时的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复cur_co_ctx。&lt;/li&gt;
&lt;li&gt;从Lua栈中拿到出错信息。&lt;/li&gt;
&lt;li&gt;拿到协程栈信息。&lt;/li&gt;
&lt;li&gt;如果是用户线程：
&lt;ul&gt;
&lt;li&gt;恢复Lua栈。&lt;/li&gt;
&lt;li&gt;拿到父协程指针，如果父协程还存活，做以下处理：
&lt;ul&gt;
&lt;li&gt;如果父协程在等待该协程的退出，那么向父协程返回false。&lt;/li&gt;
&lt;li&gt;否则将当前协程加入到父协程的僵尸线程链表中。&lt;/li&gt;
&lt;li&gt;置空当前协程上下文指针，返回NGX_AGAIN。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果用户线程数量为0，且入口线程还存活，那么置当前协程上下文指针cur_co_ctx为NULL，返回NGX_AGAIN。否则返回NGX_OK。&lt;/li&gt;
&lt;li&gt;如果是入口线程，则打印出错信息，恢复Lua栈，返回服务器出错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-内存池的设计</title>
      <link>https://www.codedump.info/post/20190214-nginx-memory-pool/</link>
      <pubDate>Thu, 14 Feb 2019 14:48:24 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190214-nginx-memory-pool/</guid>
      
      <description>&lt;p&gt;nginx中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放回收内存，内存池的生命周期与请求一样，请求完毕则直接回收内存。这样的好处在于：统一分配和统一释放，降低了内存泄露问题的出现。&lt;/p&gt;
&lt;p&gt;nginx的内存池设计的比较简单了，一个内存池中分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超过max大小的内存分配，走大块内存分配，这部分内存管理由ngx_pool_large_t结构体负责。&lt;/li&gt;
&lt;li&gt;否则就是在ngx_pool_t遍历符合要求的ngx_pool_t结构体，找到符合要求大小的pool直接返回，否则就申请一块新的内存pool。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ngx_pool_data_t&#34;&gt;ngx_pool_data_t&lt;/h1&gt;
&lt;p&gt;先来看结构体ngx_pool_data_t，它存储每个ngx_pool_t结构体的meta元数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;u_char *last：指向分配空间的可用空间。&lt;/li&gt;
&lt;li&gt;u_char *end：指向分配空间的最后位置。&lt;/li&gt;
&lt;li&gt;ngx_pool_t *next：指向下一个ngx_pool_t指针。&lt;/li&gt;
&lt;li&gt;ngx_uint_t failed：存储本ngx_pool_t结构体分配失败次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190214-nginx-memory-pool/ngx_pool_data_t.png&#34; alt=&#34;ngx_pool_data_t&#34; title=&#34;ngx_pool_data_t&#34;&gt;&lt;/p&gt;
&lt;p&gt;failed成员的引入是为了避免某个pool虽然还有可用的空间，但是由于空间很小了所以经常性的分配空间失败，当累计失败的次数达到某个阈值时，下一次再次查找内存就直接跳过这个pool，而去寻找内存池链表中的下一个pool。&lt;/p&gt;
&lt;h1 id=&#34;ngx_pool_large_t&#34;&gt;ngx_pool_large_t&lt;/h1&gt;
&lt;p&gt;ngx_pool_large_t结构体用于保存大内存块，这一块就比较简单粗暴了，直接分配一块大内存来使用。另外，多个大内存块之间也是以链表形式来组织数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 管理超大空间的结构体
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; ngx_pool_large_s {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 指向下一个指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_pool_large_t     &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 直接指向内存区域的指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;                 &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;alloc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;ngx_pool_t&#34;&gt;ngx_pool_t&lt;/h1&gt;
&lt;p&gt;再来看ngx_pool_t结构体，该数据结构用于表示一个内存池，内存池内部以链表形式来组织数据。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190214-nginx-memory-pool/ngx_pool_t.png&#34; alt=&#34;ngx_pool_t&#34; title=&#34;ngx_pool_t&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存池内部以链表形式组织起来，完成这个工作的就是前面的ngx_pool_data_t的next成员。&lt;/li&gt;
&lt;li&gt;current指针，用于表示当前该内存池在使用的pool指针。除了内存池链表的头结点之外，内存池链表其他节点的该指针无效。之所以需要这个指针，就是前面提到的，在某个内存池多次失效的情况下，下一次直接跳过该内存池查找空间，current指针保存当前在内存池链表的哪一个内存池上面查找空间。&lt;/li&gt;
&lt;li&gt;large指针，指向ngx_pool_large_t结构体，管理大块内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上数据结构的了解，从内存池分配内存的流程就很简单了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190214-nginx-memory-pool/memory-pool.png&#34; alt=&#34;memory-pool&#34; title=&#34;memory-pool&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-处理HTTP请求</title>
      <link>https://www.codedump.info/post/20190213-nginx-process-http-request/</link>
      <pubDate>Wed, 13 Feb 2019 09:09:19 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190213-nginx-process-http-request/</guid>
      
      <description>&lt;p&gt;前面分析了nginx&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-read-http-request/&#34;&gt;如何读取一个HTTP请求&lt;/a&gt;、&lt;a href=&#34;https://www.codedump.info/post/20190212-nginx-http-config/&#34;&gt;如何查询到HTTP对应的配置&lt;/a&gt;，本节分析如何处理HTTP请求。&lt;/p&gt;
&lt;h1 id=&#34;处理http请求的11个阶段&#34;&gt;处理HTTP请求的11个阶段&lt;/h1&gt;
&lt;p&gt;nginx将处理HTTP请求划分为了11个阶段，原因在于nginx是一个重度模块化的系统，划分为不同阶段以后，不同的模块可以根据自己的需求在相应的模块中添加自己的处理函数。&lt;/p&gt;
&lt;p&gt;简单看看这11个模块的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;enum&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在接收到完整的HTTP头部后处理的HTTP阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_POST_READ_PHASE &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在将请求的URI与location表达式匹配前，修改请求的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// URI（所谓的重定向）是一个独立的HTTP阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_SERVER_REWRITE_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 根据请求的URL寻找匹配的location表达式，这个阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 只能由ngx_http_core_module模块实现，不建议其他HTTP
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 模块模块重新定义这一阶段的行为
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_FIND_CONFIG_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在NGX_HTTP_FIND_CONFIG_PHASE阶段寻找到匹配的location
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 之后再修改请求的URI
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_REWRITE_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这一阶段用于在rewrite重写URL后，防止错误的nginx配置导致
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 死循环（递归地修改URI），因此，这一阶段仅由ngx_http_core_module
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 模块处理。目前，控制死循环的方法就是看rewrite次数，超过一定阈值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 就认为出现了死循环，返回500
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_POST_REWRITE_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 表示在处理NGX_HTTP_ACCESS_PHASE阶段决定请求的访问权限前，HTTP模块可以介入的处理阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_PREACCESS_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这个阶段用于让HTTP模块判断是否允许这个请求访问Nginx服务器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_ACCESS_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 在NGX_HTTP_ACCESS_PHASE阶段中，当HTTP模块的handler处理函数返回不允许访问的错误码时（
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 实际就是NGX_HTTP_FORBIDDEN或者NGX_HTTP_UNAUTHORIZED），这里将负责向用户发送拒绝服务的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 错误响应，因此这个阶段实际上用于给NGX_HTTP_ACCESS_PHASE阶段收尾
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_POST_ACCESS_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这个阶段完全为try_files配置项而设立的，当HTTP访问静态文件资源时，try_files配置项可以
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 使这个请求顺序地访问多个静态文件资源，如果某一次访问失败，则继续访问try_files中指定的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 下一个静态资源。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_PRECONTENT_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 用于处理HTTP请求内容的阶段，这是大部分HTTP模块最愿意介入的阶段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_CONTENT_PHASE,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理完请求记录日志的阶段。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  NGX_HTTP_LOG_PHASE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_http_phases;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这11个阶段里，有一些是可以由模块开发者插入自己的处理函数，有一些只能使用nginx的http框架的实现。另外，每个阶段并不是一定只能有一个处理函数，有的可以提供多个处理函数，在同一个阶段中顺序被调用。&lt;/p&gt;
&lt;h2 id=&#34;核心数据结构&#34;&gt;核心数据结构&lt;/h2&gt;
&lt;h3 id=&#34;ngx_http_phase_handler_t&#34;&gt;ngx_http_phase_handler_t&lt;/h3&gt;
&lt;p&gt;定义每阶段相关的处理方法，在数据结构ngx_http_phase_handler_t中，包括以下成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_phase_handler_pt checker：在处理任何一个HTTP阶段的时候，HTTP框架将会在checker方法已经实现的情况下首先调用该方法来处理请求。这种情况下不是直接调用handler方法，而是在checker中间接调用handler方法。但是所有的checker方法都是由框架中的ngx_http_core_module模块实现的，普通的HTTP模块无法重定义checker方法。&lt;/li&gt;
&lt;li&gt;ngx_http_handler_pt handler：定义处理某阶段HTTP请求的回调函数。&lt;/li&gt;
&lt;li&gt;ngx_uint_t next：将要执行的下一个HTTP处理阶段的索引。有了这个索引值，阶段的执行不见得一定得按照顺序来，可以向前或者向后跳转阶段来处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ngx_http_phase_engine_t&#34;&gt;ngx_http_phase_engine_t&lt;/h3&gt;
&lt;p&gt;ngx_http_phase_engine_t结构体用于保存所有ngx_http_phase_handler_t组成的数组，其成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_phase_handler_t  *handlers：存放handler的数组。&lt;/li&gt;
&lt;li&gt;ngx_uint_t server_rewrite_index：表示NGX_HTTP_SERVER_REWRITE_PHASE阶段第一个handler处理方法在handlers数组中的索引，用于在执行HTTP请求的任何阶段快速跳转到NGX_HTTP_SERVER_REWRITE_PHASE阶段处理请求。&lt;/li&gt;
&lt;li&gt;ngx_uint_t location_rewrite_index：表示NGX_HTTP_REWRITE_PHASE阶段第一个处理方法在handlers数组中的索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ngx_http_core_main_conf_t中与http阶段相关的成员&#34;&gt;ngx_http_core_main_conf_t中与HTTP阶段相关的成员&lt;/h3&gt;
&lt;p&gt;在ngx_http_core_main_conf_t结构体中，与HTTP处理阶段相关的成员有如下两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_phase_engine_t phase_engine：控制运行过程中一个HTTP请求所要经过的HTTP处理阶段，将配合ngx_http_request结构体中的phase_handler成员使用。&lt;/li&gt;
&lt;li&gt;ngx_http_phase_t phases[NGX_HTTP_LOG_PHASE + 1]：用于在HTTP框架初始化时帮助各个HTTP模块在任意阶段中添加HTTP处理方法，由11个成员组成（因为有11个HTTP阶段）的数组，其中每个成员对应一个HTTP阶段。在HTTP框架初始化完毕之后，运行过程中的phases数组是无用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而ngx_http_phase_t结构体实际上就是一个存放handler的数组：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_array_t                handlers;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_http_phase_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ngx_http_core_main_conf_t.phases数组，仅在启动时用于保存初始化注册进来的handler只用，是一个”静态“的数据，后续不会再做变动了。&lt;/p&gt;
&lt;h2 id=&#34;核心流程&#34;&gt;核心流程&lt;/h2&gt;
&lt;p&gt;介绍完处理HTTP请求相关的核心数据结构，现在回到处理HTTP请求的流程分析中。&lt;/p&gt;
&lt;p&gt;在前面&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-read-http-request/&#34;&gt;分析读HTTP请求&lt;/a&gt;部分，提到过当读取完毕HTTP请求，nginx将进入到ngx_http_process_request函数正式开始处理HTTP请求。&lt;/p&gt;
&lt;p&gt;由于到这里已经读取完毕HTTP的请求行以及header，所以不再有状态机机制，来看看这部分的核心流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于已经读取完毕HTTP请求行以及HTTP头部数据，此时不再存在接收HTTP请求头超时的问题，因此需要将读事件的定时器删除。&lt;/li&gt;
&lt;li&gt;由于也不再需要继续读取HTTP请求行以及头部，因此重新设置当前连接的读、写事件回调函数为ngx_http_request_handler。&lt;/li&gt;
&lt;li&gt;将ngx_http_request_t结构体的read_event_handler回调函数设置为ngx_http_block_reading，这个函数实际上并不做任何事情。可以理解为：在当前HTTP请求没有处理结束之前，即使再次有读事件被触发，也不做任何处理，实际上相当于读事件被阻塞了。&lt;/li&gt;
&lt;li&gt;接下来调用ngx_http_handler函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看ngx_http_handler函数的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查ngx_http_request_t结构体的internal标志位，区分以下情况：
&lt;ul&gt;
&lt;li&gt;0：表示不需要重定向，设置ngx_http_request_t.phase_handler为0，表示从ngx_http_phase_engine_t指定数组的第一个回调方法开始执行。&lt;/li&gt;
&lt;li&gt;1：表示需要重定向，设置ngx_http_request_t.phase_handler为phase_engine.server_rewrite_index，server_rewrite_index索引保存的是handler数组中NGX_HTTP_REWRITE_PHASE处理阶段的第一个handler回调函数。phase_handler保存着将要执行的handlers数组中的索引，因此通过修改这个索引值，可以实现HTTP处理阶段的跳转。这里将这个索引值切换为NGX_HTTP_REWRITE_PHASE，意味着无论当前在哪个阶段，都将重新回到NGX_HTTP_REWRITE_PHASE阶段开始再次执行。这是nginx代码中实现请求可以反复rewrite重定向的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将ngx_http_request_t.write_event_handler设置为ngx_http_core_run_phases。&lt;/li&gt;
&lt;li&gt;调用ngx_http_core_run_phases函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终于来到与HTTP不同阶段处理流程相关的函数ngx_http_core_run_phases了，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_http_core_run_phases&lt;/span&gt;(ngx_http_request_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;r)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t                   rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_phase_handler_t   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ph;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_main_conf_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cmcf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cmcf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_get_module_main_conf(r, ngx_http_core_module);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ph &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cmcf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_engine.handlers;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt; (ph[r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler].checker) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ph[r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler].checker(r, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ph[r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_OK) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到该函数的核心流程就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据当前phase_handler索引，取出checker（如果存在的话）进行调用。&lt;/li&gt;
&lt;li&gt;返回值为非NGX_OK，意味着将继续向下执行phase_engine的各处理函数；&lt;/li&gt;
&lt;li&gt;反之，checker方法返回NGX_OK的时候，意味着控制权交还给nginx的事件模块，等待被IO事件唤醒时再次被触发调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;处理http请求的11个阶段-1&#34;&gt;处理HTTP请求的11个阶段&lt;/h2&gt;
&lt;p&gt;下面具体看处理HTTP请求的11个阶段。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HTTP阶段&lt;/th&gt;
&lt;th&gt;checker&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_POST_READ_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_generic_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_SERVER_REWRITE_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_rewrite_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_FIND_CONFIG_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_find_config_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_REWRITE_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_rewrite_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_POST_REWRITE_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_post_rewrite_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_PREACCESS_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_generic_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_ACCESS_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_access_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_POST_ACCESS_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_post_access_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_TRY_FILES_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_try_files_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_CONTENT_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_content_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NGX_HTTP_LOG_PHASE&lt;/td&gt;
&lt;td&gt;ngx_http_core_generic_phase&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ngx_http_post_read_phase可添加自定义http模块&#34;&gt;NGX_HTTP_POST_READ_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;接收完毕HTTP请求头之后的第一个阶段，任何需要在接收完毕请求HTTP头之后添加处理的模块都可以放到这个阶段来。 当前realip模块就是在这个阶段，用于获取客户端的真是IP地址。&lt;/p&gt;
&lt;p&gt;本阶段的checker函数是ngx_http_core_generic_phase，该函数也是是NGX_HTTP_POST_READ_PHASE、NGX_HTTP_PREACCESS_PHASE、NGX_HTTP_LOG_PHASE三个阶段的checker函数，根据调用handler的返回值，有以下的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NGX_OK：执行下一个HTTP阶段的handler函数，跳过本阶段的下一个handler。&lt;/li&gt;
&lt;li&gt;NGX_DECLINED：按照注册顺序执行本阶段下一个handler函数。&lt;/li&gt;
&lt;li&gt;NGX_AGAIN：当前阶段的handler尚未处理结束，将控制权返回事件模块，等待下一次被事件触发再次被调用。&lt;/li&gt;
&lt;li&gt;NGX_DONE：同NGX_AGAIN。&lt;/li&gt;
&lt;li&gt;NGX_ERROR：调用ngx_http_finalize_request结束请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ngx_http_server_rewrite_phase可添加自定义http模块&#34;&gt;NGX_HTTP_SERVER_REWRITE_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;server级别的URI重写阶段。在使用URI匹配location配置之前，修改URI用于重定向。
本阶段的checker函数为ngx_http_core_rewrite_phase，是NGX_HTTP_SERVER_REWRITE_PHASE和NGX_HTTP_REWRITE_PHASE的checker函数，根据handler返回值有以下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NGX_DECLINED：递增phase_handler跳到下一个回调方法，并且返回NGX_AGAIN，因为返回的不是NGX_OK，因此HTTP框架不会把控制权返回给事件框架，而是马上执行下一个handler。&lt;/li&gt;
&lt;li&gt;NGX_DONE：意味着handler无法在一次调度中处理完这个阶段，此时返回NGX_OK，等待被事件框架再一次唤醒执行。&lt;/li&gt;
&lt;li&gt;其他情况：调用ngx_http_finalize_request结束请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，ngx_http_core_generic_phase与ngx_http_core_rewrite_phase的区别在于：后者永远不会跨越同一个HTTP阶段的其他处理方法，就直接跳到下一个阶段来处理请求。原因在于：许多HTTP模块在NGX_HTTP_SERVER_REWRITE_PHASE和NGX_HTTP_REWRITE_PHASE同时处理URL重写这样的业务，HTTP框架认为这两个阶段的HTTP模块是完全平等的，序号靠前的HTTP模块并不优先级更高，不能决定后续模块是否被调用。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_find_config_phase不可添加自定义http模块&#34;&gt;NGX_HTTP_FIND_CONFIG_PHASE（不可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;用于根据URI查询匹配的location表达式。
参看前面的&lt;a href=&#34;https://www.codedump.info/post/20190212-nginx-http-config/#%E6%A0%B9%E6%8D%AEuri%E6%9F%A5%E6%89%BElocation%E5%9D%97%E6%B5%81%E7%A8%8B&#34;&gt;根据URI查询location一节内容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是：一次请求可能会多次来到该阶段，因为被rewrite之后的请求需要重新查找location。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_rewrite_phase可添加自定义http模块&#34;&gt;NGX_HTTP_REWRITE_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;location级别URI重写阶段，该阶段执行location级别的重写指令，有可能导致重新回到上面的NGX_HTTP_FIND_CONFIG_PHASE阶段。
checker函数同上面的NGX_HTTP_SERVER_REWRITE_PHASE阶段。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_post_rewrite_phase不可添加自定义http模块&#34;&gt;NGX_HTTP_POST_REWRITE_PHASE（不可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;本阶段用于检查重写URI次数，不能超过10次以避免出现rewrite死循环的情况。本阶段不能自定义HTTP模块，checker函数为ngx_http_core_post_rewrite_phase。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_preaccess_phase可添加自定义http模块&#34;&gt;NGX_HTTP_PREACCESS_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;来到这一阶段，说明已经根据URI查询到了对应的location，即对应的loc_conf配置已经确定下来，该阶段主要主要用于访问资源控制，如限制频率、链接数等，本阶段的checker仍然是前面的ngx_http_core_generic_phase。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_access_phase可添加自定义http模块&#34;&gt;NGX_HTTP_ACCESS_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;本阶段与上一阶段的区别在于，使用的checker为ngx_http_core_access_phase，主要用于检测用户发起的请求是否合法，比如IP地址是否允许访问等。&lt;/p&gt;
&lt;p&gt;涉及到nginx配置文件中的satisfy配置项，根据本阶段handler的不同返回值，有以下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NGX_OK：如果在配置文件中配置了satisfy all，那么将按照顺序执行下一个ngx_http_handler_pt方法；如果配置了satisfy any，那么将会执行下一个ngx_http_phase阶段的第一个ngx_http_handler_pt方法。&lt;/li&gt;
&lt;li&gt;NGX_DECLINED：按照顺序执行下一个ngx_http_handler_pt方法。&lt;/li&gt;
&lt;li&gt;NGX_AGAIN, NGX_DONE：当前的ngx_http_handler_pt方法尚未结束，当前方法有机会被再次调用。&lt;/li&gt;
&lt;li&gt;NGX_HTTP_FORBIDDEN: 如果在配置文件中配置了satisfy any，那么将ngx_http_request_t中的access_code成员设置为返回值。按照顺序执行下一个ngx_http_handler_pt处理方法；如果是satisfy all，那么调用ngx_http_finalize_request结束请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// NGX_HTTP_ACCESS_PHASE阶段的处理函数，用于控制用户发起的请求是否合法，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如检测客户端的IP地址是否允许被访问
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_int_t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_http_core_access_phase&lt;/span&gt;(ngx_http_request_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;r, ngx_http_phase_handler_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ph)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t                  rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_loc_conf_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;clcf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// r != r-&amp;gt;main表示当前请求只是派生出来的子请求，子请求不需要执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// NGX_HTTP_ACCESS_PHASE阶段的处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (r &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;main) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ph&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;connection&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;log, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;access phase: %ui&amp;#34;&lt;/span&gt;, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ph&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;handler(r);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回NGX_DECLINED意味着希望立刻执行下一个handler，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 无论是否属于NGX_HTTP_ACCESS_PHASE
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_DECLINED) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回AGAIN或者DONE意味着当前的NGX_HTTP_ACCESS_PHASE没有一次性执行完毕
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_AGAIN &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_DONE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下是返回值不是 NGX_DECLINED、NGX_AGAIN、NGX_DONE的情况
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 由于NGX_HTTP_ACCESS_PHASE阶段在NGX_HTTP_FIND_CONFIG_PHASE阶段后面，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 因此此时请求已经找到了匹配的的location模块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  clcf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_get_module_loc_conf(r, ngx_http_core_module);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (clcf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;satisfy &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_HTTP_SATISFY_ALL) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// NGX_HTTP_SATISFY_ALL表示nginx配置文件中配置了satisfy all参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// satisfy all要求所有NGX_HTTP_ACCESS_PHASE阶段的handler方法共同作用于该请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_OK) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 该模块返回NGX_OK，意味着该模块认为满足访问要求，需要继续调用下一个模块查询是否满足要求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;      r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果返回值不是NGX_OK，则调用ngx_http_finalize_request结束请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这里是配置中配置了satisfy any的情况
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// satisfy any不要求所有NGX_HTTP_ACCESS_PHASE阶段的模块都通过请求，只要有一个同意就可以放行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回NGX_OK，表示该模块认为有权限访问，因此phase_handler指向下一个handler
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 并且access_code置为0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_OK) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;access_code &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;headers_out.www_authenticate) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;headers_out.www_authenticate&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;hash &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ph&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// NGX_HTTP_FORBIDDEN或者NGX_HTTP_UNAUTHORIZED表示该模块不同意访问
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_HTTP_FORBIDDEN &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; rc &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; NGX_HTTP_UNAUTHORIZED) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;access_code &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; NGX_HTTP_UNAUTHORIZED) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;access_code &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* rc == NGX_ERROR || rc == NGX_HTTP_...  */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到这里是请求出错的情况，结束这次请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_http_finalize_request(r, rc);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}              
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ngx_http_post_access_phase不可添加自定义http模块&#34;&gt;NGX_HTTP_POST_ACCESS_PHASE（不可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;本阶段处理上一阶段的处理结果，具体是根据ngx_http_request_t的access_code成员来进行处理。本阶段不允许添加自定义HTTP模块。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_try_files_phase不可添加自定义http模块&#34;&gt;NGX_HTTP_TRY_FILES_PHASE（不可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;本阶段的checker函数为ngx_http_core_try_files_phase，与nginx配置文件中的try_files配置指令相关。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_content_phase可添加自定义http模块&#34;&gt;NGX_HTTP_CONTENT_PHASE（可添加自定义HTTP模块）&lt;/h3&gt;
&lt;p&gt;处理HTTP请求内容的阶段，绝大部分用户自定义的HTTP模块工作在这一阶段。&lt;/p&gt;
&lt;p&gt;与其他阶段不同的是，该阶段除了可以调用注册进来的HTTP模块的handler之外，还可以调用location配置中的content_handler，在存在location配置的content_handler的情况下，将优先调用这个函数处理请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// NGX_HTTP_CONTENT_PHASE阶段的处理函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;ngx_int_t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_http_core_content_phase&lt;/span&gt;(ngx_http_request_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;r,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_phase_handler_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ph)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  size_t     root;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  rc;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_str_t  path;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;content_handler) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// content_handler不为空意味着在NGX_HTTP_FIND_CONFIG_PHASE阶段中，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 匹配了URI请求的location内，是否有HTTP模块把处理方法设置到了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ngx_http_core_loc_conf_t结构体的handler成员中。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// ngx_http_request_empty_handler是什么都不做的方法，设置为这个函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 意味着再有写事件不做任何事情
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;write_event_handler &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_request_empty_handler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将content_handler的返回值放入ngx_http_finalize_request中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    ngx_http_finalize_request(r, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;content_handler(r));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到了这里说明没有content_handler
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;connection&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;log, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;content phase: %ui&amp;#34;&lt;/span&gt;, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ph&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;handler(r);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rc &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; NGX_DECLINED) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 没有返回NGX_DECLINED意味着不再执行该阶段的其他handler
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    ngx_http_finalize_request(r, rc);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* rc == NGX_DECLINED */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下是返回NGX_DECLINED的情况
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ph&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ph&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;checker) {  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 只有在该阶段下一个handler存在的情况下才继续执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;phase_handler&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_AGAIN;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 以下是找不到该阶段handler的情况
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* no content handler was found */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;uri.data[r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;uri.len &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// URI以/结尾，返回403
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ngx_http_map_uri_to_path(r, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;path, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;root, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ngx_log_error(NGX_LOG_ERR, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;connection&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;log, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;directory index of &lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt; is forbidden&amp;#34;&lt;/span&gt;, path.data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_log_error(NGX_LOG_ERR, r&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;connection&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;log, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;no handler found&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 返回404
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; NGX_OK;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ngx_http_log_phase&#34;&gt;NGX_HTTP_LOG_PHASE&lt;/h3&gt;
&lt;p&gt;记录访问日志。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26745255/&#34;&gt;深入理解nginx（第2版）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-查询HTTP配置流程</title>
      <link>https://www.codedump.info/post/20190212-nginx-http-config/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:25 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190212-nginx-http-config/</guid>
      
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;
&lt;p&gt;前面已经分析过&lt;a href=&#34;https://www.codedump.info/post/20190103-nginx-config-parse/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&#34;&gt;nginx解析配置文件的整体流程&lt;/a&gt;，接下来看查询HTTP配置的流程。&lt;/p&gt;
&lt;p&gt;HTTP属于nginx的core顶层模块，下面又包括了三部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main部分配置：即在HTTP块但是又不在任何server、location块中的配置，如下图中的sendfile配置指令。&lt;/li&gt;
&lt;li&gt;server块：在server块内部的配置。&lt;/li&gt;
&lt;li&gt;location块：在location块内部分配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190212-nginx-http-config/http_config.jpg&#34; alt=&#34;http_config&#34; title=&#34;http_config&#34;&gt;&lt;/p&gt;
&lt;p&gt;解析HTTP模块的入口函数是ngx_http_block，这一点可以从http指令相关的配置看出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;http),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MAIN_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_BLOCK&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_NOARGS,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_block,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个解析函数的开始，就创建了ngx_http_conf_ctx_t结构体，所以看的出来这个结构体是HTTP模块的第一级配置，它的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;        &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;main_conf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;        &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;srv_conf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;        &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;loc_conf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_http_conf_ctx_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面列举出来这几部分相关的函数以及数据结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;块&lt;/th&gt;
&lt;th&gt;入口函数&lt;/th&gt;
&lt;th&gt;数据结构&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;http&lt;/td&gt;
&lt;td&gt;ngx_http_block&lt;/td&gt;
&lt;td&gt;ngx_http_conf_ctx_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;main&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ngx_http_core_main_conf_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;server&lt;/td&gt;
&lt;td&gt;ngx_http_core_server&lt;/td&gt;
&lt;td&gt;ngx_http_core_srv_conf_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;ngx_http_core_location&lt;/td&gt;
&lt;td&gt;ngx_http_core_loc_conf_t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190212-nginx-http-config/ngx_http_module.png&#34; alt=&#34;ngx_http_module&#34; title=&#34;ngx_http_module&#34;&gt;&lt;/p&gt;
&lt;p&gt;另外，由于HTTP块内的一些配置，作用域可以在多种块中，因此需要涉及到合并配置的流程，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果子作用域某配置项在解析过程中未被赋值，则将父作用域的 相同的配置项值拷贝至此配置项里；&lt;/li&gt;
&lt;li&gt;如果子作用域配置项在解析过程中被赋值了，则保留原 样；如果子作用域配置项和父作用域配置项都没有被初始化，则填入代码中预设的默认值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关的合并配置函数列举如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;块&lt;/th&gt;
&lt;th&gt;合并函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;server&lt;/td&gt;
&lt;td&gt;ngx_http_merge_servers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;location&lt;/td&gt;
&lt;td&gt;ngx_http_merge_locations&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下具体看看一次HTTP请求如何查找到相关HTTP配置的流程，分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据Host查找server块&lt;/li&gt;
&lt;li&gt;根据URI查找location块&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;根据host查找server块流程&#34;&gt;根据Host查找server块流程&lt;/h1&gt;
&lt;p&gt;前面分析&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-read-http-request/&#34;&gt;nginx接收HTTP请求流程&lt;/a&gt;中分析到，nginx在接收HTTP请求流程中，将调用ngx_http_process_request_headers函数来处理请求头。&lt;/p&gt;
&lt;p&gt;nginx使用一个ngx_http_header_t结构体，定义了哪些请求头需要进行特定的函数回调处理，函数ngx_http_process_request_headers会根据这个表来查询接收到的请求头都需要哪些回调函数来处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_http_header_t  ngx_http_headers_in[] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;), offsetof(ngx_http_headers_in_t, host),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_http_process_host },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;Connection&amp;#34;&lt;/span&gt;), offsetof(ngx_http_headers_in_t, connection),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_http_process_connection },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，针对Host这个header，会调用ngx_http_process_host函数，这个函数最终会调用ngx_http_set_virtual_server函数来根据Host头确定对应的server块。&lt;/p&gt;
&lt;p&gt;nginx中，不同的server块可以监听同一个地址端口，只要对应的server_name不一样就可以了。&lt;/p&gt;
&lt;p&gt;而相同的地址端口，在nginx中对应的是ngx_http_addr_conf_t，内部将同样地址端口的多个不同server_name再组织到一起来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_hash_combined_t        names;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_uint_t                 nregex;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_server_name_t    &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;regex;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_http_virtual_names_t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; ngx_http_addr_conf_s {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* the default server configuration for this address:port */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_srv_conf_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;default_server;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_virtual_names_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;virtual_names;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;                   &lt;span style=&#34;color:#a0a000&#34;&gt;ssl&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;                   &lt;span style=&#34;color:#a0a000&#34;&gt;http2&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;                   &lt;span style=&#34;color:#a0a000&#34;&gt;proxy_protocol&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然，如果相同地址端口的server如果使用链表组织在一起，每一次都是线性时间的查找复杂度，这就太慢了。因此nginx定义了ngx_hash_combined_t这个数据结构，将相同地址端口的server_name组织到一起来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_hash_t            hash;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_hash_wildcard_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wc_head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_hash_wildcard_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;wc_tail;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_hash_combined_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该结构体中有三个成员，区分不同的server_name格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_hash_t hash：精确匹配的哈希表，用于存储没有使用通配符的虚拟主机名，如”www.example.com“。&lt;/li&gt;
&lt;li&gt;ngx_hash_wildcard_t  &lt;em&gt;wc_head：前置通配符哈希表，用于存储如”&lt;/em&gt;.example.org“和”.example.org“这样的前置通配符虚拟主机名。&lt;/li&gt;
&lt;li&gt;ngx_hash_wildcard_t  &lt;em&gt;wc_tail：后置通配符哈希表，用于存储如”example.&lt;/em&gt;“这样的后置通配符虚拟主机名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体这个支持通配符的hash表，不在这里讲解，只谈host的查找顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先查找精确匹配hash表，查找到则返回；&lt;/li&gt;
&lt;li&gt;接着查找前置通配符hash表，查找到则返回；&lt;/li&gt;
&lt;li&gt;最后查找后置通配符hash表，查找到则返回；&lt;/li&gt;
&lt;li&gt;如果以上都没有查找到，落到default_server的server块进行处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;根据uri查找location块流程&#34;&gt;根据URI查找location块流程&lt;/h1&gt;
&lt;p&gt;根据Host查找到了server块，紧跟着就是根据URI来查找location块了。&lt;/p&gt;
&lt;p&gt;location区分几种格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;location &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ configuration A ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;location &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ configuration B ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;location &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;documents&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ configuration C ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;location &lt;span style=&#34;color:#666&#34;&gt;^~&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;images&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ configuration D ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;location &lt;span style=&#34;color:#666&#34;&gt;~*&lt;/span&gt; &lt;span style=&#34;&#34;&gt;\&lt;/span&gt;.(gif&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;jpg&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;jpeg)&lt;span style=&#34;&#34;&gt;$&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [ configuration E ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的配置例子中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置A：精确匹配&amp;quot;/&amp;quot; URI，主机名后面不能带任何字符串。&lt;/li&gt;
&lt;li&gt;配置B：因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求，但是正则和最长字符串会优先匹配。&lt;/li&gt;
&lt;li&gt;配置C：匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索，只有后面的正则表达式没有匹配到时，这一条才会采用这一条。&lt;/li&gt;
&lt;li&gt;配置D：匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。&lt;/li&gt;
&lt;li&gt;配置E：匹配所有以 gif,jpg或jpeg 结尾的请求，然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体根据URI匹配location的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先先检查使用前缀字符定义的location，选择最长匹配的项并记录下来；&lt;/li&gt;
&lt;li&gt;如果找到了精确匹配的location，也就是使用了=修饰符的location，结束查找，使用它的配置。&lt;/li&gt;
&lt;li&gt;然后按顺序查找使用正则定义的location，如果匹配则停止查找，使用它定义的配置。&lt;/li&gt;
&lt;li&gt;如果没有匹配的正则location，则使用前面记录的最长匹配前缀字符location。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含正则的 location 在配置文件中的顺序不会影响匹配顺序。而包含正则表达式的 location 会按照配置文件中定义的顺序进行匹配。&lt;/li&gt;
&lt;li&gt;设置为精确匹配 (with = prefix) 的 location 如果匹配请求 URI 的话，此 location 被马上使用，匹配过程结束。&lt;/li&gt;
&lt;li&gt;在其它只包含普通字符的 location 中，找到和请求 URI 最长的匹配。如果此 server {} 没有包含正则的 location 或者该 location 启用了 ^~ 的话，这个最 长匹配的 location 会被使用。如果此 server {} 中包含正则的 location，则先在 这些正则 location 中进行匹配，如果找到匹配，则使用匹配的正则 location，如果 没找到匹配，依然使用最大匹配的 location。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上的准备，开始看具体的代码实现。&lt;/p&gt;
&lt;h2 id=&#34;ngx_http_core_loc_conf_s结构体&#34;&gt;ngx_http_core_loc_conf_s结构体&lt;/h2&gt;
&lt;p&gt;ngx_http_core_loc_conf_s结构体对应一个location块的配置，相关的成员如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; ngx_http_core_loc_conf_s {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_str_t           name;   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* URI 部分字符串 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_regex_t    &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;regex; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 正则引擎编译过的 正则表达式对象 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;            &lt;span style=&#34;color:#a0a000&#34;&gt;named&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* @ 修饰符 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;            &lt;span style=&#34;color:#a0a000&#34;&gt;noname&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* if () {} */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;            &lt;span style=&#34;color:#a0a000&#34;&gt;exact_match&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* = 修饰符 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt;            &lt;span style=&#34;color:#a0a000&#34;&gt;noregex&lt;/span&gt;:&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* ^= 修饰符 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_tree_node_t   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;static_location;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_loc_conf_t        &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;regex_location;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;                &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;loc_conf;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_queue_t         &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;locations; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 连接 `location` 作用域，由
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                                     ngx_http_location_queue_t 强制转
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                                     换而来 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，在ngx_http_core_loc_conf_s中使用了几个成员named、noname、exact_match、noregex区分了以上的情况。&lt;/p&gt;
&lt;h2 id=&#34;ngx_http_location_queue_t&#34;&gt;ngx_http_location_queue_t&lt;/h2&gt;
&lt;p&gt;结构体ngx_http_location_queue_t用于临时保存location的队列：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_queue_t                 queue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_loc_conf_t    &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exact; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exact_match, regex, named, noname */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_loc_conf_t    &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;inclusive; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* 非 exact 的 location */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_str_t                   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_http_location_queue_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ngx_http_location_tree_node_t&#34;&gt;ngx_http_location_tree_node_t&lt;/h2&gt;
&lt;p&gt;ngx_http_location_tree_node_t结构体是最终存储location的结构体，将location以树状组织在一起，实现location的快速查找：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; ngx_http_location_tree_node_s {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_tree_node_t   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;left;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_tree_node_t   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;right;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_tree_node_t   &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;tree;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_core_loc_conf_t        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;exact;     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 精确匹配的location配置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_http_core_loc_conf_t        &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;inclusive; &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// inclusive匹配的location配置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u_char                          auto_redirect;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u_char                          len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u_char                          name[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构建location查找树的流程&#34;&gt;构建location查找树的流程&lt;/h2&gt;
&lt;p&gt;在函数ngx_http_block中（该函数即HTTP块的入口函数），将调用两个函数进行location的初始化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_init_locations：用于完成location的排序以及分类存放。&lt;/li&gt;
&lt;li&gt;ngx_http_init_static_location_trees：用于将exact以及inclusive类型的location进一步处理，构造出可以快速访问的树状结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ngx_http_init_locations&#34;&gt;ngx_http_init_locations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先调用ngx_queue_sort(locations, ngx_http_cmp_locations)函数对location队列进行排序，排序的结果为：exact(sorted) -&amp;gt; inclusive(sorted) -&amp;gt; regex -&amp;gt; named -&amp;gt; noname，这里说明一下inclusive，它表示URI之间的包含关系，即”/abc/a“这个URI是包含”/abc“的。&lt;/li&gt;
&lt;li&gt;遍历排序过后的location队列，将其中的noname类型的location分离出队列。&lt;/li&gt;
&lt;li&gt;将named类型的location分离出来，放到配置的named_locations中。&lt;/li&gt;
&lt;li&gt;将含有正则的location分离出来，放到配置的regex_locations中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，以上流程完成之后，原先的location队列就只剩下exact以及inclusive类型的location了。接着调用ngx_http_init_static_location_trees函数做进一步的处理。&lt;/p&gt;
&lt;h3 id=&#34;ngx_http_init_static_location_trees&#34;&gt;ngx_http_init_static_location_trees&lt;/h3&gt;
&lt;p&gt;有以下几个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_join_exact_locations：将当前虚拟主机中 uri 字符串完全一致的 exact 和 inclusive 类型的 location 进行合并。&lt;/li&gt;
&lt;li&gt;ngx_http_create_locations_list：将前缀一致的location放到list链表中。&lt;/li&gt;
&lt;li&gt;ngx_http_create_locations_tree：构造location的树结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ngx_http_create_locations_list&#34;&gt;ngx_http_create_locations_list&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_http_create_locations_list&lt;/span&gt;(ngx_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;locations, ngx_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;q)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  u_char                     &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  size_t                      len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_queue_t                &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;x, tail;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_queue_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;lq, &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;lx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 由于本函数存在递归调用，所以这个判断是递归的终止条件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (q &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; ngx_queue_last(locations)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (ngx_http_location_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) q;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inclusive &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果不是inclusive类型的location，直接跳过，继续队列中下一个location的处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    ngx_http_create_locations_list(locations, ngx_queue_next(q));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  name &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;data;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 从该location的下一个元素开始遍历队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (x &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_queue_next(q);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; ngx_queue_sentinel(locations);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_queue_next(x))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    lx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (ngx_http_location_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 找到第一个不以q的location做为前缀的location就退出循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 比如当前队列location为：/a /ab /abc /b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这里的q就是/a，x就是/b，中间的/ab和/abc都是以/a为前缀的，不会终止循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (len &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; lx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;len
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; ngx_filename_cmp(name, lx&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;data, len) &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  q &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_queue_next(q);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (q &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; x) { &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果x就是q的下一个元素，说明没有找到前缀匹配的，那么直接进入x进行下次递归调用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    ngx_http_create_locations_list(locations, x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到了这里说明前面找到有前缀匹配的location了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 这里将与q相同前缀的节点，分离出队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_queue_split(locations, q, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 然后加入到q的list链表中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_queue_add(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; ngx_queue_sentinel(locations)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_http_create_locations_list(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list, ngx_queue_head(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 将x从队列中分离出来
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_queue_split(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list, x, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 放回到location队列中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_queue_add(locations, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 对lq-&amp;gt;list做相同的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_http_create_locations_list(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list, ngx_queue_head(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 对从x开始的剩余节点做相同的操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_http_create_locations_list(locations, x);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对该函数的几个说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于存在递归调用，所以函数开始要做q == ngx_queue_last(locations)的判断，做为递归的终止条件。&lt;/li&gt;
&lt;li&gt;对于非 inclusive 类型 (此时 locations 队列中也只包含 exact 和 inclusive 类型的 location 节点) 的 location 节点，直接跳过，不做任何整理。&lt;/li&gt;
&lt;li&gt;从lq开始遍历队列，直到查找到第一个不以q做为前缀的location才退出循环，退出循环时保存当前位置为x。比如当前队列location为：/a /ab /abc /b，这里的q就是/a，x就是/b，中间的/ab和/abc都是以/a为前缀的，不会终止循环。&lt;/li&gt;
&lt;li&gt;将与lq前缀匹配的队列元素，放到lq的list中，同时针对这个list递归调用ngx_http_create_locations_list函数。&lt;/li&gt;
&lt;li&gt;继续针对x开始的剩余队列节点递归调用ngx_http_create_locations_list函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示就是ngx_http_create_locations_list调用前后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190212-nginx-http-config/ngx-location-create-locations-list.png&#34; alt=&#34;ngx-location-create-locations-list&#34; title=&#34;ngx-location-create-locations-list&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;ngx_http_create_location_trees&#34;&gt;ngx_http_create_location_trees&lt;/h4&gt;
&lt;p&gt;ngx_http_create_location_trees在上面的基础上构造location查找树&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_http_location_tree_node_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#00a000&#34;&gt;ngx_http_create_locations_tree&lt;/span&gt;(ngx_conf_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cf, ngx_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;locations,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  size_t prefix)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  size_t                          len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_queue_t                    &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;q, tail;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_queue_t      &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;lq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_http_location_tree_node_t  &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 快速确定中间节点的位置，保存到q中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  q &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_queue_middle(locations);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lq &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (ngx_http_location_queue_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) q;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 左边元素的数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;len &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; prefix;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_palloc(cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pool,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    offsetof(ngx_http_location_tree_node_t, name) &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tree &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;exact &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;exact;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inclusive &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inclusive;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;auto_redirect &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (u_char) ((lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;exact &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;exact&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;auto_redirect)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt; (lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inclusive &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;inclusive&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;auto_redirect));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;len &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (u_char) len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_memcpy(node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;data[prefix], len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 从中间节点将location分为两部分
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  ngx_queue_split(locations, q, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 如果分离完毕location队列为空
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ngx_queue_empty(locations)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;     * ngx_queue_split() insures that if left part is empty,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;     * then right one is empty too
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;     */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 直接跳到构造inclusive类型的子树
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;goto&lt;/span&gt; inclusive;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 构造左子树
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_create_locations_tree(cf, locations, prefix);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_queue_remove(q);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ngx_queue_empty(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;goto&lt;/span&gt; inclusive;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 构造右子树
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_create_locations_tree(cf, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;tail, prefix);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;inclusive&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 到这里构造inclusive类型的树保存到tree成员中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// list为空说明没有inclusive类型的location了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (ngx_queue_empty(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tree &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_http_create_locations_tree(cf, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;lq&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;list, prefix &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (node&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;tree &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; node;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用ngx_queue_middle快速确定locaiton队列的中间节点。&lt;/li&gt;
&lt;li&gt;从中间节点将location分为两部分。&lt;/li&gt;
&lt;li&gt;分别构造左右子树放到成员left和right中。&lt;/li&gt;
&lt;li&gt;将inclusive类型的location放入到成员tree中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示就是ngx-location-create-locations-tree调用前后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190212-nginx-http-config/ngx-location-create-locations-tree.png&#34; alt=&#34;ngx-location-create-locations-tree&#34; title=&#34;ngx-location-create-locations-tree&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;查找location流程&#34;&gt;查找location流程&lt;/h2&gt;
&lt;p&gt;请求的 location 匹配，在请求处理的 FIND_CONFIG 阶段相对应的 checker ngx_http_core_find_config_phase 函数中完成。ngx_http_core_find_config_phase 函数调用 ngx_http_core_find_location 函数完成实际的匹配工作。&lt;/p&gt;
&lt;p&gt;本质上就是根据前面构建好的树结构，进行二分查找，不再阐述。&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ialloc.org/blog/ngx-notes-conf-parsing/&#34;&gt;Nginx 源代码笔记 - 配置文件解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ialloc.org/blog/ngx-notes-http-location/&#34;&gt;Nginx 源代码笔记 - URI 匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ialloc.org/blog/ngx-notes-hashtable-2/&#34;&gt;Nginx 源代码笔记 - 哈希表 [2]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-接收HTTP请求流程</title>
      <link>https://www.codedump.info/post/20190131-nginx-read-http-request/</link>
      <pubDate>Fri, 01 Feb 2019 17:50:37 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-read-http-request/</guid>
      
      <description>&lt;p&gt;前面已经描述过nginx的事件模块了，接下来具体分析nginx如何接收一个HTTP请求，下一部分接着解析nginx解析HTTP请求的流程。&lt;/p&gt;
&lt;h1 id=&#34;协议状态机编程模式&#34;&gt;协议状态机编程模式&lt;/h1&gt;
&lt;p&gt;TCP协议是一种流协议（stream protocol），这意味着数据是以字节流形式给数据接收者的，一次网络接收不一定能接收完毕，需要上面的应用层根据自己协议的情况来解析处理。它的数据没有边界，需要应用层自己根据协议来判断边界的存在。&lt;/p&gt;
&lt;p&gt;如果两次请求，分开为几次接收，但是某次接收的数据中，有跨两次请求的数据，这就是所谓的“粘包(sticky-package)”问题。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190131-nginx-read-http-request/sticky-package-problem.png&#34; alt=&#34;sticky-package-problem&#34; title=&#34;sticky-package-problem&#34;&gt;&lt;/p&gt;
&lt;p&gt;结合epoll之类的事件派发器来设计一个TCP协议的服务器时，因为并不能确保每一次接收数据，都能完整的接收到协议所需的所有数据。因此一般而言，写一个高性能服务器的协议解析部分，会以状态机的方式来实现，即定义了协议数据的每个部分，如下伪代码所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 定义协议头数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; header_t {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 协议版本号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; version;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 定义body部分大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; size;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} header_t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 定义协议数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; protocol_t {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  header_t header;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; body[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} protocol;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 定义接收数据的状态机类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;enum&lt;/span&gt; state_t {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RECV_HEADER,        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收包头
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  RECV_BODY,          &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收包体
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  PROCESS_PROTOCOL,   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理协议
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  SEND_RESPONSE       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 发送回复
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理请求的状态机
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;statemachine&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt; (state) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;RECV_HEADER&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收协议包头数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收完毕之后，切换state到RECV_BODY
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;RECV_BODY&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收协议包体数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 接收完毕之后，切换state到PROCESS_PROTOCOL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;PROCESS_PROTOCOL&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理协议
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 处理完毕之后，切换state到SEND_RESPONSE
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;SEND_RESPONSE&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 发送应答
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上面的伪代码所示，接收一个请求之后，会初始化一个变量state用于保存当前协议处理的状态类型，假如第一次接收数据时还不能接收完毕协议的数据，就将接收fd重新放入到事件派发器中，下一次被唤醒之后再根据当前的状态继续接收数据进行处理。&lt;/p&gt;
&lt;p&gt;协议的包头部分，一般有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包头大小固定，这个原因还是因为不能确定每次都能接收完整的数据，而总是需要一个长度或者确定的结束符（如HTTP协议最后的两个\r\n）来告诉你是否接收完了数据。如果后面还需要对包头数据有扩展，会根据不同的版本进行区别，所以一般而言包头部分还会有个版本号，以便以后包头数据发生了变化，可以根据包头来进行区分。&lt;/li&gt;
&lt;li&gt;包头内有字段定义包体部分的大小，这样在状态切换到接收包体时才有依据何时接收完毕了数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一般的思路，实际中还有一些不一样的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的服务不是以暴露给使用者事件派发器接口的方式来实现的，内部采用了协程之类的机制，这样应用开发者写起代码了就好像独占了一个“线程”，比如使用golang来写代码，每个连接对应goroutine的情况下，这时候就没有必要连接内部保存一个状态变量了。&lt;/li&gt;
&lt;li&gt;上面的协议定义中，用长度来定义每部分的边界：即包头固定长度，包头内部的长度成员来表示包体的大小。有一些协议就不是这么实现协议的，比如HTTP协议采用连续两个\r\n来表示包头部分结束或者包体部分结束（在包体部分长度不确定时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了协议状态机之后，处理前面的粘包问题就很简单了，无非就是当事件被回调的时候进入状态机，看当前在哪个协议状态来进行处理。&lt;/p&gt;
&lt;h1 id=&#34;nginx接收http请求流程&#34;&gt;Nginx接收HTTP请求流程&lt;/h1&gt;
&lt;p&gt;以上解释了以状态机来驱动的协议接收流程，Nginx也是类似状态机的机制，只不过内部并没有一个state这样的变量保存当前到哪个状态了，而是切换不同状态对应的handler函数来做解析。&lt;/p&gt;
&lt;p&gt;nginx既可以做7层代理，也可以做4层代理，因此在实现的时候，需要考虑兼容不同的应用层协议，具体来说设置了一个监听端口的时候，该端口可能处理的是HTTP请求，也可能是配置在stream块中处理的是4层的TCP请求。&lt;/p&gt;
&lt;p&gt;而nginx采用了统一的ngx_connection_t结构体来表示一个tcp连接，这里就要根据不同的协议做区分了，来看看这个结构体中相关的字段：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void *data&lt;/td&gt;
&lt;td&gt;连接相关数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ngx_event_t *read&lt;/td&gt;
&lt;td&gt;读事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ngx_event_t *write&lt;/td&gt;
&lt;td&gt;写事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ngx_recv_pt recv&lt;/td&gt;
&lt;td&gt;接收请求的函数指针，每个平台可能有区别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ngx_send_pt send&lt;/td&gt;
&lt;td&gt;发送应答的函数指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;即：不同的tcp协议，对应的连接相关的data是不一样的，这样读写事件对应的回调函数也就不一样。&lt;/p&gt;
&lt;p&gt;类似的，nginx中ngx_listening_t来表示监听socket，其中的成员handler也是区分了不同的协议有不同的注册回调函数。&lt;/p&gt;
&lt;p&gt;如果这个监听端口，处理的是HTTP请求，那么注册进去的回调函数就是ngx_http_init_connection，这样在接收到一个HTTP请求时就会回调该函数进行处理。&lt;/p&gt;
&lt;p&gt;完整的流程图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190131-nginx-read-http-request/nginx-read-http-statemachine.png&#34; alt=&#34;nginx-read-http-statemachine&#34; title=&#34;nginx-read-http-statemachine&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来按照上面的流程图具体看接收HTTP请求的流程中对应的几个回调函数。&lt;/p&gt;
&lt;h2 id=&#34;ngx_http_init_connection&#34;&gt;ngx_http_init_connection&lt;/h2&gt;
&lt;p&gt;这个函数是接收到HTTP请求之后的第一个回调函数，用于初始化请求连接相关的一些数据，主要做的工作是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化读事件的回调函数为ngx_http_wait_request_handler，而写事件的回调函数是一个什么也不做的空函数ngx_http_empty_handler。这是因为，该接收完连接还没有应答数据，所以即使可写也什么都不做。&lt;/li&gt;
&lt;li&gt;将读事件添加到一个定时器中，这样如果一段时间内都接收不完请求则关闭连接，不至于被占用资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ngx_http_wait_request_handler&#34;&gt;ngx_http_wait_request_handler&lt;/h2&gt;
&lt;p&gt;ngx_http_wait_request_handler函数是接收到HTTP请求之后第一次被读事件回调的函数，主要工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断连接是否超时，如果超时则关闭连接。&lt;/li&gt;
&lt;li&gt;分配读缓存空间。&lt;/li&gt;
&lt;li&gt;调用recv函数指针读客户端请求。此后需要对这个函数调用的结果做判断：
&lt;ul&gt;
&lt;li&gt;NGX_AGAIN：说明还没有读完请求，将会再次将读事件加入定时器，读事件加入到epoll监控事件中，等待下一次被读事件唤醒，或者超时。&lt;/li&gt;
&lt;li&gt;NGX_ERROR：请求出错了，关闭连接。&lt;/li&gt;
&lt;li&gt;没有读到任何数据，说明对端关闭连接。&lt;/li&gt;
&lt;li&gt;其他情况说明已经读出一部分数据，此时将该读事件的handler切换为ngx_http_process_request_line，开始接收请求行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ngx_http_process_request_line&#34;&gt;ngx_http_process_request_line&lt;/h2&gt;
&lt;p&gt;ngx_http_process_request_line负责接收处理请求行，这个函数可能被多次调用，就跟前面分析状态机接收请求的情况一样，只要状态没有变化，下一次被读事件唤醒还是会走到响应的状态处理函数中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断连接是否超时，如果超时则关闭连接。&lt;/li&gt;
&lt;li&gt;初始化rc为 NGX_AGAIN，接下来进入一个循环处理的流程，分别经历了以下流程：
&lt;ul&gt;
&lt;li&gt;如果rc == NGX_AGAIN：调用ngx_http_read_request_header函数读请求头，返回NGX_AGAIN或者NGX_ERROR则退出循环返回。&lt;/li&gt;
&lt;li&gt;调用ngx_http_parse_request_line函数分析请求行，下面区分该函数的返回值不同情况处理：
&lt;ul&gt;
&lt;li&gt;rc == NGX_OK，说明调用成功：
&lt;ul&gt;
&lt;li&gt;初始化ngx_http_request_t相关的数据，如request_line、method_name等。&lt;/li&gt;
&lt;li&gt;调用ngx_http_process_request_uri处理请求URI。&lt;/li&gt;
&lt;li&gt;分析请求HOST。&lt;/li&gt;
&lt;li&gt;初始化headers_in链表，准备解析header。&lt;/li&gt;
&lt;li&gt;将读事件的hander切换为ngx_http_process_request_headers，准备处理HTTP header。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rc != NGX_AGAIN：说明出错了，调用ngx_http_finalize_request终止请求。&lt;/li&gt;
&lt;li&gt;其他请求就是rc == NGX_AGAIN的情况了，说明此时还没有接受完毕HTTP请求。如果r-&amp;gt;header_in-&amp;gt;pos == r-&amp;gt;header_in-&amp;gt;end，说明接受header的缓冲区已经满了，需要分配一块大内存来存储header。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ngx_http_process_request_headers&#34;&gt;ngx_http_process_request_headers&lt;/h2&gt;
&lt;p&gt;ngx_http_parse_request_line分析请求行成功之后，就将读事件的handler切换为ngx_http_process_request_headers，该函数处理请求头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断连接是否超时，如果超时则关闭连接。&lt;/li&gt;
&lt;li&gt;初始化rc为 NGX_AGAIN，接下来进入一个循环处理的流程，分别经历了以下流程：
&lt;ul&gt;
&lt;li&gt;rc == NGX_AGAIN:
&lt;ul&gt;
&lt;li&gt;如果r-&amp;gt;header_in-&amp;gt;pos == r-&amp;gt;header_in-&amp;gt;end：说明header_in缓冲区已经被用尽，需要分配大空间来接收header。&lt;/li&gt;
&lt;li&gt;调用ngx_http_read_request_header函数读请求头，如果返回值为NGX_AGAIN或者NGX_ERROR，则退出循环返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用ngx_http_parse_header_line函数解析header_in缓冲区中的字节流，分析header，根据返回值区分以下情况：
&lt;ul&gt;
&lt;li&gt;rc == NGX_OK：说明成功解析一个HTTP header，向headers_in数组分配一个新的元素用于存储该header。&lt;/li&gt;
&lt;li&gt;rc == NGX_HTTP_PARSE_HEADER_DONE：说明全部header已经解析完成，将处理HTTP请求的遍历http_state切换为NGX_HTTP_PROCESS_REQUEST_STATE，调用ngx_http_process_request_header处理请求头，如果返回结果不为NGX_OK则退出循环返回，否则进入ngx_http_process_request处理HTTP请求。&lt;/li&gt;
&lt;li&gt;rc == NGX_AGAIN：说明还有未接收完毕的数据，退出循环等待下一次被读事件唤醒再次读取数据进行处理。&lt;/li&gt;
&lt;li&gt;除了上面以外的其他情况，说明出错了，调用ngx_http_finalize_request终止请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上，基本把接收一个HTTP请求中间过程中涉及到的主要函数分析了一遍。可以看到，nginx对接收HTTP请求的处理，也是状态机驱动的，区别于最开始说明的状态机编程模式，nginx没有在每个连接相关的结构体中用一个状态变量来表示当前的状态，而是通过切换读事件的handler来完成状态处理的切换。&lt;/p&gt;
&lt;p&gt;以上的流程和涉及的函数，看起来很多，其实就是分了两部分可能会循环被调用的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理请求URI，对应函数ngx_http_process_request_line。&lt;/li&gt;
&lt;li&gt;处理请求header，对应函数ngx_http_process_request_headers。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这里的分析可以看到，高性能TCP协议服务器的一个重点就是读请求的流程，这部分不能阻塞，要点就是通过状态机驱动的模式来读取协议，nginx这里划分的很细致，不会因为一次网络IO阻塞住这个流程。&lt;/p&gt;
&lt;p&gt;下一部分解析nginx处理HTTP请求的流程。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-事件处理模块</title>
      <link>https://www.codedump.info/post/20190131-nginx-event/</link>
      <pubDate>Thu, 31 Jan 2019 21:12:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-event/</guid>
      
      <description>&lt;p&gt;大概做高性能服务器的，都绕不开事件处理模块来，一般一个事件模块，会分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何定义一个描述事件的数据结构。&lt;/li&gt;
&lt;li&gt;如何在事件模块中支持定时器。&lt;/li&gt;
&lt;li&gt;如果需要支持多平台，事件模块需要考虑如何统一以及区分各平台的具体实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面就这三部分展开Nginx事件处理模块的分析。&lt;/p&gt;
&lt;h1 id=&#34;ngx_event_t&#34;&gt;ngx_event_t&lt;/h1&gt;
&lt;p&gt;描述事件的数据结构，一般至少需要以下几部分数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于保存用户相关的数据。&lt;/li&gt;
&lt;li&gt;用于保存事件触发之后的回调函数。&lt;/li&gt;
&lt;li&gt;用于表示事件状态、类型的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nginx中，描述事件采用的数据结构是ngx_event_t中，其内部成员就是按照前面的三部分来划分了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void *data：事件相关的数据。&lt;/li&gt;
&lt;li&gt;ngx_event_handler_pt handler：事件被触发时的回调函数。&lt;/li&gt;
&lt;li&gt;第三类数据，ngx_event_t中划分的比较仔细：
&lt;ul&gt;
&lt;li&gt;unsigned write:1：可写标志位&lt;/li&gt;
&lt;li&gt;unsigned active:1：活跃标志位&lt;/li&gt;
&lt;li&gt;unsigned disabled:1：禁用标志位&lt;/li&gt;
&lt;li&gt;unsigned eof:1：为1表示字节流已经结束&lt;/li&gt;
&lt;li&gt;unsigned error:1：处理事件出错&lt;/li&gt;
&lt;li&gt;unsigned timedout:1：事件超时&lt;/li&gt;
&lt;li&gt;unsigned timer_set:1：为1表示这是一个超时事件&lt;/li&gt;
&lt;li&gt;unsigned deferred_accept:1：为1表示需要延迟接收TCP连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了以上三部分，还有其他一些重要的数据：
&lt;ul&gt;
&lt;li&gt;ngx_rbtree_node_t timer：红黑树节点，用于实现定时器的，下面讨论定时器再展开。&lt;/li&gt;
&lt;li&gt;ngx_queue_t queue：延迟队列，如果事件不在轮询循环中直接处理，而是之后被处理，就放在这个队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来看，event这个结构体为了涵盖所有可能的事件，做的大而全，不只是用来描述一般的IO事件，还包括了定时器事件，还包括了接收连接相关的数据。&lt;/p&gt;
&lt;h1 id=&#34;定时器的实现&#34;&gt;定时器的实现&lt;/h1&gt;
&lt;p&gt;Nginx内部使用红黑树来实现定时器，目的在于能够快速的查询到哪些定时器超时了。不同的事件结构中，这部分实现采用的数据结构不一样，libevent、libuv采用的是最小堆，redis比较挫，这部分采用的是链表。&lt;/p&gt;
&lt;p&gt;在一个事件循环中，因为既要考虑到一般的IO事件，又要考虑到定时器事件，所以都会以一个最近被触发的定时器来做为查询IO事件被触发的时间，即以下的伪代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;查询最近将被触发的定时器超时时间返回&lt;/span&gt;t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;将&lt;/span&gt;t做为epoll_wait之类的查询IO事件的超时时间&lt;span style=&#34;&#34;&gt;，即最长等待&lt;/span&gt;t时间看有没有IO事件被触发
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;遍历定时器，查询已经超时的定时器进行回调处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从这里可以看出，“迅速查询到距离当前最近被触发的定时器时间”以及“迅速查询到当前哪些定时器超时”，是这个定时器模块速度的关键。&lt;/p&gt;
&lt;p&gt;由于红黑树、最小堆这种平衡数据结构，每次查询都排除掉当前一半的元素，可以做到时间复杂度O(logn)，所以就常用来实现定时器了。&lt;/p&gt;
&lt;h1 id=&#34;事件模块的实现&#34;&gt;事件模块的实现&lt;/h1&gt;
&lt;p&gt;由于nginx需要跑在多个平台下面，而不同平台使用的事件机制又不一样，比如linux是epoll，bsd是kqueue等，需要实现事件模块的时候，既需要统一事件模块的共性部分，又需要区分不同平台的差异部分。&lt;/p&gt;
&lt;p&gt;这看上去又是一个面向对象的设计问题了：基类负责实现共性的部分，子类具体再来实现各平台相关的部分。&lt;/p&gt;
&lt;p&gt;前面&lt;a href=&#34;http://localhost:1313/post/20190123-libuv/#%E6%80%BB%E7%BB%93&#34;&gt;分析libuv&lt;/a&gt;的时候提到过，libuv多使用宏来模拟C++中的继承，不是很认可这个代码风格，来看看nginx类似场景的实现。&lt;/p&gt;
&lt;p&gt;nginx中，将事件相关的操作函数统一放在结构体ngx_event_actions_t中，可以把这部分类比于子类需要实现的函数接口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;add)(ngx_event_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ev, ngx_int_t event, ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;del)(ngx_event_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ev, ngx_int_t event, ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;enable)(ngx_event_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ev, ngx_int_t event, ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;disable)(ngx_event_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ev, ngx_int_t event, ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;add_conn)(ngx_connection_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;del_conn)(ngx_connection_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;c, ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;notify)(ngx_event_handler_pt handler);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;process_events)(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cycle, ngx_msec_t timer,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_uint_t flags);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_int_t  (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;init)(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cycle, ngx_msec_t timer);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;       (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;done)(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cycle);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_event_actions_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;前面在分析到nginx如何解析配置的时候提到过，nginx中的配置是分层次的，event模块做为一个顶层的core模块，内部又有子模块，而这里的事件模块就是event模块中的子模块：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_str_t              &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;                 &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;create_conf)(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cycle);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt;                 &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;init_conf)(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cycle, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;conf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_event_actions_t     actions;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} ngx_event_module_t;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在具体实现中，每个平台的事件模块创建自己的ngx_event_module_t结构，在create_conf、init_conf中完成对事件模块的初始化，然后填充模块的actions结构体。&lt;/p&gt;
&lt;p&gt;最后，具体调用actions结构体中的函数，封装到宏里面，毕竟虽然有多平台的实现，最后也只能用上一个而已：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_process_events   ngx_event_actions.process_events
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_done_events      ngx_event_actions.done
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_add_event        ngx_event_actions.add
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_del_event        ngx_event_actions.del
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_add_conn         ngx_event_actions.add_conn
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_del_conn         ngx_event_actions.del_conn
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define ngx_notify           ngx_event_actions.notify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而前面提到的事件处理部分共性的地方，全都放在函数ngx_process_events_and_timers里，那个函数里面再通过宏ngx_process_events调用具体事件模块的处理函数。&lt;/p&gt;
&lt;p&gt;这里有个细节，其实前面的分析也提到过，nginx的事件模块里，不一定在检查到事件触发之后就会被马上调用回调函数来处理，而是可能放在一个post队列中，在轮询完所有事件之后再进行回调：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (flags &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; NGX_POST_EVENTS) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 有NGX_POST_EVENTS标志位的情况，将accept事件放到ngx_posted_accept_events队列中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 等待后续被回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		queue &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;accept &lt;span style=&#34;color:#666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;ngx_posted_accept_events&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;												: &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_posted_events;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		ngx_post_event(rev, queue);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// 否则直接处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;		rev&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;handler(rev);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-Master Woker进程模型</title>
      <link>https://www.codedump.info/post/20190131-nginx-master-worker/</link>
      <pubDate>Thu, 31 Jan 2019 09:53:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-master-worker/</guid>
      
      <description>&lt;h1 id=&#34;master进程&#34;&gt;master进程&lt;/h1&gt;
&lt;p&gt;Nginx采用的模型是master-worker模型，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由master进程负责创建worker进程，以及监控worker进程的情况，如需要更新配置的情况下发消息给worker进程重新加载配置等。&lt;/li&gt;
&lt;li&gt;master进程负责具体网络事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将里面核心的流程和函数抽取出来，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190131-nginx-master-worker/master-worker.png&#34; alt=&#34;master-worker&#34; title=&#34;master-worker&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master进程的主循环在函数ngx_master_process_cycle中，主要负责：
&lt;ul&gt;
&lt;li&gt;调用ngx_start_worker_processes函数创建worker子进程。&lt;/li&gt;
&lt;li&gt;监控各种信号量的变化做处理，比如需要停止进程、重新加载配置等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;master进程最终会调用函数ngx_spawn_process函数来创建出worker子进程：
&lt;ul&gt;
&lt;li&gt;使用共享内存创建出用于master-worker进程之间通信的channel。&lt;/li&gt;
&lt;li&gt;fork出子进程之后，进入worker进程的主函数ngx_worker_process_cycle。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列举出几个相关的信号量：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号&lt;/th&gt;
&lt;th&gt;对应全局变量&lt;/th&gt;
&lt;th&gt;处理&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;QUIT&lt;/td&gt;
&lt;td&gt;ngx_quit&lt;/td&gt;
&lt;td&gt;优雅关闭整个Nginx服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TERM或者INT&lt;/td&gt;
&lt;td&gt;ngx_terminate&lt;/td&gt;
&lt;td&gt;强制关闭Nginx服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USR1&lt;/td&gt;
&lt;td&gt;ngx_reopen&lt;/td&gt;
&lt;td&gt;重新打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WINCH&lt;/td&gt;
&lt;td&gt;ngx_noaccept&lt;/td&gt;
&lt;td&gt;所有worker进程不再接受新的连接，相当于给子进程发送QUIT信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USR2&lt;/td&gt;
&lt;td&gt;ngx_change_binary&lt;/td&gt;
&lt;td&gt;平滑升级到新的Nginx二进制文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HUP&lt;/td&gt;
&lt;td&gt;ng_reconfigure&lt;/td&gt;
&lt;td&gt;重新加载配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHLD&lt;/td&gt;
&lt;td&gt;ngx_reap&lt;/td&gt;
&lt;td&gt;需要监控所有子进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;worker进程&#34;&gt;worker进程&lt;/h1&gt;
&lt;p&gt;worker进程的函数入口在ngx_worker_process_cycle中，其主要做的工作分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用ngx_process_events_and_timers处理IO事件以及定时器事件。&lt;/li&gt;
&lt;li&gt;判断ngx_terminate、ngx_quit、ngx_reopen这几个变量是否被置位来做相应的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面主要谈网络IO事件的处理，即ngx_process_events_and_timers函数。&lt;/p&gt;
&lt;p&gt;先来介绍几个与接收连接相关的全局变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_use_accept_mutex：由配置项accept_mutex配置，表示是否需要使用accept锁，只有抢到该锁的worker才允许接收新的连接。&lt;/li&gt;
&lt;li&gt;ngx_accept_mutex_delay：由配置项accept_mutex_delay配置，在开启accept_mutex的情况下，一个worker进程在抢不到accept锁的情况下，最长多少时间才重新接收新的连接。&lt;/li&gt;
&lt;li&gt;ngx_accept_disabled：值为ngx_cycle-&amp;gt;connection_n / 8 - ngx_cycle-&amp;gt;free_connection_n，可以看到当链接数量到nginx.conf中配置的worker_connections的7/8以上时，这个变量ngx_accept_disabled为正数，此时不会接收新的连接，直到该值小于等于0为止。&lt;/li&gt;
&lt;li&gt;ngx_accept_mutex_held：表示是否抢到了accept锁，只有抢到的才能接收新连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来看看ngx_process_events_and_timers函数中与接收连接相关的逻辑，伪代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;如果开启了&lt;/span&gt;accept_mutex配置&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;如果当前&lt;/span&gt;ngx_accept_disabled大于0&lt;span style=&#34;&#34;&gt;，表示不能接收新的连接，直接返回。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;否则尝试获取&lt;/span&gt;accept mutex&lt;span style=&#34;&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;如果获取&lt;/span&gt;accept mutex锁成功&lt;span style=&#34;&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;&#34;&gt;将调用事件轮询函数的标志位加上&lt;/span&gt;NGX_POST_EVENTS标志
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;如果获取失败：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;&#34;&gt;调用事件轮询函数的事件参数不得超过&lt;/span&gt;ngx_accept_mutex_delay值&lt;span style=&#34;&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;调用&lt;/span&gt;ngx_process_events函数处理轮询事件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;调用&lt;/span&gt;ngx_event_process_posted(cycle, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_posted_accept_events)&lt;span style=&#34;&#34;&gt;函数处理&lt;/span&gt;accept事件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;如果前面拿到了&lt;/span&gt;accept mutex锁&lt;span style=&#34;&#34;&gt;，则释放这个锁，好让其他&lt;/span&gt;worker也有机会接收新的连接
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;调用&lt;/span&gt;ngx_event_expire_timers处理定时器事件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;&#34;&gt;调用&lt;/span&gt;ngx_event_process_posted(cycle, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_posted_events);&lt;span style=&#34;&#34;&gt;函数处理除了&lt;/span&gt;accept事件以外的其他post事件
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在ngx_process_events处理函数中，当传入的flags有NGX_POST_EVENTS标志时，意味着并不马上在这个函数中调用事件的回调函数进行处理，而是放在一个队列中，回头在后面的ngx_event_process_posted函数中再进行处理。&lt;/p&gt;
&lt;p&gt;而这里的队列分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_posted_accept_events用于存放接收新连接事件。&lt;/li&gt;
&lt;li&gt;ngx_posted_events用于存放除了accept之外的其他事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的做法，是为了将接收新连接的事件优先级放在其他IO事件以及定时器事件之前。&lt;/p&gt;
&lt;p&gt;在下一篇文章，再详细展开事件模块的分析。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-配置解析流程</title>
      <link>https://www.codedump.info/post/20190103-nginx-config-parse/</link>
      <pubDate>Thu, 03 Jan 2019 08:41:44 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190103-nginx-config-parse/</guid>
      
      <description>&lt;p&gt;本系列文章基于openresty-1.13.6.1版本的代码做的笔记，其对应的nginx源码版本是nginx-1.13.6。&lt;/p&gt;
&lt;h1 id=&#34;模块与配置值解析相关数据结构&#34;&gt;模块与配置值解析相关数据结构&lt;/h1&gt;
&lt;p&gt;整个Nginx是以模块的方式来组织的，即使是核心的组件如epoll之类的，最终也是以模块的方式注册到nginx中的。所以先了解整个nginx模块的结构很有必要。&lt;/p&gt;
&lt;p&gt;与模块相关的核心数据结构有以下这几个。&lt;/p&gt;
&lt;p&gt;ngx_module_t结构体用于定义nginx模块相关的数据结构，其中包括几个核心的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void *ctx：用于存储每个模块相关的context数据。&lt;/li&gt;
&lt;li&gt;ngx_command_t *commands：用于存储与该模块相关的配置命令解析数据。所谓的配置命令，就是对应的nginx配置文件中的语句，如”event“、”include“等，每个配置语句最终一定有一个相关的ngx_command_t数据与之对应，负责解析这个命令。&lt;/li&gt;
&lt;li&gt;ngx_uint_t type：用于保存模块的类型，目前包括NGX_HTTP_MODULE，NGX_CORE_MODULE，NGX_CONF_MOULE，NGX_EVENT_MODULE，NGX_MAIL_MODULE这几种类型。&lt;/li&gt;
&lt;li&gt;一组回调函数：用于在解析配置的时候进行回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而上面的ngx_command_t结构体又有以下成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_str_t name：配置文件里对应的配置项名称。如前面提到的nginx配置文件中的”event“、”include“等。&lt;/li&gt;
&lt;li&gt;ngx_uint_t type：配置项类型，这里会存储如该配置项应该出现在什么位置（http块、server块、location块等），以及配置项参数数量，以便于解析过程中进行合法性的判断。
&lt;ul&gt;
&lt;li&gt;命令的作用域，即该命令能够出现在什么位置（http块、server块、location块等），这些与作用域相关的类型有NGX_MAIN_CONF、NGX_EVENT_CONF、NGX_HTTP_MAIN_CONF、NGX_HTTP_SRV_CONF、 NGX_HTTP_LOC_CONF、NGX_MAIL_MAIN_CONF、NGX_MAIL_SRV_CONF 等。&lt;/li&gt;
&lt;li&gt;命令能够接受的参数数量，如NGX_CONF_NOARGS、NGX_CONF_TAKE1等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngx_uint_t offset：该配置命令所要修改的配置项在该模块配置结构体中的偏移量。&lt;/li&gt;
&lt;li&gt;ngx_uint_t conf：该配置在子模块配置项中的索引。&lt;/li&gt;
&lt;li&gt;回调函数set：在解析到配置项的时候进行回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图中给出一个简单的nginx配置文件的作用域示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/ngx-conf-scope.png&#34; alt=&#34;ngx-conf-scope&#34; title=&#34;ngx-conf-scope&#34;&gt;&lt;/p&gt;
&lt;p&gt;有了以上两个核心数据结构，可以知道每个nginx模块注册时的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义一组与本模块相关的ngx_command_t，用于定义本模块相关的配置项信息。&lt;/li&gt;
&lt;li&gt;定义一个与本模块相关的数据结构，注册为ngx_module_t的ctx指针，用于保存本模块相关的数据结构。&lt;/li&gt;
&lt;li&gt;最后，将上面的数据放到ngx_module_t中，nginx解析配置的时候会自动回调对应的处理函数了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以epoll模块来说，其ngx_module_t结构体是如下组织的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/epoll-module.png&#34; alt=&#34;epoll-module&#34; title=&#34;epoll-module&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据上面的图示，不难想象，nginx在配置解析的时候是如何解析epoll相关的配置的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先解析到event模块，也就是nginx配置文件中的event{}部分，此时会把对用的context指针指向ngx_epoll_module_ctx，开始进行event模块的解析工作。&lt;/li&gt;
&lt;li&gt;如果在event块中遇到名为“epoll_events”或者“worker_aio_requests”开始的配置，那么就知道是上面ngx_epoll_commands数组中定义的配置命令，nginx首先会根据这里定义的type来分析其出现的位置（是否出现在event块）以及参数数量（NGX_CONF_TAKE1）是否正确，都检测通过之后，才会调用ngx_command_t中set回调函数进行配置解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解析配置流程&#34;&gt;解析配置流程&lt;/h1&gt;
&lt;h2 id=&#34;相关核心函数&#34;&gt;相关核心函数&lt;/h2&gt;
&lt;p&gt;上面分析到ngx_module_t结构体的时候曾经提到过，当前的type有如下类型：NGX_HTTP_MODULE，NGX_CORE_MODULE，NGX_CONF_MOULE，NGX_EVENT_MODULE，NGX_MAIL_MODULE。&lt;/p&gt;
&lt;p&gt;实际上，nginx的模块类型是一个树形结构，最顶层的是NGX_CORE_MODULE，它下面的子类型是NGX_HTTP_MODULE、NGX_EVENT_MODULE等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/module-tree.png&#34; alt=&#34;module-tree&#34; title=&#34;module-tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果一个结构体是使用树形结构来进行组织的，那么首先会想到的是“递归算法”。&lt;/p&gt;
&lt;p&gt;实际上nginx配置解析，确实也是以递归的方式来进行解析的。仍然是以前面的epoll模块解析为例来说明这个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先解析类型为NGX_CORE_MODULE的顶层模块，由于event模块（即event{}配置块）也是NGX_CORE_MODULE，因此解析到event{}块时会进入event模块相关的配置解析中。&lt;/li&gt;
&lt;li&gt;下面开始进入NGX_EVENT_MODULE这个二层模块的解析中，当遇到epoll相关的指令时，进入epoll模块的解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面可以看到，既然是递归方式来解析的，那么意味着解析配置使用的解析函数是可以被递归调用的，在nginx中这个会被递归调用的核心函数是core/ngx_conf_file.c中的ngx_conf_parse函数。&lt;/p&gt;
&lt;p&gt;在ngx_conf_parse中，会根据传入的filename来区分几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filename不为空：说明是首次调用该函数，此时会打开filename指定的文件名开始解析。&lt;/li&gt;
&lt;li&gt;cf-&amp;gt;conf_file-&amp;gt;file.fd != NGX_INVALID_FILE：说明此时是被递归调用的情况，用于分析一个{}block的内容。&lt;/li&gt;
&lt;li&gt;如果以上情况都不是，说明也是被递归调用的情况，而这时是分析一个参数的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，既然ngx_conf_parse会被递归调用，每次传入的参数就都是一个类型的，被递归调用的时候就需要相应的做修改。&lt;/p&gt;
&lt;p&gt;ngx_conf_parse的函数原型如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;char*
ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到其中有两个入参，其中之一的filename前面已经介绍过了，下面来介绍ngx_conf_t结构体。这个结构体可以认为是解析配置文件过程中为了保存数据的中间数据结构，其重要的几个成员是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ngx_uint_t module_type：模块类型，即前面提到的NGX_HTTP_MODULE，NGX_CORE_MODULE，NGX_CONF_MOULE，NGX_EVENT_MODULE，NGX_MAIL_MODULE。&lt;/li&gt;
&lt;li&gt;ngx_uint_t cmd_type：命令类型，表示指令的作用域。有NGX_MAIN_CONF、NGX_EVENT_CONF、NGX_HTTP_MAIN_CONF、NGX_HTTP_SRV_CONF、 NGX_HTTP_LOC_CONF、NGX_MAIL_MAIN_CONF、NGX_MAIL_SRV_CONF 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在每次递归调用ngx_conf_parse函数之前，调用方都要相应的设置ngx_conf_t结构体这两个成员，好让ngx_conf_parse函数知道当前解析的是哪个模块、在哪个配置作用域中。&lt;/p&gt;
&lt;p&gt;在ngx_conf_parse内部，又会调用ngx_conf_handler来做配置的解析，其主体的代码流程如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;-------------&lt;/span&gt;core&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;ngx_conf_file.c&lt;span style=&#34;color:#666&#34;&gt;-------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_int_t
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_conf_handler(ngx_conf_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cf, ngx_int_t last)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; ngx_modules[i]; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module type checking */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cmd &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;commands;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; ( &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* void */&lt;/span&gt; ; cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;name.len; cmd&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* name comparison */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* namespace checking */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* checking argument numbers */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* set up the directive&amp;#39;s configuration context */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;type &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; NGX_DIRECT_CONF) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx)[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;index];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;type &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; NGX_MAIN_CONF) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;(((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx)[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;index];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        confp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) ((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;conf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (confp) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; confp[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx_index];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      rc &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;set(cf, cmd, conf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数做的主要事情是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取到一条配置指令后，将使用指令名在所有指令中查找对应的ngx_command_t结构体，找到对应的ngx_command_t结构体之后，将进行校验工作：检查模块的类型和当前解析函数上下文的类型是否一致、检查指令的作用域是否包含当前解析函数上下文记录中的作用域、检查参数数量是否和指令中定义的一致。&lt;/li&gt;
&lt;li&gt;校验工作完成后，根据指令类型来找到配置项。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二步值得好好分析一下，毕竟这里是很多人读到这部分代码的困惑。&lt;/p&gt;
&lt;p&gt;前面讲到ngx_module_t结构体的时候，提到其成员ctx用来保存模块相关的context数据。最终这些数据创建成功之后，是保存在ngx_cycle_t.conf_ctx，注意到这是一个void ****类型的指针。&lt;/p&gt;
&lt;p&gt;为什么这是一个四级的void指针？原因在于，nginx模块之间也是分层次的。比如前面提到的模块分层，最顶层是NGX_CORE_MODULE，然后如果解析到event块就到了NGX_EVENT_MODULE模块，如果在event块中再解析到epoll命令，就到了epoll模块中。&lt;/p&gt;
&lt;p&gt;而这些所有的模块，不管在哪一层，最终都是存储在这个ngx_cycle_t.conf_ctx中的，四级指针是它能够接受的最大模块层级。&lt;/p&gt;
&lt;p&gt;但是呢，所有模块都存储在这个数据中，存储读写的时候却不一样：有的配置是有子项目的，比如http块、event块，内部都还有别的指令
，所以在操作这些有子项的指令时，应该拿到它的指针，再到子项中修改指针中的某个成员；有的配置项只顾着自己就好，能从这个conf_ctx中读到自己模块的上下文指针就可以进行操作了。&lt;/p&gt;
&lt;p&gt;从上面的代码里面，可以看到根据命令类型的不同，区分三种不同的配置项存储位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NGX_DIRECT_CONF类型的配置指令：这类型的命令，一定在类型中同时和NGX_MAIN_CONF一起出现，即一个配置命令如果是NGX_DIRECT_CONF类型的，那么它一定也是NGX_MAIN_CONF类型的，反之不然。这类型的指令，指的是在nginx配置文件中只出现在顶层作用域，但是又没有单独block即没有子项目的配置项，比如daemon，master_process这样的指令。这种就是前面提到的只需要顾着自己配置的模块，因此从ctx中提取的时候直接拿出来就好了。&lt;/li&gt;
&lt;li&gt;NGX_MAIN_CONF：在顶层模块而且有子项的配置，都有这个类型，比如http块、event块。因为这些模块还有内部的子项，提取出来的时候要提取出的是指针，内部再解析它们的子项时使用指针来读写操作。&lt;/li&gt;
&lt;li&gt;除了以上两种类型之外，剩下的就是第三种类型的配置命令了。从代码中可以看出，读取这种类型的配置是，首先取出来对应的配置项（没有取配置项的指针），然后在配置中根据配置上下文索引ctx_index再取出对应的配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的说明还是有些抽象，所以还是以例子来进行说明。&lt;/p&gt;
&lt;h2 id=&#34;解析ngx_direct_conf类型指令的例子&#34;&gt;解析NGX_DIRECT_CONF类型指令的例子&lt;/h2&gt;
&lt;p&gt;从最简单的解析NGX_DIRECT_CONF类型的指令开始说起，以daemon指令为例。&lt;/p&gt;
&lt;p&gt;daemon指令属于core模块，因此是首先解析到core模块才到这个模块中的daemon指令的。&lt;/p&gt;
&lt;p&gt;先看core模块的定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_command_t  ngx_core_commands[] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;daemon&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MAIN_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_DIRECT_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_FLAG,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_conf_set_flag_slot,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  offsetof(ngx_core_conf_t, daemon),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_core_module_t  ngx_core_module_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;core&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_core_module_create_conf,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_core_module_init_conf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_module_t  ngx_core_module &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_core_module_ctx,                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module context */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_core_commands,                     &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module directives */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_CORE_MODULE,                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module type */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init module */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1_PADDING
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到其对应的context是ngx_core_module_t类型的指针，首先会调用ngx_core_module_create_conf函数创建这个模块对应的配置数据，这个数据结构就是ngx_core_conf_t，因此在ngx_init_cycle函数中，首先解析core类型模块时，会调用create_conf函数指针创建该模块的上下文数据并且保存下来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_init_cycle&lt;/span&gt;(ngx_cycle_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;old_cycle)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; cycle&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;modules[i]; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cycle&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;type &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; NGX_CORE_MODULE) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		module &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; cycle&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (module&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;create_conf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			rv &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; module&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;create_conf(cycle);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (rv &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				ngx_destroy_pool(pool);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			cycle&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;conf_ctx[cycle&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;index] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; rv;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，cycle-&amp;gt;conf_ctx数组存储的关于core模块的context数据，就是前面ngx_core_module_create_conf函数返回的ngx_core_conf_t结构体。&lt;/p&gt;
&lt;p&gt;接着进入core模块中配置命令的解析。当解析到daemon命令时，因为这个命令的类型是NGX_DIRECT_CONF，因此在ngx_conf_handler函数中，其对应的获取配置存储位置的代码是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;type &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; NGX_DIRECT_CONF) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx)[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;index];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里取出来的conf指针，就是core模块最开始创建的ngx_core_conf_t结构体指针。&lt;/p&gt;
&lt;p&gt;而daemon指令的ngx_command_t是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{ ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;daemon&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	NGX_MAIN_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_DIRECT_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_FLAG,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ngx_conf_set_flag_slot,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	offsetof(ngx_core_conf_t, daemon),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;daemon指令对应的set函数是ngx_conf_set_flag_slot。&lt;/li&gt;
&lt;li&gt;该指令修改的数据，在ngx_core_conf_t结构体的daemon成员，即用offsetof(ngx_core_conf_t, daemon)来表示这个数据在该结构体中的偏移量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把以上的分析总结下来就是下图所示的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/core-daemon.png&#34; alt=&#34;core-daemon&#34; title=&#34;core-daemon&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;解析ngx_main_conf类型指令的例子&#34;&gt;解析NGX_MAIN_CONF类型指令的例子&lt;/h2&gt;
&lt;p&gt;以event命令为例，来说明NGX_MAIN_CONF类型指令的解析。&lt;/p&gt;
&lt;p&gt;event命令对应的模块相关结构体如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_command_t  ngx_events_commands[] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;events&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NGX_MAIN_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_BLOCK&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_NOARGS,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_events_block,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_null_command
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_core_module_t  ngx_events_module_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;events&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_event_init_conf
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_module_t  ngx_events_module &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_events_module_ctx,                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module context */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_events_commands,                   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module directives */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_CORE_MODULE,                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module type */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init module */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1_PADDING
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，该模块对应的create_conf函数为NULL，而其取配置的存储位置是取其指针：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;type &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt; NGX_MAIN_CONF) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;(((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx)[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;index];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在event命令的回调set函数ngx_events_block，就将event模块对应的ctx存入进来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00a000&#34;&gt;ngx_events_block&lt;/span&gt;(ngx_conf_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cf, ngx_command_t &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;cmd, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;conf)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) conf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;is duplicate&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* count the number of the event modules and set up their indices */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ngx_event_max_module &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_count_modules(cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;cycle, NGX_EVENT_MODULE);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_pcalloc(cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pool, &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ngx_pcalloc(cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;pool, ngx_event_max_module &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ctx; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该函数的主要工作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;既然前面conf = &amp;amp;(((void **) cf-&amp;gt;ctx)[ngx_modules[i]-&amp;gt;index]传入了模块ctx的指针，所以首先判断该指针存放值是否为空，不为空意味着前面已经解析过event命令了，因此这是一个重复配置，将报错退出。&lt;/li&gt;
&lt;li&gt;ctx初始化为一个void&lt;em&gt;型数据的指针，而该指针保存的是一个有ngx_event_max_module个void&lt;/em&gt;型数据的数组。&lt;/li&gt;
&lt;li&gt;最后将ctx写入传入的event模块配置context中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样的，将以上分析event模块的流程总结下来，形成的就是下面的数据结构图：
&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/event-module.png&#34; alt=&#34;event-module&#34; title=&#34;event-module&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到event模块的context最终是一个存储void*数据的指针。原因在于：event模块中又会存储一些不同的数据类型，这些数据最终都保存在这个数组中。&lt;/p&gt;
&lt;p&gt;不仅是event模块是这样，http模块的上下文结构存储的也是一个数组，都是因为这些模块都还有从属于它们的子模块。&lt;/p&gt;
&lt;h2 id=&#34;解析其它类型指令的例子&#34;&gt;解析其它类型指令的例子&lt;/h2&gt;
&lt;p&gt;有了以上的准备，最后来讲解最后一种类型指令的解析，这种类型既不是NGX_DIRECT_CONF类型，也不是NGX_MAIN_CONF类型，因为这类型指令属于从属于某个NGX_CORE_MODULE内部的配置命令，如epoll模块，下面就以这个模块做为例子来分析。&lt;/p&gt;
&lt;p&gt;而这个类型是这样来读取配置项存储位置的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;confp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;**&lt;/span&gt;) ((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;) cf&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; cmd&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;conf);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (confp) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  conf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; confp[ngx_modules[i]&lt;span style=&#34;color:#666&#34;&gt;-&amp;gt;&lt;/span&gt;ctx_index];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明一下上面的代码：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先使用confp = *(void **) ((char *) cf-&amp;gt;ctx + cmd-&amp;gt;conf);取到该模块的配置，注意这里取的并不是指针而是指针存储的数据位置，以event模块来说，就是前面在ngx_events_block函数中创建的数组。另外需要注意的是，这里是使用cmd-&amp;gt;conf做为该数组的索引，ngx_command_t的conf成员就是存储某一个子模块（这里是epoll模块）在所属模块（这里是event模块，epoll模块从属于event模块）配置数组中的索引的。&lt;/li&gt;
&lt;li&gt;接下来，根据模块的ctx_index索引在该数组中找到该模块真正的存储位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以该模块的epoll_events命令为例，其与配置解析相关的数据如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_command_t  ngx_epoll_commands[] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { ngx_string(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;epoll_events&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NGX_EVENT_CONF&lt;span style=&#34;color:#666&#34;&gt;|&lt;/span&gt;NGX_CONF_TAKE1,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ngx_conf_set_num_slot,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    offsetof(ngx_epoll_conf_t, events),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; ngx_event_module_t  ngx_epoll_module_ctx &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;epoll_name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_epoll_create_conf,               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* create configuration */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_epoll_init_conf,                 &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init configuration */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngx_module_t  ngx_epoll_module &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;ngx_epoll_module_ctx,               &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module context */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ngx_epoll_commands,                  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module directives */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_EVENT_MODULE,                    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* module type */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init module */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* init thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit thread */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit process */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;,                                &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* exit master */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  NGX_MODULE_V1_PADDING
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从以上结构体可以看出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create_conf回调函数是ngx_epoll_create_conf，该函数创建了ngx_epoll_conf_t类型的结构存储起来，这个类型就是epoll模块的context数据。该数据最终就是存储到event模块数组中，其索引是ctx_index。&lt;/li&gt;
&lt;li&gt;epoll_events命令通过offsetof(ngx_epoll_conf_t, events)来做为ngx_epoll_conf_t类型中的偏移量来修改该类型中的成员，对应的修改函数是ngx_conf_set_num_slot。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样的，将以上分析epoll模块的流程总结下来，形成的就是下面的数据结构图：
&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/epoll-module-struct.png&#34; alt=&#34;epoll-module-struct&#34; title=&#34;epoll-module-struct&#34;&gt;&lt;/p&gt;
&lt;p&gt;而在最顶层，开始从NGX_CORE_MODULE类型模块进行解析的解析配置入口函数则是core/ngx_cycle.c中的ngx_init_cycle函数，其做的事情最核心的就是初始化ngx_conf_t结构体，将module_type设置为最顶层的模块NGX_CORE_MODULE，cmd_type设置为NGX_MAIN_CONF，接着就调用ngx_conf_parse函数进行配置解析了，这就开启了整个解析Nginx配置的流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/config-parse.png&#34; alt=&#34;config-parse&#34; title=&#34;config-parse&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在解析配置的入口函数ngx_init_cycle中，将ngx_conf_t的module_type类型初始化为NGX_CORE_MODULE，而cmd_type初始化为NGX_MAIN_CONF，这就是解析配置的起点。在接下来对ngx_conf_parse函数的调用中，该函数就会查找module_type和cmd_type都对应的模块，比如event、http这样的模块。&lt;/li&gt;
&lt;li&gt;解析到event命令时，进入event模块的解析，此时就会将module_type变成NGX_EVENT_MODULE，以及把cmd_type变为NGX_EVENT_CONF
，这样再调用ngx_conf_parse函数时就只会查询event模块的配置命令了。&lt;/li&gt;
&lt;li&gt;http模块的解析过程类似，不再阐述。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有的模块信息，保存在ngx_cycle_t结构体的conf_ctx中，从类型来看是一个void****的四级指针，如果解析到的模块又有自己内部的子模块ctx数据，那么就会继续存放到这个模块之中，比如epoll模块就是event模块的子模块。总体来看结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20190103-nginx-config-parse/ngx-conf-chart.png&#34; alt=&#34;ngx-conf-chart&#34; title=&#34;ngx-conf-chart&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ialloc.org/blog/ngx-notes-conf-parsing/&#34;&gt;Nginx 源代码笔记 - 配置文件解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
