<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codedump的网络日志 on codedump的网络日志</title>
    <link>https://www.codedump.info/</link>
    <description>Recent content in codedump的网络日志 on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 11 Feb 2022 22:27:57 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>博客系列文章索引</title>
      <link>https://www.codedump.info/post/20200122-series-pages/</link>
      <pubDate>Wed, 22 Jan 2020 14:36:00 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200122-series-pages/</guid>
      <description>

&lt;p&gt;在博客已经写了很多文章了，有一些文章独立成体，有一些则是系列文章来讲述一个主题，在这里将这些系列文章整理下来，本页面将不定期更新。&lt;/p&gt;

&lt;h1 id=&#34;linux系统相关&#34;&gt;Linux系统相关&lt;/h1&gt;

&lt;h2 id=&#34;面向应用开发者的系统指南&#34;&gt;面向应用开发者的系统指南&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&amp;amp;目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;基础篇&#34;&gt;基础篇&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200128-systemtap-by-example/&#34;&gt;通过实例快速入门Systemtap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200218-linux-traceevent/&#34;&gt;Systemtap中内核trace事件的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cpu篇&#34;&gt;CPU篇&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200502-sgfap-process/&#34;&gt;进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-schedule/&#34;&gt;进程调度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-systemtap/&#34;&gt;使用systemtap分析进程的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200516-sgfap-syscall/&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;&gt;软中断&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;分布式相关&#34;&gt;分布式相关&lt;/h1&gt;

&lt;h2 id=&#34;etcd及raft原理&#34;&gt;etcd及Raft原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210628-etcd-wal/&#34;&gt;Etcd Raft库的日志存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211011-raft-propose-prev-term/&#34;&gt;为什么Raft协议不能提交之前任期的日志？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/&#34;&gt;etcd 3.5版本的joint consensus实现解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;

&lt;h2 id=&#34;理论基础&#34;&gt;理论基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sqlite&#34;&gt;sqlite&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;leveldb&#34;&gt;leveldb&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190215-leveldb/&#34;&gt;Leveldb代码阅读笔记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;boltdb&#34;&gt;boltdb&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200625-boltdb-1/&#34;&gt;boltdb 1.3.0实现分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200711-boltdb-2/&#34;&gt;boltdb 1.3.0实现分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200725-boltdb-3/&#34;&gt;boltdb 1.3.0实现分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200726-boltdb-4/&#34;&gt;boltdb 1.3.0实现分析（四）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;缓存服务&#34;&gt;缓存服务&lt;/h1&gt;

&lt;h2 id=&#34;memcached&#34;&gt;memcached&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210701-memcached/&#34;&gt;Memcached的存储原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210812-memcached/&#34;&gt;Memcached的存储原理解析（续）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;系统设计相关&#34;&gt;系统设计相关&lt;/h1&gt;

&lt;h2 id=&#34;im服务器设计&#34;&gt;IM服务器设计&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190608-im-design-base/&#34;&gt;IM服务器设计-基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190608-im-msg-storage/&#34;&gt;IM服务器设计-消息存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190818-im-msg-gate/&#34;&gt;IM服务器设计-网关接入层 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191013-im-msg-out-of-order/&#34;&gt;IM服务器设计-如何解决消息的乱序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;服务调用&#34;&gt;服务调用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190629-service-history/&#34;&gt;服务调用的演进历史&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;多核编程&#34;&gt;多核编程&lt;/h1&gt;

&lt;h2 id=&#34;内存模型&#34;&gt;内存模型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191214-cxx11-memory-model-1/&#34;&gt;C++11中的内存模型上篇 - 内存模型基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191214-cxx11-memory-model-2/&#34;&gt;C++11中的内存模型下篇 - C++11支持的几种内存模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;源码解析类&#34;&gt;源码解析类&lt;/h1&gt;

&lt;h2 id=&#34;etcd&#34;&gt;Etcd&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;nginx-openresty&#34;&gt;Nginx &amp;amp;&amp;amp; OpenResty&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190103-nginx-config-parse/&#34;&gt;Nginx源码阅读笔记-配置解析流程 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-master-worker/&#34;&gt;Nginx源码阅读笔记-Master Woker进程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-event/&#34;&gt;Nginx源码阅读笔记-事件处理模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-read-http-request/&#34;&gt;Nginx源码阅读笔记-接收HTTP请求流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190212-nginx-http-config/&#34;&gt;Nginx源码阅读笔记-查询HTTP配置流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190213-nginx-process-http-request/&#34;&gt;Nginx源码阅读笔记-处理HTTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190214-nginx-memory-pool/&#34;&gt;Nginx源码阅读笔记-内存池的设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190501-lua-stream/&#34;&gt;OpenResty Lua Stream实现分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;zeromq&#34;&gt;Zeromq&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190209-zeromq-lockfree-queue/&#34;&gt;zeromq所谓的“无锁消息队列”&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190409-redis-sentinel/&#34;&gt;redis高可用原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;glog&#34;&gt;Glog&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190729-glog/&#34;&gt;glog C++版本代码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;libuv&#34;&gt;Libuv&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190123-libuv/&#34;&gt;Libuv代码简单分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;读书笔记&#34;&gt;读书笔记&lt;/h1&gt;

&lt;h2 id=&#34;数据密集型应用系统设计&#34;&gt;《数据密集型应用系统设计》&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181118-ddia-chapter05-replication/&#34;&gt;《数据密集型应用系统设计》第五章数据复制笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181124-ddia-chapter06-partitioning/&#34;&gt;《数据密集型应用系统设计》第六章数据分区笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190403-ddia-chapter07-transaction/&#34;&gt;《数据密集型应用系统设计》第七章《事务》笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190405-ddia-chapter08-the-trouble-with-distributed-system/&#34;&gt;《数据密集型应用系统设计》第八章《分布式系统的挑战》笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/&#34;&gt;《数据密集型应用系统设计》第九章《一致性与共识》笔记 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;杂&#34;&gt;杂&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190324-how-to-read-code/&#34;&gt;如何阅读一份源代码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200605-how-to-read-code-v2020/&#34;&gt;如何阅读一份源代码？（2020年版）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>周刊（第5期）：从存储模型聊一聊时序数据库的应用场景</title>
      <link>https://www.codedump.info/post/20220211-weekly-5/</link>
      <pubDate>Fri, 11 Feb 2022 22:27:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220211-weekly-5/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;引言：本期介绍时序数据库的存储模型，只有理解了时序数据的存储模型，才能更好的了解时序数据库的优缺点以及其适用场景。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;从存储模型聊一聊时序数据库的应用场景&#34;&gt;从存储模型聊一聊时序数据库的应用场景&lt;/h1&gt;

&lt;p&gt;想写本文，是因为看到了知乎上的一篇文章：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/453556881&#34;&gt;投资数据库领域：2021年总结（NoSQL、图、时序） - 知乎&lt;/a&gt;，里面谈到了时序数据库：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;但缺陷是实际的市场空间较小。跟通用型数据库，尤其是OLAP数据库相比，时序数据库最大的差异点在于对于时间维度建立了独特的索引与优化，而其他所谓schemaless等特性在OLAP数据库上都能做到，不存在技术障碍。这也就是为什么其实在公司做时序场景的数据库选型的时候会直接将时序数据库与一些OLAP数据库（比如ClickHouse）做比较。如果要把时序数据库往更宽的场景发展，那就是想好如何与那么多的通用型数据库做竞争了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于之前有过短暂一段时间的时序数据库从业经历，所以想从我的理解聊聊时序数据库的应用场景。&lt;/p&gt;

&lt;p&gt;要了解应用场景，需要首先对时序数据库的存储模型有个大概的了解，在下文中我尽量不涉及到太艰深的技术术语来描述我的理解。由于我从业时序数据库的时间并不长，所以有可能理解会有偏差。&lt;/p&gt;

&lt;p&gt;何谓“时序数据（time-series data）”？就我个人粗浅的理解，就是任何一定会带上时间戳（timestamp）维度的数据。日常生活里，在微博、微信等社交媒体的发现就可以理解时序数据，因为它们肯定都有一个发言时间，所以有时候会把个人看到的微博等称为“时间线（timeline）”。对应到工业领域，比如一个电表每小时上报的用电量也是时序数据，比如服务器监控时每隔15分钟采集的性能数据也是时序数据。&lt;/p&gt;

&lt;p&gt;由于时序数据天然有“时间“这个维度，为了更好的优化其写入性能，通常专门存储时序数据的存储引擎会按照时间分块、按列来存储数据，如下图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220211-weekly-5/time-series-model.png&#34; alt=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; title=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;上图中，演示用的数据格式有三列：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时间戳。&lt;/li&gt;
&lt;li&gt;A指标。&lt;/li&gt;
&lt;li&gt;B指标。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常，时序数据库存储时，会按照时间来划分块（block）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;块的大小固定。&lt;/li&gt;
&lt;li&gt;在同一个块时间区的数据，会存储到同一个块中。&lt;/li&gt;
&lt;li&gt;而块内部，将除了时间维度之外的其他的列，将其中相同列的数据存储在一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做的好处是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于时序数据的特点，写入的数据也是在时间上连续的，因此通常写入的时候按照上面的设计就能落在同一个块中。&lt;/li&gt;
&lt;li&gt;不同行但是同一列的数据，都是相同类型的，将相同类型的数据紧邻放在一起，更容易进行压缩。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;换言之，这样做换来的好处是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在时序数据的写入场景下，写入速度很快。&lt;/li&gt;
&lt;li&gt;由于同类型数据放在一起，压缩性能也很好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些都是相对于传统BTree类存储引擎而言的，因为这类型的数据写入更像append操作，这是必然会更快的。&lt;/p&gt;

&lt;p&gt;但是注意到没有，这样存储数据之后，最大的问题是：查询时只有时间这个维度做了索引，而除去时间维度之外的其他列都没有做索引。&lt;/p&gt;

&lt;p&gt;这样导致的问题是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任何查询都要带上时间参数才能管用。比如：“请查询过去一个小时里哪五分钟的CPU最高”这样的查询是可以的，但是更多其他的查询是不知道时间维度，或者说查询者就是不知道具体时间才想来查询的，比如“我是什么时候达成了累计跑步100公里成就的？”这类探索型、且没有时间维度的查询。&lt;/li&gt;
&lt;li&gt;即便是带上了时间维度的查询可行，由于没有对其他维度做索引，所以查询时的处理，更多的是按照时间维度查询出数据、再进行聚合计算，比如上面的“请查询过去一个小时里哪五分钟的CPU最高”这个查询，只能先把过去一小时的CPU数据全部查出来，然后逐个计算才能算出哪5分钟的CPU最高了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结下来：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时序数据库根据时序数据的特点设计和优化了时序数据库的存储模型，对比传统的关系数据库存储模型来说，优势是写入速度快、压缩比高。&lt;/li&gt;
&lt;li&gt;但这样的存储只有时间这个维度，换言之由于没有其他维度的索引数据，导致对不带有时间维度或者时间跨度大的查询支持的不够友好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到最开始引用的文章，了解了时序数据库的存储特点，也就能解释为何作者认为纯粹的时序数据库场景不大了。&lt;/p&gt;

&lt;p&gt;好像大部分时候，事情也是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在一个维度优化到极致，可能其他维度就做的不够好，不存在各个维度都能做得很好的产品，因为不同维度之间也会彼此有制约，更多时候要看使用者自己的场景取舍，并不存在适用于一切场景的产品。&lt;/li&gt;
&lt;li&gt;所谓”优势“，在换了上下文和场景之后，也可能会变成劣势。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;相关推荐&#34;&gt;相关推荐&lt;/h1&gt;

&lt;h2 id=&#34;writing-a-time-series-database-from-scratch-fabian-reinartz-https-fabxc-org-tsdb&#34;&gt;&lt;a href=&#34;https://fabxc.org/tsdb/&#34;&gt;Writing a Time Series Database from Scratch | Fabian Reinartz&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;项目的核心开发者写的文章，介绍了如何从头实现一个时序数据库的存储引擎，可做为上面文章更深入的补充。&lt;/p&gt;

&lt;h2 id=&#34;阿里云数据库内核月报分类整理-https-github-com-tangwz-db-monthly&#34;&gt;&lt;a href=&#34;https://github.com/tangwz/db-monthly&#34;&gt;阿里云数据库内核月报分类整理&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;阿里云数据库内核团队的月报提供了很多学习数据库技术的资料、文章，这个github将每个月的月报进行了分类整理，推荐收藏。&lt;/p&gt;

&lt;h2 id=&#34;how-does-a-database-work-let-s-build-a-simple-database-https-cstack-github-io-db-tutorial&#34;&gt;&lt;a href=&#34;https://cstack.github.io/db_tutorial/&#34;&gt;How Does a Database Work? | Let’s Build a Simple Database&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;自己动手打造一个简单的数据库，应该有很多地方参考了&lt;a href=&#34;https://sqlite.org/index.html&#34;&gt;SQLite&lt;/a&gt;的实现，本博客也深度解析了sqlite的btree实现，见：&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;上面这个项目是使用C语言实现的，类似的打造简易数据库来学习原理的项目还有其他语言的版本：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java版本：&lt;a href=&#34;https://github.com/awelm/simpledb&#34;&gt;awelm/simpledb: A simple database built from scratch that has some the basic RDBMS features (SQL query parser, transactions, query optimizer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust版本：&lt;a href=&#34;https://github.com/erikgrinaker/toydb&#34;&gt;erikgrinaker/toydb: Distributed SQL database in Rust, written as a learning project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;

&lt;h2 id=&#34;河西走廊-https-movie-douban-com-subject-24736278&#34;&gt;&lt;a href=&#34;https://movie.douban.com/subject/24736278/&#34;&gt;《河西走廊 》&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;非常棒的介绍河西走廊的历史纪录片，2017年在甘肃旅游，就是一路沿着河西走廊过来的，一边旅游一边看这部纪录片。&lt;/p&gt;

&lt;h2 id=&#34;浮生一日-https-space-bilibili-com-110930331&#34;&gt;&lt;a href=&#34;https://space.bilibili.com/110930331&#34;&gt;《浮生一日》&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;B站上纯纯甘的节目《浮生一日》是我每期都会看的节目，主题是每次采访跟踪一个不同行业素人的生活。&lt;/p&gt;

&lt;p&gt;最开始知道这个栏目是看了&lt;a href=&#34;https://www.bilibili.com/video/BV1V54y1h7Zr?spm_id_from=333.999.0.0&#34;&gt;【浮生一日】北京国企外卖小哥的真实一天&lt;/a&gt;，背景是这位小哥由于疫情原因失业，所以找了一份国企的工作；媳妇买P2P赔光了积蓄，赶上老人得病要治疗，所以晚上得出来兼职跑跑外卖。&lt;/p&gt;

&lt;p&gt;里面有句话让我感动：“结婚时面对自己媳妇儿最漂亮的时候，你说我愿意和你同甘共苦，然后现在又开始责怪她，那当初又何必说这四个字呢？”&lt;/p&gt;

&lt;p&gt;这个栏目里还有各色不同职业的人：程序员、投资者、早餐摊位主人&amp;hellip;等等。&lt;/p&gt;

&lt;p&gt;不同的职业，都有各自不同的生活轨道和选择。&lt;/p&gt;

&lt;p&gt;油管上有&lt;a href=&#34;https://www.youtube.com/channel/UCIs3-LcOCdpiGve6yu1-Fug&#34;&gt;同名频道&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;porter-io-porter-io&#34;&gt;&lt;a href=&#34;porter.io&#34;&gt;porter.io&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;porter.io是基于Github关注项目推荐相关文章发送邮件通知的应用：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“We analyse your Github footprint, filter Hacker News items according to your taste, and deliver them to your mailbox.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我听过这个应用，还是被推荐才看到了不少有价值的文章的的。&lt;/p&gt;

&lt;h2 id=&#34;独立开发变现周刊-https-www-ezindie-com-weekly&#34;&gt;&lt;a href=&#34;https://www.ezindie.com/weekly&#34;&gt;独立开发变现周刊&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;每周更新推荐一些独立开发变现的产品。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>周刊（第4期）：为什么我还在看中国足球</title>
      <link>https://www.codedump.info/post/20220204-weekly-4/</link>
      <pubDate>Fri, 04 Feb 2022 21:55:23 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220204-weekly-4/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;引言：虎年大年初一的晚上，一场脆败发生在世界杯亚洲区预选赛中国客场对越南队的比赛上。如今，“你居然还在看中国男足”，仿佛已成一句骂人的质问。本期从我角度来谈谈，我眼中的中国足球，以及说说我为什么还一直在关注这个领域。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;我为什么还在看中国足球&#34;&gt;我为什么还在看中国足球&lt;/h1&gt;

&lt;p&gt;我从94年开始看球，中国足球绝大部分的重要比赛都看了：94年亚运会决赛输给乌兹别克斯坦、97年大连金州被伊朗逆转、2002年世界杯出线&amp;hellip;太多了，数不过来，算是从我开始看球之后就一直有关注中国足球。&lt;/p&gt;

&lt;p&gt;在看国足比赛二十多年之后，慢慢地从一个参与者、评论者的角色，切换到了近似于第三方视角的观察者角色。切换到这个视角之后，让我能从里面各种情绪里抽离出来，当然高兴的时候也会像个普通球迷那样欢乐，比如2017年世界杯预选赛击败韩国这样的比赛。&lt;/p&gt;

&lt;p&gt;我国虽然在奥运会上取得了看似很好的成绩，金牌数总是保持前列，但是有一说一，并不算是体育大国，更别提强国了。&lt;/p&gt;

&lt;p&gt;只看我们占优势、能取得好成绩的项目，大多有这样的特点：小众、冷门，这样的特点直接导致这样的项目，实际是商业化程度很低的领域。这样的领域，国外参与的人不会太多，也因此可以继续沿用以前我们擅长的打法：集中力量办大事，换到体育这个领域，就是所谓的“举国体制”。&lt;/p&gt;

&lt;p&gt;这样做的好处是，能用较少的资源拿到不错的效果，因为大部分人只关注金银牌这些数字，并不关心你怎么拿到的。这个策略，用知乎上一个回答的话来说叫“田忌赛马”，见：&lt;a href=&#34;https://www.zhihu.com/question/414037344/answer/1713991758&#34;&gt;为什么中国的其他运动项目那么强，到了男足这里就不行呢？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在商业化、职业化很好的体育项目，比如足球、篮球、网球等等领域，我们的成绩就不这么好了，李娜、姚明、刘翔是少数在这些领域拿得出手的世界级运动员。（后面会专门谈谈女足）&lt;/p&gt;

&lt;p&gt;一言以蔽之：举国体制从目前的成绩来看，并不适合职业化、商业化很好的体育项目。&lt;/p&gt;

&lt;p&gt;“足球是体育工业化的集大成者”（见&lt;a href=&#34;https://www.zhihu.com/question/310636566/answer/1720809481&#34;&gt;(为什么整个中国都知道中国足球的问题，为什么还是没有办法解决？ - 知乎&lt;/a&gt;），所以它不像其他领域那样，需要长期的积累和基础。&lt;/p&gt;

&lt;p&gt;所以，男足的存在，在我看来更多像是一个“大型的社会实验”，我在这个实验中，看到不同的政策、体制、行政干预、市场行为等对这个运动的影响，看到各方参与者、评论者、媒体的所作所为，从中能看到某些我们社会的缩影。&lt;/p&gt;

&lt;p&gt;男足也是“客观规律”的具象化代言人（见&lt;a href=&#34;https://weibo.com/1573046985/Ldz5zvYdY&#34;&gt;中国男足挺好的，理直&amp;hellip; - @祝佳音的微博 - 微博&lt;/a&gt;）：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;男足不跟你讲这些虚的，不按科学规律办事就是不行。给钱诱惑也不行，立规矩骂人也不行，做思想工作说服不行，临时加班加练也不行。富贵不能淫威武不能屈，不行就是不行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相对其他很多领域，足球的成绩更透明、公开，足球运动一直在提醒我要尊重“客观规律”。&lt;/p&gt;

&lt;p&gt;足球在中国，属于“参与度很低，但是关注度高”的体育项目。在这样的领域：看起来中超火爆的时候现场能有几万球迷现场观赛，看起来花了很多钱、投入了很多人力，但是只要没有按照足球的“客观规律”办事，成绩马上就能打脸，公开透明。&lt;/p&gt;

&lt;p&gt;规则透明、结果公开，等等这些都是我一直还在关注这个“大型社会实验”的原因。&lt;/p&gt;

&lt;h2 id=&#34;番外&#34;&gt;番外&lt;/h2&gt;

&lt;p&gt;番外篇里，试图简单科普关于中国足球相关的几个常见问题。&lt;/p&gt;

&lt;h3 id=&#34;14亿人里为什么就选不出11个能踢球的人&#34;&gt;“14亿人里为什么就选不出11个能踢球的人？”&lt;/h3&gt;

&lt;p&gt;这是最常见的问题了，用类比的方式试图回答一下，这就好比问：“这么大一块沙漠为什么就种不出几棵树来？”。显然很多人并没有意识到，我国在足球从业人员领域属于“沙漠”，只是看起来热闹，仅此而已。&lt;/p&gt;

&lt;p&gt;我们的选材不是从14亿里选，而是足球注册球员里面选（中国好像只有几万足球从业人口），这个基数对比足球发达国家差的很多。&lt;/p&gt;

&lt;h3 id=&#34;怎么看待女足的成绩比男足好这么多&#34;&gt;怎么看待女足的成绩比男足好这么多？&lt;/h3&gt;

&lt;p&gt;女足有过比男足更光辉的历史：奥运会银牌、世界杯亚军。但是需要认识到，这些成绩的取得，已经年代久远，距离现在有20多年了。&lt;/p&gt;

&lt;p&gt;取得这些成绩很大的原因是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于宗教、妇女地位等原因，参与女足运动的国家并不多。&lt;/li&gt;
&lt;li&gt;当时职业化的女足并不多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如在亚洲，男足要打世界杯预选赛、亚洲杯决赛这样的比赛，都要先进行一轮预选赛，因为有50多个国家参与；而女足对应的比赛，则无需预选赛，因为参与的队伍实在不多，比如一大批相对落后的国家派不出女足，比如阿拉伯国家也不让女足参赛（这次女足亚洲杯伊朗倒是参赛了）。&lt;/p&gt;

&lt;p&gt;另外，说到女足职业化。随着欧美女足职业联赛的发展，她们的水平提高了很多，此消彼长，这就是后来北京奥运会、东京奥运会大比分输球，以及世界排名一路滑到19名的原因。&lt;/p&gt;

&lt;p&gt;做一个可能不正确的类比：10个人参加的比赛里，取得第3名的成绩，确实比50个人参加的比赛里取得第10名，看起来好看一些。&lt;/p&gt;

&lt;p&gt;但是，即便抛开职业化、商业化、参赛队伍基数等因素，有一说一，女足的精气神确实比男足要高出一大截来，尤其在春节密集得看了几场男足、女足的比赛对比就更明显了。&lt;/p&gt;

&lt;p&gt;豆瓣上有人整理了本届女足亚洲杯现役国家队成员的介绍：&lt;a href=&#34;https://www.douban.com/group/topic/258215115/?_dtcc=1&amp;amp;_i=4158490DTua3Gc&#34;&gt;中国女足现役国家队队员介绍（亚洲杯来了）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;是否一定要-搞好足球&#34;&gt;是否一定要“搞好足球”？&lt;/h3&gt;

&lt;p&gt;这个问题见仁见智，我不认为一定有“搞好足球”的必要，毕竟比这个事情重要的事情还有很多，“足球”也并不能代表一个国家的综合国力。&lt;/p&gt;

&lt;p&gt;我比较同意知乎这个回答里的几段话：&lt;a href=&#34;https://www.zhihu.com/question/310636566/answer/1830192531&#34;&gt;为什么整个中国都知道中国足球的问题，为什么还是没有办法解决？ - 知乎&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;因为和整个国家要解决的问题来比，中国足球不重要。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;有基建重要吗？有国防重要吗？有教育重要吗？有医疗重要吗？有扶贫攻坚重要吗？有抗击疫情重要吗？……三百六十行，至少得有三百行排在竞技体育前面好不好？&lt;/p&gt;

&lt;p&gt;中国人喜欢足球吗？中国人只喜欢看足球，而且是可有可无的那种喜欢。真喜欢踢，投身足球事业的不会只有这么点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是不同意回答里的这句话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;中国足球的问题不是没有办法解决，要解决中国足球的问题，集国家力量有一万种办法解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;毕竟我们还从来没有解决过，实事求是。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结一下我的观点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;足球属于商业化、职业化程度很高的竞技体育项目，“举国体制”从目前来看不适用于这样的领域。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;足球在中国属于“参与度低、关注度高”的项目，看着很热闹，实际真正参与、从业的人并不多。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为早期我们只关注奥运会的金银牌，所以集中力量发展冷门项目更容易出成绩。大部分人只关注简单的数字、金银牌，不会关注背后的难易程度，“10个人参加的比赛里，取得第3名的成绩，确实比50个人参加的比赛里取得第10名，看起来好看一些。”&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我并不认为，有一定要“搞好足球”的必要性，至少现在没有，因为还有更重要的事情需要做。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;足球在我看来是“大型社会实验”，是“客观规律的具象代言人”，规则透明、结果公开，所以我一直关注这个领域。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;只此青绿-千里江山图-和王希孟&#34;&gt;《只此青绿》、《千里江山图》和王希孟&lt;/h1&gt;

&lt;p&gt;虎年春晚个人认为最好的节目是脱胎于传世名画&lt;a href=&#34;https://baike.baidu.com/item/%E5%8D%83%E9%87%8C%E6%B1%9F%E5%B1%B1%E5%9B%BE/386355&#34;&gt;《千里江山图》&lt;/a&gt;的舞剧&lt;a href=&#34;https://www.youtube.com/watch?v=OZlUvIV50Ww&#34;&gt;《只此青绿》&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;最近几年看了好几个讲述《千里江山图》的纪录片，比如&lt;a href=&#34;https://www.youtube.com/watch?v=UYz1njDuqr4&#34;&gt;[国家宝藏]王希孟《千里江山图》卷&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;宋徽宗赵佶固然是一个糟糕的皇帝，历史惨案“靖康之耻”大半的锅都是他的。但是也不能否认他在艺术上的成就，发掘、培养了天才少年王希孟，才能最后让《千里江山图》传世千年。可惜的是，王希孟就这一幅作品，后世再没有关于这个人的更多资料了。&lt;/p&gt;

&lt;p&gt;赵佶后来把这幅画赏赐给了蔡京，蔡京跋里能勉强看到一些王希孟作画时的信息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;此卷政和三年閏四月一日賜。希孟年十八嵗，昔在畫學為生徒，召入禁中文書庫，數以畫獻，未甚工。上知其性可教，遂誨諭之，親授其法，不踰半嵗，乃以此圖進，上嘉之，因以賜臣京，謂天下士在作之而已。今希孟已死，展卷深為悼惜。政和五年季春望太師魯國公臣京謹記&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这几句话里交代了几个信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;王希孟作画的时候才18岁。&lt;/li&gt;
&lt;li&gt;最开始，王希孟并不出色，但是赵佶看他潜力不错，于是亲自传授技法。&lt;/li&gt;
&lt;li&gt;王希孟完成这幅画，只用了不到半年的时间。要知道，《千里江山图》可是长达20米的巨幅画作。&lt;/li&gt;
&lt;li&gt;蔡京题跋的时候，王希孟已经死了。（&lt;code&gt;今希孟已死，展卷深為悼惜&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我特别喜欢陈丹青在&lt;a href=&#34;https://v.youku.com/v_show/id_XMTI2MDk4MTA5Ng==.html?spm=a2h0c.8166622.PhoneSokuProgram_1.dselectbutton_16&amp;amp;showid=cc117696c7cb11e4b432&#34;&gt;局部 第一季 千里江山图&lt;/a&gt;里评价十八岁王希孟的这段话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通常成年的老熟的大师，喜欢做减法，也就是所谓取舍和概括，可十八岁英年的王希孟呢，他是忙着做加法。人在十八岁年纪，才会有这股子雄心和细心，一点不乱。不枝蔓，不繁杂，通篇贵气，清秀逼人。那就是他的天赋了。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;十八岁干的事，多半其实是不自知的，他好也好在不自知。照西洋人的说法，那是上帝让他干了这件事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我回想起来我在这个岁数的时候，也是在“做加法”，天地广阔任我遨游；年纪大了，慢慢知道自己的边界在哪里，于是慢慢“做减法”，减掉自己做不到的事情。&lt;/p&gt;

&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;

&lt;h2 id=&#34;武侠风格的滑雪创意短片&#34;&gt;武侠风格的滑雪创意短片&lt;/h2&gt;

&lt;p&gt;冬奥会正在进行中，B站上看到一个很有意思的武侠风格的滑雪创意短片：&lt;a href=&#34;https://www.bilibili.com/video/BV16q4y1h7v7&#34;&gt;我悍刀愿称你为最行&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;置身事内&#34;&gt;《置身事内》&lt;/h2&gt;

&lt;p&gt;一本讲解中国政经体制的好书，强烈推荐，看完之后能对国家层面宏观的很多政策等有更好的理解，比如城市化、土地财政政策、城市化等等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/35546622/&#34;&gt;置身事内 (豆瓣)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;paxos原理的直观解释&#34;&gt;Paxos原理的直观解释&lt;/h2&gt;

&lt;p&gt;这是目前看到这么多的Paxos原理解释的文章里写的最清晰的一篇了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.openacid.com/algo/paxos/&#34;&gt;可靠分布式系统-paxos的直观解释 - OpenACID Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其他很多文章多是囫囵吞枣式的论文翻译，这篇文章有作者自己的理解和解释（图示、例子）。&lt;/p&gt;

&lt;h2 id=&#34;testing-distributed-systems&#34;&gt;Testing Distributed Systems&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://asatarin.github.io/testing-distributed-systems/&#34;&gt;Testing Distributed Systems | Curated list of resources on testing distributed systems&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;列举了各种分布式系统、数据库的测试方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>周刊（第3期）：一个前游戏开发者眼中的游戏后端技术</title>
      <link>https://www.codedump.info/post/20220129-weekly-3/</link>
      <pubDate>Sat, 29 Jan 2022 14:21:20 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220129-weekly-3/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;引言：在我之前的工作里，因为各种原因，断续在游戏行业里有过总共大概四年左右的从业时间，今天想从我的视角聊聊游戏行业后端开发相关的技术，供那些想在这个行业从业，尤其是后端开发从业人员一些参考。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;一个前游戏开发者眼中的游戏后端技术&#34;&gt;一个前游戏开发者眼中的游戏后端技术&lt;/h1&gt;

&lt;p&gt;由于我从业的方向都是后端开发，所以这里仅谈论游戏开发后端的技术。&lt;/p&gt;

&lt;p&gt;游戏本质是个内容行业，所以游戏开发时相当一部分工作内容，就是不停的更新新的内容出来给玩家消费。这些内容包括但不限于：新的英雄、技能、玩法，等等。&lt;/p&gt;

&lt;p&gt;而要支撑这些玩法，相当一部分是策划的配表数据，即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序员把玩法的框架、逻辑搭建好，留出读玩法数据的接口来。&lt;/li&gt;
&lt;li&gt;玩法数据由负责该玩法的策划来配表实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这其实就是很朴素的“表驱动”的编程方式。&lt;/p&gt;

&lt;p&gt;因为这个原因，所以游戏服务器启动时，要加载相当多的数据，主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;玩家的数据，包括账号、角色、帮派、金钱等数据。&lt;/li&gt;
&lt;li&gt;玩法相关的策划配表数据。比如一个场景的坐标位置、NPC的坐标位置、任务，等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于需要在启动的时候要加载很多数据，游戏服务器才能完成初始化，所以“编译型”语言在游戏开发里并不适用来编写游戏玩法逻辑，试想下面的开发场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;策划提出了新的玩法需求。&lt;/li&gt;
&lt;li&gt;开发使用如C++这样的编译型语言编码实现玩法。&lt;/li&gt;
&lt;li&gt;编译新修改的代码：这里面有包括了编译、修改编译不通过时候的报错，等等。&lt;/li&gt;
&lt;li&gt;停止服务器，重启服务器来验证玩法的逻辑。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，姑且不论其他因素，单是每次验证代码修改时需要停服、重启服务器的流程，而重启时又要加载一堆数据才能完成初始化，这个过程就严重影响开发效率。&lt;/p&gt;

&lt;p&gt;换言之，“编译型”语言并不适合于用来编码在游戏开发里需要经常变更的玩法逻辑。&lt;/p&gt;

&lt;p&gt;于是，一种新的开发架构出现了，见下图。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220129-weekly-3/game-server-arch.png&#34; alt=&#34;游戏后端的架构分层&#34; title=&#34;游戏后端的架构分层&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在图中，将游戏服务器架构分为了两层：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引擎层：这部分由C++编码，实现了游戏开发中与具体逻辑关系不大、且不太会变更的部分，如网络数据收发、数据库访问，等等。&lt;/li&gt;
&lt;li&gt;脚本层：这部分由Python、Lua这样的脚本语言实现，主要就是各种玩法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;采用这样的架构最主要的优点，就是解决前面提到的开发效率问题。由于Python、Lua这样的脚本语言，支持热更新，即“不需要重启进程也能更新最新的代码”，这样开发模式就变成了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;策划提出了新的玩法需求。&lt;/li&gt;
&lt;li&gt;开发使用如Python、Lua这样的脚本型语言编码实现玩法。&lt;/li&gt;
&lt;li&gt;热更新脚本代码，调试玩法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，由于支持“热更新”，省去了停服、重启、加载数据的步骤，一下子开发效率就提升了很多。&lt;/p&gt;

&lt;p&gt;多说一句，“热更新”还有一个优点：假如线上出问题时，总不可能停服下来修复，热更新不需要重启就能更新最新代码的特点在这里又发挥了作用。&lt;/p&gt;

&lt;p&gt;从这个开发架构里，也可以看到游戏服务器人员的构成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引擎层只有少数人能够去维护，要求稳定、高效。&lt;/li&gt;
&lt;li&gt;绝大部分人，都在脚本层用脚本语言来写各种玩法逻辑，类似于web开发中的CRUD。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个架构已经很久没变化了，而且每个公司都有自己一套（甚至几套）维护得较为稳定的服务器引擎，这会有一个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;技术演进慢。十几年前的架构到现在基本没变。&lt;/li&gt;
&lt;li&gt;由于演进慢，而且对稳定性的要求高，实际上新人也很难找到机会在引擎层发挥作用，引擎层的代码通常也不会让脚本层工作的人看到，这样就进入不到这一层的开发，而且引擎层绝大部分的问题已经被前人解决了，用现在的话来说，这部分技术“固化”了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了证实我的观点，我找来了去年刚出版的&lt;a href=&#34;https://book.douban.com/subject/35669430/&#34;&gt;《腾讯游戏开发精粹Ⅱ 》&lt;/a&gt;这本书，来看看书里关于游戏服务器都有哪些内容。全书一共21章，与游戏服务器相关的只有三章：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;部分Ⅴ 服务端架构和技术&lt;/p&gt;

&lt;p&gt;第15章 面向游戏的高性能服务网格TbusppMesh 304&lt;/p&gt;

&lt;p&gt;15.1　TbusppMesh摘要 304&lt;/p&gt;

&lt;p&gt;15.2　TbusppMesh数据通信 305&lt;/p&gt;

&lt;p&gt;15.3　TbusppMesh组网策略 309&lt;/p&gt;

&lt;p&gt;15.4　TbusppMesh有状态服务 315&lt;/p&gt;

&lt;p&gt;15.5　总结 321&lt;/p&gt;

&lt;p&gt;第16章 游戏配置系统设计 322&lt;/p&gt;

&lt;p&gt;16.1　游戏配置系统概述 322&lt;/p&gt;

&lt;p&gt;16.2　游戏配置简介 322&lt;/p&gt;

&lt;p&gt;16.3　游戏配置系统 323&lt;/p&gt;

&lt;p&gt;16.4　配置设计与发布 324&lt;/p&gt;

&lt;p&gt;16.5　配置Web管理系统 328&lt;/p&gt;

&lt;p&gt;16.6　总结 330&lt;/p&gt;

&lt;p&gt;第17章 游戏敏捷运营体系技术 331&lt;/p&gt;

&lt;p&gt;17.1　游戏运营概况 331&lt;/p&gt;

&lt;p&gt;17.2　DataMore大数据计算体系建设 335&lt;/p&gt;

&lt;p&gt;17.3　基础平台 343&lt;/p&gt;

&lt;p&gt;17.4　总结 360&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且，其中一章还是讲的偏运营体系、大数据方面的内容，这部分内容跟“游戏开发”本身相关性不大。造成这样的原因，是因为游戏服务器用脚本写玩法逻辑，这实在没有太多可以说的:)。&lt;/p&gt;

&lt;p&gt;在这样一个演进慢、技术固化的领域里，新人大部分时候都挤在了写玩法逻辑的脚本层里。这是游戏行业新人需要考虑的问题：一旦落到脚本层开发，技术积累很慢很少，也会很累、加班很多。这还是由于前面讲述的游戏行业的特点导致的：游戏本质是个内容行业，而“内容”落到开发分工上，主要就是由脚本层的开发来完成。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结一下我的观点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;游戏本质是个内容行业，游戏开发大部分时候都是生产“内容”给玩家消费。&lt;/li&gt;
&lt;li&gt;由于生产游戏内容的过程繁杂，且启动游戏服务器时需要加载大量数据，编译型语言并不适合来写游戏玩法逻辑。&lt;/li&gt;
&lt;li&gt;于是产生了编译型语言编写引擎+脚本型语言编写玩法逻辑的架构。&lt;/li&gt;
&lt;li&gt;而这种架构已经沿用了很多年，游戏服务器后端技术领域，技术演进慢、固化严重。&lt;/li&gt;
&lt;li&gt;在一个固化严重的技术领域，新人很难找到机会。这个结论不仅适用于游戏行业的开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;番外&#34;&gt;番外&lt;/h1&gt;

&lt;h2 id=&#34;lua的兴起&#34;&gt;Lua的兴起&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.lua.org/&#34;&gt;Lua&lt;/a&gt;是一门发源于巴西的脚本语言，我之前深入研究过Lua 5.1.4版本的代码，写过其分析的文档（&lt;a href=&#34;https://github.com/lichuang/Lua-Source-Internal&#34;&gt;Lua source internal&lt;/a&gt;），后续被出版为正式出版物&lt;a href=&#34;https://book.douban.com/subject/27108476/&#34;&gt;《Lua设计与实现》&lt;/a&gt;。我在写作本书的时候，研究过一些Lua的发展历史。可以说，Lua在游戏行业开始流行起来就是源自上面的脚本+引擎这样的架构体系，能够提高游戏开发者的开发效率。这部分内容参见&lt;a href=&#34;https://www.lua.org/history.html&#34;&gt;The evolution of an extension language: a history of Lua&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It turned out that Bret Mogilefsky was the lead programmer on Grim Fandango, the main adventure game LucasArts released in 1997. In another message he told us that &amp;ldquo;A TREMENDOUS amount of this game is written in Lua&amp;rdquo; (his emphasis). This first use of Lua in a game attracted the attention of many game developers around the world to the language. Soon after, Lua started to appear frequently in game newsgroups, such as &lt;code&gt;rec.games.programmer&lt;/code&gt; and &lt;code&gt;comp.ai.games&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;人们为什么需要游戏&#34;&gt;人们为什么需要游戏？&lt;/h2&gt;

&lt;p&gt;游戏一直是个有很大争议的行业：杀戮、利用人性阴暗面、未成年人沉迷导致的各种问题，等等。&lt;/p&gt;

&lt;p&gt;我在从业的时候，也会纠结在这些问题里。&lt;/p&gt;

&lt;p&gt;再后来，我找到一个解释给自己的理由：由于人们的肉身，受时空范围的限制，所以需要游戏来帮助人们扩展人生体验的范围。&lt;/p&gt;

&lt;p&gt;比如，如果没有&lt;code&gt;FootballManager&lt;/code&gt;这款游戏，我如何都体会不到执教、管理一个球队的体验。&lt;/p&gt;

&lt;p&gt;《庄子》里有所谓“庄周梦蝶”的故事，其大意是：庄子一天做梦，梦见自己变成了一只蝴蝶。醒来之后他发现自己还是庄子，于是他不知道自己到底是变成庄子的蝴蝶呢，还是梦中变成蝴蝶的庄子。庄子认为人不能确切的区分“真实”和“虚幻”，游戏某种程度上以构建在数字上的“虚幻”，来给了我们不同时空上的“真实”体验。&lt;/p&gt;

&lt;p&gt;从这一点看，游戏的内容，和书籍、影视剧，其实没有太多的区别：载体不同，但都让人扩展了体验的范围。&lt;/p&gt;

&lt;p&gt;也因为这样，大家都是”内容消费行业“，所以游戏的竞争对手，除了游戏行业以内，还有各种能够消费时间的产品：视频、书籍、电视，等等。&lt;/p&gt;

&lt;p&gt;在人口增速放缓之后，换算成能用来消费这些内容的总时间也放缓了，再加上前面提到各种消费时间的产品越来越多，各种游戏也越来越多，所以这个领域是很难的（当然大家都难）。&lt;/p&gt;

&lt;p&gt;关于”游戏是内容行业“这个话题，最近看到一篇不错的文章：&lt;a href=&#34;https://mp.weixin.qq.com/s/NkNLbkRG26M8dqt5t8hvxA&#34;&gt;科技巨头的游戏野心为何经常以失败告终？&lt;/a&gt;，有兴趣的可以参考一起看看。&lt;/p&gt;

&lt;h2 id=&#34;我为什么离开游戏行业&#34;&gt;我为什么离开游戏行业？&lt;/h2&gt;

&lt;p&gt;总结起来有以下的原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;太累：每周都有版本更新（注意是每周），每到版本更新的日子，全组都要一起待到版本发布，经常就搞到了晚上十点后，打车回家只能洗洗睡了。第二天还要早早起来，赶版本更新之后、还未外放前的验证工作，如果有问题要马上线上修复。除此以外，其他时候有严重的线上问题，还要马上更新修复（热更新性质再次救了游戏开发者）。这一算下来，每周五个工作日，至少有两天是在快节奏下工作的。这样的工作节奏，对年纪大的人太不友好了。&lt;/li&gt;
&lt;li&gt;学不到什么技术：就是我上面说的技术固化、演进慢等因素。天天用脚本写各种玩法，积累不出什么个人技术壁垒来。我一直对”被平台、工作所体制化“的事情保持着警惕，见我之前的周刊：&lt;a href=&#34;https://www.codedump.info/post/20220123-weekly-2/&#34;&gt;周刊（第2期）：从笔记软件谈被体制化 - codedump的网络日志&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;推荐&#34;&gt;推荐&lt;/h1&gt;

&lt;h2 id=&#34;游戏服务器和普通服务器有什么区别&#34;&gt;游戏服务器和普通服务器有什么区别？&lt;/h2&gt;

&lt;p&gt;这是知乎上的一个问题：&lt;a href=&#34;https://www.zhihu.com/question/23508968&#34;&gt;游戏服务器与普通服务器有什么区别? - 知乎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结前面分析的游戏行业的特点、开发架构，我做一个简短的回答：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;游戏要模拟各种虚拟世界的场景，包括但不限于：社交、战斗、玩家可见性（比如买了一个装备，什么样的玩家能看到，涉及到这个属性的广播范围等问题）。简而言之，游戏开发有时候在游戏里就是造世主一般的存在。&lt;/li&gt;
&lt;li&gt;所以，大部分时候，游戏服务是“有状态的”服务。这点是跟一般的web服务最大的区别：web服务通常一个短链接请求过来，查询一段数据，完事了可能就断开了；而游戏服务器，由于要维持状态，大部分时候都是长连接，一个连接对应一个玩家角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;科普游戏服务端技术的资料&#34;&gt;科普游戏服务端技术的资料&lt;/h2&gt;

&lt;p&gt;如果觉得前面的讲解太过粗糙，还想多了解这方面的技术，推荐以下几篇文章：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/fingerpass/p/game-server-programming-paradigm.html&#34;&gt;游戏服务端究竟解决了什么问题？ - fingerpass - 博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.skywind.me/blog/archives/1265&#34;&gt;游戏服务端架构发展史（上） - Skywind Inside&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.skywind.me/blog/archives/1301&#34;&gt;游戏服务端架构发展史（中） - Skywind Inside&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;上面两部曲没有下篇了，作者已经鸽了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;skywind&#34;&gt;skywind&lt;/h2&gt;

&lt;p&gt;这是我推荐的一位前游戏行业从业者、知乎答主、博客作者、以及开源项目作者。&lt;/p&gt;

&lt;p&gt;他主要的领域有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;游戏（引擎）开发。&lt;/li&gt;
&lt;li&gt;网络传输、音视频开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这几个方面，他是既有理论技术文章的输出、也有开源项目的，最出名的开源项目当属&lt;a href=&#34;https://github.com/skywind3000/kcp&#34;&gt;KCP - A Fast and Reliable ARQ Protocol&lt;/a&gt;。（我曾经写过一篇不太好的、个人不甚满意的KCP分析文章，见：&lt;a href=&#34;https://www.codedump.info/post/20201105-kcp/&#34;&gt;KCP 1.4源码分析 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;知乎：&lt;a href=&#34;https://www.zhihu.com/people/skywind3000&#34;&gt;https://www.zhihu.com/people/skywind3000&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;github：&lt;a href=&#34;https://github.com/skywind3000&#34;&gt;https://github.com/skywind3000&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;博客：&lt;a href=&#34;http://www.skywind.me/blog/&#34;&gt;http://www.skywind.me/blog/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推特：&lt;a href=&#34;https://twitter.com/skywind3000&#34;&gt;https://twitter.com/skywind3000&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于他之前也是游戏行业的从业者，所以也对游戏领域有自己的见解，见：&lt;a href=&#34;http://www.skywind.me/blog/archives/1259&#34;&gt;你为什么会离开游戏行业？ - Skywind Inside&lt;/a&gt;，也是难得一见的好文。另外，知乎上有很多他有趣的回答。&lt;/p&gt;

&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;

&lt;h2 id=&#34;无穷之路-https-zh-wikipedia-org-wiki-e7-84-a1-e7-aa-ae-e4-b9-8b-e8-b7-af&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%84%A1%E7%AA%AE%E4%B9%8B%E8%B7%AF&#34;&gt;无穷之路&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;香港TVB电视台在内地拍摄的一部讲述内地扶贫情况的纪录片。我觉得这类型的片，由内地媒体拍出来，和香港媒体拍出来，感觉还是不一样的，香港媒体的视角更像第三方的视角。在拍摄时，有时候主持人也会切换到自己用自拍杆的视角来拍摄，又多了一些亲切的感觉，不会那么高高在上。&lt;/p&gt;

&lt;p&gt;”无穷之路“这个名字也很好：”穷“既代表脱离贫穷，也寓意着内地有很多素材可供香港媒体拍摄记录。&lt;/p&gt;

&lt;p&gt;这里面让我印象最深刻的，就是第一集的”&lt;a href=&#34;https://baike.baidu.com/item/%E9%98%BF%E5%9C%9F%E5%88%97%E5%B0%94%E6%9D%91/13981071&#34;&gt;悬崖村&lt;/a&gt;“，万万没想到就是在最近，还有人居住在这种天险之地。&lt;/p&gt;

&lt;p&gt;B站有视频全集&lt;a href=&#34;https://www.bilibili.com/bangumi/play/ss40050&#34;&gt;无穷之路-纪录片-全集-高清独家在线观看-bilibili-哔哩哔哩&lt;/a&gt;，如果能听懂粤语也可以选择听粤语原版。&lt;/p&gt;

&lt;h2 id=&#34;deepl&#34;&gt;DeepL&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.deepl.com/zh/translator&#34;&gt;DeepL翻译&lt;/a&gt;是由德国一家AI创业公司的推出的翻译服务，主打使用人工智能、深度学习技术来进行翻译服务，支持 简体中文、英语、德语、法语、日语、西班牙语、意大利语、荷兰语及波兰语之间的翻译。&lt;/p&gt;

&lt;p&gt;我自己尝试了一下这个翻译工具，将我博客的一篇中文博文翻译成英文，几乎不加修改就能比较顺畅了，读者可以自行对比一下效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200605-how-to-read-code-v2020/&#34;&gt;如何阅读一份源代码？（2020年版） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210215-how-to-read-code-en/&#34;&gt;How to Read Code(En Version) - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;感觉对于技术类文章的翻译来说，这个工具的表现已经很好了。&lt;/p&gt;

&lt;p&gt;Mac、Win桌面版可以免费下载，也有网页版本，但是免费版本有每次翻译的字数限制，文章长了需要自己多倒腾几次。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>周刊（第2期）：从笔记软件谈被体制化</title>
      <link>https://www.codedump.info/post/20220123-weekly-2/</link>
      <pubDate>Sun, 23 Jan 2022 15:38:31 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220123-weekly-2/</guid>
      <description>

&lt;h1 id=&#34;从笔记软件谈被体制化&#34;&gt;从笔记软件谈被体制化&lt;/h1&gt;

&lt;p&gt;前两周，一则收购消息，在偌大的中文互联网上，几乎没有掀起任何的讨论：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/luImz3NFwN5zmNHsqvjmDg&#34;&gt;为知笔记并入 ONES，WizNote X 迎来新的征程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我是为知笔记的老用户了，从 2011 年就开始使用为知笔记，即便是现在不怎么使用的情况下，也已经把 VIP 会员续费到了 2024 年。在我看来，为知笔记是一个气质与众不同的互联网产品：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在互联网上几乎没看到这款产品主动来宣传自己，都是靠用户的口碑传播，最开始我也是通过用户的介绍知道这款产品的。&lt;/li&gt;
&lt;li&gt;是最早支持 Markdown 的笔记本软件，这在我最开始了解 MD 并且开始用这个格式来记录笔记时起了很大的帮助。&lt;/li&gt;
&lt;li&gt;价格良心。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，当看到为知笔记被收购的新闻，心情还是有些复杂的。我大体知道一些互联网产品的玩法，知道为知笔记应该生存的不太好，被收购了也许对团队是个好事。&lt;/p&gt;

&lt;p&gt;于是，我开始回想起来，到底是什么样的契机，让我开始慢慢抛弃了传统的笔记软件，以及我现在都用什么方式记录笔记。&lt;/p&gt;

&lt;p&gt;在 Evernote 刚出来的时候，多端可用、可以收藏文章、记录自己的笔记等等，我也大概是那时候开始记录笔记的，然后就是后来使用网易云笔记，再到主力使用为知笔记。&lt;/p&gt;

&lt;p&gt;让我逐渐意识到不应该把笔记托管到笔记软件上，有那么几个原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;笔记软件之间竞争激烈，可能你从 A 家换到 B 家的产品时，数据的迁移是个大问题，有时候就不得不丢掉一部分难迁移的数据。比如把数据从 Evernote 迁移出来就很麻烦，还好我之前放在这里的笔记也不太用得上了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Markdown 格式开始流行以后。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我大概是从2015年开始用MD格式开始写笔记的，这种格式马上就让我爱上了记录笔记：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式对比LaTex来说太简单了，只有常见的几种格式，易学易写。&lt;/li&gt;
&lt;li&gt;纯文本格式，这意味着用任何文本编辑器就能打开。&lt;/li&gt;
&lt;li&gt;搭配好用的编辑器，能获得”所见即所得“的体验。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我开始反思之前对笔记本软件的使用：以往都将数据的格式和具体的软件绑定了，这是后面一系列问题（迁移难、文本编辑器打不开）的核心原因。&lt;/p&gt;

&lt;p&gt;这样，我慢慢意识到，对记录笔记工具这件事情，应该是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式通用，且是纯文本格式。&lt;/li&gt;
&lt;li&gt;由于上面这个限制条件，于是就能将格式和写作软件解除绑定，我能在用不惯一款写作工具的时候，毫不费力的用另一款支持这个通用格式的软件继续写我的笔记。&lt;/li&gt;
&lt;li&gt;而为知笔记之类的笔记软件，即便后来支持了MD格式，也存储为自己的私有格式，导致了导出数据麻烦。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我后来也是这样实践的：本地建一个仓库，在里面写MD格式文件，搭配顺手的MD编辑器，需要存储的时候将这个仓库同步到云端。&lt;/p&gt;

&lt;p&gt;现在看来，能让这个写笔记方式发生很大变化，有这么几个契机：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MD格式开始流行。&lt;/li&gt;
&lt;li&gt;由于这个格式开始流行，雨后春笋般出来了很多相关编辑器。用现在的话来说，MD编辑器这个领域开始卷了起来，这样做为用户就有了很多选择，依赖关系反转。&lt;/li&gt;
&lt;li&gt;微软收购Github之后，创建私人仓库变得轻而易举。（有钱，真的能让用户为所欲为。）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;”笔记格式，应该和笔记软件解绑“，这样我就不会被绑定在一个具体的软件里面了，就不会被一个具体的软件所”体制化“。我怀疑这类想法，很大程度上受到最喜欢的《肖申克的救赎》这部电影的影响：电影里在监狱里生活了几十年的老布，已经被监狱”体制化“，这导致他出去监狱没多久就适应不了不被体制化的生活，选择了上吊自杀。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;These walls are funny.First you hate them,then you get used to them;Enough time passes,gets so you depend on them.That&amp;rsquo;s institutionalized.&lt;/p&gt;

&lt;p&gt;（&lt;strong&gt;这些墙很有趣，刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就叫体制化。&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了《肖申克的救赎》以外，成长过程中目睹父辈的人因为下岗被体制甩出来，恐怕也是影响我思考个体和体制关系的原因。&lt;/p&gt;

&lt;p&gt;”去体制化“的想法，除了影响我笔记方式的选择之外，还在其他地方有影响：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公司是一个体制平台，雇员跟平台之间应该是双赢的关系才是良性的，雇员切不能将自己的技能等局限于特定的公司、平台上。&lt;/li&gt;
&lt;li&gt;十年前我刚开始自建博客开始写博客的时候，用的是WordPress，这也是一套封闭的技术栈。后来也是全面换用了MD方案：MD写文字、hugo负责渲染MD形成静态文件，哪一天我不爽了，可以换另一个hugo主题，甚至把hugo这个渲染方案换掉。&lt;/li&gt;
&lt;li&gt;对于现在的自媒体平台，比如微信公众号之类的，做为创作者应该利用平台，创作者与这类自媒体平台的关系是依附关系，这些平台是渠道之一，而不是唯一渠道，一旦唯一这就变成了依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有类似的词语形容这种依赖关系：路径依赖，百度百科中对“路径依赖”的解释是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;路径依赖（Path-Dependence），又译为路径依赖性，它的特定含义是指人类社会中的技术演进或制度变迁均有类似于物理学中的惯性，即一旦进入某一路径（无论是“好”还是“坏”）就可能对这种路径产生依赖。
一旦人们做了某种选择，就好比走上了一条不归之路，惯性的力量会使这一选择不断自我强化，并让你轻易走不出去。第一个使“路径依赖”理论声名远播的是道格拉斯·诺斯，由于用“路径依赖”理论成功地阐释了经济制度的演进，道格拉斯·诺斯于1993年获得诺贝尔经济学奖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结起来：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内容（技能）应该是开放的，不应局限于特定的软件（平台）。&lt;/li&gt;
&lt;li&gt;个体和平台之间，应该是依附关系，而不是依赖关系。&lt;/li&gt;
&lt;li&gt;体制容易让人产生惯性，而一旦进入惯性，再走出来就会很难。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到这里，只是谈了我记录笔记工具方式的变化，后面再找一期专门讲讲我自己是怎么记录笔记的。&lt;/p&gt;

&lt;h1 id=&#34;相关推荐&#34;&gt;相关推荐&lt;/h1&gt;

&lt;h2 id=&#34;王川微博&#34;&gt;王川微博&lt;/h2&gt;

&lt;p&gt;王川在微博上正好也谈到一些工作选择上的看法：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://weibo.com/5339148412/LbKMJ8luF&#34;&gt;提高调整纠错的能力的&amp;hellip; - @硅谷王川的微博 - 微博&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;要从事流动性好，通用程度高，虚拟程度高的事业。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;通用程度低的工作和服务，一旦失去现有客户，很难找到新的市场和应用，因此被迫中止，之前的努力无法重复利用，完全白费。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想这里的观点，是类似的。&lt;/p&gt;

&lt;h2 id=&#34;typora&#34;&gt;Typora&lt;/h2&gt;

&lt;p&gt;我现在主力用的MD编辑器是&lt;a href=&#34;https://typora.io/&#34;&gt;Typora&lt;/a&gt;，这款软件给我很棒的写作体验（包括本文也是用这个软件写作），前段时间&lt;a href=&#34;https://support.typora.io/What&#39;s-New-1.0/&#34;&gt;Typora 1.0&lt;/a&gt;正式版宣布收费之后果断第一时间买了正版支持。&lt;/p&gt;

&lt;h2 id=&#34;logseq&#34;&gt;Logseq&lt;/h2&gt;

&lt;p&gt;笔记本软件最近几年确实出来太多玩家，”软件太多，用户都不够分了“。其中有一家中国起步的开源笔记软件&lt;a href=&#34;https://logseq.com/&#34;&gt;Logseq&lt;/a&gt;，从个人兴趣爱好出发，在&lt;a href=&#34;https://github.com/logseq/logseq&#34;&gt;github&lt;/a&gt;上开源吸引了国内外的很多用户，最后成立了公司专职做这款产品。小宇宙上有创始人的访谈：&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/61c6cccac525309a443b5b36&#34;&gt;7. 跟 Logseq 的创造者天生聊聊 Logseq 的故事&lt;/a&gt;，有意思的是，很多投资人是这款产品的使用者，甚至还提交了PR，这应该是很少见的。&lt;/p&gt;

&lt;h2 id=&#34;为知笔记创始人的访谈&#34;&gt;为知笔记创始人的访谈&lt;/h2&gt;

&lt;p&gt;Teahour上有一期为知笔记创始人的访谈节目，算是对这款产品有了一些了解：&lt;a href=&#34;https://teahour.fm/46&#34;&gt;Teahour: #46 - 和为知笔记的 CTO 聊聊他的经历和技术&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;

&lt;h2 id=&#34;linux-c编程一站式学习&#34;&gt;《Linux C编程一站式学习》&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/4141733/&#34;&gt;《Linux C编程一站式学习 》&lt;/a&gt;是一本在国内广受好评的C语言初学者教程，豆瓣评分9.0。&lt;/p&gt;

&lt;p&gt;可惜，后来已经不再版，早期作者曾经开放了免费的版本，但是可能内容和正式版有不少区别：
&lt;a href=&#34;https://akaedu.github.io/book/&#34;&gt;Linux C编程一站式学习&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而且，现在免费版本也不再更新了。&lt;/p&gt;

&lt;p&gt;即便是现在，很少人会直接拿C写代码，C语言慢慢变成了“云时代的汇编语言”，但是学习一点C语言，对于了解系统还是很有帮助的。&lt;/p&gt;

&lt;h2 id=&#34;大妈的世界&#34;&gt;《大妈的世界》&lt;/h2&gt;

&lt;p&gt;最后推荐最近看的剧&lt;a href=&#34;https://movie.douban.com/subject/35715961/&#34;&gt;《大妈的世界 》&lt;/a&gt;，由87版《西游记》玉兔精扮演者李玲玉出演，每一集大概5分钟，主题涉及反诈骗、广场舞、互联网等大妈日常的生活话题，轻松搞笑，在临近春节的时间点，倒是不错的能和父母一起看的剧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>周刊第1期：开刊，数字化生活数据</title>
      <link>https://www.codedump.info/post/20220116-weekly-1/</link>
      <pubDate>Sun, 16 Jan 2022 10:00:54 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220116-weekly-1/</guid>
      <description>

&lt;h1 id=&#34;为什么会写周刊&#34;&gt;为什么会写周刊&lt;/h1&gt;

&lt;p&gt;我为写周刊这个事情思考了小一阵子。&lt;/p&gt;

&lt;p&gt;列举了好几个优点和缺点。比如，优点有能以输出来倒逼自己的输入，缺点有我的积累是否能够足以支撑我每周写一点东西，以及这种有明确时间限制的输出，是否会给我带来心智负担，等等。再比如，以往的博客内容都是很“硬”的技术内容，周刊不可能也不会每周都更新硬技术文章，会不会导致读者群有点分裂。&lt;/p&gt;

&lt;p&gt;思考到最后，我还是决定写周刊。&lt;/p&gt;

&lt;p&gt;从去年开始远程工作，大部分时间都在家里。由于我又很宅，网购也足够的发达，这又让我更宅了。然而，“物理”意义上的活动范围变小，并不意味着“逻辑”上能触达的范围也变小了，实际情况是，由于把通勤时间节省下来，我有更多时间看书、跑步了。所以，我需要一种方式，能输出我看到的一些东西，来与外界发生交流。&lt;/p&gt;

&lt;p&gt;我在微博上看到了这么两句话，也反向让我坚定了这么做的意义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（&lt;a href=&#34;https://weibo.com/1244214071/LagQ8fzm0&#34;&gt;宋一松SYS的微博&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;社交媒体在我看来最大的价值：它是最开放的peer review system&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://weibo.com/5339148412/L6LhDE7Zu&#34;&gt;硅谷王川的微博&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;让读书产生好处的最简单办法是，一旦有灵感和想法之后，马上写出来，公开发布在社交媒体上，即使不成熟也没关系。写的过程也是自己深度思考的一个步骤，外人的有价值评论可帮你不断推敲，或给你带来新的线索，积累多了自然会出深刻的洞见。一个人孤立封闭的傻读写笔记，很难迅速提高思考深度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;周刊于我的意义，就是能定期把自己想到、看到的事情都公开出去，反向的让自己定期整理、输出，这是我突破“物理”界限和人交流的手段之一。内容将会以自己的一些想法、业界的动态、推荐、读书、影视等为准，与我写的其他技术文章相比，不会这么“硬”。&lt;/p&gt;

&lt;p&gt;另外，写周刊还有一个好处，之前有很多想法、念头会散落在各种社交平台这样的新媒体上，实际对整理、汇总、索引等也不好，把念头汇之于文章，用这种更老式的传播方式可以更好得记录下来。&lt;/p&gt;

&lt;h1 id=&#34;数字化生活数据&#34;&gt;数字化生活数据&lt;/h1&gt;

&lt;p&gt;既然谈到了周刊做为个人对外输出的一个手段，我就想起最近几年一直在做的事情：数字化各种生活数据。&lt;/p&gt;

&lt;p&gt;做过一阵子时序数据库的开发，有些人当时并不太了解什么叫做“时序数据”，于是我当时想了一下生活里的类比，其实“时序数据”就好比我们的“流水账”：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;9:00：起床，洗漱。&lt;/li&gt;
&lt;li&gt;9:30：工作。&lt;/li&gt;
&lt;li&gt;12:00：午餐。&lt;/li&gt;
&lt;li&gt;&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所谓“数字化生活数据”，也就是按照时间顺序把这些记录下来。“时序数据”，说白了就是时间强相关的数据，以时间为第一维度来存储、查询的数据。&lt;/p&gt;

&lt;p&gt;“数字化各种生活数据”，这么做的好处有什么？在我看来，有这些好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;形成上面的“时序数据”之后，可以方便进行聚合、统计、查询。&lt;/li&gt;
&lt;li&gt;定期还能依赖于各种工具来进行汇总、回顾等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如，我每天都在用的&lt;code&gt;DayOne&lt;/code&gt; app，就有一个“每年今日”的功能，提醒我以往的这一天我都记录了什么，这就是基于这些时序数据的汇总；再比如，每到年底各种app都会自动给用户汇总生成这一年的用户行为统计数据，告诉你最喜欢的歌、和你爱好最匹配的人，等等。&lt;/p&gt;

&lt;p&gt;这些功能，都依赖于你之前上报过的“时序数据”。&lt;/p&gt;

&lt;p&gt;今天要推荐的两个相关的开源项目，作者都是&lt;a href=&#34;https://github.com/yihong0618&#34;&gt;yihong0618 (yihong)&lt;/a&gt;，他也是“数字化生活数据”的提倡者，可以在小宇宙里收听他的访问：&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/619896e8138b51cbd78f3912&#34;&gt;S01E03 专访 YiHong，自学成为流行开源项目作者的点滴 - 开源面对面 | 小宇宙 - 听播客，上小宇宙&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第一个项目是&lt;a href=&#34;https://github.com/yihong0618/running_page&#34;&gt;yihong0618/running_page: Make your own running home page&lt;/a&gt;，可以抓取主流的几个跑步app数据，生成好看的跑步数据展示页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/15976103/98808834-c02f1d80-2457-11eb-9a7c-70e91faa5e30.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二个项目是&lt;a href=&#34;https://github.com/yihong0618/GitHubPoster&#34;&gt;yihong0618/GitHubPoster: Make everything a GitHub svg poster and Skyline!&lt;/a&gt;，可以将在各种app上（twitter、多邻国、扇贝等）上报的数据可视化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/yihong0618/GitHubPoster/raw/main/examples/summary_2021.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/yihong0618/GitHubPoster/raw/main/examples/strava_circular.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可视化展示，会给人很直观的反馈。人的行为如果能得到即时的反馈，某种程度上会有正向作用。以我来说，去年9月份开始跑步，也是fork了这个项目每天生成跑步的可视化数据到我的网站，时不时会看一看数据，知道自己都做了哪些努力，潜移默化的会让我有一些成就感。&lt;/p&gt;

&lt;p&gt;一个想法：未来会不会有一天，可以拿到一个人所有的数字化数据，在这个人去世之后以这些数据重塑回一个“一样”的人？&lt;/p&gt;

&lt;h1 id=&#34;推荐&#34;&gt;推荐&lt;/h1&gt;

&lt;h2 id=&#34;算法可视化交互动图&#34;&gt;算法可视化交互动图&lt;/h2&gt;

&lt;p&gt;既然这一期讲到了数字化数据之后方便交互演示，就接着推荐旧金山大学制作的系列算法可视化交互动图，包括常见的堆、栈、队列等。学习算法数据结构的时候，如果能图示化的展现其变化过程，理解起来就会更顺畅，在学习B+Tree算法的时候，我就用过这里的演示来理解流程。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&#34;&gt;Data Structure Visualization&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;b-tree中的-b-是什么意思&#34;&gt;B-Tree中的“B”是什么意思？&lt;/h2&gt;

&lt;p&gt;上面提到了B+Tree，B-Tree数据结构中的“B”到底是什么单词的缩写？&lt;/p&gt;

&lt;p&gt;下意识的，都认为是“balance”的缩写，毕竟这是一个平衡的树形数据结构。但是其实，连几位发明人，也从来没有解释过。&lt;/p&gt;

&lt;p&gt;有可能是“boeing”的缩写，因为作者当时就职于波音公司；还有可能是第一作者Bayer的名字首字母。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;B-trees were invented by &lt;a href=&#34;https://en.wikipedia.org/wiki/Rudolf_Bayer&#34;&gt;Rudolf Bayer&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Edward_M._McCreight&#34;&gt;Edward M. McCreight&lt;/a&gt; while working at &lt;a href=&#34;https://en.wikipedia.org/wiki/Boeing&#34;&gt;Boeing Research Labs&lt;/a&gt;, for the purpose of efficiently managing index pages for large random-access files. The basic assumption was that indexes would be so voluminous that only small chunks of the tree could fit in main memory. Bayer and McCreight&amp;rsquo;s paper, &lt;em&gt;Organization and maintenance of large ordered indices&lt;/em&gt;,[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-bayer-mccreight-1970-1&#34;&gt;1]&lt;/a&gt; was first circulated in July 1970 and later published in &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Acta_Informatica&#34;&gt;Acta Informatica&lt;/a&gt;&lt;/em&gt;.[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-FOOTNOTEBayerMcCreight1972-3&#34;&gt;3]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bayer and McCreight never explained what, if anything, the &lt;em&gt;B&lt;/em&gt; stands for: &lt;em&gt;Boeing&lt;/em&gt;, &lt;em&gt;balanced&lt;/em&gt;, &lt;em&gt;broad&lt;/em&gt;, &lt;em&gt;bushy&lt;/em&gt;, and &lt;em&gt;Bayer&lt;/em&gt; have been suggested.[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-FOOTNOTEComer1979123_footnote_1-4&#34;&gt;4]&lt;/a&gt;[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-herrenalb-5&#34;&gt;5]&lt;/a&gt;[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-6&#34;&gt;6]&lt;/a&gt; McCreight has said that &amp;ldquo;the more you think about what the B in B-trees means, the better you understand B-trees.&amp;rdquo;[&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree#cite_note-herrenalb-5&#34;&gt;5]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree&#34;&gt;B-tree - Wikipedia&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（四）- WAL的实现</title>
      <link>https://www.codedump.info/post/20220106-sqlite-btree-4-wal/</link>
      <pubDate>Thu, 06 Jan 2022 21:48:18 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220106-sqlite-btree-4-wal/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;前面两节，分别讲解了sqlite中写入事务时的并发控制框架，以及journal备份文件的实现机制。&lt;/p&gt;

&lt;p&gt;回忆一下journal备份文件的实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次一个新的写事务开始之前，要首先写journal文件的文件头。&lt;/li&gt;
&lt;li&gt;写事务过程中，如果修改了哪个页面，在修改之前需要首先将这个页面的内容写入到journal文件中。&lt;/li&gt;
&lt;li&gt;写事务完成后，在同步所有缓存中被修改的页面到数据库文件之前，要首先将journal文件中的所有修改同步到磁盘，然后再修改数据库文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，journal备份的整个流程都较为原始，性能不高，所以在sqlite 3.7.0版本（&lt;a href=&#34;https://www.sqlite.org/releaselog/3_7_0.html&#34;&gt;SQLite Release 3.7.0 On 2010-07-21&lt;/a&gt;，2010-07-21）中，引入了另一种备份机制：WAL（Write Ahead Log）。&lt;/p&gt;

&lt;p&gt;本节首先介绍WAL的实现原理，然后再展开其具体的实现。&lt;/p&gt;

&lt;h1 id=&#34;wal工作原理&#34;&gt;WAL工作原理&lt;/h1&gt;

&lt;p&gt;从前面journal的实现中可以看到，写入journal文件中的内容，是待修改页面修改之前的内容，而WAL则相反：被修改的页面内容首先写入到WAL中。&lt;/p&gt;

&lt;p&gt;用sqlite官网的文字来说，WAL文件的定义是这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The write-ahead log or &amp;ldquo;wal&amp;rdquo; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即WAL文件中存储的是被修改但是还没有写入数据库文件的页面内容。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/page-backup.png&#34; alt=&#34;两种页面备份机制&#34; title=&#34;两种页面备份机制&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;WAL整体的实现机制，分为以下几个流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对页面的修改，可以只写入到WAL文件中就认为完成，不必一定要落盘到数据库文件才能算完成，这个设定保证了WAL的修改操作比journal性能有很大的提升。&lt;/li&gt;
&lt;li&gt;由于上面的这一点保证，同一时间的并发读操作，能继续读数据库中未修改的内容，极大提升了读并发的性能。&lt;/li&gt;
&lt;li&gt;当然WAL也不能无限制的一直写下去，必须有一个机制，触发将保存在WAL中的页面内容写入回到数据库文件中，这个流程被称为&lt;code&gt;checkpoint&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wal相关文件结构&#34;&gt;WAL相关文件结构&lt;/h2&gt;

&lt;p&gt;在工作原理部分，只会简单讲解WAL相关文件结构，具体的格式等细节留待下面的实现部分详细讲解。&lt;/p&gt;

&lt;p&gt;WAL文件本身的格式很简单，有如下两部分组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WAL文件头。&lt;/li&gt;
&lt;li&gt;紧跟着文件头之后的，就是由修改之后的页面内容组成的页面内容数组。&lt;/li&gt;
&lt;li&gt;最后，当事务被提交时，还会有一个特殊的WAL日志，标记这个事务提交了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;换言之，一个WAL中，可能先后存储了多个事务的写入。&lt;/p&gt;

&lt;p&gt;由于WAL文件保存的&lt;strong&gt;修改页面&lt;/strong&gt;的内容，同一个页面，可能在一次事务中被多次修改，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-and-index.png&#34; alt=&#34;WAL及WAL页面索引数据&#34; title=&#34;WAL及WAL页面索引数据&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;WAL存储了四个页面数据，其中页面编号1被修改了两次。&lt;/p&gt;

&lt;p&gt;如果在这个写操作完成之后，需要读这些页面的内容，都需要读到最新的内容。所以，WAL还有一个对应的&lt;code&gt;WAL页面索引&lt;/code&gt;数据，这部分索引数据存储在内存中，作用是根据页面编号，知道该页面编号对应的最新内容，存储在WAL文件中的具体位置，以取得某个页面的最新页面内容；如果在这个内存索引中查不到的数据，都需要到数据库文件中读取。&lt;/p&gt;

&lt;h2 id=&#34;checkpoint&#34;&gt;checkpoint&lt;/h2&gt;

&lt;p&gt;随着WAL文件的增长，终究要将里面修改的内容同步到数据库文件中，这个流程被称为“checkpoint”。只要WAL文件被“checkpoint”，就可以从头开始写这个文件，避免文件的无限增大。&lt;/p&gt;

&lt;p&gt;对于journal备份机制而言，只有两种操作：读和写；而对于WAL机制而言，实际有三种操作：读、写、checkpoint。这也是两种机制的主要区别之一。&lt;/p&gt;

&lt;h2 id=&#34;并发的实现&#34;&gt;并发的实现&lt;/h2&gt;

&lt;p&gt;前面提到了，WAL机制的一个优势在于：在写未完成之前，可以允许同时并发多个读操作，来看看这一点是如何做到的。&lt;/p&gt;

&lt;p&gt;在每次读操作开始之前，都会记录下来当前最后提交事务的提交记录，这条记录被称为“end mark”。因为WAL会随着写操作的进行不断增加，通过读操作的“end mark”，就能知道对于这个读操作而言，页面内容应该以当前WAL内容为准，还是以数据库文件为准。&lt;/p&gt;

&lt;p&gt;以下图为例来做个说明：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/read-concurrency.png&#34; alt=&#34;读并发的实现&#34; title=&#34;读并发的实现&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在上图中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WAL文件中先后记录了两个写事务，其中第一个写事务修改了页面编号1、2，已经提交完成；还有一个在进行还未完成的写事务，修改了页面编号1。&lt;/li&gt;
&lt;li&gt;这时候，如果来了一个读事务，那么将记录下来最后一个完成事务的提交记录做为自己的“end mark”，即图中的浅蓝色的那个提交记录。&lt;/li&gt;
&lt;li&gt;假设现在这个读事务，依次要读取页面编号1和2的页面，那么：

&lt;ul&gt;
&lt;li&gt;到页面索引中查询页面1的位置，发现位置比自己的“end marker”更大，也就是说这个页面在上一次完成写事务之后，被当前还未完成的写事务修改了，于是并不能读WAL的内容，因为这部分内容对这个读操作来说还是未提交的，所以页面1需要到数据库文件中读取。&lt;/li&gt;
&lt;li&gt;到页面索引中查询页面2的位置，发现位置比自己的“end marker”更小，也就是在自己标记的写事务完成之后并未被修改过，于是可以读WAL中这个页面的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，有了“end mark”这一标记位置之后，加上页面索引，任意数量的读操作都能快速判断自己应该读WAL文件还是数据库文件，写操作可以继续写，读和写之间并不会冲突，极大提升了读并发的性能。&lt;/p&gt;

&lt;p&gt;同样要看到的是，由于只有一个WAL文件，同一时间之内，只能有一个写操作。即：&lt;strong&gt;sqlite的WAL模式，只能支持单写多读的模式。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;读操作和checkpoint的联系&#34;&gt;读操作和checkpoint的联系&lt;/h2&gt;

&lt;p&gt;前面讲到了checkpoint以及读并发的实现，两者可以并发一起执行，但是某些时刻会有一些关联，影响系统的性能。&lt;/p&gt;

&lt;p&gt;因为超过读操作“end mark”的页面，读操作需要到数据库文件中读取该页面内容，那么反过来，当checkpoint操作要将一个超过当前并发的&lt;strong&gt;任意读操作&lt;/strong&gt;“end mark”的页面落到数据库文件中时，就必须等待这个读操作完成才能进行。&lt;/p&gt;

&lt;p&gt;仍然以前面读并发的示意图来解释这个过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;checkpoint 页面编号2的内容到数据库文件时，该页面最后在WAL文件中的位置，并不比当前的任意读操作的“end mark“更大，所以checkpoint这个页面的内容到数据库文件时无需等待即可完成。&lt;/li&gt;
&lt;li&gt;反过来，checkpoint 页面编号1的内容到数据库文件时，该页面最后在WAL文件中的位置，大于当前读操作的”end mark“，所以这个页面的内容就需要等待读操作完成才能进行下去。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;换言之：一个执行很久的读操作，可能会影响同时在进行的checkpoint操作的执行。&lt;/p&gt;

&lt;p&gt;被阻塞的checkpoint必须等待读操作完成才能继续执行，因此需要一些额外的信息来维护当前checkpoint执行的状态，这些具体的实现细节都会在下面实现环节的分析中涉及。&lt;/p&gt;

&lt;p&gt;现在已经大体清楚WAL的原理了，下面来看具体的实现。&lt;/p&gt;

&lt;h1 id=&#34;wal的实现&#34;&gt;WAL的实现&lt;/h1&gt;

&lt;p&gt;sqlite中，可以使用&lt;code&gt;PRAGMA journal_mode=wal&lt;/code&gt;设置页面备份机制为wal，这时候就会有三个与数据库相关的文件在同一个目录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库文件，假设名字为X。&lt;/li&gt;
&lt;li&gt;WAL文件，名字为“X-wal”。&lt;/li&gt;
&lt;li&gt;wal索引文件，名字为“X-shm”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wal的文件格式&#34;&gt;WAL的文件格式&lt;/h2&gt;

&lt;p&gt;首先来看WAL文件的格式，分为两个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WAL文件头：一次写事务，对应一个WAL文件头。&lt;/li&gt;
&lt;li&gt;除去文件头，每一页数据都是存储在“帧（frame）”里，每一帧又包括两部分数据：

&lt;ul&gt;
&lt;li&gt;帧头部：描述存储的这一页数据的信息。&lt;/li&gt;
&lt;li&gt;页面数据：存储页面数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WAL文件头，只会在每次写事务中写入一次，而帧可能在一次写事务中多多个，取决于这一次写事务修改了多少页面。如下图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-format.png&#34; alt=&#34;WAL文件结构&#34; title=&#34;WAL文件结构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;上图中，依次存储了两次写事务的数据，其中第一次写了两帧数据，第二次写了一帧数据。&lt;/p&gt;

&lt;p&gt;有了以上的概念，下面详细看WAL文件的结构。&lt;/p&gt;

&lt;h3 id=&#34;wal文件头格式&#34;&gt;WAL文件头格式&lt;/h3&gt;

&lt;p&gt;（引用自 &lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt; section 4.1）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Offset&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Size&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Magic number. 0x377f0682 or 0x377f0683&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;File format version. Currently 3007000.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Database page size. Example: 1024&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checkpoint sequence number&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Salt-1: random integer incremented with each checkpoint&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Salt-2: a different random number for each checkpoint&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checksum-1: First part of a checksum on the first 24 bytes of header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checksum-2: Second part of the checksum on the first 24 bytes of header&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中的很多字段自有解释，其中多数涉及到页面内容的校验，后面再展开说。&lt;/p&gt;

&lt;h3 id=&#34;wal帧头部格式&#34;&gt;WAL帧头部格式&lt;/h3&gt;

&lt;p&gt;（引用自 &lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt; section 4.1）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Offset&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Size&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Page number&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;For commit records, the size of the database file in pages after the commit. For all other records, zero.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Salt-1 copied from the WAL header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Salt-2 copied from the WAL header&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checksum-1: Cumulative checksum up through and including this page&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checksum-2: Second half of the cumulative checksum.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;帧头部需要存储如下的信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0-4字节：页面编号。&lt;/li&gt;
&lt;li&gt;4-8字节：对于提交记录而言，这4字节存储的是该事务提交之后，数据库文件的最大页面编号；其它的时候，这4字节为0。也就是说，这4字节大于0的时候，表示是一次事务的最后一次页面修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其它的字段，都跟页面的校验有关，接下来就看看这部分的实现。&lt;/p&gt;

&lt;h3 id=&#34;页面内容校验算法&#34;&gt;页面内容校验算法&lt;/h3&gt;

&lt;p&gt;前面的格式中，无论是WAL文件头，还是WAL帧头部，都有以下的字段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;8字节的salt数据。&lt;/li&gt;
&lt;li&gt;两组4字节的checksum数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;校验时，只有满足以下条件的情况下才认为是正确的帧数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;帧头部中的8字节的salt数据，和WAL头部的salt数据相同。&lt;/li&gt;
&lt;li&gt;根据校验算法遍历页面数据计算出来的checksum，和帧头部的checksum数据相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一部分salt数据，每次写事务生成一次，所以校验这个值可以认为校验这一帧数据是否和这次事务匹配；而第二部分的checksum数据，则会用来依次串起一次写事务的所有页面修改。&lt;/p&gt;

&lt;p&gt;比如下面这个写事务流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一次写页面，由于之前这个写事务没有写过页面，所以初始的checksum为0，以这个初始的checksum来计算这第一个页面的checksum，计算之后的值记录到这个页面的checksum，记为&lt;code&gt;checksum_1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第二次写页面，取上一次计算的checksum即&lt;code&gt;checksum_1&lt;/code&gt;，来计算这第二个页面的checksum，记为&lt;code&gt;checksum_2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;类似的，第N次写页面时，以上一次计算的checksum即&lt;code&gt;checksum_n-1&lt;/code&gt;来做为计算的初始值计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样，相邻页面之间的校验值就有了关联。&lt;/p&gt;

&lt;p&gt;总结起来：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;salt：每次事务算一次随机值。&lt;/li&gt;
&lt;li&gt;checksum：满足以下以下条件：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;checksum_0 = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checksum_n = F(checksum_n-1, 页面数据)&lt;/code&gt;，其中函数F是根据初始校验值和页面数据计算出新校验值的函数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;校验页面的函数实现在&lt;code&gt;walDecodeFrame&lt;/code&gt;中，而计算页面校验值的函数实现在&lt;code&gt;walChecksumBytes&lt;/code&gt;中。&lt;/p&gt;

&lt;h2 id=&#34;wal页面索引&#34;&gt;WAL页面索引&lt;/h2&gt;

&lt;h3 id=&#34;结构&#34;&gt;结构&lt;/h3&gt;

&lt;p&gt;前面分析WAL文件结构的时候，提到保存一页数据的内容被称为“帧（frame）”，帧的编号从1开始顺序递增，每一帧内容存储的页面内容可能会发生变化，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-frame.png&#34; alt=&#34;帧与页面的对应关系&#34; title=&#34;帧与页面的对应关系&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;图中，依次有四帧页面数据，帧数与页面的对应关系依次是：(1,1)，(2,3)，(3,5)，(4,4)。假设随着运行，第一帧对应的页面1被写入了数据库，那么第一帧的空间就会被复用来存储别的页面的内容。&lt;/p&gt;

&lt;p&gt;所以，WAL页面索引中，需要存储帧数与页面编号之间的对应关系，这样就能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;访问一帧的内容时，知道保存的是哪个页面的内容；&lt;/li&gt;
&lt;li&gt;根据页面编号，能查到这个页面的最新数据保存在哪一帧中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据需要的这两份数据，定义了用于保存wal索引的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct WalHashLoc {
  volatile ht_slot *aHash;  /* Start of the wal-index hash table */
  volatile u32 *aPgno;      /* aPgno[1] is the page of first frame indexed */
  u32 iZero;                /* One less than the frame number of first indexed*/
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aHash：保存了根据页面编号查找iFrame帧数的hash数组数据。&lt;/li&gt;
&lt;li&gt;aPgno：保存了根据帧数查找页面编号的数据。&lt;/li&gt;
&lt;li&gt;iZero：保存了当前索引页面第一帧的帧数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这么看来有一些抽象，我们以下图来做解释wal-index文件的结构：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-index-format.png&#34; alt=&#34;WAL-Index索引文件结构图&#34; title=&#34;WAL-Index索引文件结构图&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wal索引文件一页大小为32KB，需要注意的是：不要把wal索引文件的一页与数据库文件的一页搞混，两者并不一定相同，但是都为2的次方，数据库文件的一页可以编译期修改，但是wal索引文件的一页大小写死为32KB。&lt;/li&gt;
&lt;li&gt;第一页相对有些特殊，因为最开始的136字节是wal索引文件头，所以相对的，剩下用来存储索引数据的空间就会变少一些。索引文件头的内容，留待后面再详细解释。&lt;/li&gt;
&lt;li&gt;每一页存储的数据中，&lt;code&gt;aPgno&lt;/code&gt;大小为4096（第一页只有4062，因为有头部用到的空间），&lt;code&gt;aHash&lt;/code&gt;的大小为8192。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/WalHashLoc.png&#34; alt=&#34;页面索引数据的构成&#34; title=&#34;页面索引数据的构成&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这几个常量，由下面这几个宏来定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 每一页aPgno数组大小
#define HASHTABLE_NPAGE      4096                 /* Must be power of 2 */
// 查询时hash取模时的质数
#define HASHTABLE_HASH_1     383                  /* Should be prime */
// 每一页hash slot数组大小
#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  /* Must be a power of 2 */

// 页面1实际能容纳的aPgno大小：HASHTABLE_NPAGE减去WALINDEX_HDR_SIZE使用的大小
#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))

// 一个wal索引页面的大小，为4096*4+8192*2 = 32KB
#define WALINDEX_PGSZ   (                                         \
    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;索引文件头结构&#34;&gt;索引文件头结构&lt;/h4&gt;

&lt;p&gt;来看看索引文件头的结构，其整体大小为136字节，划分为三部分：&lt;/p&gt;

&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt; section 2.1）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Bytes&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0..47&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;First copy of the WAL Index Information&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;48..95&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Second copy of the WAL Index Information&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;96..135&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checkpoint Information and Locks&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这总共136字节的数据，一共分为三个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0-47字节：WAL索引头部，由结构体&lt;code&gt;WalIndexHdr&lt;/code&gt;来描述。&lt;/li&gt;
&lt;li&gt;48-95字节：还是一个由结构体&lt;code&gt;WalIndexHdr&lt;/code&gt;描述的WAL索引头部。&lt;/li&gt;
&lt;li&gt;96-136字节：由结构体&lt;code&gt;WalCkptInfo&lt;/code&gt;描述的WAL checkpoint信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的表格，详细展示了这136字节中都有哪些字段。&lt;/p&gt;

&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt; section 2.1）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Bytes&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0..3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;iVersion&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The WAL-index format version number. Always 3007000.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;4..7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unused padding space. Must be zero.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;8..11&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;iChange&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unsigned integer counter, incremented with each transaction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;isInit&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The &amp;ldquo;isInit&amp;rdquo; flag. 1 when the shm file has been initialized.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;bigEndCksum&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;True if the WAL file uses big-ending checksums. 0 if the WAL uses little-endian checksums.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;14..15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;szPage&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The database page size in bytes, or 1 if the page size is 65536.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;16..19&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mxFrame&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of valid and committed frames in the WAL file.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;20..23&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nPage&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Size of the database file in pages.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;24..31&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;aFrameCksum&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Checksum of the last frame in the WAL file.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;32..39&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;aSalt&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;40..47&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;aCksum&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A checksum over bytes 0 through 39 of this header.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;48..95&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A copy of bytes 0 through 47 of this header.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;96..99&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nBackfill&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of WAL frames that have already been backfilled into the database by prior checkpoints&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;100..119&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;read-mark[0..4]&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Five &amp;ldquo;read marks&amp;rdquo;. Each read mark is a 32-bit unsigned integer (4 bytes).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;120..127&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unused space set aside for 8 file locks.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;128..132&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nBackfillAttempted&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;132..136&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Unused space reserved for further expansion.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面就这里的一些重点字段做一下介绍。&lt;/p&gt;

&lt;h5 id=&#34;为什么需要两个相同大小的wal索引头部&#34;&gt;为什么需要两个相同大小的WAL索引头部？&lt;/h5&gt;

&lt;p&gt;注意到0-47和48-95这两部分48字节的数据，都是同样类型的数据，都由&lt;code&gt;WalIndexHdr&lt;/code&gt;结构体来描述。&lt;/p&gt;

&lt;p&gt;这样设计的目的，是为了读写的时候数据校验。假设头48字节为&lt;code&gt;h1&lt;/code&gt;，后48字节为&lt;code&gt;h2&lt;/code&gt;。那么读操作的时候是先读&lt;code&gt;h1&lt;/code&gt;再读&lt;code&gt;h2&lt;/code&gt;，而写操作的时候则相反，先写&lt;code&gt;h2&lt;/code&gt;再写&lt;code&gt;h1&lt;/code&gt;。这样，如果在读操作的时候，读到这两部分内容并不一样，说明当前有写操作在进行。&lt;/p&gt;

&lt;p&gt;读头部的实现见函数&lt;code&gt;walIndexTryHdr&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged)
{
  u32 aCksum[2];              /* Checksum on the header content */
  WalIndexHdr h1, h2;         /* Two copies of the header content */
  WalIndexHdr volatile *aHdr; /* Header in shared memory */

  aHdr = walIndexHdr(pWal);
  memcpy(&amp;amp;h1, (void *)&amp;amp;aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */
  walShmBarrier(pWal);
  memcpy(&amp;amp;h2, (void *)&amp;amp;aHdr[1], sizeof(h2));

  // 对比两个header，不相同就返回
  if (memcmp(&amp;amp;h1, &amp;amp;h2, sizeof(h1)) != 0)
  {
    return 1; /* Dirty read */
  }
  if (h1.isInit == 0)
  {
    return 1; /* Malformed header - probably all zeros */
  }
  // 对比校验值
  walChecksumBytes(1, (u8 *)&amp;amp;h1, sizeof(h1) - sizeof(h1.aCksum), 0, aCksum);
  if (aCksum[0] != h1.aCksum[0] || aCksum[1] != h1.aCksum[1])
  {
    return 1; /* Checksum does not match */
  }

  // 到了这里，就是判断是否发生过改变了
  if (memcmp(&amp;amp;pWal-&amp;gt;hdr, &amp;amp;h1, sizeof(WalIndexHdr)))
  {
    *pChanged = 1;
    memcpy(&amp;amp;pWal-&amp;gt;hdr, &amp;amp;h1, sizeof(WalIndexHdr));
    pWal-&amp;gt;szPage = (pWal-&amp;gt;hdr.szPage &amp;amp; 0xfe00) + ((pWal-&amp;gt;hdr.szPage &amp;amp; 0x0001) &amp;lt;&amp;lt; 16);
    testcase(pWal-&amp;gt;szPage &amp;lt;= 32768);
    testcase(pWal-&amp;gt;szPage &amp;gt;= 65536);
  }

  /* The header was successfully read. Return zero. */
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;mxframe和nbackfill&#34;&gt;mxFrame和nBackfill&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;mxFrame&lt;/code&gt;记录着当前WAL文件的最大帧数，而&lt;code&gt;nBackfill&lt;/code&gt;记录着当前&lt;code&gt;checkpoint&lt;/code&gt;操作进行到第几帧，即在&lt;code&gt;nBackfill&lt;/code&gt;之前的帧数都已经被写入数据库文件了。&lt;/p&gt;

&lt;p&gt;显然这两个值有如下关系：&lt;code&gt;nBackfill&amp;lt;=mxFrame&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nBackfill&amp;lt;mxFrame&lt;/code&gt;，&lt;code&gt;checkpoint&lt;/code&gt;过程还未结束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nBackfill==mxFrame&lt;/code&gt;，&lt;code&gt;checkpoint&lt;/code&gt;过程已经结束，这时候：

&lt;ul&gt;
&lt;li&gt;WAL文件中的所有页面已经被回填（backfill）到数据库文件中了；&lt;/li&gt;
&lt;li&gt;所有读页面的操作，都不再需要访问WAL文件，而是直接访问数据库文件；&lt;/li&gt;
&lt;li&gt;下一次再有写操作，可以从WAL的头部开始写。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;p&gt;有了前面的准备，我们来看看这两种对应关系的查找是怎么做的。&lt;/p&gt;

&lt;h4 id=&#34;索引页面的存储&#34;&gt;索引页面的存储&lt;/h4&gt;

&lt;p&gt;前面分析到，一个wal索引页面的大小为32KB，这些数据是存储在&lt;code&gt;Wal&lt;/code&gt;结构体中的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Wal {
	// ...
	int nWiData;               /* Size of array apWiData */
	volatile u32 **apWiData;   /* Pointer to wal-index content in memory */
	// ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apWiData：存储页面指针的数组。&lt;/li&gt;
&lt;li&gt;nWiData：页面指针数组的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;根据帧数查询页面编号&#34;&gt;根据帧数查询页面编号&lt;/h4&gt;

&lt;p&gt;首先来看根据帧数查询这一帧存储的是哪个页面的数据，即根据帧数查询页面编号的实现。&lt;/p&gt;

&lt;p&gt;由于wal文件中，到了一定大小之后，就会执行“checkpoint”操作，所以帧数一定是有限的。即帧数满足以下的条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从0开始递增。&lt;/li&gt;
&lt;li&gt;不会无限增大。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以在&lt;code&gt;aPgno&lt;/code&gt;中，就直接使用帧数来做为这个数组的索引。总结下来，添加一个帧数和页面之间对应关系的大体的步骤如下（函数&lt;code&gt;walIndexAppend&lt;/code&gt;）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先根据帧数，知道在第几个索引页面中，也就是&lt;code&gt;apWiData&lt;/code&gt;数组的第几个元素，这样就拿到这一帧对应在哪个32KB的数据。（函数&lt;code&gt;walHashGet&lt;/code&gt;，另外函数&lt;code&gt;walFramePage&lt;/code&gt;是根据帧数得到&lt;code&gt;apWiData&lt;/code&gt;数组索引）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;rc = walHashGet(pWal, walFramePage(iFrame), &amp;amp;sLoc);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;帧数减去这一页的&lt;code&gt;iZero&lt;/code&gt;知道是这一页中的&lt;code&gt;aPgno&lt;/code&gt;数组的索引：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;idx = iFrame - sLoc.iZero;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在hash数组中找到空位置存储页面编号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Write the aPgno[] array entry and the hash-table slot. */
nCollide = idx;
for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){
  if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将两者的对应关系存储下来，即：向&lt;code&gt;aPgno&lt;/code&gt;中存入页面编号，向&lt;code&gt;aHash&lt;/code&gt;中存储帧数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  sLoc.aPgno[idx] = iPage;
  AtomicStore(&amp;amp;sLoc.aHash[iKey], (ht_slot)idx);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了这个过程的大体示意：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/frame-pageno.png&#34; alt=&#34;添加帧数与页面编号对应关系的流程&#34; title=&#34;添加帧数与页面编号对应关系的流程&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;举个例子来说明上面的流程，假设要存储的对应关系是帧数5000存储的是页面编号5：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据帧数5000，算出这一帧的索引数据应该存储在第二个索引页面中，由此拿到这个页面的&lt;code&gt;WalHashLoc&lt;/code&gt;指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再根据5000，减去这个页面的帧数起始位置4063，得到帧数偏移量为927，即这个帧在这个&lt;code&gt;WalHashLoc-&amp;gt;aPgno&lt;/code&gt;数组的位置是927，即&lt;code&gt;idx=927&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再到&lt;code&gt;WalHashLoc-&amp;gt;aHash&lt;/code&gt;中，找到一个空的位置，这个空位置假设是&lt;code&gt;iKey=101&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;到了这里，位置都找到了，更新数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sLoc.aPgno[927] = 5;
AtomicStore(&amp;amp;sLoc.aHash[101], (ht_slot)927);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过帧数找到&lt;code&gt;aPgno&lt;/code&gt;是一个两次索引的过程：第一次根据帧数找到32KB页面，第二次再根据帧数找到在这一页中的帧数偏移量。&lt;/li&gt;
&lt;li&gt;最后修改&lt;code&gt;aHash&lt;/code&gt;是一次原子操作，因为其它地方可能同时在查询。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;根据页面编号查询所在帧&#34;&gt;根据页面编号查询所在帧&lt;/h4&gt;

&lt;p&gt;前面分析了如何存储帧数到页面编号的对应关系，可以看到这一次更新是把两个对应关系一起更新的。也可以看到，根据帧数查找的流程实际还是相对简单的，就是两次索引：一次找到页面，再一次就是页面内的查找，原因在于：帧数是有限的。&lt;/p&gt;

&lt;p&gt;但是页面就不是这样了，因为这里要存储的页面编号是数据库文件中的页面编号，并不知道当前数据库到底变到多大了，这样就不能按照前面的方式来两次索引。&lt;/p&gt;

&lt;p&gt;我们来看看如何根据页面编号，知道这一页面是存储在哪一帧里的，即wal文件的帧数，这个过程在函数&lt;code&gt;sqlite3WalFindFrame&lt;/code&gt;中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拿到该读操作当前最大和最小帧数，根据这两个帧数得到对应的索引32KB页面。&lt;/li&gt;
&lt;li&gt;从后往前遍历这些页面，每个页面中到&lt;code&gt;WalHashLoc-&amp;gt;aHash&lt;/code&gt;中，根据页面编号的hash值来查找。&lt;/li&gt;
&lt;li&gt;这个流程一直到找到页面，或者全部遍历完毕为止。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/sqlite3WalFindFrame.png&#34; alt=&#34;根据页面编号查找帧的流程&#34; title=&#34;根据页面编号查找帧的流程&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;从这个流程可以看到：查找页面对应帧数的流程，最坏的情况下可能遍历了所有索引页面，虽然其中的查找过程会根据页面编号的hash值来查找。于是一个重要的结论就出来了：&lt;strong&gt;WAL的实现，其中有一个缺点是，当WAL文件很大时，对应的索引页面也会很大，在索引中查找页面编号的流程就会变久。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;锁的实现&#34;&gt;锁的实现&lt;/h2&gt;

&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;

&lt;p&gt;wal模式提供了以下4种锁，这4种锁从wal索引文件头部120字节处开始，每种锁占一个字节：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WAL_WRITE_LOCK：写锁，写操作之前必须拿到写锁。&lt;/li&gt;
&lt;li&gt;WAL_CKPT_LOCK：checkpoint锁，在做checkpoint之前需要拿到这个锁。&lt;/li&gt;
&lt;li&gt;WAL_RECOVER_LOCK：恢复锁，在进行恢复操作之前要拿到这个锁。&lt;/li&gt;
&lt;li&gt;WAL_READ_LOCK：读锁，一共有五个读锁，但是作用不尽相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四种锁，其中有五个读锁，一共加起来就是8个锁，定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// wal索引文件中锁的数量
#define SQLITE_SHM_NLOCK        8

// 写锁在所有锁中的偏移量
#define WAL_WRITE_LOCK 0
// 除了写锁以外的其他所有锁
#define WAL_ALL_BUT_WRITE 1
// checkpoint锁在所有锁中的偏移量
#define WAL_CKPT_LOCK 1
// 恢复锁在所有锁中的偏移量
#define WAL_RECOVER_LOCK 2
// 输入读锁索引，返回对应读锁在所有锁中的偏移量，因为读锁从3开始，所以+3
#define WAL_READ_LOCK(I) (3 + (I))
// 读索引的数量 = 所有锁数量 - 读锁起始位置3
#define WAL_NREADER (SQLITE_SHM_NLOCK - 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题来了，为什么是索引文件头部120字节处开始的呢？从上面对wal索引文件的格式分析可知：索引文件开始是两个&lt;code&gt;WalIndexHdr&lt;/code&gt; + 一个&lt;code&gt;WalCkptInfo&lt;/code&gt;，而&lt;code&gt;WalCkptInfo&lt;/code&gt;结构体定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct WalCkptInfo
{
  u32 nBackfill;              /* Number of WAL frames backfilled into DB */
  u32 aReadMark[WAL_NREADER]; /* Reader marks */
  u8 aLock[SQLITE_SHM_NLOCK]; /* Reserved space for locks */
  u32 nBackfillAttempted;     /* WAL frames perhaps written, or maybe not */
  u32 notUsed0;               /* Available for future enhancements */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;aLock&lt;/code&gt;字段就是存储上面的这些锁的数组，把前面这些数据的大小加起来，一直到这个字段就正好是120，有宏定义为证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* A block of WALINDEX_LOCK_RESERVED bytes beginning at
** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systems
** only support mandatory file-locks, we do not read or write data
** from the region of the file on which locks are applied.
*/
#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr) * 2 + offsetof(WalCkptInfo, aLock))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（引用自&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt;）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Offset&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;xShmLock&lt;/td&gt;
&lt;td&gt;File&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_WRITE_LOCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_CKPT_LOCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td&gt;121&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_RECOVER_LOCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;td&gt;122&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_READ_LOCK(0)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_READ_LOCK(1)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td&gt;124&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_READ_LOCK(2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;5&lt;/td&gt;
&lt;td&gt;125&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_READ_LOCK(3)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;6&lt;/td&gt;
&lt;td&gt;126&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;WAL_READ_LOCK(4)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;加解锁操作&#34;&gt;加解锁操作&lt;/h3&gt;

&lt;p&gt;wal与前面的journal相比，少了很多其他类型的锁，wal只有两种类型的锁：shared共享锁，以及exclusive排它锁。对应的API有下面四个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int walLockShared(Wal *pWal, int lockIdx);
static void walUnlockShared(Wal *pWal, int lockIdx);
static int walLockExclusive(Wal *pWal, int lockIdx, int n);
static void walUnlockExclusive(Wal *pWal, int lockIdx, int n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有几个细节，需要交待一下。&lt;/p&gt;

&lt;p&gt;首先，其中传入的参数&lt;code&gt;lockIdx&lt;/code&gt;，就是上面提到的几种锁的类型索引。&lt;/p&gt;

&lt;p&gt;其次，代码中有&lt;code&gt;walLockShared(pWal, WAL_WRITE_LOCK)&lt;/code&gt;这样的操作。对一个写锁加共享锁应该怎么理解？需要纠正的是，类似&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;这样的宏，只是表示这一字节用于什么操作，比如&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;用于写操作，即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要拒绝其他写请求的情况下读数据时，就应该对&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;类型的锁加共享锁。&lt;/li&gt;
&lt;li&gt;要开始写操作时，就应该对&lt;code&gt;WAL_WRITE_LOCK&lt;/code&gt;类型的锁加排它锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他类型的锁依次类推，即&lt;code&gt;WAL_*_LOCK&lt;/code&gt;这类宏只是表示这一个字节的用途。&lt;/p&gt;

&lt;p&gt;最后一个细节是，加共享锁时只能传入锁类型索引，而加排它锁的时候还能传入一个参数n，这是什么意思？&lt;/p&gt;

&lt;p&gt;因为这些不同类型的锁，本质上就是wal索引共享文件上连续的字节，所以区别在于，共享锁一次只能对一个锁进行操作；而排它锁则可以一次多对多个锁进行操作。&lt;/p&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER - 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能把从1号读锁开始的所有读锁都加上排它锁。&lt;/p&gt;

&lt;p&gt;再比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  iLock = WAL_ALL_BUT_WRITE + pWal-&amp;gt;ckptLock;
  rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0) - iLock);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的几个常量取值如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ckptLock&lt;/code&gt;取值为0或者1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_ALL_BUT_WRITE&lt;/code&gt;为1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define WAL_READ_LOCK(I) (3 + (I))&lt;/code&gt;，所以&lt;code&gt;WAL_READ_LOCK(0)&lt;/code&gt;为3。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;ckptLock&lt;/code&gt;取值为0，表示这时候还没有加上了checkpoint的排它锁：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iLock&lt;/code&gt;为1，1为&lt;code&gt;WAL_CKPT_LOCK&lt;/code&gt;这个类型的锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_READ_LOCK(0) - iLock&lt;/code&gt;为2。&lt;/li&gt;
&lt;li&gt;这样，&lt;code&gt;walLockExclusive(pWal, iLock, WAL_READ_LOCK(0) - iLock);&lt;/code&gt;就能把checkpoint和0号读锁都加上排它锁，这样就不会其他checkpoint操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;ckptLock&lt;/code&gt;取值为1，表示这时候已经加上了checkpoint的排它锁：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iLock&lt;/code&gt;为2，2为&lt;code&gt;WAL_RECOVER_LOCK&lt;/code&gt;这个类型的锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAL_READ_LOCK(0) - iLock&lt;/code&gt;为1。&lt;/li&gt;
&lt;li&gt;这样，&lt;code&gt;walLockExclusive(pWal, iLock, WAL_READ_LOCK(0) - iLock);&lt;/code&gt;就能把恢复加上排它锁，这样能进行恢复操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;特殊的0号读锁&#34;&gt;特殊的0号读锁&lt;/h3&gt;

&lt;p&gt;除此以外，还需要注意0号读锁很特殊，它表示读事务申请的共享锁，和WAL_WRITE_LOCK不冲突，读写可以完全并发进行，互不影响，但是不能和数据库同步操作和WAL-index文件恢复并发进行。0号读锁表示只从数据库读取页。&lt;/p&gt;

&lt;p&gt;有了对锁的了解，可以接下来看各种操作的具体实现了。&lt;/p&gt;

&lt;h2 id=&#34;读操作&#34;&gt;读操作&lt;/h2&gt;

&lt;p&gt;进行读操作时，大体需要以下两个操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保存当前的&lt;code&gt;aReadMark&lt;/code&gt;，因为这涉及到读页面的时候数据从哪里来的问题。&lt;/li&gt;
&lt;li&gt;拿到对应的读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面分别讨论这两方面的内容。&lt;/p&gt;

&lt;h3 id=&#34;readmark&#34;&gt;readMark&lt;/h3&gt;

&lt;p&gt;首先来了解一下什么叫&lt;code&gt;readMark&lt;/code&gt;，以及有什么作用。&lt;/p&gt;

&lt;p&gt;回顾之前谈到wal文件以及wal索引文件的格式，有这么几个要点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于同一个页面编号的页面，可能会在wal文件存在不同时间的多次写入结果。这些多次写入结果里，如果所在的事务还未提交，那么这个修改应该对读操作还处于不可见的状态。wal文件头中使用&lt;code&gt;mxFrame&lt;/code&gt;这个字段来存储当前最后完成的写事务的帧数，超过这个帧数的修改都认为还没有完成。&lt;/li&gt;
&lt;li&gt;wal索引保存着页面的最新修改的位置信息，这“最新修改”指的是已经提交的事务，并不包括还未提交的事务的修改。&lt;/li&gt;
&lt;li&gt;读操作时，以页面编号先从wal索引中尝试读这个页面在wal中的位置信息：

&lt;ul&gt;
&lt;li&gt;如果读成功，根据这个wal的位置信息，到wal文件中读取该页面。&lt;/li&gt;
&lt;li&gt;否则，该页面没有在wal中，到数据库文件中读取。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下图为例来说明情况，为了简化说明，一个页面存储的一对KV的信息。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/read-wal.png&#34; alt=&#34;读操作看到的数据库文件和wal&#34; title=&#34;读操作看到的数据库文件和wal&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在上图中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有三个写事务，其中：

&lt;ul&gt;
&lt;li&gt;第一个事务已经完成，修改了值&lt;code&gt;y=20&lt;/code&gt;，这个修改存在第一帧中。&lt;/li&gt;
&lt;li&gt;第二个事务也已经完成，修改了值&lt;code&gt;x=1&lt;/code&gt;和&lt;code&gt;y=2&lt;/code&gt;，这两个修改存在第二和第三帧中。&lt;/li&gt;
&lt;li&gt;第三个事务还在进行中，目前修改了值&lt;code&gt;x=3&lt;/code&gt;，这个修改存在第四帧中，其余修改还在进行中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据上面的描述，那么wal索引中这几个维护位置信息的内容就是：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mxFrame=3&lt;/code&gt;，因为这是最后一个完成的写事务的最大帧数。&lt;/li&gt;
&lt;li&gt;wal索引中：&lt;/li&gt;
&lt;li&gt;x的位置在第四帧，但是需要注意这个值还并未提交，所以要区分不能读到未提交的值（read uncommitted），这在下面会展开说明。&lt;/li&gt;
&lt;li&gt;y的位置在第三帧。注意到y有两个数据，但是取了已提交事务中最新的那次数据。&lt;/li&gt;
&lt;li&gt;z在wal中没有，即在wal当前保存的所有事务中都没有修改到z，于是如果需要读取z的值，需要到数据库文件。&lt;/li&gt;
&lt;li&gt;在数据库文件中，x、y、z又是另外的三个值，因为这个时候，已提交事务的修改还在WAL文件中，并未写入数据库文件里面。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，当一个新的读操作开始的时候，会记录下来当时的&lt;code&gt;mxFrame&lt;/code&gt;，这个值对于读操作而言，被称为&lt;code&gt;readMark&lt;/code&gt;，保存在&lt;code&gt;WalCkptInfo&lt;/code&gt;结构体的成员&lt;code&gt;aReadMark&lt;/code&gt;数组中。有了这个值，当进行checkpoint操作的时候，就能判断当前是否需要等待读操作完成。这部分将在下面结合checkpoint流程继续讲解。&lt;/p&gt;

&lt;p&gt;除此之外，&lt;code&gt;readMark&lt;/code&gt;还有另一层含义：即当前已完成事务的最大帧数，所以当读事务去读一个页面的内容时，会首先到wal索引中，根据该页面的编号查询这个页面对应的帧数，有这几种可能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有找到：这说明当前wal文件中没有该页面的内容，要到数据库文件中查询。&lt;/li&gt;
&lt;li&gt;找到了，假设这个帧数为&lt;code&gt;iFrame&lt;/code&gt;，这又分为两种情况：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iFrame&amp;gt;readMark&lt;/code&gt;：这说明是这个读事务之后才进行的写操作，于是这个页面的内容还是不能从WAL文件中读取，仍然到数据库文件中读。这是因为如果从WAL中读取，可能读到的是还未提交的事务的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iFrame&amp;lt;=readMark&lt;/code&gt;：这说明是在这个读事务之前的写操作，可以从WAL文件读这个页面的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仍然以前面的图为例来说明情况，假设在上图的第三个写事务还在进行的时候，来了一个读事务，按照前面的解释，此时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个读事务的&lt;code&gt;readMark=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;假如这个读事务分别读了x、y、z这三个值，它需要到wal索引中查询这几个值是否在wal文件中，那么：

&lt;ul&gt;
&lt;li&gt;x：x的最新值在第四帧，大于&lt;code&gt;readMark=3&lt;/code&gt;，说明是个发起读操作之后还未提交的写事务更新的，这就不能读wal的最新值，而要读数据库文件中的值，此时读出来的值为&lt;code&gt;x=100&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;y：y的最新值在第三帧，并不大于&lt;code&gt;readMark=3&lt;/code&gt;，所以可以以wal的值为准，读出来&lt;code&gt;y=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;z：在wal索引中没有找到z，只能去数据库文件中查，读出来&lt;code&gt;z=300&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次说明的是，为了问题描述的简化，这里假设一个页面只存储了一对KV的值。&lt;/p&gt;

&lt;p&gt;有了对&lt;code&gt;readMark&lt;/code&gt;的初步了解，继续看读操作如何获得读锁。&lt;/p&gt;

&lt;h3 id=&#34;读锁&#34;&gt;读锁&lt;/h3&gt;

&lt;p&gt;前面已经提到，读锁的信息保存在&lt;code&gt;WalCkptInfo&lt;/code&gt;的&lt;code&gt;aLock&lt;/code&gt;成员中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct WalCkptInfo
{
	// ...
  u32 aReadMark[WAL_NREADER]; /* Reader marks */
  u8 aLock[SQLITE_SHM_NLOCK]; /* Reserved space for locks */
  // ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aReadMark&lt;/code&gt;：用于存储每个读操作的&lt;code&gt;readMark&lt;/code&gt;值，这个值已经在上面做了解释，这个数组的大小为&lt;code&gt;WAL_NREADER&lt;/code&gt;，即每个reader一个readMark值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aLock&lt;/code&gt;：存储锁类型的数组，这些锁类型也在上面做了诠释。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个读操作来的时候，需要获得一个读锁，才能继续往下进行它的读操作，这个获得锁的流程，在函数&lt;code&gt;walTryBeginRead&lt;/code&gt;中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;walIndexReadHdr&lt;/code&gt;函数读取wal的索引文件头。&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;WalCkptInfo&lt;/code&gt;信息存储在索引文件头中，于是可以接下来调用&lt;code&gt;walCkptInfo&lt;/code&gt;函数拿到这部分信息。&lt;/li&gt;
&lt;li&gt;寻找当前可用的读锁，分为以下几步：

&lt;ol&gt;
&lt;li&gt;有了当前的&lt;code&gt;WalCkptInfo&lt;/code&gt;信息，遍历其中的&lt;code&gt;aReadMark&lt;/code&gt;数组，选出其中&lt;code&gt;readMark&lt;/code&gt;最小的那个值，并且记录下这个最小值的索引&lt;code&gt;i&lt;/code&gt;。这是因为&lt;code&gt;readMark&lt;/code&gt;小的读操作，更有可能已经完成了读操作。&lt;/li&gt;
&lt;li&gt;尝试调用&lt;code&gt;walLockExclusive(pWal, WAL_READ_LOCK(i), 1)&lt;/code&gt;对上一步拿到的&lt;code&gt;readMark&lt;/code&gt;数组索引加排他锁：

&lt;ol&gt;
&lt;li&gt;如果成功，说明这个读锁当前没有其它进程在用，可以退出循环了。&lt;/li&gt;
&lt;li&gt;否则，就递增&lt;code&gt;i&lt;/code&gt;索引对下一个读锁进行尝试，直到遍历完毕所有读锁。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;到了这里，已经拿到一个可用的读锁了，调用&lt;code&gt;walLockShared&lt;/code&gt;对这个读锁加共享锁。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;在前面的过程中，很可能有写操作在进行，所以在返回之前，最后判断一下wal 索引头数据是否发生了变化，如果发生了变化，前面的步骤就得重新来过，返回重试。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要补充说明的是，函数&lt;code&gt;walTryBeginRead&lt;/code&gt;在调用时，如果返回重试（&lt;code&gt;WAL_RETRY&lt;/code&gt;）的话，调用者会将调用计数递增，当这个调用计数超过一个阈值时，再次调用时&lt;code&gt;walTryBeginRead&lt;/code&gt;会休眠一下，超过100次则会报错不再尝试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  // 尝试超过5次的情况下，要休眠一下
  if (cnt &amp;gt; 5)
  {
    int nDelay = 1; /* Pause time in microseconds */
    if (cnt &amp;gt; 100)
    {
      // 超过100次了，退出报错
      VVA_ONLY(pWal-&amp;gt;lockError = 1;)
      return SQLITE_PROTOCOL;
    }
    if (cnt &amp;gt;= 10)
      nDelay = (cnt - 9) * (cnt - 9) * 39;
    sqlite3OsSleep(pWal-&amp;gt;pVfs, nDelay);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/walTryBeginRead.png&#34; alt=&#34;walTryBeginRead函数流程&#34; title=&#34;walTryBeginRead函数流程&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;可以从加读锁的流程看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sqlite的WAL机制，最大只能支持同时有&lt;code&gt;WAL_NREADER&lt;/code&gt;个读操作并发。&lt;/li&gt;
&lt;li&gt;加读锁的时候，如果因为写操作导致wal索引文件头发生了变化，将前功尽弃再次尝试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;写操作&#34;&gt;写操作&lt;/h2&gt;

&lt;h3 id=&#34;写锁&#34;&gt;写锁&lt;/h3&gt;

&lt;p&gt;拿到写锁的流程，对比上面拿到读锁的流程来说，就简单很多了，在函数&lt;code&gt;sqlite3WalBeginWriteTransaction&lt;/code&gt;中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;walLockExclusive(pWal, WAL_WRITE_LOCK, 1)&lt;/code&gt;拿到写锁的排它锁。&lt;/li&gt;
&lt;li&gt;同样也是检查是否wal索引头发生了变化，如果是则需要再次尝试。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而解写锁操作就在函数&lt;code&gt;sqlite3WalBeginWriteTransaction&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这两个函数的实现都挺简单，就不展开阐述了。&lt;/p&gt;

&lt;h3 id=&#34;写操作-1&#34;&gt;写操作&lt;/h3&gt;

&lt;p&gt;真正将脏页面写入wal文件中的操作在函数&lt;code&gt;sqlite3WalFrames&lt;/code&gt;中，该函数有几个比较重要的参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PgHdr *pList：脏页面链表。&lt;/li&gt;
&lt;li&gt;int isCommit：为1的情况下，表示这是提交操作，即这个写事务的最后一次调用&lt;code&gt;sqlite3WalFrames&lt;/code&gt;函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;sqlite3WalFrames&lt;/code&gt;函数的实现也并不复杂，有这么几个事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拿到当前写wal的起始位置，从这个位置开始，遍历脏页面写入wal文件中。而这个起始位置，就是前面提到的&lt;code&gt;mxFrame+1&lt;/code&gt;帧。

&lt;ul&gt;
&lt;li&gt;但是这个过程中需要考虑到可能出现的覆盖情况，即：同一次写事务，对同一个页面有多次写操作，这种情况下，后面对同一个页面的写操作，不应该写到wal后面，而是覆盖前面的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;遍历脏页面链表，将脏页面写入wal文件之后，就需要根据最新的页面编号和wal文件帧数的对应关系，更新wal索引的内容。&lt;/li&gt;
&lt;li&gt;最后，更新&lt;code&gt;mxFrame&lt;/code&gt;的值为WAL文件当前的最大帧数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还是以一个例子来说明这个流程。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/write-wal.png&#34; alt=&#34;写事务修改WAL文件和WAL索引数据&#34; title=&#34;写事务修改WAL文件和WAL索引数据&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，精简了很多情况，假设从WAL文件的开头开始写脏页面了，图中的写事务一共写了三次页面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写入&lt;code&gt;y=200&lt;/code&gt;：这时候将这个内容写入WAL文件中的第一帧，更新wal索引中y页面的帧数为1，而此时x还没有内容。写完毕之后，更新&lt;code&gt;mxFrame=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;x=100&lt;/code&gt;：这时候将这个内容写入WAL文件中的第二帧，更新wal索引中x页面的帧数为2。写完毕之后，更新&lt;code&gt;mxFrame=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;y=101&lt;/code&gt;：写入时发现，同一个事务之前已经修改过y页面了，于是这一次并不把&lt;code&gt;y=101&lt;/code&gt;的修改继续写到WAL文件结尾，而是覆盖第一帧中已经存在的y页面内容，同时索引数据也不需要更新：因为是覆盖操作，y页面的帧数并没有发生变化。同样的，由于没有修改WAL文件的最大帧数，&lt;code&gt;mxFrame&lt;/code&gt;也没有修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;页面校验值的计算&#34;&gt;页面校验值的计算&lt;/h3&gt;

&lt;h2 id=&#34;checkpoint-1&#34;&gt;checkpoint&lt;/h2&gt;

&lt;h3 id=&#34;总体流程&#34;&gt;总体流程&lt;/h3&gt;

&lt;p&gt;有了前面读、写操作的了解，接着来了解一下checkpoint操作是如何实现的。&lt;/p&gt;

&lt;p&gt;我们回顾一下&lt;code&gt;checkpoint&lt;/code&gt;操作要完成的事情：由于wal日志中存储的，都是每次写事务被修改的页面，因此&lt;code&gt;checkpoint&lt;/code&gt;操作就是将wal日志中被修改的页面写入数据库文件中。也是因为这个原因，因此&lt;code&gt;checkpoint&lt;/code&gt;也被称为&lt;code&gt;backfill（回填）&lt;/code&gt;操作。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/checkpoint.png&#34; alt=&#34;checkpoint操作&#34; title=&#34;checkpoint操作&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;从上面的读写流程的分析里看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同时能支持多个读事务，每个读事务都有一个&lt;code&gt;readMark&lt;/code&gt;值，用来区分这个读操作读到在WAL中存储的某个页面时，是以wal的页面为准，还是应该到数据库文件中读取这个页面。&lt;/li&gt;
&lt;li&gt;同时只能存在一个写事务，这个写事务没有完成之前，任何读事务不能读到它的数据，因为是未提交（uncommitted）的修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，在做&lt;code&gt;checkpoint&lt;/code&gt;的时候，需要保证：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能将未提交写事务的修改，回填到数据库文件中。&lt;/li&gt;
&lt;li&gt;对于正在进行的读操作，不能将超过该读操作的&lt;code&gt;readMark&lt;/code&gt;值的帧，回填到数据库文件中，需要等待读操作完成才能回填这部分数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/checkpoint-readmark.png&#34; alt=&#34;checkpoint操作&#34; title=&#34;checkpoint操作&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;第一点很好理解，因为未提交的写事务，可能只修改了一部分，如果在未提交这个写事务之前，就把这一部分回填到数据库文件中，会造成读出来的这部分数据驴头不对马嘴。比如一个写事务的修改，是将A账号的100转账到B账号上，于是这个写事务就涉及两个修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A：扣除100。&lt;/li&gt;
&lt;li&gt;B：加上100。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果这个事务当前只完成了上面的第一步修改，这个修改马上被回填到数据库文件中，这时候看到的就是A少了100，而B没有变化，这显然是不可接受的。&lt;/p&gt;

&lt;p&gt;第二点的理解，要回到前面对&lt;code&gt;readMark&lt;/code&gt;值的解释上：一个读操作开始之前，会记录一下当前已完成写事务的最大修改帧数做为自己的&lt;code&gt;readMark&lt;/code&gt;，在后续的读操作中，从wal索引中查询一个页面编号，有以下几种可能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有找到，说明需要到数据库文件中查找该页面内容。&lt;/li&gt;
&lt;li&gt;找到了，又需要区分两种情况：

&lt;ul&gt;
&lt;li&gt;这个页面所在的帧数&amp;lt;&lt;code&gt;readMark&lt;/code&gt;：说明这个页面在读操作开始之后再没有被修改了，可以以wal的内容为准。&lt;/li&gt;
&lt;li&gt;否则：说明这个页面在读操作之后被修改了，需要到数据库文件中查询被修改之前的值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：上面的”这个页面在读操作之后被修改“条件，不仅包括这个修改对应的写事务没有被提交，也包括写事务已提交的情况。&lt;/p&gt;

&lt;p&gt;即：&lt;code&gt;readMark&lt;/code&gt;保证了，一个读事务绝对不能读到在这个读事务之后的任何修改。&lt;/p&gt;

&lt;p&gt;由这个解释可以看到，当一个读操作判断一个页面的内容需要到数据库文件中读取时，需要读到的是这个读事务之前的修改。因此，&lt;code&gt;checkpoint&lt;/code&gt;需要保证：不能将超过当前任何读操作的&lt;code&gt;readMark&lt;/code&gt;值的帧数，回填其保存的页面到数据库文件中。&lt;/p&gt;

&lt;p&gt;到了这里，基本可以确定一个&lt;code&gt;checkpoint&lt;/code&gt;操作的流程了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加&lt;code&gt;checkpoint&lt;/code&gt;的排它锁，保证同时只能有一个&lt;code&gt;checkpoint&lt;/code&gt;操作在进行。&lt;/li&gt;
&lt;li&gt;算出当前最大可以回填到第几帧的数据，假设这个值保存在变量&lt;code&gt;mxSafeFrame&lt;/code&gt;中，流程如下：

&lt;ul&gt;
&lt;li&gt;初始时，取&lt;code&gt;mxSafeFrame=mxFrame&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历当前所有还在进行的读操作，取&lt;code&gt;mxSafeFrame=min(mxSafeFrame, aReadMark)&lt;/code&gt;，即不能超过任何一个在进行的读操作的&lt;code&gt;readMark&lt;/code&gt;值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;计算出来了最大回填帧数，可以实际进行回填操作了：遍历当前的wal文件，将所有帧数小于等于&lt;code&gt;mxSafeFrame&lt;/code&gt;的修改都回填到数据库文件中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是&lt;code&gt;checkpoint&lt;/code&gt;流程的总体描述，其中涉及的主要函数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sqlite3WalCheckpoint&lt;/code&gt;：&lt;code&gt;checkpoint&lt;/code&gt;操作的入口函数，负责加&lt;code&gt;checkpoint&lt;/code&gt;排它锁，然后继续调用下面的&lt;code&gt;walCheckpoint&lt;/code&gt;进行实际的回填操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;walCheckpoint&lt;/code&gt;：执行&lt;code&gt;checkpoint&lt;/code&gt;操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想了解更多细节的读者可以自行阅读。&lt;/p&gt;

&lt;h3 id=&#34;不同的checkpoint模式&#34;&gt;不同的checkpoint模式&lt;/h3&gt;

&lt;p&gt;上面只是了解了&lt;code&gt;checkpoint&lt;/code&gt;的大体流程，但是不同的checkpoint模式又有区别，有如下的宏来进行区分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define SQLITE_CHECKPOINT_PASSIVE  0  /* Do as much as possible w/o blocking */
#define SQLITE_CHECKPOINT_FULL     1  /* Wait for writers, then checkpoint */
#define SQLITE_CHECKPOINT_RESTART  2  /* Like FULL but wait for for readers */
#define SQLITE_CHECKPOINT_TRUNCATE 3  /* Like RESTART but also truncate WAL */
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sqlite-checkpoint-passive&#34;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/h4&gt;

&lt;p&gt;这个模式下，不会等待读写操作完成，而是基于现有的数据，尽可能将安全的帧回填到数据库文件中。&lt;/p&gt;

&lt;p&gt;可以看到，这种模式更接近于一种”步进（step）“的模式：每次回填一部分数据，回填不完就直接返回不再进行。所以，需要某些变量来保存当前的回填进度，这个值保存在&lt;code&gt;WalCkptInfo.nBackfill&lt;/code&gt;，所以回填还没有结束的条件也就是：&lt;code&gt;pInfo-&amp;gt;nBackfill &amp;lt; pWal-&amp;gt;hdr.mxFrame&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-checkpoint-full&#34;&gt;SQLITE_CHECKPOINT_FULL&lt;/h4&gt;

&lt;p&gt;这个模式下，&lt;code&gt;checkpoint&lt;/code&gt;操作会等待写操作完成，才继续进行回填操作，而在回填过程中也不再允许有新的写操作进行。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-checkpoint-restart&#34;&gt;SQLITE_CHECKPOINT_RESTART&lt;/h4&gt;

&lt;p&gt;对比&lt;code&gt;SQLITE_CHECKPOINT_FULL&lt;/code&gt;模式，这一个模式更进了一步：等待所有读操作完成才开始回填操作，同样的，在&lt;code&gt;checkpoint&lt;/code&gt;过程中除了不能有写操作还不能有读操作。&lt;/p&gt;

&lt;h4 id=&#34;sqlite-checkpoint-truncate&#34;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/h4&gt;

&lt;p&gt;这一个模式对比&lt;code&gt;SQLITE_CHECKPOINT_RESTART&lt;/code&gt;又更近了一步，在回填完毕之后，将截断WAL文件，这样后面新来的wal的写操作，将从wal文件的开始位置开始写。我们前面提到，在wal文件中查找一个页面时，跟wal文件的大小成正比，所以回填完毕截断wal文件重新开始写，会加速后面的查询操作。&lt;/p&gt;

&lt;h2 id=&#34;错误恢复&#34;&gt;错误恢复&lt;/h2&gt;

&lt;p&gt;以上已经把wal的读、写、checkpoint流程都了解了，最后了解一下wal的错误恢复是如何实现的。&lt;/p&gt;

&lt;p&gt;区分几种情况下面的出错崩溃，以及这些情况下都如何恢复的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写事务进行时出错崩溃：这种情况下，显然wal中存储了一部分这个写事务的修改，崩溃恢复时校验后会发现这部分的修改不完全，于是会将这部分修改截断，而数据库文件，根据前面&lt;code&gt;checkpoint&lt;/code&gt;流程的讲解，并不会回填还未提交的写事务的修改，所以数据库文件并未损坏。&lt;/li&gt;
&lt;li&gt;当前没有任何写事务，在进行&lt;code&gt;checkpoint&lt;/code&gt;过程中崩溃：在进行&lt;code&gt;checkpoint&lt;/code&gt;时，不允许同时并发有写操作。于是这种情况下，wal文件中保存的数据，都是完整的写事务修改数据。启动后校验wal文件发现内容都是对的，于是遍历wal文件，首先将当前wal文件中的内容全部回填至数据库文件中再启动即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;最后对wal机制做一个简短的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;与journal备份机制不同的是：journal备份的是修改之前的页面内容，而wal存储的是修改后的内容。&lt;/li&gt;
&lt;li&gt;于是，wal中可能存储了同一个页面的多次修改结果，因为不同的事务、甚至相同的事务，都有可能修改了同一个页面，而每一次修改都要将修改结果存储wal文件。&lt;/li&gt;
&lt;li&gt;wal文件中，存储一个页面内容的单位是”帧（frame）“，一帧存储一个页面，而反过来一个页面可能先后被存储在不同帧的内容中。于是就需要wal索引数据：&lt;/li&gt;
&lt;li&gt;wal索引需要存储两类数据：一个帧存储的是哪个页面的数据，以及某个页面最新的数据存储在哪一帧。&lt;/li&gt;
&lt;li&gt;完成一次写操作，wal只需一次sync操作（sync wal文件），journal需要两次（sync journal文件一次，将页面缓存写入数据库文件之后sync数据库文件一次），因此wal的写性能更高。&lt;/li&gt;
&lt;li&gt;wal支持一写多读的并发，但是journal在写的时候不支持同时读数据。&lt;/li&gt;
&lt;li&gt;有两个重要的变量来保证并发读时不会读到读操作开始之后的修改：&lt;code&gt;mxFrame&lt;/code&gt;保存的是当前最提交的写事务写的最大帧数；每个读操作还保存了一个&lt;code&gt;readMark&lt;/code&gt;值，存储的是读操作开始时的&lt;code&gt;mxFrame&lt;/code&gt;值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkpoint&lt;/code&gt;操作，又称为&lt;code&gt;回填（backfill）&lt;/code&gt;操作，用于将wal文件的内容同步到数据库文件中，它需要前面的&lt;code&gt;mxFrame&lt;/code&gt;和&lt;code&gt;readMark&lt;/code&gt;来保证回填操作的正确性。回填操作会影响同时在进行的读、写操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/wal.html&#34;&gt;Write-Ahead Logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/walformat.html&#34;&gt;WAL-mode File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WAL文件格式见：&lt;a href=&#34;https://www.sqlite.org/fileformat2.html&#34;&gt;Database File Format&lt;/a&gt;中“4. The Write-Ahead Log”这一小节内容。&lt;/li&gt;
&lt;li&gt;checkpoint中几种模式的解释：&lt;a href=&#34;https://sqlite.org/c3ref/wal_checkpoint_v2.html&#34;&gt;Checkpoint a database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zearot/article/details/51039593&#34;&gt;SQLite分析之WAL机制_岩之痕-CSDN博客_sqlite wal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/pfysw/article/details/80531495&#34;&gt;SQLite3源码学习（31） WAL日志的锁机制_test-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>etcd 3.5版本的joint consensus实现解析</title>
      <link>https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/</link>
      <pubDate>Sat, 01 Jan 2022 15:02:50 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;在以前的etcd实现中，“集群节点变更”这一功能，仅支持每次变更一个节点，最新的etcd已经能支持一次变更多个节点配置的功能了。本文将就这部分的实现进行解析。&lt;/p&gt;

&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;

&lt;p&gt;Raft论文《CONSENSUS: BRIDGING THEORY AND PRACTICE》的第四章”集群成员变更“中，支持两种集群变更方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次变更单节点，即“One Server Config Change”。&lt;/li&gt;
&lt;li&gt;多节点联合共识，即“Joint Consensus”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文先就这两种实现方式进行原理上的讲解。&lt;/p&gt;

&lt;h2 id=&#34;集群节点变更的问题&#34;&gt;集群节点变更的问题&lt;/h2&gt;

&lt;p&gt;要保证Raft协议的安全性，就是要保证任意时刻，集群中只有唯一的&lt;code&gt;leader&lt;/code&gt;节点。如果不加限制条件，那么动态向当前运行集群增删节点的操作，有可能会导致存在多个&lt;code&gt;leader&lt;/code&gt;的情况。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/multi-server.png&#34; alt=&#34;集群节点变更问题&#34; title=&#34;集群节点变更问题&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;图中有两种颜色的配置，绿色表示旧的集群配置（&lt;code&gt;C_old&lt;/code&gt;），蓝色表示新的集群配置（&lt;code&gt;C_new&lt;/code&gt;），如果不加任何限制，直接将配置启用，由于不同的集群节点之间，存在时间差，那么可能出现这样的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Server{1,2}：当前都使用旧的集群配置，所以可能选出server1为集群的leader。&lt;/li&gt;
&lt;li&gt;Server{3,4,5}：当前都使用新的集群配置，可能选出server3为集群的leader。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由上图可以看到：如果不加任何限制，直接应用新的集群配置，由于时间差的原因，可能导致集群中出现两个不同leader的情况。&lt;/p&gt;

&lt;h2 id=&#34;单节点成员变更-one-server-confchange&#34;&gt;单节点成员变更（One Server ConfChange）&lt;/h2&gt;

&lt;p&gt;“单节点成员变更”，意指每次只添加或删除一个节点，这样就能保证集群的安全性，不会在同一时间出现多个&lt;code&gt;leader&lt;/code&gt;的情况。之所以能有这个保证，是因为每次变更一个节点，那么新旧两种配置的半数节点（majorrity）肯定存在交集。以下图来说明：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/one-server-confchange.png&#34; alt=&#34;单节点成员变更&#34; title=&#34;单节点成员变更&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;上图演示了向偶数或奇数的集群增删一个节点的所有可能情况。不论哪种情况，新旧配置都有交集，在每个任期只能投出一张票的情况下，是不会出现多&lt;code&gt;leader&lt;/code&gt;的情况的。&lt;/p&gt;

&lt;p&gt;有了上面的理论基础，下面来看&lt;code&gt;单节点集群变更&lt;/code&gt;的全流程，当下发集群节点变更配置时，新的配置会以一种特殊的日志方式进行提交，即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通日志：半数通过，提交成功时，会传给应用层的状态机。&lt;/li&gt;
&lt;li&gt;配置变更类日志：半数通过，提交成功时，集群节点将以新的集群配置生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其流程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将集群配置变更数据，序列化为日志数据，需要将日志类型标记为&lt;code&gt;集群配置变更&lt;/code&gt;类的日志，提交给&lt;code&gt;leader&lt;/code&gt;节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;leader&lt;/code&gt;节点收到日志后，需要存储该日志的索引为&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;，像其它正常日志一样处理：先写本地的日志，再广播给集群的其他节点，半数应答则认为日志达成一致可以提交了。如果提交了这类日志，可以将前面保存的&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;置为空了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;集群配置变更&lt;/code&gt;日志提交之后，对照新旧的集群变更数据，该添加到集群的添加到集群，该删除的节点停机。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，同一时间只能有唯一一个&lt;code&gt;集群变更类日志&lt;/code&gt;存在，怎么保证这一点？就算是在&lt;code&gt;leader&lt;/code&gt;收到该类型日志时，判断&lt;code&gt;未完成的集群配置变更索引&lt;/code&gt;是否为空。&lt;/p&gt;

&lt;h2 id=&#34;多节点联合共识-joint-consensus&#34;&gt;多节点联合共识（Joint Consensus）&lt;/h2&gt;

&lt;p&gt;除了上面的单节点变更，有时候还需要一次提交多个节点的变更。但是按照前面的描述，如果一次提交多个节点，很可能会导致集群的安全性被破坏，即同时出现多个&lt;code&gt;leader&lt;/code&gt;的情况。因此，一次提交多节点时，就需要走&lt;code&gt;联合共识&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所谓的&lt;code&gt;联合共识&lt;/code&gt;，就是将新旧配置的节点一起做为一个节点集合，只有该节点集合达成半数一致，才能认为日志可以提交，由于新旧两个集合做了合并，那么就不会出现多&lt;code&gt;leader&lt;/code&gt;的情况了。具体流程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;leader&lt;/code&gt;收到成员变更请求，新集群节点集合为&lt;code&gt;C_new&lt;/code&gt;，当前集群节点集合为&lt;code&gt;C_old&lt;/code&gt;，此时首先会以新旧节点集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;做为一个&lt;code&gt;集群配置变更&lt;/code&gt;类的日志，走正常的日志提交流程。注意，这时候的日志，需要提交到&lt;code&gt;C_{old,new}&lt;/code&gt;中的所有节点。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;C_{old,new}&lt;/code&gt;集群变更日志提交之后，&lt;code&gt;leader&lt;/code&gt;节点再马上创建一个只有&lt;code&gt;C_new&lt;/code&gt;节点集合的&lt;code&gt;集群配置变更&lt;/code&gt;类日志，再次走正常的日志提交流程。这时候的日志，只需要提交到&lt;code&gt;C_new&lt;/code&gt;中的所有节点。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;C_new&lt;/code&gt;日志被提交之后，集群的配置就能切换到&lt;code&gt;C_new&lt;/code&gt;对应的新集群配置下了。而不在&lt;code&gt;C_new&lt;/code&gt;配置内的节点，将被移除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;code&gt;多节点联合共识&lt;/code&gt;的提交流程分为了两次提交：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先提交新旧集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再提交新节点集合&lt;code&gt;C_new&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下图来说明，这几个阶段中，集群的安全性都得到了保证：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/Joint-Consensus.png&#34; alt=&#34;多节点联合共识&#34; title=&#34;多节点联合共识&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;C_{old,new}&lt;/code&gt;配置提交之前：在做个阶段，集群中的节点，要么处于&lt;code&gt;C_old&lt;/code&gt;配置下，要么处于&lt;code&gt;C_new,old&lt;/code&gt;配置之下。此时，如果集群的&lt;code&gt;leader&lt;/code&gt;节点宕机，那么将会基于&lt;code&gt;C_old&lt;/code&gt;或者&lt;code&gt;C_new,old&lt;/code&gt;配置来选出新的&lt;code&gt;leader&lt;/code&gt;，而不会仅仅基于&lt;code&gt;C_new&lt;/code&gt;，因此不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_{old,new}&lt;/code&gt;配置提交之后，&lt;code&gt;C_new&lt;/code&gt;下发之前：如果这时候&lt;code&gt;leader&lt;/code&gt;宕机，只会基于&lt;code&gt;C_{old,new}&lt;/code&gt;的配置选出&lt;code&gt;leader&lt;/code&gt;，因此也不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_new&lt;/code&gt;下发但还未提交时：如果这时候&lt;code&gt;leader&lt;/code&gt;宕机，只会基于&lt;code&gt;C_{old,new}&lt;/code&gt;或者&lt;code&gt;C_new&lt;/code&gt;的配置选出&lt;code&gt;leader&lt;/code&gt;，同时也不再会发给仅仅在&lt;code&gt;C_old&lt;/code&gt;中的节点了，所以无论是哪个配置，都需要得到&lt;code&gt;C_new&lt;/code&gt;的半数同意，因此不会选出不同的&lt;code&gt;leader&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_new&lt;/code&gt;提交之后：此时集群中只有一种配置了，安全性得到了保证。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;

&lt;p&gt;了解了原理之后，可以来具体看etcd 3.5中这部分的实现了。&lt;/p&gt;

&lt;h2 id=&#34;learner&#34;&gt;learner&lt;/h2&gt;

&lt;p&gt;首先需要了解&lt;code&gt;learner&lt;/code&gt;这个概念，在Raft中，这类型节点有以下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;与其他节点一样，能正常接收&lt;code&gt;leader&lt;/code&gt;同步的日志。&lt;/li&gt;
&lt;li&gt;但是&lt;code&gt;learner&lt;/code&gt;节点没有投票权，即：投票时会忽略掉这类型节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也因为这样，所以&lt;code&gt;learner&lt;/code&gt;节点也常被称为&lt;code&gt;non voter&lt;/code&gt;类型的节点。&lt;/p&gt;

&lt;p&gt;那么，什么时候需要&lt;code&gt;learner&lt;/code&gt;节点呢？如果一个节点刚加入集群，此时要追上当前的进度，需要一段时间，但是由于这个新节点的加入，导致集群的不可用风险增加了，即原来三节点的集群，挂了一个还能工作；加入这个新节点之后，新节点还没赶上进度，那么可能挂了一个节点集群就不可用了。&lt;/p&gt;

&lt;p&gt;所以，对于新加入的节点，可以先将它置为&lt;code&gt;learner&lt;/code&gt;类型，即：只同步日志，不参与投票。等到进度追上了，再变成正常的有投票权的节点。&lt;/p&gt;

&lt;p&gt;一个节点，需要添加到集群中变成集群的&lt;code&gt;learner&lt;/code&gt;，或者从原集群的&lt;code&gt;voter&lt;/code&gt;变成&lt;code&gt;learner&lt;/code&gt;，也都不能直接添加，而是必须走前面正常的&lt;code&gt;集群变更&lt;/code&gt;流程，即：集群中的&lt;code&gt;learner&lt;/code&gt;集合也是集群节点配置的一部分。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;h3 id=&#34;每个节点的进度数据-progress结构体&#34;&gt;每个节点的进度数据（Progress结构体）&lt;/h3&gt;

&lt;p&gt;etcd中，使用&lt;code&gt;Progress&lt;/code&gt;结构体来存储集群中每个节点当前的进度数据，包括以下成员：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;日志索引类成员：

&lt;ul&gt;
&lt;li&gt;Match索引&lt;/li&gt;
&lt;li&gt;Next索引。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当前的进度状态：

&lt;ul&gt;
&lt;li&gt;探针状态（probe）：节点刚加入，或者刚恢复都是该状态。&lt;/li&gt;
&lt;li&gt;正常同步状态（replicate）。&lt;/li&gt;
&lt;li&gt;同步快照状态：当前没有在进行日志同步，而是在同步快照。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IsLearner：标记当前该节点是否是&lt;code&gt;learner&lt;/code&gt;状态的节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code&gt;进度状态&lt;/code&gt;类似于TCP协议中的流控，不在这里做阐述了；两个&lt;code&gt;日志索引&lt;/code&gt;也是Raft论文中用于存储节点进度数据的索引，也不在这里阐述了；唯独需要注意的是&lt;code&gt;IsLearner&lt;/code&gt;，该成员标记了该节点是否&lt;code&gt;learner&lt;/code&gt;节点。&lt;/p&gt;

&lt;h3 id=&#34;集群配置-config结构体&#34;&gt;集群配置（Config结构体）&lt;/h3&gt;

&lt;p&gt;集群配置使用&lt;code&gt;Config&lt;/code&gt;结构体来保存，其成员如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Voters：包括新旧两个配置。新旧两个配置的节点集合合集，成为当前的所有节点集合。

&lt;ul&gt;
&lt;li&gt;[0]：&lt;code&gt;incoming&lt;/code&gt;配置，新的集群配置。&lt;/li&gt;
&lt;li&gt;[1]：&lt;code&gt;outgoing&lt;/code&gt;配置，旧的集群配置。一般这个集合为空，这个集合不为空时，存储的是变更之前旧的集群配置，因此不为空时表示当前有未提交的&lt;code&gt;joint consensus&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Learners：当前的learner集合，learner集合和前面的所有节点集合交集必须为空集。&lt;/li&gt;
&lt;li&gt;LearnersNext：集群配置提交后，从原集群的&lt;code&gt;voter&lt;/code&gt;降级为&lt;code&gt;learner&lt;/code&gt;的节点集合。&lt;/li&gt;
&lt;li&gt;AutoLeave：该配置为true时，自动让新配置生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面原理的部分，只讲解了新旧配置的变更流程，但是在etcd的实现中，集群配置里除了新旧配置，还多了存储&lt;code&gt;Learner&lt;/code&gt;节点的两种集合，这会让情况变得更复杂一些。&lt;/p&gt;

&lt;p&gt;如果一个节点要在新的集群配置中变成&lt;code&gt;Learner&lt;/code&gt;，需要区分两种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;该节点原先是集群的&lt;code&gt;voter&lt;/code&gt;：并不是直接加入到&lt;code&gt;Learner&lt;/code&gt;集合的，而是首先提交到&lt;code&gt;LearnersNext&lt;/code&gt;集合中，同样也是等待这个新的集群配置被成功之后，才移动到&lt;code&gt;Learner&lt;/code&gt;集合中。否则，如果直接修改加入到&lt;code&gt;Learner&lt;/code&gt;集合中，可能导致集群的安全性受到影响。比如一个三节点{a,b,c}的集群，原先有只挂了一个节点还能继续工作；现在由于各种原因，想将节点c降级为&lt;code&gt;learner&lt;/code&gt;，将节点d加入到集群中，如果直接将c节点降级为&lt;code&gt;learner&lt;/code&gt;，就会导致在这个流程里一旦一个节点不可用，整个集群就不可用了。&lt;/li&gt;
&lt;li&gt;该节点原先不是集群中的成员：这种节点由于之前并不存在，并不影响集群的安全性，这时候可以直接移动到&lt;code&gt;Learner&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20220101-etcd3.5-joint-Consensus/add-learner.png&#34; alt=&#34;单节点成员变更&#34; title=&#34;单节点成员变更&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;所以：&lt;code&gt;Voters&lt;/code&gt;两个配置，与两种&lt;code&gt;Learner&lt;/code&gt;集合，必须满足以下的关系（见函数&lt;code&gt;checkInvariants&lt;/code&gt;）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;LearnersNext&lt;/code&gt;中的节点，表示未提交的集群配置中待添加&lt;code&gt;learner&lt;/code&gt;节点集合的节点：

&lt;ul&gt;
&lt;li&gt;必须出现在&lt;code&gt;outgoing&lt;/code&gt;中，即必须出现在旧的集群配置中。&lt;/li&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;为False。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Learners&lt;/code&gt;中的节点，表示当前集群的&lt;code&gt;learner&lt;/code&gt;节点集合：

&lt;ul&gt;
&lt;li&gt;不能出现在任一个&lt;code&gt;voter&lt;/code&gt;集合中（&lt;code&gt;incoming&lt;/code&gt;和&lt;code&gt;outgoing&lt;/code&gt;）中，即不能出现在新、旧的集群配置中。&lt;/li&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;为True。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;集群整体监控-progresstracker结构体&#34;&gt;集群整体监控（ProgressTracker结构体）&lt;/h3&gt;

&lt;p&gt;有了节点的进度数据（Progress结构体），以及集群配置数据（Config结构体），整个集群的进度管控，都放在了结构体&lt;code&gt;ProgressTracker&lt;/code&gt;中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Config：存储当前集群的配置。&lt;/li&gt;
&lt;li&gt;Progress：以节点ID为键，值为&lt;code&gt;Progress结构体&lt;/code&gt;的map。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;负责提交配置流程-changer结构体&#34;&gt;负责提交配置流程（Changer结构体）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Changer&lt;/code&gt;属于提交流程中存储中间状态的数据结构，对其输入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前的&lt;code&gt;ProgressTracker结构体&lt;/code&gt;数据，即当前的配置和进度数据。&lt;/li&gt;
&lt;li&gt;要进行的变更数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要提交的配置数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Raft最终以其输入的配置数据，来生成&lt;code&gt;集群配置类型&lt;/code&gt;的日志，走正常的日志提交流程。提交成功之后，配置生效。&lt;/p&gt;

&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;

&lt;p&gt;按照前面原理部分的分析，&lt;code&gt;多节点联合共识&lt;/code&gt;的提交分为两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先提交新旧集合的交集&lt;code&gt;C_{old,new}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再提交新节点集合&lt;code&gt;C_new&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际在etcd中，也是这样做的，分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EnterJoint：将新旧集合的交集提交。&lt;/li&gt;
&lt;li&gt;LeaveJoint：提交新节点集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;enterjoint&#34;&gt;EnterJoint&lt;/h3&gt;

&lt;p&gt;该流程在&lt;code&gt;Changer::EnterJoint&lt;/code&gt;中实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拷贝当前&lt;code&gt;ProgressTracker&lt;/code&gt;结构体当前的进度（&lt;code&gt;Progress&lt;/code&gt;）和配置数据（&lt;code&gt;Config&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;如果当前有在提交的配置，就返回退出，因为同一时间只能有一个未提交的配置变更。如何判断当前是否有未提交的配置？看&lt;code&gt;Config&lt;/code&gt;中的&lt;code&gt;outgoing&lt;/code&gt;（即&lt;code&gt;voters[1]&lt;/code&gt;）是否为空。我们下面再详细解释。&lt;/li&gt;
&lt;li&gt;下面，以第一步拷贝的配置数据，生成新的配置数据：

&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;Config&lt;/code&gt;中的&lt;code&gt;incoming&lt;/code&gt;数据拷贝到&lt;code&gt;outgoing&lt;/code&gt;中，即先保存当前的配置到&lt;code&gt;outgoing&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历需要修改的配置，根据不同的操作类型做操作，生成新的配置：&lt;/li&gt;
&lt;li&gt;如果要删除某节点，调用&lt;code&gt;Changer::remove&lt;/code&gt;函数：

&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;incoming&lt;/code&gt;中删除该节点。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Learner&lt;/code&gt;以及&lt;code&gt;LearnerNext&lt;/code&gt;集合中删除该节点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果增加&lt;code&gt;voter&lt;/code&gt;，调用&lt;code&gt;Changer::makeVoter&lt;/code&gt;函数：

&lt;ul&gt;
&lt;li&gt;该节点的进度数据中，&lt;code&gt;IsLearner&lt;/code&gt;变为&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;Learner&lt;/code&gt;以及&lt;code&gt;LearnerNext&lt;/code&gt;集合中删除该节点。&lt;/li&gt;
&lt;li&gt;将节点ID加入&lt;code&gt;incoming&lt;/code&gt;集合中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果增加&lt;code&gt;learner&lt;/code&gt;，调用&lt;code&gt;Changer::makeLearner&lt;/code&gt;函数：

&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;Changer::remove&lt;/code&gt;函数先删除该节点。&lt;/li&gt;
&lt;li&gt;判断是否在&lt;code&gt;outgoing&lt;/code&gt;配置中有该节点，表示该节点是降级节点：&lt;/li&gt;
&lt;li&gt;有：表示在新配置下变成了&lt;code&gt;learner&lt;/code&gt;，但是此时并不能直接变成&lt;code&gt;learner&lt;/code&gt;，所以这种情况下该节点加入到了配置的&lt;code&gt;LearnersNext&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;否则，说明是新增节点，直接加入到&lt;code&gt;Learner&lt;/code&gt;集合中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上面生成了新旧配置的交集配置，以这个配置数据生成日志来进行提交，生效后应用该配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;leavejoint&#34;&gt;LeaveJoint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;拷贝当前&lt;code&gt;ProgressTracker&lt;/code&gt;结构体当前的进度（&lt;code&gt;Progress&lt;/code&gt;）和配置数据（&lt;code&gt;Config&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;下面，以第一步拷贝的配置数据，生成新的配置数据：

&lt;ul&gt;
&lt;li&gt;遍历&lt;code&gt;LearnersNext&lt;/code&gt;集合，将其中的节点：&lt;/li&gt;
&lt;li&gt;加入&lt;code&gt;Learner&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IsLearner&lt;/code&gt;置为true。&lt;/li&gt;
&lt;li&gt;清空&lt;code&gt;LearnerNext&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;遍历&lt;code&gt;outgoing&lt;/code&gt;节点集合：&lt;/li&gt;
&lt;li&gt;如果一个节点，既不在&lt;code&gt;incoming&lt;/code&gt;集合中，也不在&lt;code&gt;Learner&lt;/code&gt;集合中，则认为在新的配置中没有该节点了，删除其进度数据。&lt;/li&gt;
&lt;li&gt;清空&lt;code&gt;outgoing&lt;/code&gt;节点集合。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上面生成了新旧配置的交集配置，以这个配置数据生成日志来进行提交，生效后应用该配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;以一个例子来说明上面的流程，假设集群当前的配置为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;投票节点：{1,2}。&lt;/li&gt;
&lt;li&gt;Learner节点：{}。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新提交的配置中有以下三个操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新增投票节点：{3}。&lt;/li&gt;
&lt;li&gt;降级节点{2}为&lt;code&gt;learner&lt;/code&gt;节点。&lt;/li&gt;
&lt;li&gt;新增Learner节点：{4}。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要再次强调：&lt;strong&gt;无论是&lt;code&gt;EnterJoint&lt;/code&gt;还是&lt;code&gt;LeaveJoint&lt;/code&gt;操作，都并不会让配置马上生效，而是生成了一份待提交的配置，Raft拿到这份配置生成一个提交配置变更的日志，走正常的日志提交流程，待这条日志被半数通过时，才生效该配置。&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;incoming节点集合&lt;/th&gt;
&lt;th&gt;outgoing节点集合&lt;/th&gt;
&lt;th&gt;Learner节点集合&lt;/th&gt;
&lt;th&gt;LearnerNext节点集合&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;提交之前&lt;/td&gt;
&lt;td&gt;{1,2}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EnterJoint&lt;/td&gt;
&lt;td&gt;{1,3}&lt;/td&gt;
&lt;td&gt;{1,2}&lt;/td&gt;
&lt;td&gt;{4}&lt;/td&gt;
&lt;td&gt;{2}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LeaveJoint&lt;/td&gt;
&lt;td&gt;{1,3}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;td&gt;{2,4}&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;读者可以对着上面的流程，以这个例子来理解一下。&lt;/p&gt;

&lt;h2 id=&#34;自动提交&#34;&gt;自动提交&lt;/h2&gt;

&lt;p&gt;这里还有一个细节，即&lt;code&gt;多节点联合共识&lt;/code&gt;是一个两阶段的提交流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnterJoint&lt;/code&gt;之后，&lt;code&gt;outgoing&lt;/code&gt;节点集合变为一个非空集合，这时候不再能提交新的配置，需要到&lt;code&gt;LeaveJoint&lt;/code&gt;之后，才会清空这个集合。&lt;/li&gt;
&lt;li&gt;在etcd中，&lt;code&gt;LeaveJoint&lt;/code&gt;操作，并不见得会自动执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是否在&lt;code&gt;EnterJoint&lt;/code&gt;之后自动执行&lt;code&gt;LeaveJoint&lt;/code&gt;，取决于当前提交的&lt;code&gt;Config&lt;/code&gt;结构体中的&lt;code&gt;AutoLeave&lt;/code&gt;字段，它有两种可能，见&lt;code&gt;ConfChangeTransition&lt;/code&gt;枚举类型的定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConfChangeTransitionAuto&lt;/code&gt;和&lt;code&gt;ConfChangeTransitionJointImplicit&lt;/code&gt;：如果是这两种情况，都会自动做转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfChangeTransitionJointExplicit&lt;/code&gt;：需要用户手动执行&lt;code&gt;LeaveJoint&lt;/code&gt;操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（见函数&lt;code&gt;ConfChangeV2::EnterJoint&lt;/code&gt;的实现。）&lt;/p&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;《CONSENSUS: BRIDGING THEORY AND PRACTICE》chapter4”Cluster membership changes“&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://etcd.io/docs/v3.3/learning/learner/&#34;&gt;Learner | etcd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（三）- journal文件备份机制</title>
      <link>https://www.codedump.info/post/20211222-sqlite-btree-3-journal/</link>
      <pubDate>Wed, 22 Dec 2021 19:15:31 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211222-sqlite-btree-3-journal/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;在上一节中（&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;），已经讲解了sqlite中的并发控制机制，里面会涉及到一个“备份页面”的模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;备份所有在一个事务中会修改到的页面。&lt;/li&gt;
&lt;li&gt;出错时回滚页面内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;里面也提到，有两种备份文件的机制：journal文件，以及WAL文件。今天首先讲解journal文件的实现，它的效率会更低一些，也正是因为这个原因后续推出了更优的WAL机制。&lt;/p&gt;

&lt;h2 id=&#34;相关命令&#34;&gt;相关命令&lt;/h2&gt;

&lt;p&gt;sqlite中，可以使用&lt;code&gt;PRAGMA journal_mode&lt;/code&gt;来修改备份文件机制，包括以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;delete：默认模式。在该模式下，在事务结束时，备份文件将被删除。&lt;/li&gt;
&lt;li&gt;truncate：日志文件被阶段为零字节长度。&lt;/li&gt;
&lt;li&gt;persist：日志文件被留在原地，但头部被重写，表明日志不再有效。&lt;/li&gt;
&lt;li&gt;memory：日志记录保留在内存中，而不是磁盘上。&lt;/li&gt;
&lt;li&gt;off：不保留任何备份记录。&lt;/li&gt;
&lt;li&gt;wal：采用wal形式的备份文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，前面三种delete、truncate、persist都是使用journal文件来实现的备份，区别在于事务结束之后的对备份文件的处理罢了。&lt;/p&gt;

&lt;p&gt;本节首先讲解journal文件，下一节讲解wal备份文件。&lt;/p&gt;

&lt;h1 id=&#34;journal文件格式&#34;&gt;journal文件格式&lt;/h1&gt;

&lt;p&gt;journal文件的文件名规则是：与同目录的数据库文件同名，但是多了字符串“-journal”为后缀。比如数据库文件是“test.db”，那么对应的journal文件名为“test.db-journal”。&lt;/p&gt;

&lt;h2 id=&#34;文件头&#34;&gt;文件头&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;文件头的magic number: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;journal文件中的页面数量，如果为-1表示一直到journal文件尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;每次计算校验值时算出来的随机数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;在开始备份前数据库文件的页面数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;磁盘扇区大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;journal文件中的页面大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里大部分的字段都自解释了，不必多做解释，唯一需要注意的是随机数，因为这是用来后续校验备份页面的字段，这将在后面结合流程来说明。&lt;/p&gt;

&lt;h2 id=&#34;页面内容&#34;&gt;页面内容&lt;/h2&gt;

&lt;p&gt;紧跟着文件头之后，journal文件还有一系列页面数据组成的内容，其中每部分的结构如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;页面编号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;备份的页面内容，N以页面大小为准，其中每页面大小在文件头中定义&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;N+4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;页面的校验值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由上面分析可见，整个journal文件是这样来组织的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;28字节的文件头。&lt;/li&gt;
&lt;li&gt;页面数据组成的数组，其中数组每个元素的大小为：4+页面大小（N）+4。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal.png&#34; alt=&#34;journal文件结构&#34; title=&#34;journal文件结构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;流程&#34;&gt;流程&lt;/h1&gt;

&lt;h2 id=&#34;判断页面是否已经备份&#34;&gt;判断页面是否已经备份&lt;/h2&gt;

&lt;p&gt;启动一个写事务的时候，可能会修改多个页面，但是这其中可能有些修改，修改的是同一个页面的内容，因此这种情况下只需要对这个页面备份一次即可。&lt;/p&gt;

&lt;p&gt;如何知道页面是否已经被备份过？页面管理器通过一个位图数据结构来保存这个信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bitvec *pInJournal;         /* One bit for each page in the database file */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;计算页面校验值&#34;&gt;计算页面校验值&lt;/h2&gt;

&lt;p&gt;计算一个页面校验码的流程在函数&lt;code&gt;pager_cksum&lt;/code&gt;中实现，其核心逻辑是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以随机算出的校验值为初始值，这个初始值就是存在journal文件头中偏移量为[12,16]的数据。&lt;/li&gt;
&lt;li&gt;从后往前遍历页面数据，每隔200字节取一个u32类型的值，累加起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这样的关联，进行数据恢复时就能马上通过文件头存储的随机数，计算出来页面的数据是否准确。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static u32 pager_cksum(Pager *pPager, const u8 *aData){
  u32 cksum = pPager-&amp;gt;cksumInit;         /* Checksum value to return */
  int i = pPager-&amp;gt;pageSize-200;          /* Loop counter */
  // 每隔200字节算一个值累加起来
  while( i&amp;gt;0 ){
    cksum += aData[i];
    i -= 200;
  }
  return cksum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备份页面&#34;&gt;备份页面&lt;/h2&gt;

&lt;p&gt;有了前面计算校验值、以位图来判断页面是否已经备份过的了解，现在开始将备份页面的流程。&lt;/p&gt;

&lt;p&gt;每一次需要修改一个页面之前，都会调用函数&lt;code&gt;pager_write&lt;/code&gt;，这样就能在修改之前首先备份这个页面的内容。&lt;/p&gt;

&lt;p&gt;要区分两种不同的页面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果页面编号比当前数据库文件的页面数量小，说明是已有页面，需要走备份页面的流程。&lt;/li&gt;
&lt;li&gt;否则，说明是新增页面，新增的页面不需要备份，只需要修改该页面的标志位是需要落盘（&lt;code&gt;PGHDR_NEED_SYNC&lt;/code&gt;），并且放入脏页面链表即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种情况是新增页面，没有备份的需求，这里就不做解释。&lt;/p&gt;

&lt;p&gt;这里具体解释第一种情况，即备份已有页面的流程，其主要逻辑如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先根据前面的&lt;code&gt;pInJournal&lt;/code&gt;位图数据，传入页面编号，判断这个页面是否备份过，如果已经备份过，不做任何操作。&lt;/li&gt;
&lt;li&gt;否则说明需要备份页面，将进入函数&lt;code&gt;pagerAddPageToRollbackJournal&lt;/code&gt;中将该页面内容备份写入journal文件：

&lt;ul&gt;
&lt;li&gt;调用前面提到的&lt;code&gt;pager_cksum&lt;/code&gt;函数，计算页面的校验值。&lt;/li&gt;
&lt;li&gt;按照上面解释的journal文件格式，依次写入页面编号、页面内容、第一步计算出来的校验值。&lt;/li&gt;
&lt;li&gt;由于备份了页面，所以要把这个新增的备份页面编号写入&lt;code&gt;pInJournal&lt;/code&gt;位图数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;备份页面的例子&#34;&gt;备份页面的例子&lt;/h3&gt;

&lt;p&gt;我们以一个例子来说明备份页面的流程，假设写事务执行时，情况如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当时数据库的页面数量为2，即有2个页面，其中页面的内容如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面一：保存了&lt;code&gt;x=0&lt;/code&gt;和&lt;code&gt;y=1&lt;/code&gt;的数据。&lt;/li&gt;
&lt;li&gt;页面二：保存了&lt;code&gt;z=2&lt;/code&gt;的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写事务执行时，依次做了如下的修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;修改页面1的一处内容：&lt;code&gt;x=1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;修改页面2的一处内容：&lt;code&gt;z=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;修改页面1的一处内容：&lt;code&gt;y=2&lt;/code&gt;，注意这里跟第一次修改属于同一个页面的不同位置。&lt;/li&gt;
&lt;li&gt;新增页面3：&lt;code&gt;p=4&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，对照上面的流程，这四次页面修改在调用函数&lt;code&gt;pager_write&lt;/code&gt;时，情况是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;修改页面1的一处内容&lt;code&gt;x=1&lt;/code&gt;：由于在备份页面位图中查不到页面编号为1的页面，且页面1小于当前数据库文件的页面数量2，因此属于修改当前已有页面，于是将这个页面备份到journal文件，即将页面一的未修改之前的内容&lt;code&gt;x=0,y=1&lt;/code&gt;写入journal备份文件中，完事了之后将这个页面编号1加入位图，表示已经备份了这个页面的未修改之前的内容。&lt;/li&gt;
&lt;li&gt;修改页面2的一处内容：类似的，也是备份了页面2的内容&lt;code&gt;z=2&lt;/code&gt;，同时将页面2加入位图，表示已经备份了这个页面的未修改之前的内容。&lt;/li&gt;
&lt;li&gt;修改页面1的一处内容&lt;code&gt;y=2&lt;/code&gt;：这一次虽然也是要修改已有页面，但是由于在位图中找到这个页面编号，说明在这一次事务中已经备份过这个页面了，于是不再需要备份操作，直接返回。&lt;/li&gt;
&lt;li&gt;新增页面3&lt;code&gt;p=4&lt;/code&gt;：发现该页面的编号3，大于当前数据库页面数量2，属于新增页面，于是不进行备份，只是加入到脏页面链表中同时标记需要落盘。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即：在这一次写事务执行的过程中，虽然需要修改4处内容，实际修改备份文件两次，新增数据库页面页面一次。&lt;/p&gt;

&lt;p&gt;这个例子前后数据库文件以及备份文件内容的对比见下图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal-example.png&#34; alt=&#34;journal备份页面例子&#34; title=&#34;journal备份页面例子&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;何时落盘&#34;&gt;何时落盘&lt;/h2&gt;

&lt;p&gt;前面备份待修改页面的流程中，备份的页面内容只是写到了备份文件里，实际还并没有执行&lt;code&gt;sync&lt;/code&gt;操作强制落盘，只要没有落盘就还是存在备份数据损坏的情况。&lt;/p&gt;

&lt;p&gt;在上一节的（&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;），备份文件内容落盘是放在第七步做的，此时对用户空间的页面内容的修改已经完成了，不清楚这一流程的可以回头再看看上一节的内容。&lt;/p&gt;

&lt;p&gt;具体到journal文件的机制，这一步是放在函数&lt;code&gt;pager_end_transaction&lt;/code&gt;进行的，&lt;code&gt;pager_end_transaction&lt;/code&gt;函数就是上面介绍的：在事务修改完毕用户空间的页面之后，被调用。&lt;/p&gt;

&lt;h2 id=&#34;错误恢复&#34;&gt;错误恢复&lt;/h2&gt;

&lt;p&gt;继续以上面的例子来解释一下使用journal备份文件机制下的错误恢复的流程。&lt;/p&gt;

&lt;p&gt;从上面的流程里，我们可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;journal备份文件备份的是未修改之前的页面内容，如果一个页面在一次修改中会被多次修改，也只会备份一次（如上面例子中的页面1）。&lt;/li&gt;
&lt;li&gt;写事务完成之后，首先会将journal备份文件中的内容首先sync到磁盘，才开始将页面缓存中的内容落到数据库文件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次来回顾一下之前&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架&lt;/a&gt;中的内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库文件：任何写操作的修改最终都将落到数据库文件中。&lt;/li&gt;
&lt;li&gt;页面缓存：暂存每次写操作过程中修改的内容。&lt;/li&gt;
&lt;li&gt;journal备份文件：备份页面被修改之前的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的例子，加上页面缓存之后如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211222-sqlite-btree-3-journal/journal-backup.png&#34; alt=&#34;journal恢复流程例子&#34; title=&#34;journal恢复流程例子&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;对应这个流程，这一次写操作只可能在以下这几个阶段中发生错误宕机，其对应的恢复机制如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写操作开始之前：这个没有太多可以说的，由于还没有开始真正的写操作，数据库文件中的内容还是完整的，且journal备份文件中没有内容，于是可以直接以数据库文件内容来启动即可。&lt;/li&gt;
&lt;li&gt;写操作流程中：即写了一部分数据，还没有完成整个写事务的时候发生错误。这个场景中，之前写入的数据都在页面缓存里，备份修改页面的内容在备份文件中，而数据库文件还未发生任何改动。所以在错误重新启动的时候，页面缓存中已经没有任何内容了，然后会去校验一下备份文件，由于只写了一部分数据而已，所以备份文件是不完整即损坏的，此时备份文件的内容不能算数。于是和上面的场景一样，以数据库文件来启动即可，即这次不完整的写操作，之前写入的部分内容会被全部丢弃了。&lt;/li&gt;
&lt;li&gt;写操作完成之后：这个阶段是写操作完成，修改的页面在修改之前的内容已经全部写入备份文件，但是页面缓存中的内容还没有全部落盘到数据库文件时，发生了错误崩溃。这种情况下重启，那么数据库文件可能是错乱的，因为只有部分内容落盘了，如这里的页面1，初始内容是&lt;code&gt;x=0,y=1&lt;/code&gt;，完整的修改应该是&lt;code&gt;x=1,y=2&lt;/code&gt;，如果只修改了一部分则是&lt;code&gt;x=1,y=1&lt;/code&gt;。这种情况下重启时，检查到备份文件中的内容是完整的，这就会以备份文件中的内容，来覆盖数据库文件中的内容，即将数据库文件恢复到这次写事务开始之前的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从这个恢复流程可以看到：使用页面备份机制，在完成写操作、但是还未完全将页面缓存的内容落盘到数据库文件之前，任何出错都会导致这个写事务的修改（不管是部分修改还是全部修改）被丢掉。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;本节讲解了journal文件的实现机制，从最早的sqlite btree实现时，备份页面的机制就一直使用journal机制，从这里的分析可以看到，这种机制很“朴素”，性能也并不好，所以后续在3.7版本的sqlite中引入了更优的WAL实现机制。&lt;/p&gt;

&lt;p&gt;本节也并没有把所有journal文件实现机制都详细描述，只是把最核心的文件结构以及备份流程做了讲解，因为并不想在这个性能不高的机制上着墨更多，有兴趣的读者可以自行阅读相关代码。&lt;/p&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/fileformat.html&#34;&gt;Database File Format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（二）- 并发控制框架</title>
      <link>https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/</link>
      <pubDate>Sat, 18 Dec 2021 15:25:05 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;按照之前起步阶段对sqlite btree整体架构的分析，“页面管理模块”分为以下几个子模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面缓存管理。&lt;/li&gt;
&lt;li&gt;页面备份，又分为以下两种实现：

&lt;ul&gt;
&lt;li&gt;journal文件。&lt;/li&gt;
&lt;li&gt;WAL文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;页面管理模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面一节讲完了“页面缓存管理”的实现，按照自下往上的顺序，就应该到“页面备份”了。“页面备份”核心的工作是：在真正修改页面内容之前，将还未修改的页面内容备份，这样一旦系统在事务过程中宕机崩溃，就可以用这部分内容回滚还未落盘的事务修改，让系统回到一个正确的状态。&lt;/p&gt;

&lt;p&gt;“页面备份”有两种实现方式，在早期使用的journal文件，这种方式性能不高；在3.7版本之后，sqlite引入了WAL文件来保存页面内容，这样做的效率更高。&lt;/p&gt;

&lt;p&gt;本节就讲解这部分内容，在对这部分内容有一个总体的了解之后，继续讲解页面备份的总体流程。后面的章节再具体分析journal以及WAL的实现。&lt;/p&gt;

&lt;h1 id=&#34;写事务的流程&#34;&gt;写事务的流程&lt;/h1&gt;

&lt;p&gt;（以下流程分析，按照sqlite官网中的文档&lt;a href=&#34;https://sqlite.org/atomiccommit.html&#34;&gt;Atomic Commit In SQLite&lt;/a&gt;进行讲解，图例也全部引用自官网。）&lt;/p&gt;

&lt;p&gt;sqlite的写事务，分为以下几个流程：&lt;/p&gt;

&lt;h2 id=&#34;1-初始化阶段-initial-state&#34;&gt;1、初始化阶段（Initial State）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-0.gif&#34; alt=&#34;初始化&#34; title=&#34;初始化&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如上图中，从右到左即是系统的磁盘、操作系统缓冲区、用户空间三部分，其中磁盘和操作系统缓冲区有划分为多块的空间，每一块在sqlite里被称为一个&lt;code&gt;sector&lt;/code&gt;，蓝色部分表示是修改之前的数据。&lt;/p&gt;

&lt;p&gt;这是系统初始时的样子。&lt;/p&gt;

&lt;h2 id=&#34;2-拿到读锁-acquiring-a-read-lock&#34;&gt;2、拿到读锁（Acquiring A Read Lock）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-1.gif&#34; alt=&#34;拿到读锁&#34; title=&#34;拿到读锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在开始进行写操作之前，sqlite必须先把待修改的页面加载内存中（这就是上一节“页面缓存管理器”做的事情），后续的修改其实也是首先修改这部分加载到内存中的页面内容，因为可能一次提交会修改同一个页面中的多处内容，最后才把页面内容落盘。&lt;/p&gt;

&lt;p&gt;所以，这一步所要做的，是首先拿到数据库文件的读锁（shared lock），需要说明的是，这个读锁是数据库级别的锁。同一时间，系统中可以存在多个读锁，但是只要系统中还存在读锁，就不再允许分配出新的写锁（write lock）。&lt;/p&gt;

&lt;h2 id=&#34;3-读出页面的内容到页面缓存&#34;&gt;3、读出页面的内容到页面缓存&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-2.gif&#34; alt=&#34;读出页面内容&#34; title=&#34;读出页面内容&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;拿到读锁之后，就可以把需要进行修改的页面读出来到用户空间的页面缓存了。从上图来看，读了三个页面的内容出来，也就是例子中的写操作要修改三个页面的内容。&lt;/p&gt;

&lt;h2 id=&#34;4-拿到保留锁-obtaining-a-reserved-lock&#34;&gt;4、拿到保留锁（Obtaining A Reserved Lock）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-3.gif&#34; alt=&#34;拿到保留锁&#34; title=&#34;拿到保留锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在进行修改之前，还需要首先将前面拿到的读锁（shared lock）升级为保留锁（reserved lock）。同一时间，系统中保留锁可以和多个读锁并存，但是只能存在最多一个保留锁。这个机制，保证了同一时间只能有一个进程对数据库进行写操作。&lt;/p&gt;

&lt;p&gt;需要说明的是，拿到保留锁的进程，还并没有真正进行数据的修改操作，只是用这个锁，挡住了其它打算进行写操作的进程。&lt;/p&gt;

&lt;h2 id=&#34;5-创建回滚用的备份文件-creating-a-rollback-journal-file&#34;&gt;5、创建回滚用的备份文件（Creating A Rollback Journal File）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-4.gif&#34; alt=&#34;创建回滚用的备份文件&#34; title=&#34;创建回滚用的备份文件&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;到了这一步，首先将待修改的页面内容备份。官网原文写的是备份到回滚用的journal文件中，我们上面提到备份机制除了journal文件还有wal文件，所以这里的“journal文件”应该更泛化的理解为“保存到备份文件中”，这种备份文件可能是journal文件，也可能是wal文件，视机制而定。&lt;/p&gt;

&lt;p&gt;上图中，用户空间的页面写入到了备份文件中，注意到备份文件上面有一小块绿色的部分，理解为备份文件的meta信息即可。&lt;/p&gt;

&lt;p&gt;另外还需要特别说明的是，从上图中可以看到，备份工作也仅仅到了操作系统缓冲区，即图中的中间部分，而磁盘部分还是空的。即到了这一步，即便是备份页面的内容，也还并没有sync到磁盘中，即只进行了备份的写操作，并没有强制落盘。&lt;/p&gt;

&lt;h2 id=&#34;6-修改用户空间的页面内容-changing-database-pages-in-user-space&#34;&gt;6、修改用户空间的页面内容（Changing Database Pages In User Space）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-5.gif&#34; alt=&#34;修改用户空间的页面内容&#34; title=&#34;修改用户空间的页面内容&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;到了这一步，修改进程用户空间的页面内容，即上图中的橙色部分，就是修改后的用户空间数据。由于每个进程都有自己的用户空间（即便是同一个进程下的不同线程，对sqlite而言，只要使用的是不同的连接（connection），那么连接背后的页面缓冲区就不一样），所以这些修改并不被其它进程所见。这样，写进程做自己的修改，其它读进程读到的还是修改之前的页面数据。&lt;/p&gt;

&lt;h2 id=&#34;7-将备份文件的内容落盘-flushing-the-rollback-journal-file-to-mass-storage&#34;&gt;7、将备份文件的内容落盘（Flushing The Rollback Journal File To Mass Storage）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-6.gif&#34; alt=&#34;将备份文件的内容落盘&#34; title=&#34;将备份文件的内容落盘&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;上面的第5步提到，当时还只是写页面内容到备份文件中，这一步接在修改页面内容之后，将修改之前的页面内容sync到磁盘中。&lt;/p&gt;

&lt;h2 id=&#34;8-拿到排他锁-obtaining-an-exclusive-lock&#34;&gt;8、拿到排他锁（Obtaining An Exclusive Lock）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-7.gif&#34; alt=&#34;拿到排他锁&#34; title=&#34;拿到排他锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;前面的步骤做完，达到了这样的效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于待修改页面，修改之前的内容已经保存到了备份文件中。&lt;/li&gt;
&lt;li&gt;需要修改的内容，已经体现在了进程的用户空间的页面缓存里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此时，需要将页面修改的内容写到数据库文件中。在修改数据库文件之前，还需要首先拿到排他锁（exclusive lock）。拿到排他锁，又分为两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先拿到悬锁（pending lock）。&lt;/li&gt;
&lt;li&gt;将悬锁升级为排他锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么要首先拿到悬锁？同一时间内，悬锁和前面的保留锁一样，只能存在最多一个；但是不同的是，悬锁不允许再分配新的读锁（shared lock），而保留锁没有这样的机制。换言之，在悬锁之前的所有读锁，可以继续读操作，悬锁会等待它们完成，再升级为排他锁；同时，只要系统中有悬锁，就不再允许有新的读操作，必须等待修改数据库完成才可以有新的读操作。&lt;/p&gt;

&lt;p&gt;这样的机制，避免了读操作时，读到了未提交的事务写到一半的数据。&lt;/p&gt;

&lt;h2 id=&#34;9-保存修改到数据库文件中-writing-changes-to-the-database-file&#34;&gt;9、保存修改到数据库文件中（Writing Changes To The Database File）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-8.gif&#34; alt=&#34;拿到排他锁&#34; title=&#34;拿到排他锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;拿到了排他锁之后，意味着此时系统中没有读操作、没有其他写操作，这时候可以放心将页面缓存中的内容落盘到数据库文件中了。&lt;/p&gt;

&lt;p&gt;同样需要注意的是，这一步的修改，还还只是到了操作系统的缓冲区，并不保证落盘到数据库文件中。&lt;/p&gt;

&lt;h2 id=&#34;10-落盘数据库文件修改-flushing-changes-to-mass-storage&#34;&gt;10、落盘数据库文件修改（Flushing Changes To Mass Storage）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-9.gif&#34; alt=&#34;落盘数据库文件修改&#34; title=&#34;落盘数据库文件修改&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这一步，将对数据库文件的修改落盘。&lt;/p&gt;

&lt;h2 id=&#34;11-删除备份文件-deleting-the-rollback-journal&#34;&gt;11、删除备份文件（Deleting The Rollback Journal）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-A.gif&#34; alt=&#34;删除备份文件&#34; title=&#34;删除备份文件&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;至此，这一次写操作已经落盘到了数据库文件中，前面保存到备份文件中的数据可以清除了。清除备份文件内容，是一个比较费时的操作，具体实现由不同的机制去优化，后面讲到journal文件以及wal的实现时再展开描述。&lt;/p&gt;

&lt;h2 id=&#34;12-释放锁-releasing-the-lock&#34;&gt;12、释放锁（Releasing The Lock）&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/commit-B.gif&#34; alt=&#34;释放锁&#34; title=&#34;释放锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;写操作全部完成，备份文件也清除了，到了这一步就可以释放锁，以便后面其他的读写操作进来。&lt;/p&gt;

&lt;h1 id=&#34;写事务中涉及到的锁&#34;&gt;写事务中涉及到的锁&lt;/h1&gt;

&lt;p&gt;上面写事务流程中，依次会拿到以下类型的锁，下图中做一个简单的总结：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211218-sqlite-btree-2-concurrency-control/write_lock.png&#34; alt=&#34;写操作中涉及到的锁&#34; title=&#34;写操作中涉及到的锁&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;崩溃恢复流程&#34;&gt;崩溃恢复流程&lt;/h1&gt;

&lt;p&gt;上面的流程中，随时都可能因为系统崩溃而导致数据错乱的，因此一个写事务如果还未完成，重启时存储引擎需要识别出来，将还没有完成的事务进行回滚操作（rollback）。&lt;/p&gt;

&lt;p&gt;分为以下几种情况来处理：&lt;/p&gt;

&lt;h2 id=&#34;写备份数据之前失败&#34;&gt;写备份数据之前失败&lt;/h2&gt;

&lt;p&gt;如果系统在落盘备份数据之前失败，即前面的流程7之前失败，按照上面的流程来看，情况是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写事务的数据还停留在用户空间的页面缓存中，未落盘到数据库文件上（流程6）。&lt;/li&gt;
&lt;li&gt;在流程5，只是将数据写到备份文件，还没有强制刷盘，所以这时候崩溃，可能备份文件中的数据是损坏的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以在这种情况下重启，面对的是这样的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库文件：还在写事务之前的状态，因为写事务还未落盘。&lt;/li&gt;
&lt;li&gt;备份文件：可能损坏。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，启动之后将校验备份文件是否完整，如果完整将重放一遍备份文件中的页面到数据库文件中；否则，只是简单的删除备份文件中的数据即可。&lt;/p&gt;

&lt;h2 id=&#34;写数据库文件时失败&#34;&gt;写数据库文件时失败&lt;/h2&gt;

&lt;p&gt;如果已经过了流程7，而在将页面缓存中的修改落盘到数据库文件的过程中，系统崩溃了，那么面临的是这样的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据库文件肯定损坏了。&lt;/li&gt;
&lt;li&gt;写事务中被修改页面之前的内容，已经落盘到备份文件中了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，启动恢复的时候，只需要将备份文件中的页面重放一遍到数据库文件即可将数据库文件恢复到写事务修改前的状态了。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;以上，就是sqlite中写事务的总体流程，以及重启恢复的流程，这里还并没有涉及到具体的代码细节，有了对总体流程的理解，后面再来分析具体的两种备份机制：journal以及wal的实现。&lt;/p&gt;

&lt;p&gt;另外，需要看到的是：sqlite中锁的粒度，都还是数据库级别的，现在我还不知道其它更高效的数据库所谓行锁的实现，留待以后吧。&lt;/p&gt;

&lt;h1 id=&#34;参考文档&#34;&gt;参考文档&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sqlite.org/atomiccommit.html&#34;&gt;Atomic Commit In SQLite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sqlite.org/lockingv3.html&#34;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（一）- 管理页面缓存</title>
      <link>https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/</link>
      <pubDate>Fri, 17 Dec 2021 14:22:06 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;页面管理&lt;/code&gt;模块中，很重要的一个功能是缓存页面的内容在内存中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读页面：如果页面已经在内存，就不需要到文件中读出页面内容。&lt;/li&gt;
&lt;li&gt;写页面：如果页面已经在内存，那么对页面的修改就只需要修改页面在内存中的数据即可，被修改了但是还没有落盘的页面，被称为“脏页面（dirty page）“。这样，多次对某个页面的修改，可能最后只需要一次落盘即可。当然，对页面的修改，如果在还没有落盘之前，系统就崩溃了，这种情况下应该如何处理，这就是“崩溃恢复”模块做的事情了。本节中，将专注在“页面缓存”这个子模块的实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然要将页面缓存在内存中，就会涉及到几个功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何知道哪些页面已经被缓存在内存里了？&lt;/li&gt;
&lt;li&gt;缓存在内存中的页面如何组织管理？&lt;/li&gt;
&lt;li&gt;缓存页面使用的内存不够用时，应该如何处理？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们首先来了解一下“页面缓存”模块的总体划分：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/pagecache.png&#34; alt=&#34;页面缓存功能的模块划分&#34; title=&#34;页面缓存功能的模块划分&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;按照上图的划分，页面缓存模块分为以下几部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面缓存管理器：实现了页面缓存的总体算法流程，以及提供对外的接口，但是具体到“页面缓存算法”的实现，则有赖于下面这个可用户定制的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;。这部分功能在代码&lt;code&gt;pcache.c&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;页面缓存算法：用户可自己定制，只要实现&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中的接口即可。系统中的默认实现，在文件&lt;code&gt;pcache1.c&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;除此以外，还需要快速根据页面编号就能知道哪些页面已经被缓存的功能，这部分sqlite使用位图数据结构来实现，在文件&lt;code&gt;bitvec.c&lt;/code&gt;中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;页面缓存管理器，核心功能就是维护脏页面链表，缓存页面的管理，诸如根据页面编号查找页面、淘汰页面算法等，都由“页面缓存算法”来维护。可以这样来简单的理解上面的功能划分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“页面缓存管理器”：定义了管理页面缓存的接口、总体流程，维护管理目前在用的脏页面。&lt;/li&gt;
&lt;li&gt;“页面缓存算法”：维护其它不在使用但还在内存中的页面，负责其淘汰、回收等实现。由“sqlite3_pcache_methods2”结构体实现，用户可以定制自己实现的“sqlite3_pcache_methods2”，系统也提供默认的实现。当内存不足以分配时，需要淘汰不常用的页面，这时候需要使用“页面缓存管理器”注册的回调函数来淘汰页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/pagecache_module.png&#34; alt=&#34;页面缓存两个模块的功能划分&#34; title=&#34;页面缓存两个模块的功能划分&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;简而言之，如果把当前在内存中的页面划分为以下两类，那么：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前在使用的页面：即与页面编号对应的页面，由“页面缓存管理器”维护。&lt;/li&gt;
&lt;li&gt;当前还未使用、但也在内存中的页面：即随时准备拿出来存储从磁盘中读出来的数据的页面，由“页面缓存算法”维护，比如淘汰、回收、复用等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/page_cache_memory.png&#34; alt=&#34;两种页面的划分&#34; title=&#34;两种页面的划分&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;下面，就开始“页面缓存”这几部分功能的具体讲解。&lt;/p&gt;

&lt;h1 id=&#34;管理页面&#34;&gt;管理页面&lt;/h1&gt;

&lt;h2 id=&#34;页面相关的数据数据结构&#34;&gt;页面相关的数据数据结构&lt;/h2&gt;

&lt;p&gt;首先来看页面相关的数据结构，sqlite中使用&lt;code&gt;PgHdr&lt;/code&gt;结构体来在内存中描述一个页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
** Every page in the cache is controlled by an instance of the following
** structure.
*/
struct PgHdr {
  sqlite3_pcache_page *pPage;    /* Pcache object page handle */
  void *pData;                   /* Page data */
  void *pExtra;                  /* Extra content */
  PCache *pCache;                /* PRIVATE: Cache that owns this page */
  PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */
  Pager *pPager;                 /* The pager this page is part of */
  Pgno pgno;                     /* Page number for this page */
#ifdef SQLITE_CHECK_PAGES
  u32 pageHash;                  /* Hash of page content */
#endif
  u16 flags;                     /* PGHDR flags defined below */

  /**********************************************************************
  ** Elements above, except pCache, are public.  All that follow are 
  ** private to pcache.c and should not be accessed by other modules.
  ** pCache is grouped with the public elements for efficiency.
  */
  i16 nRef;                      /* Number of users of this page */
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的信息，大部分在注释中已经自解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pPage：这个字段稍显复杂，后面展开详细解释。&lt;/li&gt;
&lt;li&gt;pData，pExtra：pData指向了页面实际的内容，pExtra指向页面额外数据，大部分时候，后者的内容可以忽视。&lt;/li&gt;
&lt;li&gt;pCache：页面缓存管理器对象指针。&lt;/li&gt;
&lt;li&gt;pDirty：脏页面链表指针。&lt;/li&gt;
&lt;li&gt;pPager：页面管理器对象指针。（注意和pCache进行区分，pCache是“页面缓存管理器”）。&lt;/li&gt;
&lt;li&gt;pgno：存储该页面的页面编号。&lt;/li&gt;
&lt;li&gt;flags：页面标志位，有如下几种，可以通过位操作来加上多个标志位：

&lt;ul&gt;
&lt;li&gt;PGHDR_CLEAN：干净的页面。&lt;/li&gt;
&lt;li&gt;PGHDR_DIRTY：脏页面。&lt;/li&gt;
&lt;li&gt;PGHDR_WRITEABLE：已经记录下来修改之前的页面内容，所以此时可以对内存中的页面内容进行修改了。&lt;/li&gt;
&lt;li&gt;PGHDR_NEED_SYNC：将该页面内容写入数据库文件之前，需要sync journal文件中的页面内容。&lt;/li&gt;
&lt;li&gt;PGHDR_DONT_WRITE：不需要写页面内容到磁盘。&lt;/li&gt;
&lt;li&gt;PGHDR_MMAP：该页面内容是通过mmap到内存中的。&lt;/li&gt;
&lt;li&gt;PGHDR_WAL_APPEND：页面内容已经添加到WAL文件中了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;nRef：页面引用计数。&lt;/li&gt;
&lt;li&gt;pDirtyNext、pDirtyPrev：存储脏页面链表中前、后页面指针，如果该页面不是脏页面，则这两个字段未定义。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以简略的总结该结构体中的内容，最重要的莫过于以下几项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pData存储的页面内容，所谓的读、写页面内容实际上操作的是这个成员指向的内容。&lt;/li&gt;
&lt;li&gt;pDirty、pDirtyNext、pDirtyPrev这几个成员维护的脏页面相关的指针。&lt;/li&gt;
&lt;li&gt;flags维护的页面标志位，通过这些标志位来区分应该对页面进行什么操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/PgHdr.png&#34; alt=&#34;内存中脏页面的组织&#34; title=&#34;内存中脏页面的组织&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;sqlite3-pcache-page数据结构&#34;&gt;sqlite3_pcache_page数据结构&lt;/h3&gt;

&lt;p&gt;上面的&lt;code&gt;PgHdr&lt;/code&gt;结构体中，还有第一个成员，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;类型的pPage指针没有讲解，这里展开解释。&lt;/p&gt;

&lt;p&gt;前面概述部分提到，“页面缓存算法”的实现，是可以交给用户自定义的，这就带来一个问题：每个自定义的实现，内部实现的管理页面的结构体可能并不相同。于是，就要类似C++中的面向对象机制一样，先声明一个“页面”的基类，基类中定义最基础的成员变量，这样做之后有这样的好处：页面管理模块，所有的操作都能针对这个基类来进行，而不需要管具体实现中的差异。&lt;/p&gt;

&lt;p&gt;在这里，这个基类就是成员&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;，其定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;        /* The content of the page */
  void *pExtra;      /* Extra information associated with the page */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成员中的用途，注释中也写得挺清楚了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pBuf：指向页面内容。&lt;/li&gt;
&lt;li&gt;pExtra：保存页面的额外信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然是“基类”，就要求每个子类都要有该基类的信息，实际上也是这样做的，比如“页面缓存算法”的默认实现中，其管理页面的结构体是&lt;code&gt;PgHdr1&lt;/code&gt;（后面会展开解释这个结构体），其初始定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp;amp; pExtra */
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从注释可以看到，sqlite中要求所有实现页面缓存算法中管理页面的数据结构体，都要以&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体开始做为第一个成员。&lt;/p&gt;

&lt;p&gt;实际上，&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体中，&lt;code&gt;pExtra&lt;/code&gt;成员包括如下两部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;额外内容：由系统指定&lt;code&gt;szExtra&lt;/code&gt;大小来指定这部分内容大小，简单起见，目前可以认为这部分为0。&lt;/li&gt;
&lt;li&gt;PgHdr结构体：即前面讲解的&lt;code&gt;页面缓存模块&lt;/code&gt;中描述一个页面的结构体大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读到这里，有可能把读者绕晕了，我们以代码和图示为引子详细看一下。&lt;/p&gt;

&lt;p&gt;首先，创建一个“页面缓存算法”模块时，要调用&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中定义的&lt;code&gt;xCreate&lt;/code&gt;函数指针来完成，其函数定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入的第二个参数&lt;code&gt;szExtra&lt;/code&gt;需要指定额外部分的内容大小，实际在调用时，这个参数的大小就是我们上面说的&lt;code&gt;szExtra&lt;/code&gt;和PgHdr结构体大小之和（做了8字节对齐）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sqlite3_pcache *pNew;
    pNew = sqlite3GlobalConfig.pcache2.xCreate(
                szPage, pCache-&amp;gt;szExtra + ROUND8(sizeof(PgHdr)),
                pCache-&amp;gt;bPurgeable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，“页面缓存模块”中要获取一个页面时，是通过&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体中定义的&lt;code&gt;xFetch&lt;/code&gt;函数指针来完成的，这个函数指针的定义是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这里返回的就是上面说的“基类”，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体指针。而在内部的默认实现中，其实返回的是&lt;code&gt;PgHdr1&lt;/code&gt;指针进行强制转换之后的结果，即&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;这一基类的子类，之所以能够做，完全是因为在&lt;code&gt;PgHdr1&lt;/code&gt;结构体定义时，把&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;结构体成员放在第一个成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp;amp; pExtra */
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到返回的&lt;code&gt;sqlite3_pcache_page&lt;/code&gt;指针之后，就能通过其中的&lt;code&gt;pExtra&lt;/code&gt;指针拿到&lt;code&gt;PgHdr&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PgHdr *sqlite3PcacheFetchFinish(
  PCache *pCache,             /* Obtain the page from this cache */
  Pgno pgno,                  /* Page number obtained */
  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */
){
  PgHdr *pPgHdr;

  pPgHdr = (PgHdr *)pPage-&amp;gt;pExtra;
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结起来，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/sqlite3_pcache_page.png&#34; alt=&#34;sqlite3_pcache_page&#34; title=&#34;sqlite3_pcache_page&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;页面所在的数据结构&#34;&gt;页面所在的数据结构&lt;/h2&gt;

&lt;p&gt;缓存中的页面，可能存在于以下三种数据结构中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脏页面链表：该链表维护所有当前在使用的页面，由“页面缓存管理器”维护。&lt;/li&gt;
&lt;li&gt;hash数组：作用是以页面编号为键来查询页面，由默认的“页面缓存算法”来维护。&lt;/li&gt;
&lt;li&gt;LRU链表：越是常被访问的页面，在LRU链表中就越往前，从LRU链表中淘汰数据都是从链表尾部开始的，也是由默认的“页面缓存算法”来维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-1-pagecache/page_ds.png&#34; alt=&#34;页面所在的三种数据结构&#34; title=&#34;页面所在的三种数据结构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;脏页面链表&#34;&gt;脏页面链表&lt;/h3&gt;

&lt;p&gt;这个页面链表叫“脏页面（dirty page）链表”实际上并不十分准确，这会让人误以为这个链表上的页面全都是脏页面，实际上是可能存在干净的页面的。更准确的说法，是当前系统在使用的页面，都维护在这个页面链表中。&lt;/p&gt;

&lt;p&gt;操作这个链表的入口函数是&lt;code&gt;pcacheManageDirtyList&lt;/code&gt;，其传入的参数一个是&lt;code&gt;PgHdr&lt;/code&gt;类型的指针，另一个用于指定行为，有以下三种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */
#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */
#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;pcacheManageDirtyList&lt;/code&gt;函数实现中，也是根据这个参数进行与操作判断来做不同的行为的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pcacheManageDirtyList实现：
  如果 addRemove &amp;amp; PCACHE_DIRTYLIST_REMOVE:
    从链表上删除
  如果 addRemove &amp;amp; PCACHE_DIRTYLIST_ADD：
    添加到链表头
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的是，参数&lt;code&gt;PCACHE_DIRTYLIST_FRONT&lt;/code&gt;为3，而另外两个参数一个是1（删除）一个是2，所以当传入&lt;code&gt;PCACHE_DIRTYLIST_FRONT&lt;/code&gt;的时候，按照上面的流程，就是首先从链表上删除，再放到链表头。&lt;/p&gt;

&lt;p&gt;由于脏页面链表是由“页面缓存管理器”来管理的，所以描述页面的结构体与这个链表相关的数据结构，都在&lt;code&gt;PgHdr&lt;/code&gt;上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PgHdr {
  ...
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hash数组&#34;&gt;hash数组&lt;/h3&gt;

&lt;p&gt;为了快速根据页面编号，查找到该编号的页面是否已经加载到页面中，每个页面的数据还存在于一个hash数组中。&lt;/p&gt;

&lt;p&gt;如前所述，这个数据结构由默认的“页面缓存算法”维护，所以与之相关的数据结构，都在结构体&lt;code&gt;PgHdr1&lt;/code&gt;上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PgHdr1 {
  ...
  PgHdr1 *pNext;                 /* Next in hash table chain */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hash数组的实现，与一般的实现并没有太大区别，这里就不展开说了。&lt;/p&gt;

&lt;h3 id=&#34;lru链表&#34;&gt;LRU链表&lt;/h3&gt;

&lt;p&gt;当需要加载当前还不在内存中的页面时，需要首先分配出一块空间，用于保存从文件中加载的页面数据。如前所述，“页面缓存管理器”管理的是还在使用的页面，而“页面缓存算法”管理的是当前没有被使用的页面，所以这部分功能也是由默认的“页面缓存算法”来实现的，与之相关的数据结构，和hash数组的实现一样，也在结构体&lt;code&gt;PgHdr1&lt;/code&gt;上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PgHdr1 {
  ...
  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */
  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */
                                 /* NB: pLruPrev is only valid if pLruNext!=0 */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要从“没有被使用的页面”中，分配出来一个页面数据用于保存加载的页面时，就涉及到淘汰问题：如果一个页面虽然当前没有被使用，但是由于经常被访问，所以不应该淘汰这个页面，因为很有可能它马上又会被访问到，应该首先淘汰那些不常被访问的页面，用来加载页面数据。&lt;/p&gt;

&lt;p&gt;维护这些信息的数据结构，就是LRU链表：在链表中越往前的数据，意味着被访问的越频繁；反之，淘汰都是从链表尾部开始。&lt;/p&gt;

&lt;h3 id=&#34;pin和unpin操作&#34;&gt;pin和unpin操作&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;pin&lt;/code&gt;和&lt;code&gt;unpin&lt;/code&gt;操作，在默认的缓存算法中，是针对LRU链表而言的：一个页面数据，如果执行了&lt;code&gt;pin&lt;/code&gt;操作，就是将这个页面从LRU链表上摘下来。而&lt;code&gt;unpin&lt;/code&gt;操作则反之，将页面放入LRU链表。&lt;/p&gt;

&lt;p&gt;为什么需要这两个操作？&lt;/p&gt;

&lt;p&gt;再复习一下前面提到的分工：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面缓存管理器：负责维护在使用的页面。&lt;/li&gt;
&lt;li&gt;页面缓存算法：负责维护未使用的页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设一个页面编号为N的页面，被访问时需要加载到内存，此时就会由“页面缓存管理器”加载到内存中，放入脏页面链表；而一旦访问完成，就会调用页面缓存算法的&lt;code&gt;xUnpin&lt;/code&gt;函数指针执行&lt;code&gt;unpin&lt;/code&gt;操作（实现页面缓存算法的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体在后面解释）。&lt;/p&gt;

&lt;p&gt;在默认的缓存算法中，执行&lt;code&gt;unpin&lt;/code&gt;操作，就是将页面放入LRU链表，并不会将页面从hash数组中删除，也就是说：&lt;code&gt;unpin&lt;/code&gt;操作，并不妨碍这个能够以页面编号从hash数组中再次查到该页面的数据。&lt;/p&gt;

&lt;p&gt;换言之，&lt;code&gt;unpin&lt;/code&gt;操作是在“页面缓存算法”使用完毕某个页面时执行的，只是用来通知“页面缓存算法”：这个页面我已经用不上了，后续怎么处理，可以由“页面缓存算法”自行决定。&lt;/p&gt;

&lt;p&gt;于是，对于那些经常被访问的页面，即便当前没有被使用，真正到需要它的时候，只要没有被淘汰出去分配给其他页面，就不再需要再次从文件中加载出来。&lt;/p&gt;

&lt;h2 id=&#34;页面缓存管理器&#34;&gt;页面缓存管理器&lt;/h2&gt;

&lt;h3 id=&#34;页面缓存管理器的数据结构&#34;&gt;页面缓存管理器的数据结构&lt;/h3&gt;

&lt;p&gt;页面缓存管理器，核心功能就是维护脏页面链表，页面缓存管理器的数据结构中最重要的莫过于以下几个成员：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct PCache {
  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */
  PgHdr *pSynced;                     /* Last synced page in dirty page list */
  ...

  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */
  void *pStress;                      /* Argument to xStress */
  sqlite3_pcache *pCache;             /* Pluggable cache module */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，有两个维护页面链表相关的指针：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脏页面链表：由成员pDirty, pDirtyTail指向该链表的一头一尾。脏页面链表中，页面是按照LRU的顺序进行排列的，即：越靠近链表尾的页面最可能被淘汰。&lt;/li&gt;
&lt;li&gt;最后进行sync的页面指针：在脏页面链表中，pSynced始终指向最后一个已经进行sync操作的页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么需要多一个&lt;code&gt;pSynced&lt;/code&gt;指针？因为在页面缓存紧张的时候，需要快速知道哪些页面已经sync了，这样的页面淘汰的代价最低，具体可以看函数&lt;code&gt;sqlite3PcacheFetchStress&lt;/code&gt;的实现，该函数的大体流程是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;分为两步寻找可以淘汰的页面：
  首先在pSynced指针开始往前找不需要sync且引用计数为0的页面
  如果找不到就继续在脏页面链表中寻找引用计数为0的页面
  找到之后，调用注册的xStress进行淘汰操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了这几个和脏页面链表相关的数据结构之外，上面还列举出来了其他几个成员：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xStress和pStress：在页面缓存出现压力时，需要将页面淘汰同时进行清理，清理页面的操作最终由&lt;code&gt;xStress&lt;/code&gt;函数指针来完成。&lt;/li&gt;
&lt;li&gt;sqlite3_pcache：下面会提到，实现“页面缓存算法”的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体，其内部的&lt;code&gt;xCreate&lt;/code&gt;函数指针最终会创建出一个&lt;code&gt;sqlite3_pcache&lt;/code&gt;返回，后续调用&lt;code&gt;页面缓存算法&lt;/code&gt;时，传入的都是这个返回的指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;页面缓存算法结构体&#34;&gt;页面缓存算法结构体&lt;/h2&gt;

&lt;p&gt;页面缓存算法，需要实现&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;接口并且注册到系统中，来看&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, 
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逐个解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;iVersion：版本号。&lt;/li&gt;
&lt;li&gt;pArg：参数。&lt;/li&gt;
&lt;li&gt;xInit：初始化模块的函数指针，这在模块初始化时一次性调用即可。&lt;/li&gt;
&lt;li&gt;xShutdown：停止模块的函数指针。&lt;/li&gt;
&lt;li&gt;xCreate：创建一个“页面缓存算法”的指针&lt;code&gt;sqlite3_pcache&lt;/code&gt;返回，注意这个函数里传入了页面大小、额外空间大小，这些都在上面有说明。后续的其他函数指针，传入的第一个参数都是这里返回的&lt;code&gt;sqlite3_pcache&lt;/code&gt;指针。&lt;/li&gt;
&lt;li&gt;xCachesize：返回当前cache大小。&lt;/li&gt;
&lt;li&gt;xPagecount：返回页面数量。&lt;/li&gt;
&lt;li&gt;xFetch：核心函数，根据传入的&lt;code&gt;key&lt;/code&gt;在缓存中查找页面，如果没有找到则按照&lt;code&gt;createFlag&lt;/code&gt;参数来决定后面的行为。&lt;/li&gt;
&lt;li&gt;xUnpin：页面的引用计数为0时就会调用这个函数。&lt;/li&gt;
&lt;li&gt;xRekey：表示把页面的key进行修改，这里key其实就是页面编号。&lt;/li&gt;
&lt;li&gt;xTruncate：将所有页面编号&amp;gt;=iLimit的页面都释放，回收内存。&lt;/li&gt;
&lt;li&gt;xDestroy：销毁前面&lt;code&gt;xCreate&lt;/code&gt;函数返回的&lt;code&gt;sqlite3_pcache&lt;/code&gt;指针。&lt;/li&gt;
&lt;li&gt;xShrink：尽可能的回收内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要说明的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;xInit函数：完成初始化这个模块的工作。&lt;/li&gt;
&lt;li&gt;xCreate：返回创建一个“页面缓存算法”的指针&lt;code&gt;sqlite3_pcache&lt;/code&gt;，后续的所有操作，都使用这个指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而sqlite中，其实并没有定义&lt;code&gt;sqlite3_pcache&lt;/code&gt;的具体结构，仅仅只是声明了这个类型，可以理解为是一个类似于&lt;code&gt;void*&lt;/code&gt;这样的泛型指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache type is opaque.  It is implemented by
** the pluggable module.  The SQLite core has no knowledge of
** its size or internal structure and never deals with the
** sqlite3_pcache object except by holding and passing pointers
** to the object.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache sqlite3_pcache;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;sqlite&lt;/code&gt;里的页面缓存，分为两个大的模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面缓存管理器：主要任务是管理脏页面，以及对外提供根据页面编号查询页面的接口，当某个页面不在内存时，自动将其加载到内存中。&lt;/li&gt;
&lt;li&gt;页面缓存算法：负责实现页面的缓存、淘汰、查询。这是可以由用户自己实现的模块，需要实现对应的&lt;code&gt;sqlite3_pcache_methods2&lt;/code&gt;结构体即可，也提供了默认的实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在内存中的页面，在以下几个数据结构中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脏页面链表，由&lt;code&gt;页面缓存管理器&lt;/code&gt;维护。&lt;/li&gt;
&lt;li&gt;Hash数组：根据页面编号查询到页面数据的指针，由默认的&lt;code&gt;页面缓存算法&lt;/code&gt;维护。&lt;/li&gt;
&lt;li&gt;LRU链表：负责淘汰页面，由默认的&lt;code&gt;页面缓存算法&lt;/code&gt;维护。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sqlite3.36版本 btree实现（零）- 起步及概述</title>
      <link>https://www.codedump.info/post/20211217-sqlite-btree-0/</link>
      <pubDate>Fri, 17 Dec 2021 10:19:05 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211217-sqlite-btree-0/</guid>
      <description>

&lt;h1 id=&#34;起步&#34;&gt;起步&lt;/h1&gt;

&lt;p&gt;在去年大体把btree以及b+tree算法流程研究了之后，我写了两篇博客：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（鉴于b+tree只是btree的一个特例，下面描述将仅使用“btree”，不再严格区分两者。）&lt;/p&gt;

&lt;p&gt;但是，这两篇文章仅仅只是让我懂得了最基本的原理。懂得原理，只是能做出toy级别的实现，拿btree类的存储引擎来说，要做到生产级产品，至少还有以下几个问题我当时不知道怎么做的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何处理不同大小的数据的存储？&lt;/li&gt;
&lt;li&gt;删除一个数据之后，如何复用其留下的空间？&lt;/li&gt;
&lt;li&gt;错误、崩溃恢复怎么做？&lt;/li&gt;
&lt;li&gt;跟磁盘文件是如何交互的？&lt;/li&gt;
&lt;li&gt;页面缓存模块如何实现？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等等等，还有太多我还没有弄清楚的实现细节。&lt;/p&gt;

&lt;p&gt;（我甚至还在微博上发问，得到了两个质量很高的回答，见本文最后的&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/#%E5%BD%A9%E8%9B%8B&#34;&gt;彩蛋部分&lt;/a&gt;。）&lt;/p&gt;

&lt;p&gt;对LSM类存储引擎有了解的人都知道，Leveldb这个项目在LSM领域属于入门级别的生产级实现，即这个领域最精简、但是又能放心在某些要求不高的场景下用于生产的项目。在这之后，我一直在找那种btree领域的“leveldb”，很遗憾一直都没有找到，我分别看了目前WiredTiger、innodb、sqlite的对应实现，都太复杂了，看不下去。&lt;/p&gt;

&lt;p&gt;直到有一天，无意间发现了这个项目：&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;madushadhanushka/simple-sqlite: Code reading for sqlite backend&lt;/a&gt;，看介绍，作者把sqlite2.5里b-tree相关的部分代码抽取出来了，我编译运行了一下用例都能正常跑，代码量不过几千行，我只花了几天就看完了。&lt;/p&gt;

&lt;p&gt;虽然按照&lt;a href=&#34;https://www.sqlite.org/changes.html&#34;&gt;Release History Of SQLite&lt;/a&gt;上的记载，sqlite 2.5版本是2002年的版本了，但是这个版本还是某种程度回答了我在上面的疑问。&lt;/p&gt;

&lt;p&gt;趁热打铁，我又找来更新一些的sqlite 3.6.10代码继续看这部分的实现，这次花了更多的时间才看完，但是又增强了我的信心。由于这个版本的sqlite，还未实现btree的wal，还只是用了journal文件来做崩溃恢复（无论wal还是journal，都会在后面文章展开详细讨论），所以在有足够的信心之后，我接下来又继续看当时（2021.10月份）最新的sqlite 3.36版本的实现，这部分的实现对比3.6.10来说，在btree部分最大的变化就是多了wal的实现，在已经清楚3.6.10的前提下，再增加了解这部分的实现，也并不是什么难事了。&lt;/p&gt;

&lt;p&gt;以上，简单描述了我探索一个生产级btree实现的初过程，btree类存储引擎的实现博大精深，更复杂者还有很多（WiredTiger、innodb、tokudb&amp;hellip;），但是无疑从低版本sqlite开始的探索流程，终于让我打开了走上这条路的一扇大门。&lt;/p&gt;

&lt;p&gt;本系列文章就sqlite 3.36版本的btree实现展开描述，希望对那些和我一样对“生产级btree类存储引擎实现”有好奇心的人有一点帮助。&lt;/p&gt;

&lt;p&gt;当然，如果你还是觉得吃力，可以先从&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;madushadhanushka/simple-sqlite: Code reading for sqlite backend&lt;/a&gt;这里看起。这里并不建议对btree原理没有了解的人直接上手sqlite的实现，如果需要了解原理请参考相关文章或者我上面给出的我写的两篇博客。这系列文章中，将不再对btree原理做过多描述，将假设读者已经了解这部分内容。&lt;/p&gt;

&lt;h1 id=&#34;sqlite的btree架构概述&#34;&gt;sqlite的btree架构概述&lt;/h1&gt;

&lt;p&gt;下面简单描述一下sqlite的btree架构，从高往低大体分为以下几个部分：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这三部分架构，由下往上依次是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统级API的实现：因为sqlite是一个可以在多个平台编译运行的数据库，所以系统级API这一层，需要解决平台相关的文件IO、锁等问题。这部分实现，将不在这系列文章中介绍，因为并不属于数据库实现时的核心问题。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;页面管理模块：btree存储引擎，其操作文件的最基本单位就是页面。页面管理模块解决以下的问题：对上层的btree模块，暴露针对页面读、写的接口，内部会缓存页面的内容，何时将修改的页面（所谓脏页面，dirty page）落盘到磁盘，是否需要sync修改，崩溃或者重启时的数据恢复，这些都不需要上层的btree模块关心。为了达到这些效果，内部还有几个子模块：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;页面缓存模块：用于缓存页面的内存有限，何时淘汰缓存中的页面、何时将缓存中的脏页面落盘，等等都由这个模块负责。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;页面备份：从上面的描述可以看到，因为页面的修改并不一定马上落盘，而是可能只是修改了缓存中的页面，这样在系统发生崩溃的时候，需要做恢复操作，一些没有完成的事务需要回滚，等等。这部分页面管理模块由两种不同的实现：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;journal文件：这是早期，但是效率并不高的实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WAL文件：这是从3.7之后引入的更高效的方式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务：事务处理也放在了页面管理中。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;btree：基于页面管理模块之上，实现了可以存储可变数据的btree模块。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以这样来简单区别理解“页面管理”模块和btree模块的功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;页面管理：顾名思义，页面管理模块的最基本单位是”页面“，页面的读、写、缓存、落盘、恢复、回滚等，都由页面模块负责。上一层依赖页面管理模块的btree模块，不需要关心一个页面何时缓存、何时落盘等细节。即：&lt;strong&gt;页面模块负责页面的物理级别的操作&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;btree：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负责按照btree算法，来组织页面，即负责的是页面之间逻辑关系维护。&lt;/li&gt;
&lt;li&gt;除此以外，一个页面内部的数据的物理、逻辑组织，也是btree模块来负责的。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即：&lt;strong&gt;btree负责维护页面间的逻辑关系，以及一个页面内数据的组织。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/page-module.png&#34; alt=&#34;以页面物理、逻辑关系的维护看模块划分&#34; title=&#34;以页面物理、逻辑关系的维护看模块划分&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;从上面的分析可以看出来，“页面管理模块”无疑是这里最大最复杂的部分，Andy Pavlo在CMU 15445课程中提到过：任何用&lt;code&gt;mmap&lt;/code&gt;来做页面管理的做法都是很糟糕的做法（如boltdb、LMDB等）。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/mmap.jpeg&#34; alt=&#34;mmap&#34; title=&#34;mmap&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这系列的文章，也将按照这个顺序，从下往上逐层分析sqlite的3.36版本的btree实现。&lt;/p&gt;

&lt;h1 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h1&gt;

&lt;p&gt;2021年9月5日，我在微博上就处理崩溃恢复的实现，提了一个问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那些很成熟的存储引擎，都是怎么处理崩溃恢复问题的呢，比如写数据落盘到一半，进程崩了，该如何恢复呢？求资料和指点。 ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1642628345/KwKqNgScT&#34;&gt;那些很成熟的存储引擎&amp;hellip; - @玩家老C的微博 - 微博&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;得到了两个很不错的指点回复：&lt;/p&gt;

&lt;h2 id=&#34;ba0tiao的回复&#34;&gt;ba0tiao的回复&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;做InnoDB 这块挺久了, 我试试说说 InnoDB 是怎么做的吧..&lt;/p&gt;

&lt;p&gt;其实你这里应该细分成两个问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;16kb 的page 写入的原子性该如何保证&lt;/li&gt;
&lt;li&gt;Btree 结构的完整性如何保证, 也就是你说的修改了n个页面以后如果修改了父子, 兄弟关系以后, 如果解决中间的crash 的问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;问题1 是通过double write buffer 来解决的, 因为InnoDB 的page 大小是16kb, 很多文件系统只能保证4kb 大小写入的原子性, 因此需要写入前先将page 的内容写入到double write buffer 来保证, 如果写入失败也不会将原有page 的内容覆盖.&lt;/p&gt;

&lt;p&gt;问题2 是通过redo log + mtr(mini transaction) 进行保证.&lt;/p&gt;

&lt;p&gt;InnoDB 里面的redo log 是由mtr 组成, mtr 是修改btree 的最小单位. 每次写入redo log 的时候必须是一个完整的mtr 的内容, 具体实现方式是mtr 会有MULTI_REC_END 标记, 在crash recovery 的时候, 如果读取到mtr 的内容没有MULTI_REC_END 标记, 那么则会认为这个mtr 不完整, 就会把这段mtr 抛弃.&lt;/p&gt;

&lt;p&gt;那么是不是一次insert 操作产生的redo log 都包含在一个mtr 里面呢?&lt;/p&gt;

&lt;p&gt;不是的.&lt;/p&gt;

&lt;p&gt;我们知道在btree 里面对page 的修改都需要对page 加锁, 从fsp 模块分配一个new page 也需要对root page 进行加锁等等. 所以InnoDB 的mtr 里面自然就包含对锁的操作, 因此要修改某一个page 的时候, mtr begin 的时候会对该page 加锁, 然后写入修改的内容, 然后mtr commit 的时候, 对于修改的page 的锁就可以释放了.&lt;/p&gt;

&lt;p&gt;如果整个insert 的过程都放在一个mtr 里面做, 那也是可以的, 也就是对于所有page 的latch 都是一开始持有, 最后的时候在释放, 就算后续这个page 已经不再修改了, 也依然要一直持有. 很容易理解这样并发自然就降低下来的, 因此在InnoDB 设计里面, mtr 的粒度是尽可能小的. 修改完page 就应该尽快的commit, 然后将page lock 释放. 但是又需要保证每一次的mtr 操作前和操作后btree 的完整性.&lt;/p&gt;

&lt;p&gt;体现具体的例子就是, InnoDB里面对于一个简单的insert 操作, 其实是有非常多个mtr 组成, 尽可能减少持有锁的时间.&lt;/p&gt;

&lt;p&gt;但是在做btree 分裂操作的时候, 分配新的page, 将之前page一半的数据迁移到new page 是在一个mtr 里面完成, 但是后续具体的insert 操作是在另外一个mtr 里面完成的. 那么如果在做分裂操作过程中crash, 那么这个分裂操作是不会完成的, 如果在分裂操作完成以后, insert 之前crash, 那么btree 是已经分裂过的, 只是数据没有插入了.&lt;/p&gt;

&lt;p&gt;当然这里会有你说的更复杂的设计的父节点 and 父节点的父节点的分裂, 那么自然持有锁的时间就更长了, 但是在我们在这里是做的一些优化.&lt;/p&gt;

&lt;p&gt;还有一些比如InnoDB redo log 是&amp;rdquo;physical to a page, logical within a page&amp;rdquo; 就是解决我们上面说的如果分裂操作成功了, 但是这个事务要回滚, 这个时候该如何处理等等..&lt;/p&gt;

&lt;p&gt;具体的内容其实这些文章里面都有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C. Mohan, Don Handerle. ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging.&lt;/li&gt;
&lt;li&gt;C. Mohan, Frank Levine. ARIES/lM: An Efficient and High Concurrency index Management Method Using Write-Ahead Logging.&lt;/li&gt;
&lt;li&gt;Goetz Graefe. A Survey of B-Tree Logging and Recovery Techniques.&lt;/li&gt;
&lt;li&gt;Goetz Graefe. A Survey of B-Tree Locking Techniques.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对了Goetz Graefe 号称Btree 守护神&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1832563813/KwRpIxunM&#34;&gt;做InnoDB 这块&amp;hellip; - @ba0tiao的微博 - 微博&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ba0tiao&lt;/code&gt;应该是阿里云负责PolarDB开发的资深开发。&lt;/li&gt;
&lt;li&gt;他的博客是：&lt;a href=&#34;http://baotiao.github.io/&#34;&gt;baotiao&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎专栏：&lt;a href=&#34;https://www.zhihu.com/column/360infra&#34;&gt;MySQL内核揭秘 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bohutang的回复&#34;&gt;BohuTANG的回复&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;可以深入一点：如果每次写的log都在，怎么做到基于这些log做回放的问题？其实就是redo-log +checkpoint+ LSM的机制。redo解决数据不丢，checkpoint解决recovery的时候扫描的redo尽量少，LSM解决每次写入后新的page不会覆盖老的数据，这类实现是比较简单可行，也是目前的主流做法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1691468715/KwT2GdDfu&#34;&gt;可以深入一点：如果每&amp;hellip; - @BohuTANG的微博 - 微博&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;目前大部分理论都参考于这篇 ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging – Mohan et al. 1992&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（见：&lt;a href=&#34;https://weibo.com/1691468715/Kx3yAhFKj&#34;&gt;目前大部分理论都参考&amp;hellip; - @BohuTANG的微博 - 微博&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BohuTANG已经在数据库领域沉浸多年，前阿里云数据库内核组早期成员、前青云数据库团队负责人。现在数据库领域创业，公司的项目是：&lt;a href=&#34;https://github.com/datafuselabs/databend&#34;&gt;datafuselabs/databend&lt;/a&gt;，欢迎围观。&lt;/li&gt;
&lt;li&gt;博客地址：&lt;a href=&#34;https://bohutang.me/&#34;&gt;[ 虎哥的博客 ]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为什么Raft协议不能提交之前任期的日志？</title>
      <link>https://www.codedump.info/post/20211011-raft-propose-prev-term/</link>
      <pubDate>Mon, 11 Oct 2021 23:14:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20211011-raft-propose-prev-term/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;在Raft大论文中3.6.2中，有一个细节“不允许提交之前任期的日志”，之前看了几次都理解的不够准确，把这部分内容展开阐述一下。&lt;/p&gt;

&lt;h1 id=&#34;问题&#34;&gt;问题&lt;/h1&gt;

&lt;p&gt;还是先从论文的图例开始解释，如下图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20211011-raft-propose-prev-term/propose-prev-term.png&#34; alt=&#34;论文截图&#34; title=&#34;论文截图&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;需要特别说明的是，图例中演示的是&lt;strong&gt;“如果允许提交之前任期的日志，将导致什么问题”&lt;/strong&gt;，这是大前提，这个前提条件后面会反复强调。&lt;/p&gt;

&lt;p&gt;有了这个前提，下面展开图中的步骤讨论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(a) ：S1 是leader，将黄色的日志2同步到了S2，然后S1崩溃。&lt;/li&gt;
&lt;li&gt;(b) ：S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，将蓝色日志3存储到本地，然后崩溃了。&lt;/li&gt;
&lt;li&gt;(c)：S1重新启动，选举成功。注意在这时，&lt;strong&gt;如果允许“提交之前任期的日志”&lt;/strong&gt;，将首先开始同步过往任期的日志，即将S1上的本地黄色的日志2同步到了S3。这时黄色的节点2已经同步到了集群多数节点，然后S1写了一条新日志4，然后S1又崩溃了。&lt;/li&gt;
&lt;li&gt;接下来，就可能出现两种不同的情况：

&lt;ul&gt;
&lt;li&gt;（d1）：S5重新当选，&lt;strong&gt;如果允许“提交之前任期的日志”&lt;/strong&gt;，就开始同步往期日志，将本地的蓝色日志3同步到所有的节点。结果已经被同步到半数以上节点的黄色日志2被覆盖了。这说明，如果允许“提交之前任期的日志”，会可能出现即便已经同步到半数以上节点的日志被覆盖，这是不允许的。&lt;/li&gt;
&lt;li&gt;（d2）：反之，如果在崩溃之前，S1不去同步往期的日志，而是首先同步自己任期内的日志4到所有节点，就不会导致黄色日志2被覆盖。因为leader同步日志的流程中，会通过不断的向后重试的方式，将日志同步到其他所有follower，只要日志4被复制成功，在它之前的日志2就会被复制成功。（d2）是想说明：不能直接提交过往任期的日志，即便已经被多数通过，但是可以先同步一条自己任内的日志，如果这条日志通过，就能带着前面的日志一起通过，这是（c）和（d2）两个图的区别。图（c）中，S1先去提交过往任期的日志2，图（d2）中，S1先去提交自己任内的日志4。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次强调，这里图示想演示的是&lt;strong&gt;“如果允许提交之前任期的日志，将导致什么问题”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们可以看到的是，如果允许这么做，那么：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(c)中，S1恢复之后，又再次提交在任期2中的黄色日志2。但是，从后面可以看到，即便这个之前任期中的黄色日志2，提交到大部分节点，如果允许“提交之前任期的日志”，仍然存在被覆盖的可能性，因为：&lt;/li&gt;
&lt;li&gt;(d1)中，S5恢复之后，也会提交在自己本地上保存的之前任期3的蓝色日志，这会导致覆盖了前面已经到半数以上节点的黄色日志2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，“如果允许提交之前任期的日志”，即如同(c)和(d1)演示的那样：重新当选之后，马上提交自己本地保存的、之前任期的日志，就会&lt;strong&gt;可能导致即便已经同步到半数以上节点的日志，被覆盖的情况&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而“已同步到半数以上节点的日志”，一定在新当选leader上（否则这个节点不可能成为新leader）且达成了一致可提交，即不允许被覆盖。&lt;/p&gt;

&lt;p&gt;这就是矛盾的地方，即允许“提交之前任期的日志”，最终导致了违反协议规则的情况。&lt;/p&gt;

&lt;p&gt;那么，如何确保新当选的leader节点，其本地的未提交日志被正确提交呢？图(d2)展示了正常的情况：即当选之后，不要首先提交本地已有的黄色日志2，而是首先提交一条新日志4，如果这条新日志被提交成功，那么按照Raft日志的匹配规则（log matching property）：日志4如果能提交，它前面的日志也提交了。&lt;/p&gt;

&lt;p&gt;可是，新的问题又出现了，如果在(d2)中，S1重新当选之后，客户端写入没有这条新的日志4，那么前面的日志2是不是永远无法提交了？为了解决这个问题，raft要求每个leader新当选之后，马上写入一条只有任期号和索引、而没有内容的所谓“no-op”日志，以这条日志来驱动在它之前的日志达成一致。&lt;/p&gt;

&lt;p&gt;这就是论文中这部分内容想要表达的。这部分内容之所以比较难理解，是因为经常忽略了这个图示展示的是错误的情况，允许“提交之前任期的日志”可能导致的问题。&lt;/p&gt;

&lt;h1 id=&#34;其他疑问&#34;&gt;其他疑问&lt;/h1&gt;

&lt;h2 id=&#34;c-和-d2-有什么区别&#34;&gt;(c)和(d2) 有什么区别？&lt;/h2&gt;

&lt;p&gt;看起来，(c)和(d2)一样，S1当选后都提交了日志1、2、4，那么两者的区别在哪里？&lt;/p&gt;

&lt;p&gt;虽然两个场景中，提交的日志都是一样的，但是日志达成一致的顺序并不一致：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(c)：S1成为leader之后，先提交过往任期、本地的日志2，再提交日志4。这就是“提交之前任期日志”的情况。&lt;/li&gt;
&lt;li&gt;(d2)：S1成为leader之后，先提交本次任期的日志4，如果日志4能提交成功，那么它前面的日志2就能提交成功了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于(d2)的这个场景，有可能又存在着下一个疑问：&lt;/p&gt;

&lt;h2 id=&#34;如何理解-d2-中-本任期的日志4提交成功-那么它前面的日志2也能提交成功了&#34;&gt;如何理解(d2)中，“本任期的日志4提交成功，那么它前面的日志2也能提交成功了”？&lt;/h2&gt;

&lt;p&gt;这是由raft日志的&lt;code&gt;Log Matching Property&lt;/code&gt;决定的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If two entries in different logs have the same index and term, then they store the same command.
If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.&lt;/li&gt;
&lt;li&gt;If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一条性质，说明的是在不同节点上的已提交的日志，如果任期号、索引一样，那么它们的内容肯定一样。这是由leader节点的安全性和leader上的日志只能添加不能覆盖来保证的，这样leader就永远不会在同一个任期，创建两个相同索引的日志。&lt;/p&gt;

&lt;p&gt;第二条性质，说明的是在不同节点上的日志中，如果其中有同样的一条日志（即相同任期和索引）已经达成了一致，那么在这不同节点上在这条日志之前的所有日志都是一样的。&lt;/p&gt;

&lt;p&gt;第二条性质是由leader节点向follower节点上根据&lt;code&gt;AppendEntries&lt;/code&gt;消息同步日志上保证的。leader在&lt;code&gt;AppendEntries&lt;/code&gt;消息中会携带新的新添加entries之前日志的term和index，follower会判断在log中是否存在拥有此term和index的消息，如果没有就会拒绝。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;leader为每一个follower维护一个nextIndex，表示待发送的下一个日志的index。初始化为日志长度。&lt;/li&gt;
&lt;li&gt;leader在follower拒绝&lt;code&gt;AppendEntries&lt;/code&gt;之后会对nextIndex减一，然后继续重试AppendEntries直到两者一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，回到我们开始的问题，(d2)场景中，在添加本任期日志4的时候，会发现有一些节点上并不存在过往任期的日志2，这时候就会相应地计算不同节点的nextIndex索引，来驱动同步日志2到这些节点上。&lt;/p&gt;

&lt;p&gt;总而言之，根据日志的性质，只要本任期的日志4能达成一致，上一条日志2就能达成一致。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memcached的存储原理解析（续）</title>
      <link>https://www.codedump.info/post/20210812-memcached/</link>
      <pubDate>Thu, 12 Aug 2021 08:40:04 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210812-memcached/</guid>
      <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;在前面的&lt;a href=&#34;https://www.codedump.info/post/20210701-memcached/&#34;&gt;Memcached的存储原理解析&lt;/a&gt;一文中，简单分析了memcached的存储原理，但是最近在照搬memcached的实现原理到项目中时，发现前面的梳理还不够细致，有一些细节没有谈及，因此重新整理一篇文章。&lt;/p&gt;

&lt;h1 id=&#34;slab&#34;&gt;slab&lt;/h1&gt;

&lt;p&gt;memcached是根据slab为基础单位来管理空闲空间的。slab的大体原理如下图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210812-memcached/slabclass.png&#34; alt=&#34;slabclass的分级存储&#34; title=&#34;slabclass的分级存储&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;slabs.c中定义了类型为&lt;code&gt;slabclass_t&lt;/code&gt;、大小为&lt;code&gt;MAX_NUMBER_OF_SLAB_CLASSES&lt;/code&gt;的数组&lt;code&gt;slabclass&lt;/code&gt;，用于分级存储。&lt;/p&gt;

&lt;p&gt;数组中的每个&lt;code&gt;slabclass_t&lt;/code&gt;元素，其能分配出去的内存大小递增，由如下的规则决定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个数组可分配的内存大小都要8字节对齐（&lt;code&gt;CHUNK_ALIGN_BYTES&lt;/code&gt;）,这个大小保存在&lt;code&gt;slabclass_t&lt;/code&gt;的&lt;code&gt;size&lt;/code&gt;成员中。&lt;/li&gt;
&lt;li&gt;数组的第一个&lt;code&gt;slabclass_t&lt;/code&gt;元素的可分配内存大小为&lt;code&gt;sizeof(item) + settings.chunk_size&lt;/code&gt;。这之后的&lt;code&gt;slabclass_t&lt;/code&gt;可分配内存大小，都在上一个的元素的基础上放大&lt;code&gt;factor&lt;/code&gt;倍，同时还要8字节对齐。&lt;/li&gt;
&lt;li&gt;每次分配一个页面的大小由配置项&lt;code&gt;settings.slab_page_size&lt;/code&gt;来决定，因此每一个&lt;code&gt;slabclass_t&lt;/code&gt;元素的一个页面能容纳的&lt;code&gt;item&lt;/code&gt;数量为&lt;code&gt;settings.slab_page_size / slabclass[i].size&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上图为例，假设第一级存储的item大小不超过56字节，每个slab之间的增长因子是1.2，那么下一个slab存储的item内存大小就是56*1.2=72字节。&lt;/p&gt;

&lt;p&gt;在当前还有空闲可用内存的情况下，每一次分配新的空间，都是以page（page=1MB）为单位的，然后再根据该slab的item大小划分为多个空闲可用item。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slabclass_t&lt;/code&gt;类型中最重要的是以下两个成员：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slab_list：保存已经分配出去的page数组，分配一个page的内存之后，需要将page根据该slab的size划分成多个空闲的item，挂载到下面提到的slots链表中。当最后需要回收分配出去的内存时，直接遍历slab_list中的成员回收内存即可。&lt;/li&gt;
&lt;li&gt;slots：保存空闲item链表。空闲item来源有两部分，一部分是从page中分配但是还未使用的item，还有一部分是曾经被使用后来释放回来的item，上图中使用了不同的颜色进行了区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当需要分配一块大小的内存时，首先需要根据其大小，计算出该尺寸最终对应到上面的哪个元素，这个数组索引在Memcached中被称为&lt;code&gt;clsid&lt;/code&gt;，这个计算索引的过程参见函数&lt;code&gt;slabs_clsid&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slabclass[0].size = 56，fator参数为1.2，那么slabclass[1].size = (56 * 1.25)向上对齐8位 = 72，以此类推。&lt;/li&gt;
&lt;li&gt;假设需要分配的内存大小为60，就会去找&lt;code&gt;slabclass_t.size &amp;gt;= 60&lt;/code&gt;的第一个slabclass，在这个例子中返回的&lt;code&gt;clsid&lt;/code&gt;是1，也就是&lt;code&gt;slabclass[1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;内存分配时根据大小向上取满足条件的第一个slab的做法，优点在于方便了内存的分配管理，缺陷是会浪费掉部分空间，比如上面的例子中，将大小为72的slab用于60的内存，那么12字节的空间就被浪费掉了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从上面可以看到，&lt;code&gt;slabclass_t&lt;/code&gt;用于管理空闲内存，当需要分配新item时，会依次做如下的检查：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;slots&lt;/code&gt;链表中还有空闲item，直接摘下来使用；&lt;/li&gt;
&lt;li&gt;否则，如果当前还没有达到内存分配的阈值，就分配一个新的page出来，将page按照该slab的大小划分为多个item，这些新分配出来的item都挂载到&lt;code&gt;slots&lt;/code&gt;链表中。&lt;/li&gt;
&lt;li&gt;如果以上两步都不满足了，说明当前已经没有可用的内存和空闲item，需要进行淘汰了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;讲到item的淘汰，就涉及到下面的LRU算法了。&lt;/p&gt;

&lt;h1 id=&#34;lru算法&#34;&gt;LRU算法&lt;/h1&gt;

&lt;h2 id=&#34;旧的lru算法及其问题&#34;&gt;旧的LRU算法及其问题&lt;/h2&gt;

&lt;p&gt;以往的LRU算法，基本做法都是这样的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个LRU链表，每次新加入的元素都放在链表头。&lt;/li&gt;
&lt;li&gt;如果元素被访问了一次，同样从当前链表中摘除放到链表头。&lt;/li&gt;
&lt;li&gt;需要淘汰元素时，从链表尾开始找可以淘汰的元素出来淘汰。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个算法有如下几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元素被访问一次就会被放到LRU链表的头部，这样即便这个元素可以被淘汰，也会需要很久才会淘汰掉这个元素。&lt;/li&gt;
&lt;li&gt;由于上面的原因，从链表尾部开始找可以淘汰的元素时，实际可能访问到的是一些虽然不常被访问，但是还没到淘汰时间（即有效时间TTL还未过期）的数据，这样会一直沿着链表往前找很久才能找到适合淘汰的元素。由于这个查找被淘汰元素的过程是需要加锁保护的，加锁时间一长影响了系统的并发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210701-memcached/old-lru-list.png&#34; alt=&#34;经典的LRU链表实现&#34; title=&#34;经典的LRU链表实现&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;综上，经典的LRU链表问题的核心在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只需要一次被访问就能让元素远离被淘汰的地方。&lt;/li&gt;
&lt;li&gt;以及如何高效定位到更可能被淘汰的元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从Memcached 1.5版本开始，引入了所谓的分段LRU算法（Segmented LRU）来解决这些问题。&lt;/p&gt;

&lt;h2 id=&#34;改进的分段lru算法-segmented-lru&#34;&gt;改进的分段LRU算法（Segmented LRU）&lt;/h2&gt;

&lt;p&gt;分段LRU算法中将LRU链表根据&lt;code&gt;活跃度&lt;/code&gt;分成了三类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOT_LRU：存储热数据的LRU链表。&lt;/li&gt;
&lt;li&gt;WARM_LRU：存储温数据（即活跃度不如热数据）的LRU链表。&lt;/li&gt;
&lt;li&gt;COLD_LRU：存储冷数据的LRU链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要说明的是：热（参数&lt;code&gt;settings.hot_lru_pct&lt;/code&gt;）和暖（参数&lt;code&gt;settings.warm_lru_pct&lt;/code&gt;）数据的占总体内存的比例有限制，而冷数据则无限。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define HOT_LRU 0
#define WARM_LRU 64
#define COLD_LRU 128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，使用了&lt;code&gt;heads&lt;/code&gt;和&lt;code&gt;tails&lt;/code&gt;两个数组用来保存LRU链表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#define POWER_LARGEST  256 /* actual cap is 255 */

#define LARGEST_ID POWER_LARGEST

static item *heads[LARGEST_ID];
static item *tails[LARGEST_ID];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面分析&lt;code&gt;slabclass&lt;/code&gt;的时候提到过，首先会根据被分配内存大小计算出来一个&lt;code&gt;slabclass&lt;/code&gt;数组的索引。在需要从LRU链表中淘汰数据时，由于LRU链表分为了上面三类，那么就还需要再进行一次&lt;code&gt;slabid | lru id&lt;/code&gt;计算（其实就是&lt;code&gt;slabid + lru id&lt;/code&gt;），到对应的LRU链表中查找元素：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210701-memcached/slabclass-lru.png&#34; alt=&#34;将slabclass数组索引映射到LRU队列数组&#34; title=&#34;将slabclass数组索引映射到LRU队列数组&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;有了这三种LRU队列的初步印象，可以接下来解释这个分段LRU算法了。&lt;/p&gt;

&lt;p&gt;前面提到，原有LRU算法最大的问题是：只要元素被访问过一次，就马上会被移动到LRU链表的前面，影响了后面对这个元素的淘汰。&lt;/p&gt;

&lt;p&gt;首先，改进的算法中，加入了一个机制：只有当元素被访问两次以后，才会标记成&lt;code&gt;活跃&lt;/code&gt;元素。&lt;/p&gt;

&lt;p&gt;代码中引入了两个标志位，其置位的规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ITEM_FETCHED：第一次被访问时置位该标志位。&lt;/li&gt;
&lt;li&gt;ITEM_ACTIVE：第二次被访问时（即&lt;code&gt;it-&amp;gt;it_flags &amp;amp; ITEM_FETCHED&lt;/code&gt;为true的情况下）置位该标志位。&lt;/li&gt;
&lt;li&gt;INACTIVE：不活跃状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ITEM_ACTIVE标志位清除的规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果从链表尾遍历到某一个LRU链表时，该元素是链表的最后一个元素，则认为是不活跃的元素，即可以清除ITEM_ACTIVE标志位；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样，有效避免了只访问一次就变成&lt;code&gt;活跃&lt;/code&gt;元素的问题（见函数&lt;code&gt;do_item_bump&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;以下的讨论中，元素变成&lt;code&gt;活跃&lt;/code&gt;就意指“至少被访问两次以上”。&lt;/p&gt;

&lt;p&gt;其次，由于从链表尾部往前查找可以淘汰的元素，中间可能会经历很多不能被淘汰的元素，影响了淘汰的速度，因此前面的分级LRU链表就能帮助程序快速识别出哪些元素可以被淘汰。三个分级的LRU链表之间的转换规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOT_LRU：在HOT LRU队列中的数据绝不会到HOT_LRU队列的前面，只会往更冷的队列中放。规则是：如果元素变得活跃，就放到WARM队列中；否则如果不活跃，就直接放到COLD队列中。&lt;/li&gt;
&lt;li&gt;WARM_LRU：如果WARM队列的元素变的&lt;code&gt;活跃&lt;/code&gt;，就会移动到WARM队列头；否则往COLD队列移动。&lt;/li&gt;
&lt;li&gt;COLD_LRU：从上面可知，COLD队列中的元素，都是不太活跃的了，所以当需要淘汰元素时都会首先到COLD LRU队列中找可以淘汰的数据。当一个在COLD队列的元素重新变成&lt;code&gt;活跃&lt;/code&gt;元素时，并不会移动到COLD队列的头部，而是直接移动回去WARM队列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上需要注意的是：任何操作都不能将一个元素从WARM和COLD队列中移动回去HOT队列了，也就是从HOT队列中移动元素出去的操作是单向操作。&lt;/p&gt;

&lt;p&gt;上述算法的状态机转换过程，可以参考下图。使用了这些规则来维护着三个队列之后，基本能保证COLD队列中的元素是不活跃的，这样查找起被淘汰元素也更快了。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210701-memcached/lru.png&#34; alt=&#34;三级LRU队列转换状态图&#34; title=&#34;三级LRU队列转换状态图&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;综述起来，改进的分段LRU算法做了如下的优化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要至少两次被访问，才能变成&lt;code&gt;活跃&lt;/code&gt;元素。&lt;/li&gt;
&lt;li&gt;将元素按照被访问频率的&lt;code&gt;冷热程度&lt;/code&gt;，划分为三种LRU链表来分段管理，加速了查找被淘汰元素的流程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;读写操作的实现&#34;&gt;读写操作的实现&lt;/h1&gt;

&lt;p&gt;从以上的分析里，可以看出memcached中主要有这么几种数据结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;item：存储一个KV数据的基本单位。&lt;/li&gt;
&lt;li&gt;slabclass：存储空闲item的数据结构。&lt;/li&gt;
&lt;li&gt;lru链表：根据访问的冷热程度存储当前在使用中的item。&lt;/li&gt;
&lt;li&gt;hash表：这部分没有在上面描述，用于根据key查询item的数据结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个item，必然处于空闲和在使用这两种互斥状态之一，即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;空闲的item：保存在slabclass的slots空闲链表中，这一点已经在上面slab的图示中描述过了。&lt;/li&gt;
&lt;li&gt;在使用中的item：保存在lru链表中，用于数据回收之用；同时还保存在hash表中，用于数据访问时使用。如下图所示：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210812-memcached/in-use-item.png&#34; alt=&#34;使用中的item数据组织结构&#34; title=&#34;使用中的item数据组织结构&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;对item的数据组织有了大体的概念之后，下面展开来说读写操作的具体实现。&lt;/p&gt;

&lt;h2 id=&#34;读操作&#34;&gt;读操作&lt;/h2&gt;

&lt;p&gt;由于被使用数据存储在hash表中，所以查询操作相对简单，其伪代码是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;读操作：
  加锁
    在hash表中查询数据
  释放锁

  返回查询的结果
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然简单，但是其中有一个值得注意的细节。这里的加锁操作，并不是一个全局锁，否则系统的并发性会大大折扣；同时，也不是给hash数组中的某一个hash桶进行加锁，实际上hash表本身并不存在锁操作。&lt;/p&gt;

&lt;p&gt;在这里，加的锁是首先根据所查询数据的键进行hash计算，再得到对应的锁，在memcached里被称为“item lock”（见全局变量&lt;code&gt;static pthread_mutex_t *item_locks&lt;/code&gt;）。这个锁虽然与数据的键值相关，但是如果hash数组数量与item_locks不相等，那么就不是一一对应的关系，所以才说不是针对hash桶进行加锁。如果hash桶的数量大于item lock的数量，那么这就是一对多的关系，也就是对一个item lock加锁之后，获得锁的线程可以访问多个hash桶。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210812-memcached/item-lock.png&#34; alt=&#34;item锁与hash桶的对应关系&#34; title=&#34;item锁与hash桶的对应关系&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;上图中，索引为N的item锁，管理着索引为M、P这两个hash桶，因此拿到该item锁的线程可以同时访问这两个hash桶。&lt;/p&gt;

&lt;p&gt;因此，上面的读操作更准确的描述应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;读操作：
  根据查询键值加item锁
    在hash表中查询数据
  根据查询键值释放item锁

  返回查询的结果
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;写操作&#34;&gt;写操作&lt;/h2&gt;

&lt;p&gt;与前面非常简单的读操作相比，写操作会更加复杂，因为当内存不足时需要淘汰在LRU数组中的item。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;写操作：  
  根据查询键值加item锁

    分配足够内存的item，写入新的数据
    向hash表中写入数据

  根据查询键值释放item锁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的步骤中，&lt;code&gt;分配足够内存的item&lt;/code&gt;这一步，暂不考虑分析内存足够下的情况，因为这种情况相对简单，只分析内存不足时需要淘汰的情况。将这部分代码展开来讨论，则伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;写操作：  
  1:根据查询键值加item锁

    2:内存不足情况下分配足够内存的item，写入新的数据：

      2.1:计算满足所需内存所在的LRU数组元素，对该LRU链表加锁
      2.2:从后往前遍历所要求内存的LRU数组：
        2.2.1:找到一个item，如果尝试对该item的键值进行加锁失败，则继续尝试下一个item
        2.2.3:否则，对该item的键值进行加锁成功，如果符合回收条件：
          2.2.4:从item所在的hash表中删除item
        2.2.5:释放2.2.1中加的item锁
      
      2.3:对该LRU链表解锁

    3:向hash表中写入数据

  4:根据查询键值释放item锁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，步骤2.2.1中，是尝试对当前item的键值所在的item锁加锁，这一步是可能失败的，因为在第一步中已经加上了item锁，两者有可能相同，如果这里不是尝试而是直接等待解锁，则可能造成死锁。&lt;/p&gt;

&lt;p&gt;但是仅有上面的步骤仍然是不够的，因为即便找到了一个可以被回收的item，也要确定该item没有被其他线程引用，判断的标准是根据item中的引用计数：首先将引用计数加1，如果为2的情况下（使用中的item默认引用计数为1）说明当前只有本线程引用了这个item，后面就可以安全的回收该item。&lt;/p&gt;

&lt;p&gt;在memcached代码中，如果上一步增加引用计数之后不为2时，有可能是item泄露了，如果打开tail_repair_time开关且满足时间的情况下，可以进行强制回收，但是作者也提醒了这样可能会造成程序core掉，也就是出现上面提到的被引用的item被释放的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int lru_pull_tail(const int orig_id, const int cur_lru,
        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        struct lru_pull_tail_return *ret_it) {
        
        // ...

        if (refcount_incr(search) != 2) {
            /* Note pathological case with ref&#39;ed items in tail.
             * Can still unlink the item, but it won&#39;t be reusable yet */
            itemstats[id].lrutail_reflocked++;
            /* In case of refcount leaks, enable for quick workaround. */
            /* WARNING: This can cause terrible corruption */
            if (settings.tail_repair_time &amp;amp;&amp;amp;
                    search-&amp;gt;time + settings.tail_repair_time &amp;lt; current_time) {
                itemstats[id].tailrepairs++;
                search-&amp;gt;refcount = 1;
                /* This will call item_remove -&amp;gt; item_free since refcnt is 1 */
                STORAGE_delete(ext_storage, search);
                do_item_unlink_nolock(search, hv);
                item_trylock_unlock(hold_lock);
                continue;
            }
        }

        // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤2，内存不足情况下分配足够内存的item，其完整实现在函数&lt;code&gt;lru_pull_tail&lt;/code&gt;中，读者可以自行结合上面的伪代码以及前面提及的LRU算法自行分析。&lt;/p&gt;

&lt;p&gt;以上的整个流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210812-memcached/item-recycle.png&#34; alt=&#34;需淘汰item时的写入数据流程图&#34; title=&#34;需淘汰item时的写入数据流程图&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;解释完毕了读写操作流程之后，需要回答这个问题：为什么针对键值的锁加在了item锁上，而不是hash桶？&lt;/p&gt;

&lt;p&gt;原因在于：当写入的元素过多时，hash表需要进行扩容操作，即可以认为hash桶的数量是有可能发生变化的。因此，如果锁在hash桶上，在容量发生变化的时候就难以处理。而item锁数组，其大小则是固定的，不存在这个问题。&lt;/p&gt;

&lt;h1 id=&#34;hash数组的扩容操作&#34;&gt;hash数组的扩容操作&lt;/h1&gt;

&lt;p&gt;hash数组的数量必须是2的次方，每次存储的数据总量超过数组数量的1.5倍时，就需要扩容一倍，最多到2^32。&lt;/p&gt;

&lt;p&gt;扩容流程示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210812-memcached/expand-hashtable.png&#34; alt=&#34;hashtable扩容示意图&#34; title=&#34;hashtable扩容示意图&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;扩容步骤为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按照新的大小分配出来新的hash数组保存到primary_hashtable中，原hash数组命名为old_hashtable，另外有扩容索引值expand_bucket，在该索引之前的数据，表示已经从old_hashtable中转移到新的hash数组了。&lt;/li&gt;
&lt;li&gt;每次操作一个hash桶元素，需要对该hash桶对应的item锁进行加锁之后才能开始转移。&lt;/li&gt;
&lt;li&gt;期间如果有数据访问，首先按照旧的hash桶数量进行计算，如果计算出来的索引值不小于expand_bucket，说明这个数据还在旧的桶里，到old_hashtable中查找；否则说明在新的hash数组里了，按照新的hash桶数量计算器索引值，然后再到primary_hashtable中操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;综述&#34;&gt;综述&lt;/h1&gt;

&lt;p&gt;从以上分析可以看出，实现一个完备的LRU cache库，需要考虑的细节问题其实不少的，尤其memcached需要应对的是多线程情况下cache的读写，比之redis单进程单线程的情况还是要复杂不少，主要包括以下方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何有效、快速的分配、利用内存（slab算法与数据结构）。&lt;/li&gt;
&lt;li&gt;更合理的LRU算法，不至于一次访问就导致该数据难以被回收（分段LRU算法）。&lt;/li&gt;
&lt;li&gt;细粒度加锁操作，而不是全局锁，保证读写操作的并发。不把针对键值的锁放在hash桶上，因为可能会因为容量扩充导致hash桶数组变化，而是使用了一个固定大小的锁数组。&lt;/li&gt;
&lt;li&gt;除了上述的锁之外，还需要不要回收正在被使用的内存（item引用计数）。&lt;/li&gt;
&lt;li&gt;hash数组扩容时如何尽量减少数据访问的冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;参考资料&#34;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://memcached.org/blog/modern-lru/&#34;&gt;Replacing the cache replacement algorithm in memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/memcached/memcached/blob/master/doc/new_lru.txt&#34;&gt;memcached/new_lru.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>选择的维度</title>
      <link>https://www.codedump.info/post/20210803-choice-dimension/</link>
      <pubDate>Tue, 03 Aug 2021 12:10:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210803-choice-dimension/</guid>
      <description>&lt;p&gt;工作这些年之后，我将一份工作中满意度的指标大体划分到三个维度里面：钱、事情和人。一份工作，如果有两个维度都能较好的满足自己标准的，就算是一份不错的工作了；反之，只有一个维度满意，这时毫不犹豫就应该换一份工作；三个维度都能很好的工作，可遇而不可求。&lt;/p&gt;

&lt;p&gt;虽然工作满意度指标可以划分为这三个维度，但是具体到个人身上，每个维度的权重又不尽相同。比如有的人家里条件不错，可能就不会把钱这个维度看的太过重要；另外，每个人对每个维度的满意程度标准又是不一样的。这些，都需要具体情况具体分析，但是将你工作中最在意的部分划分到这三个维度来反问自己对工作的满意程度，是一切的开始。&lt;/p&gt;

&lt;p&gt;我在年初换了一份工作，本来还有过一些犹豫和迟疑，但是当我把这份工作的各种指标映射到这三个维度时，发现事情和人这两个维度都不能让我满意，这时候，“换工作”这个决定就清晰和坚决起来。&lt;/p&gt;

&lt;p&gt;由此我还想到的是，在我们做一些选择的时候，往往考虑的维度过多，顾此失彼、没有重点。我的建议也是将维度缩小，只考虑最重要的三个（最多不超过五个）维度，按照上面的算法进行维度的排序和权重计算，以此来指导我们做出选择。&lt;/p&gt;

&lt;p&gt;要牢记的是：一个选择的维度很多，常人如我们不可能什么都想要都能要，所以要有个取舍只选择对我们来说最重要的维度；即便是最重要的维度，也不可能面面俱到，需要根据自身的情况进行估算，最终做出符合自身条件利益最大化的选择。&lt;/p&gt;

&lt;p&gt;我最近帮一个朋友的孩子做高考志愿选择。一个高考志愿在我看来，涉及的最重要的三个维度是：学校、城市、专业。小朋友想学计算机，但是分数比较尴尬，勉强能够得着211，如果要稳进211就需要选择一般的学校、城市，甚至放弃专业（服从调剂）。在了解了最近几年广东高考的分数之后，给他填报的志愿是：武汉理工大学计算机专业（不服从调剂）、南京邮电大学。南邮虽不属于211，但是胜在专业较强，南京也是不错的城市。最终，如我意料的那样，武汉理工因为不服从调剂未被录取，录取进入南邮的电子信息工程专业。&lt;/p&gt;

&lt;p&gt;以上，就是我应用前面划分选择维度、计算最满意维度组合这套方法论的理论和例子。&lt;/p&gt;

&lt;p&gt;无独有偶，系统设计里，也有所谓的&amp;rdquo;CAP不可能三角（&lt;a href=&#34;https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86&#34;&gt;CAP定理 - 维基百科，自由的百科全书&lt;/a&gt;）&amp;rdquo;：即系统设计时，只能在一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）选择两者。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://www.codedump.info/media/imgs/20210803-choice-dimension/Visualization-of-CAP-theorem.png&#34; alt=&#34;CAP不可能三角&#34; title=&#34;CAP不可能三角&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>