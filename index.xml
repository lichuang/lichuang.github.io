<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codedump的网络日志</title>
    <link>https://www.codedump.info/</link>
    <description>Recent content on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 14 May 2022 06:33:26 +0800</lastBuildDate><atom:link href="https://www.codedump.info/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>博客系列文章索引</title>
      <link>https://www.codedump.info/post/20200122-series-pages/</link>
      <pubDate>Wed, 22 Jan 2020 14:36:00 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200122-series-pages/</guid>
      
      <description>&lt;p&gt;在博客已经写了很多文章了，有一些文章独立成体，有一些则是系列文章来讲述一个主题，在这里将这些系列文章整理下来，本页面将不定期更新。&lt;/p&gt;
&lt;h1 id=&#34;linux系统相关&#34;&gt;Linux系统相关&lt;/h1&gt;
&lt;h2 id=&#34;面向应用开发者的系统指南&#34;&gt;面向应用开发者的系统指南&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200501-system-guide-for-application-programmer/&#34;&gt;《面向应用开发者的系统指南》导论&amp;amp;目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基础篇&#34;&gt;基础篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200128-systemtap-by-example/&#34;&gt;通过实例快速入门Systemtap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200218-linux-traceevent/&#34;&gt;Systemtap中内核trace事件的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cpu篇&#34;&gt;CPU篇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200502-sgfap-process/&#34;&gt;进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-schedule/&#34;&gt;进程调度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200503-sgfap-process-systemtap/&#34;&gt;使用systemtap分析进程的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200516-sgfap-syscall/&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200522-sgfap-softirq/&#34;&gt;软中断&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分布式相关&#34;&gt;分布式相关&lt;/h1&gt;
&lt;h2 id=&#34;etcd及raft原理&#34;&gt;etcd及Raft原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180921-raft/&#34;&gt;Raft算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210515-raft/&#34;&gt;Etcd Raft库的工程化实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210628-etcd-wal/&#34;&gt;Etcd Raft库的日志存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211011-raft-propose-prev-term/&#34;&gt;为什么Raft协议不能提交之前任期的日志？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/&#34;&gt;etcd 3.5版本的joint consensus实现解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;h2 id=&#34;理论基础&#34;&gt;理论基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200609-btree-1/&#34;&gt;B树、B+树索引算法原理（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200615-btree-2/&#34;&gt;B树、B+树索引算法原理（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sqlite&#34;&gt;sqlite&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/&#34;&gt;sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/&#34;&gt;sqlite3.36版本 btree实现（二）- 并发控制框架 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;leveldb&#34;&gt;leveldb&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190215-leveldb/&#34;&gt;Leveldb代码阅读笔记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;boltdb&#34;&gt;boltdb&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200625-boltdb-1/&#34;&gt;boltdb 1.3.0实现分析（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200711-boltdb-2/&#34;&gt;boltdb 1.3.0实现分析（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200725-boltdb-3/&#34;&gt;boltdb 1.3.0实现分析（三）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200726-boltdb-4/&#34;&gt;boltdb 1.3.0实现分析（四）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;缓存服务&#34;&gt;缓存服务&lt;/h1&gt;
&lt;h2 id=&#34;memcached&#34;&gt;memcached&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210701-memcached/&#34;&gt;Memcached的存储原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20210812-memcached/&#34;&gt;Memcached的存储原理解析（续）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;系统设计相关&#34;&gt;系统设计相关&lt;/h1&gt;
&lt;h2 id=&#34;im服务器设计&#34;&gt;IM服务器设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190608-im-design-base/&#34;&gt;IM服务器设计-基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190608-im-msg-storage/&#34;&gt;IM服务器设计-消息存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190818-im-msg-gate/&#34;&gt;IM服务器设计-网关接入层 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191013-im-msg-out-of-order/&#34;&gt;IM服务器设计-如何解决消息的乱序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务调用&#34;&gt;服务调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190629-service-history/&#34;&gt;服务调用的演进历史&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;多核编程&#34;&gt;多核编程&lt;/h1&gt;
&lt;h2 id=&#34;内存模型&#34;&gt;内存模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191214-cxx11-memory-model-1/&#34;&gt;C++11中的内存模型上篇 - 内存模型基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20191214-cxx11-memory-model-2/&#34;&gt;C++11中的内存模型下篇 - C++11支持的几种内存模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;源码解析类&#34;&gt;源码解析类&lt;/h1&gt;
&lt;h2 id=&#34;etcd&#34;&gt;Etcd&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20180922-etcd-raft/&#34;&gt;etcd Raft库解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181125-etcd-server/&#34;&gt;Etcd存储的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nginx--openresty&#34;&gt;Nginx &amp;amp;&amp;amp; OpenResty&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190103-nginx-config-parse/&#34;&gt;Nginx源码阅读笔记-配置解析流程 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-master-worker/&#34;&gt;Nginx源码阅读笔记-Master Woker进程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-event/&#34;&gt;Nginx源码阅读笔记-事件处理模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190131-nginx-read-http-request/&#34;&gt;Nginx源码阅读笔记-接收HTTP请求流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190212-nginx-http-config/&#34;&gt;Nginx源码阅读笔记-查询HTTP配置流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190213-nginx-process-http-request/&#34;&gt;Nginx源码阅读笔记-处理HTTP请求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190214-nginx-memory-pool/&#34;&gt;Nginx源码阅读笔记-内存池的设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190501-lua-stream/&#34;&gt;OpenResty Lua Stream实现分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zeromq&#34;&gt;Zeromq&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190209-zeromq-lockfree-queue/&#34;&gt;zeromq所谓的“无锁消息队列”&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis&#34;&gt;Redis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190409-redis-sentinel/&#34;&gt;redis高可用原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;glog&#34;&gt;Glog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190729-glog/&#34;&gt;glog C++版本代码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;libuv&#34;&gt;Libuv&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190123-libuv/&#34;&gt;Libuv代码简单分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;读书笔记&#34;&gt;读书笔记&lt;/h1&gt;
&lt;h2 id=&#34;数据密集型应用系统设计&#34;&gt;《数据密集型应用系统设计》&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181118-ddia-chapter05-replication/&#34;&gt;《数据密集型应用系统设计》第五章数据复制笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20181124-ddia-chapter06-partitioning/&#34;&gt;《数据密集型应用系统设计》第六章数据分区笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190403-ddia-chapter07-transaction/&#34;&gt;《数据密集型应用系统设计》第七章《事务》笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190405-ddia-chapter08-the-trouble-with-distributed-system/&#34;&gt;《数据密集型应用系统设计》第八章《分布式系统的挑战》笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/&#34;&gt;《数据密集型应用系统设计》第九章《一致性与共识》笔记 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;杂&#34;&gt;杂&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20190324-how-to-read-code/&#34;&gt;如何阅读一份源代码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200605-how-to-read-code-v2020/&#34;&gt;如何阅读一份源代码？（2020年版）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第15期）：图解ARIES论文（上）：日志系统</title>
      <link>https://www.codedump.info/post/20220514-weekly-15/</link>
      <pubDate>Sat, 14 May 2022 06:33:26 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220514-weekly-15/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：ARIES(Algorithm for Recovery and Isolation Exploiting Semantics的简称）是论文&lt;a href=&#34;https://cs.stanford.edu/people/chrismre/cs345/rl/aries.pdf&#34;&gt;《ARIES: A Transaction Recovery Method Supporting Fine-Franularity Locking and Partial Rollbacks Using Write-Ahead Logging》&lt;/a&gt;中提到的一种存储引擎中数据恢复的算法。这篇论文可以说是存储引擎数据恢复领域必读的一篇论文，这两期的周刊就是对这篇论文的图解，这是其中的上篇。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;图解aries论文上&#34;&gt;图解ARIES论文（上）&lt;/h1&gt;
&lt;p&gt;在展开解释ARIES算法原理之前，需要对&lt;a href=&#34;https://www.codedump.info/post/20220410-weekly-12/&#34;&gt;Page oriented类存储引擎&lt;/a&gt;的日志系统有一定的了解，才能继续解释基于这个日志系统之上做的恢复算法。&lt;/p&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;在一个存储系统中，出错是非常常见的情况的，这就涉及到出错了之后系统恢复时还需要能继续工作，即数据不能发生破坏导致整个系统跑不起来。&lt;/p&gt;
&lt;p&gt;于是，当系统出错需要重启恢复时，就涉及到以下两个动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销（Undo）：未完成或者由于各种原因发生的事务，其修改需要被撤销，即回滚为事务之前的旧值。&lt;/li&gt;
&lt;li&gt;重做（Redo）：已经提交的事务，其修改操作的效果需要体现为新值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看下图中提出的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/bufferpool.png&#34; alt=&#34;bufferpool&#34; title=&#34;bufferpool&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在事务T1和T2在同时执行：
&lt;ul&gt;
&lt;li&gt;事务T1：修改A值为3，但是在事务还未提交前，事务T2开始执行。&lt;/li&gt;
&lt;li&gt;事务T2：修改B值为8，并且成功提交。&lt;/li&gt;
&lt;li&gt;事务T1终止：在事务T2成功提交之后，事务T1终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个事务调度的执行顺序引发了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回滚未提交的事务T1需要做什么？&lt;/li&gt;
&lt;li&gt;对于未提交的事务T1，是否允许其修改操作在持久化存储上生效（即将A修改为3）？&lt;/li&gt;
&lt;li&gt;在磁盘的数据库文件中，已成功提交的事务T2，其修改操作是否应该立即落盘（即从buffer pool中同步修改的内容到硬盘）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个问题当前暂且放到一边，来看后面两个问题。&lt;/p&gt;
&lt;p&gt;“是否允许未提交事务的修改在持久化存储上生效”（Whether the DBMS allows an uncommitted txn to overwrite the most recent committed value of an object in non-volatile storage），被称为&lt;code&gt;Steal policy&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;steal：允许未提交事务的修改持久化存储上生效。&lt;/li&gt;
&lt;li&gt;no steal：反之。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务在提交之前是否需要将所有修改同步到持久化存储上（Whether the DBMS requires that all updates made by a txn are reflected on non-volatile storage before the txn is allowed to commit.），也有两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;force：必须将事务的所有修改都同步到持久化存储上，事务才被允许提交。&lt;/li&gt;
&lt;li&gt;no-force：反之。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;围绕着这两个不同的维度，有了不同的做法。&lt;/p&gt;
&lt;p&gt;我们来按照上面的定义，使用&lt;code&gt;no-steal+force&lt;/code&gt;的策略，来重新看看前面的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/no-steal+force.png&#34; alt=&#34;no-steal+force&#34; title=&#34;no-steal+force&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务T1：由于采用no-steal策略，所以对于未能提交的事务T1而言，该事务的修改顶多到内存的buffer pool中，不会在磁盘上生效，因此回滚事务的操作只需要将内存的buffer pool中的数据撤销即可。&lt;/li&gt;
&lt;li&gt;事务T2：由于采用force策略，因此在事务提交之前，必须将所有修改都同步到磁盘的数据库文件上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，使用&lt;code&gt;no-steal+force&lt;/code&gt;的策略是相对简单的，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undo&lt;/code&gt;操作只需要回滚内存中的数据即可，因为还未同步到磁盘的数据库文件上。&lt;/li&gt;
&lt;li&gt;对于已提交事务而言，无需&lt;code&gt;redo&lt;/code&gt;操作，这是因为事务提交之前必须强制同步所有修改到数据库文件上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，这个策略组合的问题在于：无法支撑一个修改了大量数据的事务。比如假设内存中的buffer pool仅能容纳1K大小的修改缓冲区，而某一个事务一共修改了2K的数据，这时候超过buffer pool大小的数据，是否应该即时落盘？按照这个策略是解决不了这个问题的。&lt;/p&gt;
&lt;p&gt;接下来看看两种最常见的做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;影子页面（shadow page）。&lt;/li&gt;
&lt;li&gt;WAL（Write Ahead Log）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;影子页面shadow-page&#34;&gt;影子页面（shadow page）&lt;/h2&gt;
&lt;p&gt;影子页面的原理是这样的，维护两个独立的数据库文件的拷贝：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主拷贝：只保存已提交事务的修改。&lt;/li&gt;
&lt;li&gt;影子拷贝：拷贝待修改页面的内容，保存未提交事务的修改。&lt;/li&gt;
&lt;li&gt;有了两份不同的数据，在进行中的事务只需要修改影子拷贝即可，当未提交事务需要提交时，切换影子拷贝变成主拷贝。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下图来解释影子页面的工作原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/shadow-page.png&#34; alt=&#34;shadow-page&#34; title=&#34;shadow-page&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分别用三种颜色标记了不同类型的页面：主页面、影子页面、空闲页面，其中空闲页面是被替换出去的主页面，由于已经有新的主页面产生，所以之前的主页面就变成了空闲页面可以重新在下一次生成影子页面的时候使用上。&lt;/li&gt;
&lt;li&gt;在修改之前，已经存在3个主页面，其中的页面1为当前的根页面。&lt;/li&gt;
&lt;li&gt;假设一个事务，需要同时修改这三个主页面，系统发现当前没有可用的空闲页面，于是扩展数据库文件生成三个新的物理页面，首先拷贝原页面内容，然后再这个基础上进行事务的修改。&lt;/li&gt;
&lt;li&gt;当事务修改完成之后，只需要修改根页面为最新的页面1即可，而这次修改中涉及到几个之前的主页面就变成了空闲页面，下一次修改时可以回收利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据前面对两种策略的定义，影子页面属于采用&lt;code&gt;no-steal+force&lt;/code&gt;策略的方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no-steal：未提交的时候，不能直接修改变成主页面。&lt;/li&gt;
&lt;li&gt;force：事务提交之前，必须把修改后的影子页面切换为新的主页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们看一看，影子页面的重做和撤销是怎么做的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销：只需要将写事务时多分配出来的物理页面再次变成空闲页面即可，下一次可以回收利用。由于没有切换根页面编号，并不需要多做什么其它的工作了。&lt;/li&gt;
&lt;li&gt;重做：不需要重做操作，因为只要完成了影子页面切换到主页面的操作，就相当于这个事务的修改可见了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看看影子页面的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;既然是“影子”，那么就要求这些页面在修改之前，必须先拷贝一份原始页面的数据，这个代价是很重的。&lt;/li&gt;
&lt;li&gt;对于类似B-Tree这样的数据结构，这个修改会一直从下往上进行，路径中经过的节点都需要一个影子页面来存储修改。&lt;/li&gt;
&lt;li&gt;被替换的主页面会产生空闲页面，对应的就需要垃圾回收策略把这些空闲页面给回收利用上。&lt;/li&gt;
&lt;li&gt;页面内容会碎片化，因为写入的影子页面可能是新增的物理页面，还可能是被回收利用的空闲页面，如果逻辑上相邻的页面在物理上分散，对于读写缓存是不友好的。&lt;/li&gt;
&lt;li&gt;最后，当数据落盘到影子页面时，本质上还是针对文件的一个随机写，随机写的代价是很大的：需要首先寻址到指定位置，然后再进行修改。&lt;/li&gt;
&lt;li&gt;同一时间，只允许有一个写事务在进行，因为如果存在多个写事务，而不同写事务又修改了同一个页面的话，是无法处理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;采用影子页面的例子&#34;&gt;采用影子页面的例子&lt;/h3&gt;
&lt;p&gt;之前的博客中分析过boltdb的实现，以及sqlite的journal实现，这两者都是影子页面的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200625-boltdb-1/&#34;&gt;boltdb 1.3.0实现分析（一）&lt;/a&gt;：在boltdb中，修改页面之前，首先使用mmap机制复制出来待修改的页面，修改完毕之后统一切换主页面和影子页面，同时将修改之前的主页面设置为空闲页面可供下一次回收利用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211222-sqlite-btree-3-journal/&#34;&gt;sqlite3.36版本 btree实现（三）- journal文件备份机制&lt;/a&gt;：sqlite的journal文件，负责备份修改的页面在修改前的数据，事务提交之后这些备份的数据就无用了，如果中间事务中断可以直接用journal备份文件的内容来恢复数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感兴趣的，可以由这两篇文章了解更详细的影子页面的实现。不过，影子页面机制的使用已经不多，更多的是下面介绍的WAL。&lt;/p&gt;
&lt;h2 id=&#34;walwrite-ahead-log&#34;&gt;WAL（Write Ahead Log）&lt;/h2&gt;
&lt;p&gt;除了shadow paging策略以外，另一种保存修改的策略就是使用WAL（Write Ahead Log），对比前者而言，WAL最大的好处是：由于将修改添加到日志中就可以认为保存修改完成，而在文件尾追加（append）操作对比随机写是相对快很多的。&lt;/p&gt;
&lt;p&gt;对于一个写事务而言，如果采用WAL机制，WAL日志的格式有以下三类（后面还会扩展）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务开始时，写入一条&lt;code&gt;BEGIN&lt;/code&gt;表示写事务开始。&lt;/li&gt;
&lt;li&gt;记录事务的修改操作：对于写事务中的每一条修改操作，都要记下以下四个数据：
&lt;ul&gt;
&lt;li&gt;事务ID，这样在同一时间进行多个写事务时，可以知道对应的是哪个事务。&lt;/li&gt;
&lt;li&gt;修改的键值。&lt;/li&gt;
&lt;li&gt;修改之前的值，用于撤掉事务时使用。&lt;/li&gt;
&lt;li&gt;修改之后的值，用于重做事务时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务提交时，写入一条&lt;code&gt;COMMIT&lt;/code&gt;表示事务结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图中演示了之前的两个写事务使用WAL策略：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/wal.png&#34; alt=&#34;WAL&#34; title=&#34;WAL&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时并发了两个写事务，每个写事务的三类不同的日志，都需要写到内存的buffer pool中，日志的格式已经在上面给出来。&lt;/li&gt;
&lt;li&gt;磁盘上存储的文件，除了之前的数据库文件之外，新增了一个叫WAL的日志文件，这个文件不会随机写，只会按照buffer pool中记录的日志顺序添加到文件结尾处。&lt;/li&gt;
&lt;li&gt;一个写事务的操作日志，首先会记录到buffer pool中，而不必立即同步到wal日志中，buffer pool中的日志同步到wal的操作，可以批量一次性写多多条记录，又进一步提升了写操作的效率。&lt;/li&gt;
&lt;li&gt;采用WAL策略之后，一个写操作完成不要求一定要将修改同步到数据库文件中，只需要所有该事务的操作都写入WAL文件即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里需要说明的是，前面提到&lt;code&gt;steal&lt;/code&gt;以及&lt;code&gt;force&lt;/code&gt;这两个维度的策略时，都与是否需要同步数据到持久化存储有关。但是，在WAL中，由于新增了WAL文件，而这个文件本身也是保存在持久化存储中的，所以&lt;code&gt;持久化存储&lt;/code&gt;文件这个概念的范畴，从仅有数据库文件，扩展到了数据库文件和WAL文件。&lt;/p&gt;
&lt;p&gt;于是，从上面对WAL的分析可以看到，WAL是&lt;code&gt;steal+no-force&lt;/code&gt;的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;steal：允许未提交事务的修改操作同步到磁盘的WAL文件中。&lt;/li&gt;
&lt;li&gt;no-force：事务提交之前，必须所有的修改操作都写入磁盘的WAL中才能提交，但并不要求一定要落入数据库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于&lt;code&gt;持久化存储&lt;/code&gt;包括了WAL文件和数据库文件，即可以认为任意时刻的数据为：&lt;code&gt;数据库文件&lt;/code&gt; + &lt;code&gt;WAL中的已提交事务数据&lt;/code&gt;，于是查询一个数据时就需要在这两类文件中依次查询：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先到WAL中查询已提交的事务数据。&lt;/li&gt;
&lt;li&gt;如果第一步没有查到，说明WAL中并没有对这个数据的修改，于是到数据库文件中查询数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面对影子页面和WAL的分析可以看出来，以&lt;code&gt;steal&lt;/code&gt;和&lt;code&gt;force&lt;/code&gt;两个策略的维度组合（一共四个组合，见下图）来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时效率：&lt;code&gt;steal&lt;/code&gt; + &lt;code&gt;no-force&lt;/code&gt;是最快的，而&lt;code&gt;no-steal&lt;/code&gt; + &lt;code&gt;force&lt;/code&gt;则是最慢的。&lt;/li&gt;
&lt;li&gt;恢复时效率：对比运行时效率，恢复时的效率就反过来了，&lt;code&gt;steal&lt;/code&gt; + &lt;code&gt;no-force&lt;/code&gt;是最慢的，而&lt;code&gt;no-steal&lt;/code&gt; + &lt;code&gt;force&lt;/code&gt;则是最快的，原因在于前者需要执行&lt;code&gt;undo&lt;/code&gt;、&lt;code&gt;redo&lt;/code&gt;操作，而后者则不需要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/policies.png&#34; alt=&#34;policies&#34; title=&#34;policies&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;checkpoint检查点&#34;&gt;Checkpoint（检查点）&lt;/h2&gt;
&lt;p&gt;前面提到过，采用了WAL策略的数据库，任意时刻的数据为：&lt;code&gt;数据库文件&lt;/code&gt; + &lt;code&gt;WAL中的已提交事务数据&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是WAL文件不可能一直增长下去，否则一来文件太大，导致影响读性能，二来数据恢复的时候时间过长。所以，每隔一段时间，都需要将WAL文件中的已提交事务数据落盘到数据库文件中，这个流程被称为&lt;code&gt;checkpoint&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了做&lt;code&gt;checkpoint&lt;/code&gt;操作，需要新增一类&lt;code&gt;checkpoint&lt;/code&gt;日志，结合前面提到的几类WAL日志，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务开始时，写入一条&lt;code&gt;BEGIN&lt;/code&gt;表示写事务开始。&lt;/li&gt;
&lt;li&gt;记录事务的修改操作：对于写事务中的每一条修改操作，都要记下以下四个数据：
&lt;ul&gt;
&lt;li&gt;事务ID，这样在同一时间进行多个写事务时，可以知道对应的是哪个事务。&lt;/li&gt;
&lt;li&gt;修改的键值。&lt;/li&gt;
&lt;li&gt;修改之前的值，用于撤掉事务时使用。&lt;/li&gt;
&lt;li&gt;修改之后的值，用于重做事务时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务提交时，写入一条&lt;code&gt;COMMIT&lt;/code&gt;表示事务结束。&lt;/li&gt;
&lt;li&gt;做&lt;code&gt;checkpoint&lt;/code&gt;时，写入一条&lt;code&gt;CHECKPOINT&lt;/code&gt;表示在这个点做了&lt;code&gt;checkpoint&lt;/code&gt;操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看看有了&lt;code&gt;checkpoint&lt;/code&gt;操作之后，如何处理恢复问题，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220514-weekly-15/checkpoint.png&#34; alt=&#34;checkpoint&#34; title=&#34;checkpoint&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务T1提交之后，又开始了事务T2、T3，在T2、T3未提交之前，开始了一个&lt;code&gt;checkpoint&lt;/code&gt;操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkpoint&lt;/code&gt;完成之后，T2完成提交。但是在T3修改之后，就发生了宕机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，如果进行数据恢复的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库文件中已经有事务T1的修改了，因为T1是在&lt;code&gt;checkpoint&lt;/code&gt;之前提交的事务，所以这个事务的修改会在&lt;code&gt;checkpoint&lt;/code&gt;的时候同步到数据库文件中。但是T2、T3这两个在&lt;code&gt;checkpoint&lt;/code&gt;时还未完成的事务，并不会在这一次&lt;code&gt;checkpoint&lt;/code&gt;时同步到数据库文件。&lt;/li&gt;
&lt;li&gt;由于WAL中存在事务T2的&lt;code&gt;COMMIT&lt;/code&gt;日志，表示事务T2已经完成提交，所以在系统恢复时：
&lt;ul&gt;
&lt;li&gt;找到崩溃之前最后一次&lt;code&gt;checkpoint&lt;/code&gt;的位置，针对这个&lt;code&gt;checkpoint&lt;/code&gt;之后的日志，进行如下的操作。&lt;/li&gt;
&lt;li&gt;对于存在&lt;code&gt;COMMIT&lt;/code&gt;日志的事务，比如事务T2，只需重放其WAL日志即可。&lt;/li&gt;
&lt;li&gt;对于不存在&lt;code&gt;COMMIT&lt;/code&gt;日志的事务，比如事务T3，不能重放这个事务，因为在崩溃之前没有落盘所有的修改在WAL中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的&lt;code&gt;checkpoint&lt;/code&gt;流程中，存在一个明显的问题：要求&lt;code&gt;checkpoint&lt;/code&gt;在进行的时候，不得有任何的写事务在进行，换言之&lt;code&gt;checkpoint&lt;/code&gt;操作会影响写事务的进行。所以，如果&lt;code&gt;checkpoint&lt;/code&gt;的频率太高，影响写事务；频率太低，又会让单次&lt;code&gt;checkpoint&lt;/code&gt;时间很长。&lt;/p&gt;
&lt;p&gt;下一期周刊会在此基础上介绍ARIES论文的思想，论文中给出了&lt;code&gt;checkpoint&lt;/code&gt;的优化做法。&lt;/p&gt;
&lt;h2 id=&#34;使用wal的例子&#34;&gt;使用WAL的例子&lt;/h2&gt;
&lt;p&gt;在sqlite的3.7.0版本之后，就采用了WAL机制，之前也写过文章分析，见&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按照落盘的策略，分为了&lt;code&gt;steal&lt;/code&gt;和&lt;code&gt;force&lt;/code&gt;这两个维度。&lt;/li&gt;
&lt;li&gt;shadow page采用的是&lt;code&gt;no-steal+force&lt;/code&gt;策略，而WAL采用的是&lt;code&gt;steal+no-force&lt;/code&gt;策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;纳瓦尔宝典&#34;&gt;《纳瓦尔宝典》&lt;/h2&gt;
&lt;p&gt;《纳瓦尔宝典》是投资人&lt;a href=&#34;https://twitter.com/naval&#34;&gt;Naval Ravikant&lt;/a&gt;的箴言记录，最早知道此人是因为他的那篇被和菜头翻译成中文的文章《如何不靠运气致富》：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中文版：&lt;a href=&#34;https://mp.weixin.qq.com/s/TfhBCbr8-IoHyPKtB3hTlw&#34;&gt;Naval：如何不靠运气致富&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文版：&lt;a href=&#34;https://twitter.com/naval/status/1002103360646823936&#34;&gt;Naval on Twitter: &amp;ldquo;How to Get Rich (without getting lucky):&amp;rdquo; / Twitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再后来， &lt;a href=&#34;https://ejorgenson.com/&#34;&gt;Eric Jorgenson&lt;/a&gt;将Naval的推特文字整理成了《Almanack of Naval Ravikant》，免费电子版在网上完全公开：&lt;a href=&#34;https://www.navalmanack.com/&#34;&gt;Almanack of Naval Ravikant&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，中文版的《纳瓦尔宝典》也被翻译出版了：&lt;a href=&#34;https://book.douban.com/subject/35876121/&#34;&gt;纳瓦尔宝典 (豆瓣)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;c语言编程透视&#34;&gt;《C语言编程透视》&lt;/h2&gt;
&lt;p&gt;C的语法糖不多，语法层面要学习的东西也实在不多，但是C的难点主要是和系统打交道层面的，这篇文档就专注在这方面的解释上，算是这方面比较少见的文档了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tinylab-1.gitbook.io/cbook/&#34;&gt;简介 - C 语言编程透视&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github地址：https://github.com/tinyclub/open-c-book&lt;/p&gt;
&lt;h2 id=&#34;rust-databend-and-the-cloud-warehouse5从-git-到-fuse-engine-存储引擎&#34;&gt;《Rust, Databend and the Cloud Warehouse（5）从 Git 到 Fuse Engine 存储引擎》&lt;/h2&gt;
&lt;p&gt;虎哥的大作&lt;a href=&#34;https://bohutang.me/2022/05/06/databend-cloud-warehouse-fuse-engine/&#34;&gt;Rust, Databend and the Cloud Warehouse（5）从 Git 到 Fuse Engine 存储引擎 [ 虎哥的博客 ]&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;这名业余程序员曾用50张1080ti对抗癌症&#34;&gt;这名“业余”程序员，曾用50张1080Ti对抗癌症。&lt;/h2&gt;
&lt;p&gt;一位业余程序员，使用人工智能的算法来识别肿瘤，很佩服他的行动力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/2zNoWtOHdwC0nNnT0d_WBQ&#34;&gt;这名“业余”程序员，曾用50张1080Ti对抗癌症。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者在V2EX的原贴：&lt;a href=&#34;https://www.v2ex.com/t/843341&#34;&gt;记得 4 年前我做的 AI 乳腺平台吗？这是我的新项目 - V2EX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四年前的原贴：&lt;a href=&#34;https://www.v2ex.com/t/462641#reply303&#34;&gt;在 D 版发过了，不过因为不少朋友看不到 D 版，我就放在这里吧，说说我最近做的这个 Project - V2EX&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第14期）：重读Raft论文中的集群成员变更算法（二）：实践篇</title>
      <link>https://www.codedump.info/post/20220507-weekly-14/</link>
      <pubDate>Sat, 07 May 2022 17:57:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220507-weekly-14/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：以前阅读Raft大论文的时候，对“集群变更”这部分内容似懂非懂。于是最近又重读了大论文这部分的内容，以下是重读时做的一些记录。这部分内容打算分为两篇文章，上篇讲解成员变更流程的理论基础，下篇讲解实践中存在的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;重读raft论文中的集群成员变更算法二实践篇&#34;&gt;重读Raft论文中的集群成员变更算法（二）：实践篇&lt;/h1&gt;
&lt;h2 id=&#34;单步成员变更存在的问题&#34;&gt;单步成员变更存在的问题&lt;/h2&gt;
&lt;h3 id=&#34;正确性问题&#34;&gt;正确性问题&lt;/h3&gt;
&lt;p&gt;单步变更成员时，可能出现正确性问题。如下面的例子所示，最开始时，系统的成员是&lt;code&gt;{a,b,c,d}&lt;/code&gt;这四个节点的集合，要将节点&lt;code&gt;u&lt;/code&gt;和&lt;code&gt;v&lt;/code&gt;加入集群，按照单步变更成员的做法，依次会经历：&lt;code&gt;{a,b,c,d}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d,u}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d,u,v}&lt;/code&gt;的变化，每次将一个节点加入到集群里。&lt;/p&gt;
&lt;p&gt;上面的步骤看起来很美好，但是考虑下面的例子，在变更过程中leader节点发生了变化的情况：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C₀ = {a, b, c, d}
Cᵤ = C₁ ∪ {u}
Cᵥ = C₁ ∪ {v}

Lᵢ: Leader in term `i`
Fᵢ: Follower in term `i`
☒ : crash

    |
 u  |         Cᵤ                  F₂  Cᵤ
--- | ----------------------------------
 a  | C₀  L₀  Cᵤ  ☒               L₂  Cᵤ
 b  | C₀  F₀          F₁          F₂  Cᵤ
 c  | C₀  F₀          F₁  Cᵥ          Cᵤ
 d  | C₀              L₁  Cᵥ  ☒       Cᵤ
--- | ----------------------------------
 v  |                     Cᵥ                  time
    +--------------------------------------------&amp;gt;
          t₁  t₂  t₃  t₄  t₅  t₆  t₇  t₈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（引用自&lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑 - OpenACID Blog&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;上面的流程中，纵坐标是集群中的节点，横坐标是不同的时间（注意不是任期），&lt;code&gt;Li&lt;/code&gt;表示在任期i时候的leader节点，&lt;code&gt;Fi&lt;/code&gt;表示在任期i时候的follower节点。&lt;/p&gt;
&lt;p&gt;上图的流程阐述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;t1：a节点被选为任期0的leader，而b、c节点为follower。&lt;/li&gt;
&lt;li&gt;t2：将节点u加入集群，但是这条加入集群的日志，仅达到了a和u节点，由于这条日志并没有半数以上通过，所以这时候节点u还并未成功加入集群。&lt;/li&gt;
&lt;li&gt;t3：节点a宕机。&lt;/li&gt;
&lt;li&gt;t4：由于原先的leader宕机，于是集群需要选出新的leader，选出来的新leader是节点d，这是任期1时候的leader。&lt;/li&gt;
&lt;li&gt;t5：节点v加入集群，加入集群的日志，到达了节点c、d、v上面，可以看到由于这条日志到了此时集群的半数以上节点上（因为这时候节点a宕机，因此只有三个节点在服务，于是只有有2个节点同意就认为可被提交），所以实际是已经提交的，即v加入集群的操作是成功的。&lt;/li&gt;
&lt;li&gt;t6：leader d宕机。&lt;/li&gt;
&lt;li&gt;t7：宕机的节点a恢复服务，看到本地有将节点u加入到集群的日志，于是它认为节点u、b是这个任期的follower节点。&lt;/li&gt;
&lt;li&gt;t8：此时节点d恢复服务，而leader a将之前把节点u加入集群的日志同步给当前集群的所有节点，这造成了之前v加入集群且已被提交的日志丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出现这个问题，本质是因为：上一任leader的变更日志，还未同步到集群半数以上节点就宕机，这时候新一任leader就进行成员变更，这样导致了形成两个不同的集群，产生脑裂将已经提交的日志被覆盖。&lt;/p&gt;
&lt;p&gt;Raft作者在&lt;a href=&#34;https://groups.google.com/g/raft-dev/c/t4xj6dJTP6E/m/d2D9LrWRza8J&#34;&gt;bug in single-server membership changes&lt;/a&gt;描述了这一现象。&lt;/p&gt;
&lt;p&gt;解决的办法也很简单：即每次新当选的leader不允许直接提交在它本地的日志，而必须先提交一个no-op日志，才能开始同步。这个问题的描述，在之前的博客有描述：&lt;a href=&#34;https://www.codedump.info/post/20211011-raft-propose-prev-term/&#34;&gt;为什么Raft协议不能提交之前任期的日志？ - codedump的网络日志&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;可用性问题&#34;&gt;可用性问题&lt;/h3&gt;
&lt;p&gt;除了以上正确性问题，单步变更还有可能出现可用性问题：当需要替换的节点在同一机房的时候，如果这个机房网络与集群中其他机房的网络断开，就会导致无法选出leader，以致于集群无法提供服务。来看下面的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220507-weekly-14/availability.png&#34; alt=&#34;availability&#34; title=&#34;availability&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，原先集群中有三个节点分别位于三个机房：机房1的节点a、机房2的节点b、机房3的节点c。现在由于各种原因，想把机房1的节点a下线，换成同机房的节点d到集群中继续服务。&lt;/p&gt;
&lt;p&gt;可以看到，这个替换操作涉及到一个节点的加入和一个节点的离开，可能有如下两种可能的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先加入新节点d再删除节点a：&lt;code&gt;{a,b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{a,b,c,d}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;先删除节点a再加入新节点d：&lt;code&gt;{a,b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c}&lt;/code&gt;-&amp;gt;&lt;code&gt;{b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种步骤各有优劣，第二种方案的问题是：中间只有两个节点在服务，一旦这时候又发生宕机，则集群就不可用了。&lt;/p&gt;
&lt;p&gt;第一种方案中，按照上图中的例子，如果正好要替换的a、d节点都位于同一个机房里面，那么假如这个机房的网络也与其它机房隔离，那么只有两个节点在服务，这时候在四节点（中间步骤）的条件下也无法服务。&lt;/p&gt;
&lt;p&gt;以上是单步变更中可能出现的两类问题。可以看到，尽管单步变更算法看起来实现简单，但是实则有很多细节需要注意。虽然Raft论文中认为单步变更是更简单的办法，但是现在主流的实现都使用了Joint Consensus（联合共识）算法。&lt;/p&gt;
&lt;h2 id=&#34;joint-consensus算法如何解决可用性问题&#34;&gt;Joint Consensus算法如何解决可用性问题&lt;/h2&gt;
&lt;p&gt;针对上面提到的：替换同一机房中的不同节点，中间过程中可能由于这个机房被网络隔离，导致的集群不可用（选不出leader）问题，来看看Joint Consensus算法是如何解决的。&lt;/p&gt;
&lt;p&gt;先来回顾一下步骤，如果使用Joint Consensus算法，需要经历两阶段提交：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先提交&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后提交&lt;code&gt;C_New&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把集合换成这里的例子，就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先提交&lt;code&gt;{a,b,c}&lt;/code&gt; $\bigcup$ &lt;code&gt;{a,b,c,d}&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;然后提交 &lt;code&gt;{a,b,c,d}&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看这两阶段中可能出现宕机的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段时leader节点宕机，这个leader节点只有可能是两种情况，其集群配置还是&lt;code&gt;C_Old&lt;/code&gt;，或者已经收到了&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C_Old&lt;/code&gt;：由于这时候这个leader并没有第一阶段提交的&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合变更，因此那些已有&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合的follower这部分的日志将被截断，成员变更失败，回退回&lt;code&gt;C_Old&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;：这意味这个leader已经有第一阶段提交的&lt;code&gt;C_Old&lt;/code&gt;$\bigcup$  &lt;code&gt;C_New&lt;/code&gt;节点集合变更，可以继续将未完成的成员变更流程走完。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似的，在第二阶段时leader节点宕机，也不会导致选不出leader的情况，可以类似推导。&lt;/p&gt;
&lt;p&gt;可见：直接使用Joint Consensus算法并不会存在单步变更时的可用性问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raft集群的单步变更算法，虽然看起来”简单“，但是实践起来有不少细节需要注意。&lt;/li&gt;
&lt;li&gt;虽然论文里提到单步变更算法比之Joint Consensus算法更为简单，很多开源的Raft实现都已经以Joint Consensus算法做为默认的实现了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（之前写过etcd 3.5版本的实现解析，见：&lt;a href=&#34;https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/&#34;&gt;etcd 3.5版本的joint consensus实现解析 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/VKu7fBLliztx3tzvzYDkqw&#34;&gt;Raft成员变更的工程实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.openacid.com/distributed/raft-bug/&#34;&gt;TiDB 在 Raft 成员变更上踩的坑 - OpenACID Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/g/raft-dev/c/t4xj6dJTP6E/m/d2D9LrWRza8J&#34;&gt;bug in single-server membership changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/ongardie/a11f32b70581e20d6bcd&#34;&gt;Safety of Raft single-server membership changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/peterbourgon/raft/blob/master/JOINT-CONSENSUS.md&#34;&gt;raft/JOINT-CONSENSUS.md at master · peterbourgon/raft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第13期）：重读Raft论文中的集群成员变更算法（一）：理论篇</title>
      <link>https://www.codedump.info/post/20220417-weekly-13/</link>
      <pubDate>Sun, 17 Apr 2022 15:16:30 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220417-weekly-13/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：以前阅读Raft大论文的时候，对“集群变更”这部分内容似懂非懂。于是最近又重读了大论文这部分的内容，以下是重读时做的一些记录。这部分内容打算分为两篇文章，上篇讲解成员变更流程的理论基础，下篇讲解实践中存在的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;重读raft论文中的集群成员变更算法一理论篇&#34;&gt;重读Raft论文中的集群成员变更算法（一）：理论篇&lt;/h1&gt;
&lt;p&gt;“集群成员变更（cluster membership change）”意指一个集群内节点的增、删操作，这在一个分布式系统中是必不可少的操作，因为并不能保证一个集群的所有节点都一直能工作的很好。Raft大论文《&lt;a href=&#34;https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf&#34;&gt;Consensus: Bridging Theory and Practice&lt;/a&gt;》中有专门的一节来讲解这部分内容。&lt;/p&gt;
&lt;h2 id=&#34;安全性&#34;&gt;安全性&lt;/h2&gt;
&lt;p&gt;首先，Raft算法中要求所有操作都需要保证安全性（safety），即：任何时候都不能在集群中同时存在两个leader节点。“集群成员变更”算法也必须保证安全性这个大前提不能被破坏，于是论文中阐述了为什么直接变更多个节点是不被允许的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.2.png&#34; alt=&#34;4.2&#34; title=&#34;4.2&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上图的图示中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧集群有1、2、3这三个节点，而需要将这个三节点的集群新增节点4、5变更到5节点集群去。&lt;/li&gt;
&lt;li&gt;如果直接如图中这样变更，由于每个节点的时间窗口并不一致，可能就会出现这种情况：
&lt;ul&gt;
&lt;li&gt;在某一时刻，节点1、2还使用的是旧集群（只含有{1,2,3}）的成员配置，而3、4、5已经是新集群（含有{1,2,3,4,5}）的成员配置了。&lt;/li&gt;
&lt;li&gt;这样就可能出现还使用旧集群节点配置的1、2选出了一个leader，以及已经使用了新集群配置的节点3、4、5选出了另一个leader的情况，于是违反了上面阐述的“安全性”要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，在上面这个错误的示例中，是由于有两类行为同时出现才导致的错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次性变更多个节点。在例子中，就是一次性把4、5两个节点加入到集群中。&lt;/li&gt;
&lt;li&gt;直接（directly）变更。直接变更由于集群中不同节点的步子不一样，而不一样的节点如果出现了两个不同的集群，那么就可能导致选出两个不同的leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/cluster-membership-change.png&#34; alt=&#34;cluster-membership-change&#34; title=&#34;cluster-membership-change&#34;&gt;&lt;/p&gt;
&lt;p&gt;于是，由于这两个错误操作是一起发生才会导致错误，论文中给出了两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要么一次性严格限制只变更一个节点。&lt;/li&gt;
&lt;li&gt;如果实在想一次变更多个节点，那就不能直接变更，需要经过一个中间状态的过渡之后才能完成同时变更多个节点的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下分别来阐述这两种不同的实现。&lt;/p&gt;
&lt;h2 id=&#34;一次变更单个节点&#34;&gt;一次变更单个节点&lt;/h2&gt;
&lt;p&gt;如果限制每次只变更一个节点，那么就能保证“新、旧集合的quorum集合是有重合的”，由于有重合，这样就能保证新旧两个集群的集合不会选出不同的leader，就能间接保证安全性。&lt;/p&gt;
&lt;p&gt;论文中以下面几个例子来说明这样操作的正确性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.3.png&#34; alt=&#34;4.3&#34; title=&#34;4.3&#34;&gt;&lt;/p&gt;
&lt;p&gt;这几个图，是在两个维度上做示范的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增、删操作。&lt;/li&gt;
&lt;li&gt;原集群节点数量是奇数还是偶数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个维度的组合一共就是上面的4中情况，但是无论哪一种情况，由于都保证了“新、旧集合的quorum集合是有重合的”这个条件，于是不会选出不一样的leader来。&lt;/p&gt;
&lt;h2 id=&#34;一次变更多个节点&#34;&gt;一次变更多个节点&lt;/h2&gt;
&lt;p&gt;从上面的例子中可以看到：只要能保证一次只变更一个节点，是可以直接（directly）变更的。即：无需中间状态，直接从A集合变更到A+1集合，因为这两个集合的quorum肯定有重合。&lt;/p&gt;
&lt;p&gt;但是，在一次需要变更多个节点的情况下，就不能这样直接变更，因为会出现最开始示例的那样同时选出两个leader的情况。于是，为了解决这个问题，需要引入一个中间状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设原先的集群节点集合为C_Old，新的集群节点集合为C_New，那么首先变更配置到{C_Old,C_New}，也就是新旧集群节点集合的并集。&lt;/li&gt;
&lt;li&gt;上面这次变更提交之后，再向集群变更配置到C_New。在这次变更提交之后，那些不在C_New节点集合中的节点，收到这个变更时，自动下线退出集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以证明：上面两个步骤中，都不会出现“同时存在两个leader”的情况。&lt;/p&gt;
&lt;p&gt;从本质上来说，这种变更算法，属于一种两阶段的成员变更算法，Raft大论文中称之为“Joint Consensus（联合共识）”算法。下图中演示了Joint Consensus算法这两个阶段的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220417-weekly-13/4.8.png&#34; alt=&#34;4.8&#34; title=&#34;4.8&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;failover&#34;&gt;Failover&lt;/h3&gt;
&lt;p&gt;我们来看看Joint Consensus算法，在变更过程中如果出错，是如何failover选出新leader的。&lt;/p&gt;
&lt;p&gt;第一阶段，这时候选出来的leader只有可能有两种情况，还是旧的C_Old节点集合，或者已经收到了{C_Old,C_New}节点集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有C_Old节点集合的节点：由于这时候这个leader并没有第一阶段提交的{C_Old,C_New}节点集合变更，因此那些已有{C_Old,C_New}节点集合的follower这部分的日志将被截断，成员变更失败，回退回C_Old集合。&lt;/li&gt;
&lt;li&gt;有{C_Old,C_New}节点集合的节点：这意味这个leader已经有第一阶段提交的{C_Old,C_New}节点集合变更，可以继续将未完成的成员变更流程走完。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似的，也可以去推导一下在第二阶段出现leader宕机时，选出来的leader只可能具备两种情况，但是这两种情况都不可能选出多个leader。&lt;/p&gt;
&lt;h2 id=&#34;集群变更何时生效&#34;&gt;集群变更何时生效？&lt;/h2&gt;
&lt;p&gt;以上讲解完毕两种不同的集群变更方式，下面来聊一聊集群变更何时生效。&lt;/p&gt;
&lt;p&gt;在Raft、Paxos这类状态机模型的一致性算法中，将任何变更操作都认为是一个命令（Command），命令的处理流程是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态机收到命令，首先在自己本地将命令持久化。&lt;/li&gt;
&lt;li&gt;然后广播给集群中的其他节点。&lt;/li&gt;
&lt;li&gt;当收到集群半数以上节点的应答时，认为命令是可以被提交（commit）的，于是可以生效将这些已经被提交的日志传给应用层的状态机使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上流程可以看到：一条命令，只有在“提交（commit）”之后才能“生效（apply）”。&lt;/p&gt;
&lt;p&gt;在Raft中，“成员变更”这个操作，也是一类命令，即：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;Command&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;LogEntry,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;	&lt;/span&gt;MembershipChange,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;};&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样设计的好处在于：处理成员变更操作，和一般的日志并没有区别，于是不存在一个特定的时间被称为“处理成员变更的时间”，在这个时间里停止响应一般的命令。&lt;/p&gt;
&lt;p&gt;但是与一般命令不同的是，“成员变更”操作并不需要等到多数通过才能生效。注意，对于一般命令而言，要“生效”必须首先“提交”，而集群变更类命令的生效没有这个依赖关系。&lt;/p&gt;
&lt;p&gt;即，在Raft的成员变更流程中，节点在收到一个新集群节点配置之后，是马上生效的，无需等待半数以上通过。&lt;/p&gt;
&lt;p&gt;这是在阅读Raft论文这一部分内容时，经常被忽略的部分。为什么集群变更类指令，可以这么做，以及这样做会不会出问题？&lt;/p&gt;
&lt;p&gt;为了安全性，Raft在进行集群变更操作时，无论是“单次变更一个节点”还是“一次变更多个节点”，在不同的阶段都不能有重叠（overlap）的情况出现，因为重叠意味着可能违反前面提到的安全性。比如将一个集群节点集合从{1,2,3}变更为{1,4,5}，如果使用这两种方式，步骤分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单次变更一个节点：{1,2,3}-&amp;gt;{1,2,3,4} （增加节点4）-&amp;gt;{1,2,3,4,5} （增加节点5）-&amp;gt;{1,3,4,5} （删除节点2）-&amp;gt; {1,4,5} （删除节点3）。&lt;/li&gt;
&lt;li&gt;单次变更多个节点：{1,2,3}（C_Old）-&amp;gt; {1,2,3,4,5}（{C_Old,C_New}）-&amp;gt; {1,4,5}（C_Old,C_New）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，无论采用哪一种方式，都会有多个步骤。由leader来决定当前的步骤，其判断的标准是：前一步修改的日志，是否已经被提交（半数以上同意）。所以，如果成员变更类的日志在提交之后才生效的话，leader就需要再多一个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先确认日志已经被提交到半数以上节点。&lt;/li&gt;
&lt;li&gt;在这之后，再确认这个成员变更已经在节点上生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而后面的这个确认，是可以避免的。因为根据前面&lt;code&gt;failover&lt;/code&gt;部分的分析，无论哪一种情况出现，即便在变更的过程中leader宕机，也不会出现选出多个leader的情况。&lt;/p&gt;
&lt;p&gt;于是，对于成员变更类的日志来说，Raft的规则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多次提交不能重叠（overlap），即如果当前已经有还未提交的成员变更日志，在它提交之前不允许提交新的成员变更修改。&lt;/li&gt;
&lt;li&gt;成员变更的生效，无需等待提交，每个节点在收到这类日志的时候，就能马上修改本节点上的成员为最新的这个配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raft算法要求任何时候都要保证安全性（safety）：不能在同一时间在集群中存在两个不同的leader节点。&lt;/li&gt;
&lt;li&gt;如果以下两个操作同时发生，就有可能违反安全性：
&lt;ul&gt;
&lt;li&gt;一次变更多个节点。&lt;/li&gt;
&lt;li&gt;直接变更集群的节点集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由这两个限制出发，分别有以下两种实现成员变更的算法：
&lt;ul&gt;
&lt;li&gt;限制每次只变更一个节点，这种情况下可以直接变更成员。&lt;/li&gt;
&lt;li&gt;每次可以变更任意数量的节点，但是必须通过两阶段提交完成才能生效：第一次从C_Old变成{C_Old,C_New}节点集合，第二次从{C_Old,C_New}变成C_New。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“成员变更”类命令，在Raft算法看来也是一条日志。但是与普通日志命令不同的是，成员变更类日志的生效，无需等待这条日志提交了才能生效，可以在收到之后马上生效。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第12期）：Page oriented类存储引擎里可能同时存在多种结构</title>
      <link>https://www.codedump.info/post/20220410-weekly-12/</link>
      <pubDate>Sun, 10 Apr 2022 11:38:16 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220410-weekly-12/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊Page oriented类存储引擎内的数据结构组织。在满足“向磁盘读写的基本单位是物理页面”这个大前提下，这类存储引擎的可能同时存在多种结构。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;page-oriented类存储引擎里可能同时存在多种树形结构&#34;&gt;page oriented类存储引擎里可能同时存在多种树形结构&lt;/h1&gt;
&lt;h2 id=&#34;存储引擎的分类&#34;&gt;存储引擎的分类&lt;/h2&gt;
&lt;p&gt;目前接触到的存储引擎，以向磁盘读写方式来分类的话，大体可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LSM-Tree结构。&lt;/li&gt;
&lt;li&gt;Page oriented类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LSM-Tree是“Log-Structured Merge-Tree”的简称，这类存储引擎写入一条数据的流程大体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向内存以及WAL日志中写入完成，即可认为写入成功。&lt;/li&gt;
&lt;li&gt;内存中的数据写满之后，将落盘到所谓的sstable中。&lt;/li&gt;
&lt;li&gt;sstable分为多层，随着写入进行，不同层次的sstable数据将进行合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220410-weekly-12/LSM.jpeg&#34; alt=&#34;LSM&#34; title=&#34;LSM&#34;&gt;&lt;/p&gt;
&lt;p&gt;（图片引用自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/181498475&#34;&gt;LSM树详解 - 知乎&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;从上面简单的写入LSM的流程可以看到：无论是写入内存还是磁盘，这类存储引擎在写入新数据时（不是合并sstable流程），磁盘操作的单位是一条记录。而一条记录的长度，是不定长的。&lt;/p&gt;
&lt;p&gt;与LSM-Tree类的结构不同的是，Page oriented类的存储引擎，向磁盘发起读写操作的基本单位是页面（page），一个页面通常的大小是2的次方，最小一般是1024字节，比如sqlite的存储，其页面大小为4K（可以修改编译选项配置页面大小）。&lt;/p&gt;
&lt;p&gt;以一个物理页面为读写磁盘的基本单位，这也是这一类存储引擎之所以被称为”Page oriented类存储引擎“的原因。本文重点是介绍Page oriented类存储引擎的结构。&lt;/p&gt;
&lt;h2 id=&#34;page-oriented存储引擎的结构&#34;&gt;Page oriented存储引擎的结构&lt;/h2&gt;
&lt;p&gt;还是以之前介绍过的sqlite的架构图来开头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个架构由下往上依次是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统层：提供不同系统级API的封装，比如文件读写、加解锁操作等。&lt;/li&gt;
&lt;li&gt;物理页面管理层：提供物理页面读写、缓存等功能。&lt;/li&gt;
&lt;li&gt;树形结构的实现：根据具体的树形算法，组织物理页面之间的逻辑关系（比如父子页面、兄弟页面），以及单个物理页面之内的数据的组织。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的重点是页面管理层和树形结构的实现这两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理页面管理相当于是磁盘文件的”原材料供应商“，负责对它的客户也就是各种不同结构的实现提供物理页面这一”原材料“的读写、缓存管理，而它对这些材料被客户拿去做成了什么，一无所知。&lt;/li&gt;
&lt;li&gt;树形结构的实现，从页面管理器拿到了”物理页面“这个原材料之后，可以按照自己的算法和数据结构任意塑造成任何合理的结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/database-file.png&#34; alt=&#34;数据库文件的物理页面组织和逻辑页面结构&#34; title=&#34;数据库文件的物理页面组织和逻辑页面结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Page oriented存储引擎，在满足“向磁盘读写的基本单位是物理页面”这个大前提下，这类存储引擎的可能同时存在多种结构：可能只有B-Tree，也可能只有B+Tree。还有另一种情况是：这类存储引擎内部同时存在多种结构。&lt;/p&gt;
&lt;p&gt;以sqlite为例，内部其实就存在两种结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储索引的index tree：结构为B-Tree，键为表索引，值为这一行数据的&lt;code&gt;rowid&lt;/code&gt;，其中&lt;code&gt;rowid&lt;/code&gt;为隐藏列，创建数据表时自动生成，这一列是自增整数。&lt;/li&gt;
&lt;li&gt;存储数据的table tree：结构为B+Tree，键为&lt;code&gt;rowid&lt;/code&gt;，值为一行数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两类存储引擎，由于同属于“Page oriented类存储引擎”，因此可以共用同一个物理页面管理器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/btree-rowid.png&#34; alt=&#34;数据库文件的rowid全量数据表和索引表&#34; title=&#34;数据库文件的rowid全量数据表和索引表&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面，以sqlite中的一个表为例来解释上面这个流程。&lt;/p&gt;
&lt;p&gt;首先，创建一个表以及索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#666&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;&#34;&gt;创建数据库&lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY(&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;ID&lt;span style=&#34;color:#bbb&#34;&gt;             &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;NAME&lt;span style=&#34;color:#bbb&#34;&gt;           &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;TEXT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;   &lt;/span&gt;AGE&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#a2f&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;NULL&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;&#34;&gt;创建索引&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;id_index&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(id);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这个建表以及创建索引之后，对应的在这个数据文件中就有了两个树形结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储&lt;code&gt;COMPANY&lt;/code&gt;表数据的table-tree。&lt;/li&gt;
&lt;li&gt;存储索引&lt;code&gt;id&lt;/code&gt;到&lt;code&gt;rowid&lt;/code&gt;关系的index-tree。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果向这个表插入数据，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INSERT&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;INTO&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(ID,NAME,AGE)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Paul&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么，这个插入操作背后实际对应了向这两棵树的插入操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，将这一行数据插入到table-tree中，同时得到&lt;code&gt;rowid&lt;/code&gt;以及插入时候的&lt;code&gt;id&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再将第一步得到的&lt;code&gt;rowid&lt;/code&gt;以及&lt;code&gt;id&lt;/code&gt;插入到index-tree中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用&lt;code&gt;id_index&lt;/code&gt;索引来查询&lt;code&gt;COMPANY&lt;/code&gt;表，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;select&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;COMPANY&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;where&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;id&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个查询操作也实际上经过了上面这两个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，通过存储&lt;code&gt;id_index&lt;/code&gt;到&lt;code&gt;rowid&lt;/code&gt;关系的index-tree，找到&lt;code&gt;id=1&lt;/code&gt;对应的&lt;code&gt;rowid&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后，再根据第一步得到的&lt;code&gt;rowid&lt;/code&gt;到table-tree中查询到这一行数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储引擎，按照对磁盘读写方式的不同，大体可以分为以下两类：
&lt;ul&gt;
&lt;li&gt;LSM-Tree：写磁盘的基本单位是一条记录，而一条记录大小是不定长的。&lt;/li&gt;
&lt;li&gt;Page oriented：读写磁盘的基本单位是页面，页面大小为2的次方。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“Page oriented”类存储引擎的核心模块是页面管理器和树形结构的实现，前者提供物理页面这一“原材料”的读写操作，对页面内部的结构一无所知；后者组织管理物理页面间的逻辑关系，以及物理页面内部的数据。&lt;/li&gt;
&lt;li&gt;在满足“读写磁盘的基本单位是页面”的大前提下，“Page oriented”类存储引擎可以使用各种树形结构，还可能在同一个存储引擎中同时存在多种树形结构。&lt;/li&gt;
&lt;li&gt;sqlite的实现，内部存在两种不同的树形结构：使用B-Tree来管理索引数据，以B+Tree来管理表数据。这是因为：
&lt;ul&gt;
&lt;li&gt;索引数据的值只有&lt;code&gt;rowid&lt;/code&gt;这样的整型数据，所以单个物理页面内能存储更多的索引数据，适合使用B-Tree这样“高而瘦”的结构来管理这类单条数据很小的数据。&lt;/li&gt;
&lt;li&gt;而B+Tree的树形结构是“矮而胖”的结构，更适合存储管理多种不定长的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;git的第一版&#34;&gt;Git的第一版&lt;/h2&gt;
&lt;p&gt;2005年4月6日，Git发布了第一版。Git无疑是最伟大的开源软件之一，它的出现极大改变了开源软件的协作、开发方式。&lt;/p&gt;
&lt;p&gt;根据这里的“史料”（ &lt;a href=&#34;https://www.ithome.com.tw/news/95088&#34;&gt;Git十歲了！Git之父Linus Torvalds說古，大談Git開發秘辛 | iThome&lt;/a&gt; ）记载：Linus最初只花了10天就写出了第一版可以跑的Git了。&lt;/p&gt;
&lt;h2 id=&#34;使用rust编写grpc服务的初学者指南&#34;&gt;使用Rust编写gRPC服务的初学者指南&lt;/h2&gt;
&lt;p&gt;最近在使用Rust编写gRPC服务，这篇教程讲解了这部分内容，包括一应一答模式、单向stream模式、双向stream模式都有对应的代码例子，见：&lt;a href=&#34;https://dev.to/anshulgoyal15/a-beginners-guide-to-grpc-with-rust-3c7o&#34;&gt;Rust gRPC: A beginners guide to gRPC with Rust&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;在大公司工作的吐槽&#34;&gt;在大公司工作的吐槽&lt;/h2&gt;
&lt;p&gt;一位在美国工作的工程师写的国外大公司（文中是亚马逊）晋升的一些槽点，看起来和国内大公司也差不多，见：&lt;a href=&#34;https://yorotoo.medium.com/%E5%85%B3%E4%BA%8E%E5%8D%87%E8%81%8C-55dbe62ebaf&#34;&gt;关于升职 - Yang Letu - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外文中还推荐了一个推特上的吐槽：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/kantrn/status/1511791378497384454&#34;&gt;Noah Kantrowitz on Twitter: &amp;ldquo;FAANG promo committees are killing Kubernetes: A Short Thread 🧵&amp;rdquo; / Twitter&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于威尔史密斯打人一位台湾老师的社会课引导思考&#34;&gt;《关于威尔史密斯打人，一位台湾老师的社会课引导思考》&lt;/h2&gt;
&lt;p&gt;关于威尔史密斯打人，一位台湾老师的社会课引导思考，见：https://www.facebook.com/hhsleo/posts/5543635368999794&lt;/p&gt;
&lt;p&gt;（上面的文章可能需要FB权限才能打开，也可以看这篇微信公众号的转发：&lt;a href=&#34;https://mp.weixin.qq.com/s/lGJpnq89gxTPxj_KUA2ZCg&#34;&gt;关于威尔史密斯打人，一位台湾老师的社会课引导思考&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我告訴學生，我今天扮演的角色，就像是政治人物或媒體，我蓄意餵養你片面的、我想要你知道的資訊，而有超過7成的人，在這個過程中，被我操弄了，你因為我每次餵養的資訊不同，而產生立場反覆的狀況！明明政治人物應該考慮的是公益，媒體應該報導的是真相，但我若故意要操弄輿論，我只要給你我要你知道的訊息就好，對我不利的，我一概不提。慢慢的，我就可以透過這種愚弄的手法，讓民眾變成對我死忠而深信不疑的禁臠而不自知，我要你膜拜你就膜拜，我要你打砸殺你就打砸殺，我要你剷除異己你就剷除異己，我要你上刀山下油鍋，你還會爭先恐後想要身先士卒。而這樣的現象，正在世界各地上演”&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第11期）：mmap适用于存储引擎吗？</title>
      <link>https://www.codedump.info/post/20220327-weekly-11/</link>
      <pubDate>Sun, 27 Mar 2022 15:06:38 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220327-weekly-11/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊mmap技术在存储引擎中的应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mmap适用于存储引擎吗&#34;&gt;mmap适用于存储引擎吗？&lt;/h1&gt;
&lt;p&gt;想写这篇文章，主要源于两篇文章（论文）中的对mmap在存储引擎中使用的两种截然不同的观点讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反方（mmap不应该用于存储引擎）：&lt;a href=&#34;https://db.cs.cmu.edu/mmap-cidr2022/&#34;&gt;Are You Sure You Want to Use MMAP in Your Database Management System? (CIDR 2022)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;正方（mmap可以用于存储引擎）：&lt;a href=&#34;https://ayende.com/blog/196161-C/re-are-you-sure-you-want-to-use-mmap-in-your-database-management-system&#34;&gt;re: Are You Sure You Want to Use MMAP in Your Database Management System? - Ayende @ Rahien&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于刚好看过这两种方式的btree存储引擎：sqlite的btree实现以及boltdb，所以可以结合我的认知来聊一聊这个问题。这两个存储引擎的实现都已经整理成了系列博客，这两个系列的第一篇分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20211217-sqlite-btree-0/&#34;&gt;sqlite3.36版本 btree实现（零）- 起步及概述 - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codedump.info/post/20200625-boltdb-1/&#34;&gt;boltdb 1.3.0实现分析（一） - codedump的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先来看看一个存储引擎实现时的大体分层，以sqlite为例分为三层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/btree-arch.png&#34; alt=&#34;btree架构&#34; title=&#34;btree架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;自下而上，这三个层次分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;os层：封装系统级API实现文件的读写等操作。&lt;/li&gt;
&lt;li&gt;页面管理层：提供以页面为单位的读、写、加载、缓存等操作。&lt;/li&gt;
&lt;li&gt;btree实现：btree以物理页面为单位向下一层的页面管理层来读写页面，而物理页面内部的逻辑组织（比如父子关系），以及页面内的数据组织（比如一个页面中管理的数据）由这一层负责。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以这样来简单区别理解“页面管理”模块和btree模块的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页面管理：顾名思义，页面管理模块的最基本单位是”页面“，页面的读、写、缓存、落盘、恢复、回滚等，都由页面模块负责。上一层依赖页面管理模块的btree模块，不需要关心一个页面何时缓存、何时落盘等细节。即：&lt;strong&gt;页面模块负责页面的物理级别的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;btree：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责按照btree算法，来组织页面，即负责的是页面之间逻辑关系维护。&lt;/li&gt;
&lt;li&gt;除此以外，一个页面内部的数据的物理、逻辑组织，也是btree模块来负责的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即：&lt;strong&gt;btree负责维护页面间的逻辑关系，以及一个页面内数据的组织。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20211217-sqlite-btree-0/page-module.png&#34; alt=&#34;以页面物理、逻辑关系的维护看模块划分&#34; title=&#34;以页面物理、逻辑关系的维护看模块划分&#34;&gt;&lt;/p&gt;
&lt;p&gt;在数据库文件中，通常按照页面为单位来划分文件，比如sqlite一般是4KB大小为一个物理页面，所以一个数据库文件可以看做是一个大的“物理页面数组”，这样的话每个物理页面都有一个对应的编号（从1开始），这个编号通常简称为PID（page id）。&lt;/p&gt;
&lt;p&gt;从上面的功能划分可以看到，“页面管理器（也被称为“buffer pool）”的功能是非常复杂的，这里列举几个最关键的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读页面：上层的btree要读一个数据库文件中的页面时，通常传入一个PID，由页面管理器去加载这个页面的数据。而页面数据并不是每次都会到数据库文件中一次磁盘IO读出来，也很可能在内存中，此时就不需要读磁盘操作了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写页面：当一个页面被修改后，就被称为“脏页面（dirty page）”，需要落盘；但并不是每一次修改了一个页面的内容之后就马上落盘，其原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次写事务可能修改了不止一个页面，需要以事务为单位去落盘脏页面。&lt;/li&gt;
&lt;li&gt;即便是落盘脏页面，由于涉及到写磁盘操作，所以还会用其他方式减少写磁盘的次数。比如sqlite的wal备份文件机制中，脏页面的内容是首先写入wal文件的，由于写wal文件是一次append操作而不是随机写，所以效率会更高，如果一个脏页面的内容被写入wal文件的话，那么这部分页面内容是不急于马上写入数据库文件的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存页面：由于页面缓存的功能，所以还需要一个页面缓存管理的功能，主要负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用缓存控制算法（sqlite中是LRU）将经常读到的页面缓存在内存中，这样不必每次都读磁盘加载数据。&lt;/li&gt;
&lt;li&gt;当缓存大小不够时，将脏页面落盘，空出来空间加载要读的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看了上面对页面管理器这个模块功能的描述，可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于有页面缓存的作用，所以能够精准的控制页面缓存的大小。&lt;/li&gt;
&lt;li&gt;将“脏页面落盘”这个操作，是与具体的事务有关，并不是修改完毕就能直接落盘，否则的话可能会涉及到脏写等问题。比如一个事务修改了1、2、3三个PID的页面，修改页面1之后并不能马上落盘这个修改，需要等到三个页面都改完了才行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看看如果使用mmap技术来代替上面的“页面管理器”会面对什么问题。&lt;/p&gt;
&lt;p&gt;首先，无法做到对内存容量的精准控制。&lt;/p&gt;
&lt;p&gt;其次，写事务如何处理，因为当使用mmap技术修改了一个页面时，实际上这个被修改的页面内容何时被OS内核落到硬盘，已经不由使用者来控制了，那么如何解决上面提到的一个事务修改了多个页面需要同时落盘的问题？&lt;/p&gt;
&lt;p&gt;以boltdb为例，它使用的是类似COW的机制来解决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220327-weekly-11/boltdb-write.png&#34; alt=&#34;boltdb实现写事务&#34; title=&#34;boltdb实现写事务&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boltdb的数据库文件中，前面三个页面依次是：meta1页面、meta2页面、freelist页面，前两者是存储数据库元信息的页面，freelist页面可以认为是存储当前空闲页面数据。之所以需要两个meta页面，是为了保存写信息：即便一次写操作失败，因为还有另一个meta页面，这样就还能恢复回来。每个meta页面都有一个单调递增的事务id，事务id越大说明是越近的写操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图中紧跟着前面三个元页面的是页面1、2、3，假设这里的写事务就修改了这三个页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进行修改时，首先拿到当前保存较大事务id的meta页面，这里假设是meta1页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后进行写事务的页面修改，此时的修改还只是在内存中进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写事务完成之后，需要将修改落盘，将按照如下的顺序来进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，数据库文件中新增三个页面保存修改后的内容，而原来的三个页面内容不动。&lt;/li&gt;
&lt;li&gt;然后，将原先的三个页面加入freelist空闲页面链表中，这样下一次就可以回收利用了。&lt;/li&gt;
&lt;li&gt;最后，将meta1页面的修改落地。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个修改的顺序必须严格遵守，否则中间一个过程失败整个数据库文件就损坏了。只有当完成meta页面的修改，才认为这次修改完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是boltdb这个使用了mmap来做页面管理的存储引擎，应对写事务操作的手段，本质上算一个COW的做法。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“页面管理器”在整个存储引擎的架构里，处于承上启下的作用：对上提供物理页面级别的读、写、缓存控制等功能，对下使用OS系统API来实现文件读写操作。&lt;/li&gt;
&lt;li&gt;其缓存功能，能够达到精准控制页面缓存这部分内容容量的作用；另外，由于一次写事务通常不止修改了一个页面，所以还需要精准控制脏页面的落盘的时机，否则会出现写坏数据库的情况。&lt;/li&gt;
&lt;li&gt;使用mmap来替代自实现的页面管理器最大的就是这两个问题：
&lt;ul&gt;
&lt;li&gt;无法做到精准控制页面缓存容量。&lt;/li&gt;
&lt;li&gt;采用类COW的做法来解决写事务问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上面的第二个问题有解决方案，但是问题一貌似没有。所以一个存储引擎如果使用mmap来实现页面管理，可以说这个存储引擎可能只适用于“内存不敏感”的业务场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;类notepad的编辑器&#34;&gt;类notepad++的编辑器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dail8859/NotepadNext&#34;&gt;dail8859/NotepadNext: A cross-platform, reimplementation of Notepad++&lt;/a&gt;是一款基于qt编写的编辑器，仅看作者提供的软件截图可以说很像notepad++了，但是目前为止好像还只有Linux、Win版本，希望以后能有Mac版本。&lt;/p&gt;
&lt;h2 id=&#34;etcd中的红黑树实现&#34;&gt;etcd中的红黑树实现&lt;/h2&gt;
&lt;p&gt;最近在看etcd的watcher机制的实现，看着看着，发现etcd还自带了一个叫adt的包，里面手写了一个红黑树的实现：&lt;a href=&#34;https://github.com/etcd-io/etcd/tree/main/pkg/adt&#34;&gt;etcd/pkg/adt&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;一条豆瓣动态引发的疫情文学复兴&#34;&gt;一条豆瓣动态引发的“疫情文学”复兴&lt;/h2&gt;
&lt;p&gt;疫情时期的豆瓣网络文学大赛，由一条豆瓣引发的网友评论回复：&lt;a href=&#34;https://www.douban.com/note/827837123/?_dtcc=1&amp;amp;_i=7741611DTua3Gc,8390080DTua3Gc&#34;&gt;一条豆瓣动态引发的“疫情文学”复兴&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;你最好的一条职业建议是什么&#34;&gt;你最好的一条职业建议是什么？&lt;/h2&gt;
&lt;p&gt;Twitter上有人发了一个推，说他之前问过一个问题：“你最好的一条职业建议是什么？”，他得到了1300多个答案，最后他整理了12条最好的建议。这些建议，也被人整理成了中文发到了微博：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&#34;https://twitter.com/chrishlad/status/1502650707274608644&#34;&gt;Chris Hladczuk on Twitter: &amp;ldquo;So I asked &amp;ldquo;What&amp;rsquo;s your single best piece of career advice&amp;rdquo;? I got 1,300+ answers. Here are the 12 best you wish you knew yesterday👇&amp;rdquo; / Twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&#34;https://weibo.com/1727858283/Ljvv75q62&#34;&gt;宝玉xp的微博 - 微博&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第10期）：“忘记目标，专注于体系”</title>
      <link>https://www.codedump.info/post/20220319-weekly-10/</link>
      <pubDate>Sat, 19 Mar 2022 13:50:46 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220319-weekly-10/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：本期聊一聊《掌控习惯》这本书里提到的养成习惯的方法论。我读下来一个最深的感受是：越不需要“坚持”就能做下去的事情，才越能长久做下去。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;忘记目标专注于体系&#34;&gt;“忘记目标，专注于体系”&lt;/h1&gt;
&lt;p&gt;“忘记目标，专注于体系（Forget About Setting Goals, Focus on the system Instead）”是出自《&lt;a href=&#34;https://jamesclear.com/atomic-habits&#34;&gt;Atomic Habits&lt;/a&gt;》（中文名&lt;a href=&#34;https://book.douban.com/subject/34326931//&#34;&gt;《掌控习惯 》&lt;/a&gt;）一书的一句话，个人认为这是本书最重要的一个观点。&lt;/p&gt;
&lt;p&gt;要做成一件事情，只是依靠简单的设定目标，是远远不够的，更重要的是建立一套体系，促进事情的良性循环，最终让事情发生；反之，如果一件不好的事情，经常重蹈覆辙，其根本原因也是从未改变导致这种状况一再发生的体系。如果没有建立一套体系，所做的一切只是治标不治本。&lt;/p&gt;
&lt;p&gt;这里说的“体系”，在作者的话语中就是“习惯”，作者列出了培养良好习惯的四个步骤（提示、渴求、反应和奖励）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、提示：让它显而易见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、渴求：让它有吸引力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、反应：让它简便易行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、奖励：让它令人愉悦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者将这四个步骤，总结在&lt;code&gt;习惯循环（habit-loop）&lt;/code&gt;里，如下图：&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/habit-cycle.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;习惯循环&#34; align=center /&gt;
&lt;/div&gt;
&lt;p&gt;这四个步骤缺一不可，任何一个环节做的不够的话，就难以形成习惯：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除提示，习惯形成循环永远也不会开始。&lt;/li&gt;
&lt;li&gt;降低渴求，就不会有足够的动力去行动。&lt;/li&gt;
&lt;li&gt;让行动变得困难，将无法付诸实施。&lt;/li&gt;
&lt;li&gt;如果奖励不能满足欲望，那么未来就没有理由再这样做了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有前三步，就不会有任何行为发生。没有这四个步骤，任何一种行为都不会得以重复。&lt;/p&gt;
&lt;h2 id=&#34;1提示让它显而易见&#34;&gt;1、提示：让它显而易见&lt;/h2&gt;
&lt;p&gt;在日常行为中，“原动力经常被高估，而环境的作用往往被低估”，比如经常会认为树立一个远大的目标，坚持做下去就好；而现实的情况是，行为是环境中人的函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B（行为）=f（函数）[P（人），E（环境）]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即有怎样的行为，除了和人有关系之外，还和环境有重要的关系。&lt;/p&gt;
&lt;p&gt;环境函数中，常见的两个提示是时间和地点。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样摆放在超市的东西，更容易被接触到、更显眼的商品，被购买的概率会更高。&lt;/li&gt;
&lt;li&gt;据书中列举的越战士兵的统计显示，在离开越南战场之后，毒瘾戒除率大大提高，因为生活环境发生了彻底的改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一定理给的提示是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假如不需要经常自我克制的话，做起来就会更容易。所以，没错，毅力、勇气和意志力是取得成功的要素，但是增强这些品质的途径不是期望你自己成为一个自律的人，而是创造一个有纪律的环境。&lt;/li&gt;
&lt;li&gt;消除坏习惯的最实用的方法之一是避免接触引起它的提示，比如要少玩手机就想办法远离手机；反过来，想养成好习惯比如多喝水，就把水杯放在易接触的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2渴求让它有吸引力&#34;&gt;2、渴求：让它有吸引力&lt;/h2&gt;
&lt;p&gt;习惯是多巴胺驱动的反馈回路。每一种极可能形成习惯的行为——吃垃圾食品、玩电子游戏、浏览社交媒体——都与较高浓度的多巴胺有关。每当你预测一个机会会有回报时，你体内的多巴胺浓度就会随着这种预期飙升。当你获得奖励时，大脑中激活的奖励系统，与你期待奖励时激活的系统是同一个。这就是对一种体验的期待往往比体验本身，更令人感到愉悦的原因之一。&lt;/p&gt;
&lt;p&gt;这就引出了“喜好绑定”的原理：把你需要做的事与愿意做的事绑定。比如想培养健身的习惯，那么可以让自己在健身的时候同时看喜欢看的视频做为奖励。&lt;/p&gt;
&lt;h2 id=&#34;3反应让它简便易行&#34;&gt;3、反应：让它简便易行&lt;/h2&gt;
&lt;p&gt;《精益求精》一书里举过这样的例子：“日本公司强调为人所知的‘精益生产’理念，坚持不懈地努力寻求从生产流程中去除各种浪费，直至重新设计工作环境，使得工人们的身体不必转来转去，从而避免为拿工具而浪费时间。结果是日本工厂比美国工厂效率更高，产品更可靠。“&lt;/p&gt;
&lt;p&gt;作者将这样的策略称为”因减而加“：寻找生产线上的每一个阻力点，予以清除。这样减少了无用功，反过来就增加了效率。&lt;/p&gt;
&lt;p&gt;与之类似的，有”两分钟法则”：当你开始培养一种新习惯时，它所用时间不应超过两分钟。这样的策略也有另一个原因：它们强化着你想要建立的身份。如果你连续五天现身健身房，哪怕只在那里停留两分钟，你就是在为你的新身份投赞同票。&lt;/p&gt;
&lt;h2 id=&#34;4奖励让它令人愉悦&#34;&gt;4、奖励：让它令人愉悦&lt;/h2&gt;
&lt;p&gt;保持习惯的关键是要有成就感，哪怕只是细微的感受。成就感是一个信号，它表明你的习惯有了回报，你为此付出的努力是值得的。比如，把要做的事情列成一个todo列表，完成一件划掉一项，看到todo上的事情全部划掉就是一种“奖励”。&lt;/p&gt;
&lt;p&gt;取得进步令人满意，借助于视觉量度，如移动曲别针、发夹或弹珠，你能清晰地看到自己的进步。这样做的结果是，它们强化着你的行为，并为任何活动增加一些即时满足感。视觉量度有多种形式：食物日志、健身日志、打孔忠诚卡、软件下载进度条，甚至书籍中的页码等等。&lt;/p&gt;
&lt;h2 id=&#34;作者做的总结表格&#34;&gt;作者做的总结表格&lt;/h2&gt;
&lt;p&gt;作者将根据以上四个步骤如何养成好习惯以及戒除坏习惯的方法，总结在下面的表格里。&lt;/p&gt;
&lt;h3 id=&#34;怎样养成好习惯&#34;&gt;怎样养成好习惯&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/habit-table.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;养成好习惯&#34; align=center /&gt;
&lt;/div&gt;
&lt;h3 id=&#34;怎样戒除坏习惯&#34;&gt;怎样戒除坏习惯&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;
 &lt;img src=&#34;https://www.codedump.info/media/imgs/20220319-weekly-10/drop-habit-table.png&#34; width=&#34;400&#34; height=&#34;200&#34; alt=&#34;戒掉坏习惯&#34; align=center /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;我的实践&#34;&gt;我的实践&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为了减少睡觉前看手机，以及睡醒之后看手机的时间，我的做法是睡觉前把手机放在远离床头的地方。（避免坏习惯就让它难以被接触）。&lt;/li&gt;
&lt;li&gt;跑步时使用&lt;a href=&#34;https://github.com/yihong0618/running_page&#34;&gt;running_page&lt;/a&gt;这个项目来记录、展示我的跑步数据，一目了然也会带来更多的成就感。（奖励习惯）。&lt;/li&gt;
&lt;li&gt;年纪越大，越发现需要“坚持”去做的事情，很难做得长久。因为一提到需要“坚持”，很大原因是因为其中有阻碍、没有正反馈等等，这些都可以在上面四个步骤里找到答案。越不需要“坚持”就能做下去的事情，才越能长久做下去。所以，以后再遇到事情发现做不下去时，第一反应不应该再是什么意志力不够等原因，而是要从上面几个步骤里找到是哪里出了问题。是不够显而易见？不够有吸引力？不够简便？奖励不够？不够愉悦？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;有关sre和devops的两篇文章&#34;&gt;有关SRE和Devops的两篇文章&lt;/h2&gt;
&lt;p&gt;推荐&lt;a href=&#34;https://twitter.com/laixintao&#34;&gt;@laixintao&lt;/a&gt;有关SRE和Devops的两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kawabangga.com/posts/4145&#34;&gt;Devops 中的 Overfitting | 卡瓦邦噶！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kawabangga.com/posts/4481&#34;&gt;SRE 的工作介绍 | 卡瓦邦噶！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;flomo和刘少楠&#34;&gt;flomo和刘少楠&lt;/h2&gt;
&lt;p&gt;这周偶然在有知有行app里听到对刘少楠的采访：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/60b0dcd6e273a1e20b43dc1e&#34;&gt;E13 专访 flomo 少楠：宇宙希望我们成为普通的人，创造是我们反抗的手段 - 知行小酒馆&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;听下来感觉这个人真诚、有意思，于是又找来了几个另外的采访和文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/617f781f82dbcd91978df9da&#34;&gt;#92：一个产品人的妄念与懦弱（flomo 创始人刘少楠） - UX Coffee 设计咖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xueqiu.com/2684655177/196666266&#34;&gt;35 岁再创业，我学会了“认怂” &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xiaoyuzhoufm.com/episode/6227d4809d2fcf46aa36aea4&#34;&gt;E25｜flomo少楠：如果你没有观点，你就不值得被关注 - 组织进化论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.notion.so/pmthinking/ProductThinking-a601a12335044f349a22caf57f274c27&#34;&gt;产品沉思录（精选） ProductThinking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些听下来、看下来，对&lt;a href=&#34;https://flomoapp.com&#34;&gt;flomo&lt;/a&gt;产生了极大的兴趣，后面找一期专门聊聊我知识整理、输入的实践。&lt;/p&gt;
&lt;p&gt;这周flomo用了几天下来，初步感觉就是“个人可见的微博”，且有“标签”和“批注”功能建立碎片信息之间的联系。于是，随着在flomo上记录的东西变多，相应地，发微博、推特就会变少。&lt;/p&gt;
&lt;p&gt;这又来到以前听过的一个有意思的结论了：打败某个领域顶尖产品的，很可能并不是另一个同类产品。比如马化腾就说过：打败QQ的，可能并不会是另一个IM。&lt;/p&gt;
&lt;p&gt;消灭产品使用的场景，这个产品自然就死了，不一定非得是同类产品取而代之。&lt;/p&gt;
&lt;p&gt;所以产品为什么需要“进化”？就是为了适应不同的场景变化。比如在PC互联网时代取得统治地位的QQ，如果没有跟上移动互联网的变化，腾讯如果没有微信，可能现在也凉了。&lt;/p&gt;
&lt;h2 id=&#34;rust-语言备忘清单&#34;&gt;Rust 语言备忘清单&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中文版：&lt;a href=&#34;https://cheats.rs.kingfree.moe/&#34;&gt;Rust 语言备忘清单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文版：&lt;a href=&#34;https://cheats.rs/&#34;&gt;Rust Language Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第9期）：Mozilla rr使用简介</title>
      <link>https://www.codedump.info/post/20220313-weekly-9/</link>
      <pubDate>Sun, 13 Mar 2022 11:20:59 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220313-weekly-9/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：在之前的&lt;a href=&#34;https://www.codedump.info/post/20220227-weekly-7/&#34;&gt;周刊（第7期）：一个C系程序员的Rust初体验&lt;/a&gt;中，简单提到过Mozilla rr这款调试工具，由于这个工具并不是太为人所知，所以本文对该工具做一个简介。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mozilla-rr使用简介&#34;&gt;Mozilla rr使用简介&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://rr-project.org/&#34;&gt;rr&lt;/a&gt;是由Mozilla出品的一款调试工具，用官网的话来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rr aspires to be your primary C/C++ debugging tool for Linux, replacing — well, enhancing — gdb. You record a failure once, then debug the recording, deterministically, as many times as you want. The same execution is replayed every time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即它的特点是：可以记录下来程序运行时的上下文环境，包括线程、堆栈、寄存器等等，这样的好处有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“deterministically”：很多问题问题的产生，都与特定的环境相关，如：
&lt;ul&gt;
&lt;li&gt;线程调度执行的顺序，先执行A线程再B线程，以及反之，可能得到的是不同的结果。&lt;/li&gt;
&lt;li&gt;环境参数，如输入不同的参数，尤其一些边界条件的触发就跟输入不同的参数有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;replay：记录下来程序执行的环境之后，rr除了支持gdb方式的调试之后，还能利用环境来不停的重放程序，甚至反向来执行程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下对&lt;code&gt;rr&lt;/code&gt;的使用做一些简单的介绍。&lt;/p&gt;
&lt;h2 id=&#34;deterministically&#34;&gt;deterministically&lt;/h2&gt;
&lt;p&gt;以下面一个最简单的多线程程序来解释何为&lt;code&gt;deterministically&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;doPrint&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_create(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pid, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;, doPrint, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid = %lu&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, pid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序很简单：创建一个线程之后，打印线程的pid。&lt;/p&gt;
&lt;p&gt;如果多次执行，会发现每次打印出来的pid并不一样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ./a.out
pid = 140301410010880

$ ./a.out
pid = 139804250023680
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个原因自不必多说：每次程序执行的时候，执行环境是有变化的。&lt;/p&gt;
&lt;p&gt;这个简单的结论，对应到bug出现的场景上，有的代码可能正常的情况下没有异常，但是会出现在特定的场景下：特定的输入参数、特定的线程执行顺序，等等。换言之，问题并不是必现的，即&lt;code&gt;un-deterministically&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;的一大功能，就是要解决这个&lt;code&gt;deterministically&lt;/code&gt;问题，即在问题发现的时候，能有一个确定的环境，可以反复重现问题。&lt;/p&gt;
&lt;h2 id=&#34;record-and-replay&#34;&gt;record and replay&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;这个名字里的两个r，意指&lt;code&gt;record and replay&lt;/code&gt;，即“记录及回放”，它的使用也很简单，就是这两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;record：&lt;code&gt;rr record /your/application --args&lt;/code&gt; 记录下来程序的执行环境。&lt;/li&gt;
&lt;li&gt;replay：&lt;code&gt;rr replay&lt;/code&gt;，默认将使用最近保存的记录文件进行回放，回放时可以进入类似gdb那样的调试环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如前面那个多线程程序，使用&lt;code&gt;rr&lt;/code&gt;来记录及回放就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;record：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ rr record ./a.out
Freezing performance counters on SMIs should be turned on for maximum rr
reliability on Comet Lake and later CPUs. Consider putting
&amp;#39;w /sys/devices/cpu/freeze_on_smi - - - - 1&amp;#39; in /etc/tmpfiles.d/10-rr.conf
See &amp;#39;man 5 sysfs&amp;#39;, &amp;#39;man 5 tmpfiles.d&amp;#39; (systemd systems)
rr: Saving execution to trace directory `/home/codedump/.local/share/rr/a.out-0&amp;#39;.
pid = 139837942626048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到记录执行的时候，打印出来的&lt;code&gt;pid&lt;/code&gt;是&lt;code&gt;139837942626048&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;replay：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ rr replay

...省略不重要信息...

（进入replay之后第一次执行，是按`c`）

(rr) c
Continuing.
pid = 139837942626048

（前面已经执行完毕，想要第二次执行，按`r`（run））

(rr) r
[Inferior 1 (process 36022) exited normally]
Starting program: /home/codedump/.local/share/rr/a.out-0/mmap_hardlink_4_a.out

Program stopped.
0x00007f2e8f19c100 in ?? () from /lib64/ld-linux-x86-64.so.2
(rr) c
Continuing.
pid = 139837942626048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，前后两次重放执行，打印的&lt;code&gt;pid&lt;/code&gt;都是之前记录的值&lt;code&gt;139837942626048&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就意味着：record下来的程序执行环境，后面可以不停的回放。因为重现问题的场景很重要，有时候还不好复现，那么类似&lt;code&gt;rr&lt;/code&gt;这样能记录下来执行环境并且重放的能力，对于查找问题就特别重要了。&lt;/p&gt;
&lt;h2 id=&#34;高级用法&#34;&gt;高级用法&lt;/h2&gt;
&lt;p&gt;前面提到过，使用&lt;code&gt;rr replay&lt;/code&gt;来重放记录时，实际会进入类似gdb那样的一个调试环境，在这个环境里，常用的gdb命令都可以使用，所以这些不会展开讨论，只说一下&lt;code&gt;rr&lt;/code&gt;在这里具备的一些其他更高级的调试能力。&lt;/p&gt;
&lt;h3 id=&#34;事件&#34;&gt;事件&lt;/h3&gt;
&lt;p&gt;为了能够更加精准的跟进某个问题，&lt;code&gt;rr&lt;/code&gt;提供了事件（event）的概念，每个事件有与之相关的两个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程pid。&lt;/li&gt;
&lt;li&gt;事件编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;在replay的时候，可以带上&lt;code&gt;-M&lt;/code&gt;参数打印出来事件编号，比如前面的实例程序改成这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;doPrint&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;arg) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;((&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;)arg);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;in thread %d&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;i) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_t pid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pthread_create(&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;pid, &lt;span style=&#34;color:#a2f&#34;&gt;NULL&lt;/span&gt;, doPrint, &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;pid = %lu&lt;/span&gt;&lt;span style=&#34;color:#b62;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&lt;/span&gt;, pid);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里创建了10个线程，线程中分别打印循环变量，如果使用&lt;code&gt;-M&lt;/code&gt;在输出时就能看到如下的信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(rr) c
Continuing.
[rr 4450 288]pid = 140096584951552
[rr 4450 305]in thread 1
[rr 4450 313]pid = 140096574461696
[rr 4450 330]in thread 2
[rr 4450 337]pid = 140096563971840
[rr 4450 354]in thread 3
[rr 4450 361]pid = 140096555579136
[rr 4450 378]in thread 4
[rr 4450 385]pid = 140096547186432
[rr 4450 402]in thread 5
[rr 4450 409]pid = 140096538793728
[rr 4450 426]in thread 6
[rr 4450 433]pid = 140096530401024
[rr 4450 450]in thread 7
[rr 4450 457]pid = 140096522008320
[rr 4450 474]in thread 8
[rr 4450 481]pid = 140096513615616
[rr 4450 498]in thread 9
[rr 4450 505]pid = 140096505222912
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最左边显示事件的格式为&lt;code&gt;[rr pid 事件id]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;知道了事件对应的&lt;code&gt;(pid,事件id)&lt;/code&gt;二元组之后，在replay的时候，可以指定这两个值，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rr -M replay -g 事件id
或者
rr -M replay -p pid
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;让程序replay的时候迅速到达指定事件发生的场景下。比如上面的例子中，如果使用&lt;code&gt;rr -M replay -g 354&lt;/code&gt;就能马上重放到&lt;code&gt;[rr 4450 354]in thread 3&lt;/code&gt;这一处。&lt;/p&gt;
&lt;p&gt;这种基于事件的调试方式，调试那种代码相同，但是由于输入参数不同导致的问题时，特别管用，因为可以直达问题发生的环境。&lt;/p&gt;
&lt;h3 id=&#34;反向执行reverse-execution&#34;&gt;反向执行（Reverse execution）&lt;/h3&gt;
&lt;p&gt;有了记录的能力之后，&lt;code&gt;rr&lt;/code&gt;除了能正向执行程序，还能反向来执行程序，这点在那种看到程序的环境发生了变化，但是不知道怎么发生，想重试一下的情况下特别管用。&lt;/p&gt;
&lt;p&gt;单向调试执行程序时，用的是&lt;code&gt;step&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;等命令，反向执行就在这些命令前面加上&lt;code&gt;reverse-&lt;/code&gt;前缀，如&lt;code&gt;reverse-cont&lt;/code&gt;（后面的可以简写）。&lt;/p&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;p&gt;前面介绍了&lt;code&gt;rr&lt;/code&gt;要解决的问题，最后聊一下它的缺陷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rr&lt;/code&gt;最开始是由Mozilla开发的工具，看来Mozilla对这类运行时问题也是深恶痛绝，发明了很多工具试图提高效率，Rust是另外一个重要的工具，可以参见之前&lt;a href=&#34;https://www.codedump.info/post/20220227-weekly-7/&#34;&gt;周刊（第7期）：一个C系程序员的Rust初体验&lt;/a&gt;中我对Rust的使用体验。&lt;/li&gt;
&lt;li&gt;很可惜，这个工具貌似只能在Linux上面运行，并没有Win\Mac版本，而且貌似也不怎么更新了。&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;rr&lt;/code&gt;在记录时，需要记录大量的数据来保存程序运行时的场景，这样一来会给程序带来卡顿，二来会有大量的记录数据，所以并不适合直接在生产环境上使用这个工具。更适合的场景是：已经找到了重现问题的办法，此时可以搭建一个环境开启&lt;code&gt;rr&lt;/code&gt;记录下来重现时的环境，即并不适合漫无目的的就打开这个工具使用。&lt;/li&gt;
&lt;li&gt;以上&lt;code&gt;rr&lt;/code&gt;的缺陷，归根到底还是之前提到的：查找运行时的问题太难了，尽量在编译时屏蔽可能出现的问题，真等问题到了运行时再解决的时候，时间、精力、场景复现等等都是不可控的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;番外篇&#34;&gt;番外篇&lt;/h1&gt;
&lt;h2 id=&#34;rr使用的wiki&#34;&gt;rr使用的wiki&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;的github上，有一篇更为详细一些的介绍使用的&lt;a href=&#34;https://github.com/rr-debugger/rr/wiki/Usage&#34;&gt;Usage · rr-debugger/rr Wiki&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;rr视频教程&#34;&gt;rr视频教程&lt;/h2&gt;
&lt;p&gt;油管上有几个视频教程，见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=hYsLBcTX00I&#34;&gt;Quick rr Demo - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=61kD3x4Pu8I&#34;&gt;rr 1.2 basic demo - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=H4iNuufAe_8&#34;&gt;Robert O&amp;rsquo;Callahan - Corporation Taming Nondeterminism - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其它文档&#34;&gt;其它文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;介绍了&lt;code&gt;rr&lt;/code&gt;是如何实现的：&lt;a href=&#34;https://arxiv.org/pdf/1705.05937.pdf&#34;&gt;Engineering Record And Replay For Deployability Extended Technical Report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gdb相关文档&#34;&gt;GDB相关文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html&#34;&gt;介绍 | 100个gdb小技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/rkubik/b96c23bd8ed58333de37f2b8cd052c30&#34;&gt;GDB cheat sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000022499197&#34;&gt;gdb深入学习手册 - SegmentFault 思否&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;如何在开源项目中做重构&#34;&gt;《如何在开源项目中做重构？》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/JrxNyDKNg9MseQZ7PlG2VQ&#34;&gt;《如何在开源项目中做重构？》&lt;/a&gt;，总结了维护一个开源项目重构的经验。&lt;/p&gt;
&lt;h2 id=&#34;linux-containers-in-500-lines-of-code&#34;&gt;《Linux containers in 500 lines of code》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.lizzie.io/linux-containers-in-500-loc.html&#34;&gt;Linux containers in 500 lines of code&lt;/a&gt;，讲解Linux容器原理的文章。&lt;/p&gt;
&lt;h2 id=&#34;收集整理远程工作相关的资料&#34;&gt;收集整理远程工作相关的资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greatghoul/remote-working&#34;&gt;greatghoul/remote-working: 收集整理远程工作相关的资料&lt;/a&gt;，但是貌似已经不更新了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第8期）：技术配图的一些心得</title>
      <link>https://www.codedump.info/post/20220304-weekly-8/</link>
      <pubDate>Fri, 04 Mar 2022 22:10:11 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220304-weekly-8/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：写过不少技术文章，以及给不少技术思路手绘示例配图之后，在这方面有了一些心得，本文权当个人的一些的总结，抛砖引玉。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;技术配图的一些心得&#34;&gt;技术配图的一些心得&lt;/h1&gt;
&lt;p&gt;我觉得我们理工科出身的，对于可以量化的事情，总是很容易根据量化差异来做出判断，比如一个程序性能优化之后，能比优化之前快出多少，都能有一个量化的数字来说明。&lt;/p&gt;
&lt;p&gt;但是对于那些不能量化的东西，就很难说出具体好在哪里了。&lt;/p&gt;
&lt;p&gt;本文主题要讨论的“技术配图”就属于这种很难量化的领域，很难有一个标准来量化说明两幅图之间差别在哪里。我也是画了很多图，以及看了别人的很多配图之后，才慢慢有一些心得，本文权当个人的一些的总结，抛砖引玉。&lt;/p&gt;
&lt;p&gt;本文并不是一个画图工具的对比说明，尽管现在各种绘图工具已经很多，也各有自己的优缺点以及个人喜好，但是在这里并不讨论具体工具的使用，会把更多的文字放在配图的一些注意事项上。但是，也总有人问我文章的配图使用什么工具做的，在这里再回答一次：&lt;a href=&#34;https://www.omnigroup.com/omnigraffle&#34;&gt;OmniGraffle&lt;/a&gt;，一款目前仅有Mac版本的工具软件。&lt;/p&gt;
&lt;h2 id=&#34;一图胜千言&#34;&gt;一图胜千言&lt;/h2&gt;
&lt;p&gt;在开始交代具体的配图注意事项之前，有必要先说说配图的重要性。&lt;/p&gt;
&lt;p&gt;绘图，某种程度也是辅助自己思考某个技术点的手段之一，以我个人的体会来说，有时候讲不清楚一个技术点的时候，就手绘图出来，比朴素的文字更容易说明问题。其中的原因，有可能是：图片可以有多维的信息，而文字通常只有一维，遇到文字表达能力不太好的人，这仅有的一维能力可能还不好发挥出来。&lt;/p&gt;
&lt;p&gt;所以，在交代技术细节、沟通交流的时候，尽量多画图。反向的，图画多了，也自然慢慢会找到感觉，如何更好的通过图示表达思路。&lt;/p&gt;
&lt;p&gt;顺便一提，还有比朴素的文字表达更差的技术沟通方式，就是简单粗暴的贴一大段代码上去。这种做法，其实更多时候是没有对作者的思路有太多个人的整理，想偷懒的方式，最后回头再看写过的文字，可能连自己都看不懂了。&lt;/p&gt;
&lt;p&gt;个人的一个体会：如果产出某些输出的时候，能假设自己未来就是这些输出的读者、维护者，那么输出起来会更“友善”一些。比如写的代码、文章、甚至于提交代码时候的信息，如果能考虑是写给未来的自己看的，会更清晰、尽可能留下更多的信息。我最开始要在文章里大量配图，也是为了将来自己回看的时候能看懂。&lt;/p&gt;
&lt;p&gt;扯远了，总之，尽可能多画图来表达技术思路。&lt;/p&gt;
&lt;p&gt;下面开始正题，以下会以简单的几个原则及示例来说明。&lt;/p&gt;
&lt;h2 id=&#34;区分联系组合&#34;&gt;区分、联系、组合&lt;/h2&gt;
&lt;p&gt;配图中，应该尽量将不同的模块、组件等区分开来，“区分”的方式有很多，常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用不同的颜色。&lt;/li&gt;
&lt;li&gt;使用不同的形状。&lt;/li&gt;
&lt;li&gt;使用箭头、曲线等表示数据的走向、趋势。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，所有的这些手段，概括起来就是尽量在图中，将不同的元素区分开来，“有区分”意味着至少有一个维度的不同，这样能给读者更加清晰的感觉。可以结合下面的例子来理解区分、联系和组合的绘图表达。&lt;/p&gt;
&lt;h2 id=&#34;分组&#34;&gt;分组&lt;/h2&gt;
&lt;p&gt;一个模块里，可能由多个组件构成，可以把这些组件分组到一个更大的模块中。&lt;/p&gt;
&lt;p&gt;分组是非常常见的一种手段，这里多举几个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/cpu.jpeg&#34; alt=&#34;cpu&#34; title=&#34;cpu&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图中，每个CPU Core中有L1、L2缓存，于是把这些组件合并在一起放在Core组件中，周围使用一个正方形包裹起来，同时这个正方形左上角有一个&lt;code&gt;Core&lt;/code&gt;的说明文字，这样一目了然：Core模块，由L1、L2缓存构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/raft-log.png&#34; alt=&#34;meituan&#34; title=&#34;meituan&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图出自Raft论文，整体上划分为了Client、Server这两大部分。而每个Server又有以下三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性算法模块。&lt;/li&gt;
&lt;li&gt;状态机。&lt;/li&gt;
&lt;li&gt;持久化的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，图示中将这三部分合在一起放在同一个矩形里，表示一个Server有这三个组件。&lt;/p&gt;
&lt;p&gt;另外还需注意的是，一般这种分组中外围的矩形，有这样的讲究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般使用斜面矩形，即四个角是圆角的矩形，这样圆润一些的边角看起来会更舒服一些，如上图。&lt;/li&gt;
&lt;li&gt;如果这个组合，是一种逻辑上的组合，那么线的形状一般用虚线；否则就一般用的实线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在分组时，有时候可以将相同类型的模块层叠起来，这样会更加简洁，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/raft.png&#34; alt=&#34;raft&#34; title=&#34;raft&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是出自Raft论文中的状态机模型，其中想要表达的一个点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有多个client向server发起请求。&lt;/li&gt;
&lt;li&gt;server要达成一致，需要将日志在server之间同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是上图中，并没有把这些同类型的组件分开表达，而是巧妙的使用层叠的方式，简洁得表达了有多个client、多个server的情况。&lt;/p&gt;
&lt;h2 id=&#34;趋势&#34;&gt;趋势&lt;/h2&gt;
&lt;p&gt;如果不同的组件之间，有不同的趋势，可以在图中使用类似箭头这样的符号表达出来。&lt;/p&gt;
&lt;p&gt;下图是描述不同层次存储的访问速度，于是用了两个方式来表达访问速度的变化趋势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边的箭头表达速度和成本的变化。&lt;/li&gt;
&lt;li&gt;不同大小的多边形表达了这些存储空间的变化：越往上访问速度越快，但是对应的存储空间也更小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/cache.png&#34; alt=&#34;cache&#34; title=&#34;cache&#34;&gt;&lt;/p&gt;
&lt;p&gt;再比如，下图中，是说明sqlite中btree页面的数据组织的。其中的两部分内容，&lt;code&gt;Cell地址数组&lt;/code&gt;以及&lt;code&gt;Cell内容区&lt;/code&gt;为变长大小，前者从地址低位向高位生长，后者反之，于是在图中，就用箭头示例出地址的高低位区别，以及两者的增长方向：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/page-format.png&#34; alt=&#34;页面内数组的组织&#34; title=&#34;页面内数组的组织&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;联系&#34;&gt;联系&lt;/h2&gt;
&lt;p&gt;用箭头等表示数据、状态等的走向，或者模块之间的联系。&lt;/p&gt;
&lt;p&gt;这在涉及：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态切换。&lt;/li&gt;
&lt;li&gt;数据流向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等场景下是非常常见的手段，比如经典的TCP状态机切换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png&#34; alt=&#34;TCP状态机&#34; title=&#34;TCP状态机&#34;&gt;&lt;/p&gt;
&lt;p&gt;以及TCP三次握手流程，也是典型的“状态切换”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&#34; alt=&#34;TCP三次握手&#34; title=&#34;TCP三次握手&#34;&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是，以上的图示中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;箭头代表的状态切换走向中，同时也配以文字说明是什么动作导致的状态切换，这样这个图示就更清晰了。&lt;/li&gt;
&lt;li&gt;箭头也分为实线和虚线，一般而言，虚线表示数据的走向，实线表示状态的走向。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;禁止&#34;&gt;禁止&lt;/h2&gt;
&lt;p&gt;需要禁止或者错误的行为，可以用特殊的符号，如带颜色的“×”符号示意出来；反之，可以用带颜色的“√”符号示意出来，而且表示禁止的时候，一般用红色会更显眼，下图就是一个示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220304-weekly-8/memory-barriers-in-dot-net-5.png&#34; alt=&#34;meituan&#34; title=&#34;meituan&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自 &lt;a href=&#34;https://afana.me/archive/2015/07/10/memory-barriers-in-dot-net.aspx/&#34;&gt;Memory Barriers in .NET · Nadeem Afana&amp;rsquo;s Blog&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;如果不好说明问题，可以在图示中搭配简短的说明文字。注意：这类型文字一定要足够的简短，否则可能会喧宾夺主。&lt;/p&gt;
&lt;p&gt;比如下图中，有两部分蓝色注解的文字来说明不同的表类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/btree-rowid.png&#34; alt=&#34;数据库文件的rowid全量数据表和索引表&#34; title=&#34;数据库文件的rowid全量数据表和索引表&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;再比如下图中，使用注解文字来说明查找数据的两步流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/find-key.png&#34; alt=&#34;查找key的流程&#34; title=&#34;查找key的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;有时候需要使用类似&lt;code&gt;{&lt;/code&gt;这样的符号，对一类元素做一些说明，例如：&lt;/p&gt;
&lt;p&gt;下图中，是说明sqlite中btree页面的数据组织的，最右边的以&lt;code&gt;{&lt;/code&gt;包起来的文字，对每部分做了简要的说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/page-format.png&#34; alt=&#34;页面内数组的组织&#34; title=&#34;页面内数组的组织&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;下图中，将页面划分为不同的部分，这些不同的组成部分，既使用了颜色进行区分，也使用了向下的&lt;code&gt;{&lt;/code&gt;辅以文字说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220201-sqlite-btree-5-btree/freelist.png&#34; alt=&#34;空闲区链表&#34; title=&#34;空闲区链表&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220201-sqlite-btree-5-btree/&#34;&gt;sqlite3.36版本 btree实现（五）- Btree的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;
&lt;p&gt;如果配图是需要讲解某个操作的步骤的，可以配以数字来辅助理解整个流程。&lt;/p&gt;
&lt;p&gt;下图中，表达的是根据帧数查找页面编号的两个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/frame-pageno.png&#34; alt=&#34;添加帧数与页面编号对应关系的流程&#34; title=&#34;添加帧数与页面编号对应关系的流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;下图中的步骤就更多了，并没有显得很乱，大概原因在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最左边表达了每一步的步骤。&lt;/li&gt;
&lt;li&gt;每一步写入数据之后，显示WAL文件在写入之后的内容。&lt;/li&gt;
&lt;li&gt;最右边使用&lt;code&gt;{&lt;/code&gt;表达修改之后的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/write-wal.png&#34; alt=&#34;写事务修改WAL文件和WAL索引数据&#34; title=&#34;写事务修改WAL文件和WAL索引数据&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;展开&#34;&gt;展开&lt;/h2&gt;
&lt;p&gt;在讲解例如文件格式，或者协议格式等内容的时候，格式由多个部分划分组成，其中又可以针对其中的某些内容展开说明。&lt;/p&gt;
&lt;p&gt;如下图中，是用于展示wal index索引文件格式的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左边示例每部分内容的大小，想说明的是，那个索引块大小为32KB，而第一块的头136字节为索引文件头。&lt;/li&gt;
&lt;li&gt;于是，在右边图中，将左边不同模块的具体格式继续展开说明。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.codedump.info/media/imgs/20220106-sqlite-btree-4-wal/wal-index-format.png&#34; alt=&#34;WAL-Index索引文件结构图&#34; title=&#34;WAL-Index索引文件结构图&#34;&gt;&lt;/p&gt;
&lt;p&gt;（出自&lt;a href=&#34;https://www.codedump.info/post/20220106-sqlite-btree-4-wal/&#34;&gt;sqlite3.36版本 btree实现（四）- WAL的实现 - codedump的网络日志&lt;/a&gt;）&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;以上简单总结了一下个人技术配图的一些心得，总的大原则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分：将组件、流程、趋势等之间的”区分“尽可能在图示中通过各种手段（如不同的颜色、形状、箭头）表达出来。&lt;/li&gt;
&lt;li&gt;联系：组件之间的数据流动、状态切换等，都是它们之间的联系，也需要通过各种手段表达出来。&lt;/li&gt;
&lt;li&gt;说明：可能的话，要在图中加上一些说明文字，如步骤说明、分类说明，等等。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>周刊（第7期）：一个C系程序员的Rust初体验</title>
      <link>https://www.codedump.info/post/20220227-weekly-7/</link>
      <pubDate>Sun, 27 Feb 2022 11:25:33 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20220227-weekly-7/</guid>
      
      <description>&lt;hr&gt;
&lt;p&gt;引言：在工作里使用Rust已经有两个多月的时间了，谈谈我做为一名多年的C系（C、C++）程序员，对Rust的初体验。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;一个c系程序员的rust初体验&#34;&gt;一个C系程序员的Rust初体验&lt;/h1&gt;
&lt;p&gt;最近由于工作的原因，使用上了Rust语言，在此之前我有多年的C、C++编码经验（以下将C、C++简称C系语言）。&lt;/p&gt;
&lt;p&gt;使用C系语言编码时，最经常面对的问题就是内存问题，诸如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;野指针（Wild Pointer）：使用了不可知的指针变量，如已经被释放、未初始化、随机，等等。&lt;/li&gt;
&lt;li&gt;内存地址由于访问越界等原因被覆盖（overflow），这不但是可能出错的问题，还有可能成为程序的内存漏洞被利用。&lt;/li&gt;
&lt;li&gt;内存分配后未回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连Chrome的报告都指出，Chrome中大约70%的安全漏洞都是内存问题，见：&lt;a href=&#34;https://www.chromium.org/Home/chromium-security/memory-safety/&#34;&gt;Memory safety&lt;/a&gt;。（不仅如此，微软的文章也显示在微软的产品中70%的安全漏洞也是内存问题，见：&lt;a href=&#34;https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/&#34;&gt;Microsoft: 70 percent of all security bugs are memory safety issues | ZDNet&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;C系语言发展到今天，已经有不少可以用于内存问题检测的利器了，其中最好用的莫过于&lt;a href=&#34;https://en.wikipedia.org/wiki/AddressSanitizer&#34;&gt;AddressSanitizer&lt;/a&gt;，它的原理是在编译时给程序加上一些信息，一旦发生内存越界访问、野指针等错误都会自动检测出来。&lt;/p&gt;
&lt;p&gt;但是即便有这些工具，内存问题也不好解决，其核心的原因在于：这些问题绝大部分都是运行时（Runtime）问题，即要在程序跑到特定场景的时候才会暴露出来，诸如上面提到的AddressSanitizer就是这样。&lt;/p&gt;
&lt;p&gt;都知道解决问题的第一步是能复现问题，而如果一个问题是运行时问题，这就意味着：复现问题可能会是一件很麻烦的事情，有时候还可能到生产环境去复现。&lt;/p&gt;
&lt;p&gt;以我之前经历的一个Bug来看这类工作的复杂度，见&lt;a href=&#34;https://www.codedump.info/post/20190413-problem-fix/&#34;&gt;线上存储服务崩溃问题分析记录 - codedump的网络日志&lt;/a&gt;，这是一个很典型的发生在生产环境上由于内存错误导致的崩溃问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不好复现，因为跟特定的请求相关，还跟线程的调度有关；&lt;/li&gt;
&lt;li&gt;本质是由于使用了被释放的内存导致的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个线上问题，记得当时花了一周时间来复现问题解决。&lt;/p&gt;
&lt;p&gt;换言之，如果一个问题要等到运行时才能发现，那么可以预见的是：一旦出现问题，要复现问题可能要花费大量的精力，以及需要很多经验才行。如果一个问题还是在特定场景，或者用户现场才出现的，那就更麻烦了，C系程序员以往一般都是这样来保存“现场”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出现崩溃的时候保存core文件来查看调用堆栈、变量等信息。&lt;/li&gt;
&lt;li&gt;发明了各种复制流量重放的工具，比如&lt;a href=&#34;https://github.com/session-replay-tools/tcpcopy&#34;&gt;tcpcopy&lt;/a&gt;等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，运行时问题一旦出现是很麻烦的，而解决这类问题的时间是难以预期的。&lt;/p&gt;
&lt;p&gt;Rust给这类内存问题的解决提供了另一个解决思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个内存地址同时只能被一个变量使用。&lt;/li&gt;
&lt;li&gt;不能使用未初始化的变量。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简而言之，凡是可能出现内存错误的地方，都在语言的语法层面给予禁止，换来的就是更多的编译时间，因为要做这么多检查嘛，而需要更多的编译时间反过来就需要更好的硬件。我想这也是Rust到了最近几年才开始慢慢流行开来的原因之一，毕竟即便是现在，一些大型的Rust项目普通的机器编译起来也还是很耗时。&lt;/p&gt;
&lt;p&gt;“编译时间（compile time）”是一个可以预期的固定时间，能通过增加硬件性能（比如买更好的机器来写Rust）来解决；而“运行时问题”一旦出现，查找起来的时间、精力、场景（比如出现在用户现场、几百万次才能重现一次等）不确定性可就很高了。&lt;/p&gt;
&lt;p&gt;两者权衡，我选择解决“编译时间”问题。而且，在我意识到有这样的工具能够在编译期解决大部分内存问题时，反过来再看使用C系语言的项目，几乎可以预期的是：只要代码和复杂度上了一定规模，那么这类项目都要花上相当的一段时间才能稳定下来。原因在于：类似内存问题这样的运行时问题，是需要场景去积累，才能暴露出来的，而场景的积累，就需要很多的小白鼠和运行时间了。&lt;/p&gt;
&lt;p&gt;总结一下我的观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C系语言最多的问题就是各类内存问题，而这些问题大多是运行时问题。即便现在已经有了各种工具，解决其运行时问题也很困难。&lt;/li&gt;
&lt;li&gt;Rust解决这类问题的思路，是在语法层面禁止一切可能出现内存问题的操作，换来的代价就是更多的编译时间。&lt;/li&gt;
&lt;li&gt;解决可预期的“编译时间”和难预期的“运行时问题”，我选择前者。人生苦短，浪费时间在解决运行时的各种内存问题太不值当了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;番外篇&#34;&gt;番外篇&lt;/h1&gt;
&lt;h2 id=&#34;rr&#34;&gt;rr&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://rr-project.org/&#34;&gt;rr: lightweight recording &amp;amp; deterministic debugging&lt;/a&gt;也是出自Mozilla的另一款调试C系程序的利器，&lt;code&gt;rr&lt;/code&gt;是&lt;code&gt;Record and Replay&lt;/code&gt;的简称，目的还是为了解决各种运行时问题，由于运行时问题中存在着各种不确定的因素，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量值。&lt;/li&gt;
&lt;li&gt;进程、线程环境，比如不同的线程调度顺序可能导致了不同的结果。&lt;/li&gt;
&lt;li&gt;输入不同的数据，能得到不同的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，&lt;code&gt;rr&lt;/code&gt;要解决的核心问题，就是让一个程序在运行时有一个固定的环境，它可以抓取程序运行的环境保存下来。这样在出现问题之后，就能使用它可以记录下来程序运行时的环境，不停的重放来调试解决问题。&lt;/p&gt;
&lt;p&gt;但是，即便是这样，&lt;code&gt;rr&lt;/code&gt;可能更适合于明确知道问题的情况下去抓取环境，不可能在线上直接打开这个工具。所以又回到前面的结论了：调试运行时问题可能面对的困难，包括场景、时间、用户现场等等不确定因素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rr&lt;/code&gt;和&lt;code&gt;Rust&lt;/code&gt;一样，都出自Mozilla，我想不是偶然的。Mozilla和chrome等一样，都是使用C++编码的超大型项目，而这里一定遇到了各种运行时问题，不止于内存问题，所以才要使用各种工具来辅助解决这类问题。&lt;/p&gt;
&lt;h2 id=&#34;吃上硬件升级的红利了吗&#34;&gt;吃上硬件升级的红利了吗？&lt;/h2&gt;
&lt;p&gt;前面提到过，Rust目前较大的问题是编译时间过长，这可能是导致它最近几年才开始逐渐流行开来的原因。其实反过来说，在硬件升级之后，应该能尽量利用上硬件，在编译期尽量多检查出错误来，减少运行时发现问题的数量。这样，才能吃上硬件升级的红利，利用硬件来减少自己的犯错。&lt;/p&gt;
&lt;p&gt;一方面硬件升级给了编程语言能施展更大、更快的的“舞台”，随着舞台的更新，就会有更新、更好的工具出现；另一方面做为从业者，也应该与时俱进，多学习跟进这些工具的演进。&lt;/p&gt;
&lt;p&gt;我看到有一些人，强调自己多早就已经用C语言写代码了，但是查内存问题还在用慢的不行的&lt;code&gt;Valgrind&lt;/code&gt;，没听过更不知道怎么用&lt;code&gt;Address Sanitizer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;想说如果技能点都已经不更新了，强调多早学的有什么意义？好比1950年就会打算盘，有意义吗？强调多早就用C语言类似的言论，在我看来就是“倚老卖老”，但是技术日新月异的领域，卖老的意义不大。&lt;/p&gt;
&lt;h1 id=&#34;推荐&#34;&gt;推荐&lt;/h1&gt;
&lt;h2 id=&#34;rust-for-rustaceans&#34;&gt;《Rust for Rustaceans》&lt;/h2&gt;
&lt;p&gt;推荐&lt;a href=&#34;https://rust-for-rustaceans.com/&#34;&gt;Rust for Rustaceans&lt;/a&gt;作者Jon Gjengset的油管频道：https://www.youtube.com/c/JonGjengset/playlists&lt;/p&gt;
&lt;p&gt;有很多很有深度的Rust分享，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=bzja9fQWzdA&amp;amp;list=PLqbS7AVVErFivDY3iKAQk3_VAm8SXwt1X&#34;&gt;Implementing TCP in Rust (part 1) - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=yQFWmGaFBjk&amp;amp;list=PLqbS7AVVErFj824-6QgnK_Za1187rNfnl&#34;&gt;Porting Java&amp;rsquo;s ConcurrentHashMap to Rust (part 1) - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍rust缘起的文章&#34;&gt;介绍Rust缘起的文章&lt;/h2&gt;
&lt;p&gt;Infoq上的&lt;a href=&#34;https://www.infoq.cn/article/Uugi_eIJusEka1aSPmQM&#34;&gt;《想要改变世界的Rust语言》&lt;/a&gt;，是一篇介绍了Rust语言的缘起和设计目标好文章，对于了解Rust的历史、设计哲学等都有帮助。其中谈到的Rust三大设计哲学中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内存安全&lt;/li&gt;
&lt;li&gt;零成本抽象&lt;/li&gt;
&lt;li&gt;实用性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;就把“内存安全”放在了第一位，可见尽量解决运行时的内存问题都是大家很关心的问题。&lt;/p&gt;
&lt;h2 id=&#34;查询rust文档的浏览器插件&#34;&gt;查询Rust文档的浏览器插件&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://rust.extension.sh/&#34;&gt;Rust Search Extension - The ultimate search extension for Rust&lt;/a&gt;，是一个方便在浏览器中快速查询Rust文档的插件，提供了各种浏览器的支持。&lt;/p&gt;
&lt;h1 id=&#34;其他推荐&#34;&gt;其他推荐&lt;/h1&gt;
&lt;h2 id=&#34;神鞭&#34;&gt;《神鞭》&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://movie.douban.com/subject/1464595/&#34;&gt;神鞭&lt;/a&gt;是一部上世纪80年代的老电影，印象里小时候在露天电影院看过，故事的梗概大概是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;故事发生在清朝末年，主角是一个会使辫子神功的人，耍起辫子来能像鞭子一样抽打对手。后来八国联军入侵，加入了义和团，结果可想而知。再后来重新出现在江湖上时，不再是当年那个会耍辫子的高手，而是变成了一个神枪手了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面主角的有一句台词“辫子没了，神还在”，至今印象深刻，我对这句话的解读是：使用的工具，也应该与时俱进的进化，这个观点放在今天这篇对比C系和Rust的文章里，我认为是合适的。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
