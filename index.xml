<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codedump的网络日志</title>
    <link>https://www.codedump.info/</link>
    <description>Recent content on codedump的网络日志</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 01 Jul 2021 14:00:22 +0800</lastBuildDate>
    
	<atom:link href="https://www.codedump.info/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>博客系列文章索引</title>
      <link>https://www.codedump.info/post/20200122-series-pages/</link>
      <pubDate>Wed, 22 Jan 2020 14:36:00 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200122-series-pages/</guid>
      <description>在博客已经写了很多文章了，有一些文章独立成体，有一些则是系列文章来讲述一个主题，在这里将这些系列文章整理下来，本页面将不定期更新。 Linux</description>
    </item>
    
    <item>
      <title>Memcached的存储原理解析</title>
      <link>https://www.codedump.info/post/20210701-memcached/</link>
      <pubDate>Thu, 01 Jul 2021 14:00:22 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210701-memcached/</guid>
      <description>概述 最近工作上的需要，需要做一个LRU形式管理内存的分配器，首先想到的就是Memcached这个项目。早些年粗略的看过一些，有个大体的了解，</description>
    </item>
    
    <item>
      <title>Etcd Raft库的日志存储</title>
      <link>https://www.codedump.info/post/20210628-etcd-wal/</link>
      <pubDate>Mon, 28 Jun 2021 17:01:53 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210628-etcd-wal/</guid>
      <description>概述 之前看etcd raft实现的时候，由于wal以及日志的落盘存储部分，没有放在raft模块中，对这部分没有扣的特别细致。而且，以前我的观点</description>
    </item>
    
    <item>
      <title>Etcd Raft库的工程化实现</title>
      <link>https://www.codedump.info/post/20210515-raft/</link>
      <pubDate>Sat, 15 May 2021 13:52:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210515-raft/</guid>
      <description>最近回顾前几年写的Raft、etcd raft的实现文章，以及重新阅读Raft论文、etcd raft代码，发现之前有些理解不够准确、深刻，但是</description>
    </item>
    
    <item>
      <title>How to Read Code(En Version)</title>
      <link>https://www.codedump.info/post/20210215-how-to-read-code-en/</link>
      <pubDate>Mon, 15 Feb 2021 09:46:47 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20210215-how-to-read-code-en/</guid>
      <description>I wrote a document in 2019 &amp;ldquo;How to read a source code?&amp;rdquo;, and now looking back, there is room for improvement in this document,so I have reorganized it on top of that.
 The ability to read source code is considered to be one of the underlying fundamental programmer skills, and the reason why this ability is important is that
 inevitably need to read or take over other people&amp;rsquo;s projects.</description>
    </item>
    
    <item>
      <title>KCP 1.4源码分析</title>
      <link>https://www.codedump.info/post/20201105-kcp/</link>
      <pubDate>Thu, 05 Nov 2020 22:08:40 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20201105-kcp/</guid>
      <description>概述 KCP是基于UDP协议之上的ARQ协议实现。TCP虽然使用的更广泛，但是在某些实时性要求更高的领域（如实时音视频、即时在线游戏等），会更</description>
    </item>
    
    <item>
      <title>boltdb 1.3.0实现分析（四）</title>
      <link>https://www.codedump.info/post/20200726-boltdb-4/</link>
      <pubDate>Sun, 26 Jul 2020 17:55:11 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200726-boltdb-4/</guid>
      <description>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结</description>
    </item>
    
    <item>
      <title>boltdb 1.3.0实现分析（三）</title>
      <link>https://www.codedump.info/post/20200725-boltdb-3/</link>
      <pubDate>Sat, 25 Jul 2020 11:26:33 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200725-boltdb-3/</guid>
      <description>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结</description>
    </item>
    
    <item>
      <title>boltdb 1.3.0实现分析（二）</title>
      <link>https://www.codedump.info/post/20200711-boltdb-2/</link>
      <pubDate>Sat, 11 Jul 2020 09:33:06 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200711-boltdb-2/</guid>
      <description>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结</description>
    </item>
    
    <item>
      <title>boltdb 1.3.0实现分析（一）</title>
      <link>https://www.codedump.info/post/20200625-boltdb-1/</link>
      <pubDate>Thu, 25 Jun 2020 21:43:17 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200625-boltdb-1/</guid>
      <description>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之Linux系统平均负载</title>
      <link>https://www.codedump.info/post/20200620-sgfap-loadavg/</link>
      <pubDate>Sat, 20 Jun 2020 12:19:08 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200620-sgfap-loadavg/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 Linux中可以使用uptime、top</description>
    </item>
    
    <item>
      <title>B树、B&#43;树索引算法原理（下）</title>
      <link>https://www.codedump.info/post/20200615-btree-2/</link>
      <pubDate>Mon, 15 Jun 2020 22:44:21 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200615-btree-2/</guid>
      <description>这一段时间由于在阅读boltdb代码的缘故，找机会学习了B树及B+树的算法原理，这个系列会花两个篇幅分别介绍这两种数据结构的实现，其用于数据</description>
    </item>
    
    <item>
      <title>B树、B&#43;树索引算法原理（上）</title>
      <link>https://www.codedump.info/post/20200609-btree-1/</link>
      <pubDate>Tue, 09 Jun 2020 18:40:46 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200609-btree-1/</guid>
      <description>这一段时间由于在阅读boltdb代码的缘故，找机会学习了B树及B+树的算法原理，这个系列会花两个篇幅分别介绍这两种数据结构的实现，其用于数据</description>
    </item>
    
    <item>
      <title>如何阅读一份源代码？（2020年版）</title>
      <link>https://www.codedump.info/post/20200605-how-to-read-code-v2020/</link>
      <pubDate>Fri, 05 Jun 2020 00:14:14 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200605-how-to-read-code-v2020/</guid>
      <description>我在2019年写过一份文档 《如何阅读一份源代码？》，现在回头来看，这份文档还有改进的空间，于是我在此基础上又重新整理了一份。 阅读源代码的能力</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之软中断</title>
      <link>https://www.codedump.info/post/20200522-sgfap-softirq/</link>
      <pubDate>Fri, 22 May 2020 21:52:58 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200522-sgfap-softirq/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 中断（interrupt）通常被定义为一</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之系统调用</title>
      <link>https://www.codedump.info/post/20200516-sgfap-syscall/</link>
      <pubDate>Sat, 16 May 2020 16:31:03 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200516-sgfap-syscall/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 应用程序需要使用内核提供出来的一些功能，</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之使用systemtap分析进程的行为</title>
      <link>https://www.codedump.info/post/20200503-sgfap-process-systemtap/</link>
      <pubDate>Sun, 03 May 2020 14:32:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200503-sgfap-process-systemtap/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 以上描述进程的创建、执行、调度器的工作原</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之进程调度</title>
      <link>https://www.codedump.info/post/20200503-sgfap-process-schedule/</link>
      <pubDate>Sun, 03 May 2020 09:53:34 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200503-sgfap-process-schedule/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 一种资源，如果本身数量有限，需要多个资源</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》CPU篇之进程</title>
      <link>https://www.codedump.info/post/20200502-sgfap-process/</link>
      <pubDate>Sat, 02 May 2020 14:41:22 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200502-sgfap-process/</guid>
      <description>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概论 进程即处于执行状态的程序。操作系统执行进</description>
    </item>
    
    <item>
      <title>《面向应用开发者的系统指南》导论</title>
      <link>https://www.codedump.info/post/20200501-system-guide-for-application-programmer/</link>
      <pubDate>Fri, 01 May 2020 21:43:43 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200501-system-guide-for-application-programmer/</guid>
      <description>导论 我想整理这份文档很久了。 做为一个主要工作在应用层、用户态的开发者，我看了不少的所谓“内核资料”。我身边不少与我相似工作背景的人，也在不停</description>
    </item>
    
    <item>
      <title>Systemtap中内核trace事件的实现</title>
      <link>https://www.codedump.info/post/20200218-linux-traceevent/</link>
      <pubDate>Tue, 18 Feb 2020 17:37:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200218-linux-traceevent/</guid>
      <description>概述 内核中定义了一系列的trace point，这些trace point在特定的内核函数中被触发调用时被记录，而对应到systemtap中就是</description>
    </item>
    
    <item>
      <title>通过实例快速入门Systemtap</title>
      <link>https://www.codedump.info/post/20200128-systemtap-by-example/</link>
      <pubDate>Tue, 28 Jan 2020 11:56:56 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20200128-systemtap-by-example/</guid>
      <description>我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个awesome-</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11中的内存模型下篇 - C&#43;&#43;11支持的几种内存模型</title>
      <link>https://www.codedump.info/post/20191214-cxx11-memory-model-2/</link>
      <pubDate>Sat, 14 Dec 2019 22:41:22 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20191214-cxx11-memory-model-2/</guid>
      <description>在本系列的上篇，介绍了内存模型的基本概念，接下来看C++11中支持的几种内存模型。 几种关系术语 在接着继续解释之前，先了解一下几种关系术语。 sequenced-before</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11中的内存模型上篇 - 内存模型基础</title>
      <link>https://www.codedump.info/post/20191214-cxx11-memory-model-1/</link>
      <pubDate>Sat, 14 Dec 2019 10:10:15 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20191214-cxx11-memory-model-1/</guid>
      <description>前段时间花了些精力研究C++11引入的内存模型相关的操作，于是把相关的知识都学习了一下，将这个学习过程整理为两篇文档，这是第一篇，主要分析内</description>
    </item>
    
    <item>
      <title>对比脚本型和编译型游戏服务器的热更新方案</title>
      <link>https://www.codedump.info/post/20191206-gameserver-hot-refresh/</link>
      <pubDate>Fri, 06 Dec 2019 22:40:49 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20191206-gameserver-hot-refresh/</guid>
      <description>本文对比游戏服务器中C++搭配脚本语言（Lua、Python）以及纯编译型语言（C++、Golang）来进行开发时，进行线上服务器热更新的方</description>
    </item>
    
    <item>
      <title>IM服务器设计-如何解决消息的乱序</title>
      <link>https://www.codedump.info/post/20191013-im-msg-out-of-order/</link>
      <pubDate>Sun, 13 Oct 2019 10:59:16 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20191013-im-msg-out-of-order/</guid>
      <description>IM消息需要面对的另一个难题：如何保证收到的消息不乱序。下面先展开看看要解决这个难题有哪些障碍。 消息乱序的原因 时间难以保证 既然谈到“顺序”，</description>
    </item>
    
    <item>
      <title>IM服务器设计-网关接入层</title>
      <link>https://www.codedump.info/post/20190818-im-msg-gate/</link>
      <pubDate>Sun, 18 Aug 2019 16:55:17 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190818-im-msg-gate/</guid>
      <description>IM服务系列文章： IM服务器设计-基础 IM服务器设计-消息存储 网关接入层负责维护与客户端之间的长连接，由于它是唯一一个与客户端进行直接通信的</description>
    </item>
    
    <item>
      <title>glog C&#43;&#43;版本代码分析</title>
      <link>https://www.codedump.info/post/20190729-glog/</link>
      <pubDate>Mon, 29 Jul 2019 11:43:56 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190729-glog/</guid>
      <description>本文基于glog CPP版本的0.4.0版本，对glog的实现机制做一些简单的分析记录。 概述 要记录一条日志，分为两个阶段： 首先生成日志。 然后将</description>
    </item>
    
    <item>
      <title>服务调用的演进历史</title>
      <link>https://www.codedump.info/post/20190629-service-history/</link>
      <pubDate>Sat, 29 Jun 2019 12:47:07 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190629-service-history/</guid>
      <description>这是2019年给组内分享时整理的一篇服务调用演进历史的科普文。写作本文的时候，我自己最大的感受是：如果能清楚理解演化历史中的一些原则和思路，</description>
    </item>
    
    <item>
      <title>IM服务器设计-消息存储</title>
      <link>https://www.codedump.info/post/20190608-im-msg-storage/</link>
      <pubDate>Sat, 08 Jun 2019 20:18:47 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190608-im-msg-storage/</guid>
      <description>这部分专门讲述IM消息存储的设计。消息存储的难度在于，要考虑以下的场景： 离线消息存储。即发送消息时对方不在线该怎么处理。 单聊、群聊消息。 随着</description>
    </item>
    
    <item>
      <title>IM服务器设计-基础</title>
      <link>https://www.codedump.info/post/20190608-im-design-base/</link>
      <pubDate>Sat, 08 Jun 2019 11:09:10 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190608-im-design-base/</guid>
      <description>IM做为非常经典的服务器系统，其设计时候的考量具备代表性，所以这一次花几个篇幅讨论其相关设计。 主要内容相当部分参考了 一套海量在线用户的移动端</description>
    </item>
    
    <item>
      <title>OpenResty Lua Stream实现分析</title>
      <link>https://www.codedump.info/post/20190501-lua-stream/</link>
      <pubDate>Wed, 01 May 2019 15:03:45 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190501-lua-stream/</guid>
      <description>概述 OpenResty（以下简称OR）是Lua应用的典范，其最大的亮点在于，使用Lua协程搭配上异步非阻塞的IO，这样开发者可以使用同步方式</description>
    </item>
    
    <item>
      <title>redis高可用原理</title>
      <link>https://www.codedump.info/post/20190409-redis-sentinel/</link>
      <pubDate>Sun, 21 Apr 2019 22:52:16 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190409-redis-sentinel/</guid>
      <description>redis中为了实现高可用（High Availability，简称HA），采用了如下两个方式： 主从复制数据。 采用哨兵监控数据节点的运行情况，</description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》第九章《一致性与共识》笔记</title>
      <link>https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/</link>
      <pubDate>Thu, 18 Apr 2019 08:40:34 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/</guid>
      <description>一致性保证 最终一致性（eventual consistency）：如果停止更新数据，等待一段时间（时间长度未知），则最终所有读请求将返回相同的</description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》第八章《分布式系统的挑战》笔记</title>
      <link>https://www.codedump.info/post/20190405-ddia-chapter08-the-trouble-with-distributed-system/</link>
      <pubDate>Tue, 16 Apr 2019 21:03:16 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190405-ddia-chapter08-the-trouble-with-distributed-system/</guid>
      <description>本章描述分布式系统中可能出现的各种问题。 故障与部分失效 单机上的程序，以一种确定性的方式运行：要么工作，要么出错。 然而涉及到多台节点时，会出现</description>
    </item>
    
    <item>
      <title>线上存储服务崩溃问题分析记录</title>
      <link>https://www.codedump.info/post/20190413-problem-fix/</link>
      <pubDate>Sat, 13 Apr 2019 12:04:59 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190413-problem-fix/</guid>
      <description>注：本文为重新发布2017-06-17所写博客，以下为正文部分。 上周我们的存储服务在某个线上项目频繁出现崩溃，花了几天的时间来查找解决该问题</description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》第七章《事务》笔记</title>
      <link>https://www.codedump.info/post/20190403-ddia-chapter07-transaction/</link>
      <pubDate>Wed, 03 Apr 2019 22:33:58 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190403-ddia-chapter07-transaction/</guid>
      <description>事务提供了一种机制，应用程序可以把一组读和写操作放在一个逻辑单元里，所有在一个事务的读和写操作会被视为一个操作：要么全部失败，要么全部成功，</description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》第六章数据分区笔记</title>
      <link>https://www.codedump.info/post/20181124-ddia-chapter06-partitioning/</link>
      <pubDate>Tue, 02 Apr 2019 22:17:24 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20181124-ddia-chapter06-partitioning/</guid>
      <description>键值数据的分区 基于关键字区间的分区 给每个分区分配一段连续的关键字或者关键字区间（以最小值和最大值来指示），从关键字区间的上下限可以确定哪个分</description>
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》第五章数据复制笔记</title>
      <link>https://www.codedump.info/post/20181118-ddia-chapter05-replication/</link>
      <pubDate>Mon, 01 Apr 2019 18:19:22 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20181118-ddia-chapter05-replication/</guid>
      <description>主从复制 集群中有一个主节点，写操作都必须经过主节点完成，读操作主从节点都可以处理。 同步复制和异步复制 同步复制 数据在副本上落盘才返回。 优点：保</description>
    </item>
    
    <item>
      <title>如何阅读一份源代码？</title>
      <link>https://www.codedump.info/post/20190324-how-to-read-code/</link>
      <pubDate>Sun, 24 Mar 2019 09:41:21 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190324-how-to-read-code/</guid>
      <description>我在本文的基础上做了一些补充和改进，见《如何阅读一份源代码？（2020年版）》 阅读源代码的能力算是程序员的一种底层基础能力之一，这个能力之所</description>
    </item>
    
    <item>
      <title>TCP协议笔记</title>
      <link>https://www.codedump.info/post/20190227-tcp/</link>
      <pubDate>Wed, 27 Feb 2019 21:01:43 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190227-tcp/</guid>
      <description>概述 应用层：通常也称为“七层”，这是大部分服务器工作的层次，如HTTP 服务器等，位于应用层上的信息分组成为报文（message）。识别不同应</description>
    </item>
    
    <item>
      <title>Leveldb代码阅读笔记</title>
      <link>https://www.codedump.info/post/20190215-leveldb/</link>
      <pubDate>Fri, 15 Feb 2019 08:52:47 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190215-leveldb/</guid>
      <description>本文基于leveldb 1.9.0代码。 整体架构 如上图，leveldb的数据存储在内存以及磁盘上，其中： memtable：存储在内存中的数据，</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-内存池的设计</title>
      <link>https://www.codedump.info/post/20190214-nginx-memory-pool/</link>
      <pubDate>Thu, 14 Feb 2019 14:48:24 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190214-nginx-memory-pool/</guid>
      <description>nginx中所有请求都单独对应一个内存池，在这个请求的过程中，所有涉及到内存分配的地方，都到该请求相关的内存池中处理，而中间不会去释放回收内</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-处理HTTP请求</title>
      <link>https://www.codedump.info/post/20190213-nginx-process-http-request/</link>
      <pubDate>Wed, 13 Feb 2019 09:09:19 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190213-nginx-process-http-request/</guid>
      <description>前面分析了nginx如何读取一个HTTP请求、如何查询到HTTP对应的配置，本节分析如何处理HTTP请求。 处理HTTP请求的11个阶段 ngi</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-查询HTTP配置流程</title>
      <link>https://www.codedump.info/post/20190212-nginx-http-config/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:25 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190212-nginx-http-config/</guid>
      <description>概述 前面已经分析过nginx解析配置文件的整体流程，接下来看查询HTTP配置的流程。 HTTP属于nginx的core顶层模块，下面又包括了三</description>
    </item>
    
    <item>
      <title>zeromq所谓的“无锁消息队列”</title>
      <link>https://www.codedump.info/post/20190209-zeromq-lockfree-queue/</link>
      <pubDate>Sat, 09 Feb 2019 20:10:13 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190209-zeromq-lockfree-queue/</guid>
      <description>本文基于zeromq 4.3.0版本，分析其无锁消息队列的实现。 概述 zeromq这个网络库，有以下几个亮点： 从以往的面向TCP流的网络开发，变</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-接收HTTP请求流程</title>
      <link>https://www.codedump.info/post/20190131-nginx-read-http-request/</link>
      <pubDate>Fri, 01 Feb 2019 17:50:37 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-read-http-request/</guid>
      <description>前面已经描述过nginx的事件模块了，接下来具体分析nginx如何接收一个HTTP请求，下一部分接着解析nginx解析HTTP请求的流程。 协</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-事件处理模块</title>
      <link>https://www.codedump.info/post/20190131-nginx-event/</link>
      <pubDate>Thu, 31 Jan 2019 21:12:01 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-event/</guid>
      <description>大概做高性能服务器的，都绕不开事件处理模块来，一般一个事件模块，会分为以下几部分： 如何定义一个描述事件的数据结构。 如何在事件模块中支持定时器</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-Master Woker进程模型</title>
      <link>https://www.codedump.info/post/20190131-nginx-master-worker/</link>
      <pubDate>Thu, 31 Jan 2019 09:53:57 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190131-nginx-master-worker/</guid>
      <description>master进程 Nginx采用的模型是master-worker模型，即： 由master进程负责创建worker进程，以及监控worker进</description>
    </item>
    
    <item>
      <title>Libuv代码简单分析</title>
      <link>https://www.codedump.info/post/20190123-libuv/</link>
      <pubDate>Wed, 23 Jan 2019 08:43:49 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190123-libuv/</guid>
      <description>本文基于libuv 1.x版本进行简单的分析。 数据结构 uv__io_t uv__io_t用来表示一个IO事件。 其成员包括： 成员 说明 uv__io_cb cb IO事件被触发的回调函数</description>
    </item>
    
    <item>
      <title>Nginx源码阅读笔记-配置解析流程</title>
      <link>https://www.codedump.info/post/20190103-nginx-config-parse/</link>
      <pubDate>Thu, 03 Jan 2019 08:41:44 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20190103-nginx-config-parse/</guid>
      <description>本系列文章基于openresty-1.13.6.1版本的代码做的笔记，其对应的nginx源码版本是nginx-1.13.6。 模块与配置值解析</description>
    </item>
    
    <item>
      <title>Etcd存储的实现</title>
      <link>https://www.codedump.info/post/20181125-etcd-server/</link>
      <pubDate>Sun, 25 Nov 2018 15:13:28 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20181125-etcd-server/</guid>
      <description>概述 本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd</description>
    </item>
    
    <item>
      <title>etcd Raft库解析</title>
      <link>https://www.codedump.info/post/20180922-etcd-raft/</link>
      <pubDate>Sat, 22 Sep 2018 11:01:02 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20180922-etcd-raft/</guid>
      <description>概述 本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd</description>
    </item>
    
    <item>
      <title>Raft算法原理</title>
      <link>https://www.codedump.info/post/20180921-raft/</link>
      <pubDate>Fri, 21 Sep 2018 20:15:32 +0800</pubDate>
      
      <guid>https://www.codedump.info/post/20180921-raft/</guid>
      <description>概述 本文是博客解析raft算法及etcd raft库实现的系列三篇文章之一，之所以详细结合etcd实现解析raft算法原理及实现，因为etcd</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.codedump.info/page/about/</link>
      <pubDate>Thu, 20 Sep 2018 23:08:27 +0800</pubDate>
      
      <guid>https://www.codedump.info/page/about/</guid>
      <description>网名“codedump”，不是“coredump”。取这个名字，是因为喜欢研究代码的原理，所以就取名“code dump”了。 个人感兴趣领域：</description>
    </item>
    
  </channel>
</rss>