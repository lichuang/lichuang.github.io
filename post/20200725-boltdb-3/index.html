<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>boltdb 1.3.0实现分析（三） - codedump的网络日志</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="https://www.codedump.info/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="https://www.codedump.info/js/eureka.min.dca6aee3d946cd994aa01d07eb82704da838affe2ddf0085a90fefe4a57fb4be6e3d98fec1465bccf45b19e269301a44.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://www.codedump.info/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://www.codedump.info/js/fontawesome.min.99528f92b28b4907b92da13a4e1aed7b955f2233b5ebd0bcad3f677237b7bde76eb543e279d164e2d6e27dee22470ad4.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126255685-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-126255685-1');
</script>


<link rel="icon" type="image/png" href="/images/C.png" sizes="64x64">

<meta name="description"
  content="boltdb 1.3.0实现分析">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://www.codedump.info/post/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"boltdb 1.3.0实现分析（三）",
      "item":"https://www.codedump.info/post/20200725-boltdb-3/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.codedump.info/post/20200725-boltdb-3/"
    },
    "headline": "boltdb 1.3.0实现分析（三） - codedump的网络日志","datePublished": "2020-07-25T11:26:33+08:00",
    "dateModified": "2020-07-25T11:26:33+08:00",
    "wordCount":  4127 ,
    "publisher": {
        "@type": "Person",
        "name": "lichuang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.codedump.info/images/C.png"
        }
        },
    "description": "boltdb 1.3.0实现分析"
}
</script><meta property="og:title" content="boltdb 1.3.0实现分析（三） - codedump的网络日志" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://www.codedump.info/images/C.png">


<meta property="og:url" content="https://www.codedump.info/post/20200725-boltdb-3/" />



<meta property="og:description" content="boltdb 1.3.0实现分析" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="codedump的网络日志" />






<meta property="article:published_time" content="2020-07-25T11:26:33&#43;08:00" />


<meta property="article:modified_time" content="2020-07-25T11:26:33&#43;08:00" />



<meta property="article:section" content="post" />


<meta property="article:tag" content="存储" />

<meta property="article:tag" content="存储引擎" />









<meta property="og:see_also" content="https://www.codedump.info/post/20200726-boltdb-4/" />





<meta property="og:see_also" content="https://www.codedump.info/post/20200711-boltdb-2/" />



<meta property="og:see_also" content="https://www.codedump.info/post/20200625-boltdb-1/" />






  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">codedump的网络日志</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
            <a href="/post/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">分类</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/index.xml" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">RSS</a>
            <a href="https://www.getrevue.co/profile/lichuang" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">邮件订阅</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">boltdb 1.3.0实现分析（三）</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2020-07-25</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>9分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="https://www.codedump.info/categories/%E5%AD%98%E5%82%A8/" class="hover:text-eureka"
          >存储</a
        >
      
        
          <span>, </span>
        <a href="https://www.codedump.info/categories/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="hover:text-eureka"
          >存储引擎</a
        >
      
    </div>
  

  
    <div class="me-6 my-2">
      <i class="fas fa-th-list me-1"></i>
      
        <a href="https://www.codedump.info/series/boltdb-1.3.0%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" class="hover:text-eureka"
          >boltdb 1.3.0实现分析</a
        >
      
    </div>
  
</div>


  
  

  <blockquote>
<p>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结构体。关于etcd、raft协议以及B+树，可以参考之前的文章：</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<blockquote>
<p>本文的写作，主要参考了<a href="https://www.jianshu.com/p/b86a69892990">《区块的持久化之BoltDB》系列文章</a>以及<a href="https://youjiali1995.github.io/storage/boltdb">boltdb 源码分析</a></p>
</blockquote>
<p>在前面的文章里，分别介绍了boltdb的几种页面格式、Bucket以及Cursor结构，本文介绍boltdb的事务（Transaction）。</p>
<h1 id="概述">概述</h1>
<p>boltdb支持事务的<code>ACID</code>特性，使用<code>MVCC</code>来做并发控制，同时可以执行一个写事务和多个读事务：</p>
<ul>
<li>原子性（Atomicity）：未提交的写事务操作都在内存中。在提交写事务的时候，按照B+树数据、freelist、meta元数据的顺序写入文件。在meta元信息写入之前，都可以进行回滚（rollback）操作，只有meta元信息写入成功才能认为写操作执行成功。</li>
<li>隔离性（Isolation）：每个读事务开始的时候获得一个版本号，读事务涉及到的页面不会被同时进行的写事务所覆盖；而每次写事务都会更新一个版本号。</li>
<li>持久性（Durability）：写事务在提交的时候，会将这次写操作修改的数据（dirty page）分配新的页面，写入文件持久化。</li>
</ul>
<p>本节首先讲解boltdb的事务基本实现，下一节讲解boltdb事务如何实现<code>MVCC</code>。</p>
<h1 id="事务初始化">事务初始化</h1>
<p>boltdb中，任何一次读写操作，都有一个事务与之对应。这时候首先会调用<code>DB.Begin</code>函数返回一个事务，而传入的参数会根据情况分别创建写和读事务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Begin</span><span class="p">(</span><span class="nx">writable</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">writable</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">beginRWTx</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">beginTx</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>可以看到，根据是否是写事务，会分别调用<code>beginRWTx</code>和<code>beginTx</code>来创建读写事务和只读事务。</p>
<p><code>DB</code>结构体中，仅有一个写事务成员，而读事务则可以同时存在多个，因此同一个时间只能有一个写事务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">type</span> <span class="nx">DB</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>	<span class="nx">rwtx</span>     <span class="o">*</span><span class="nx">Tx</span>				<span class="c1">// 同一时间只能有一个未完成的写事务
</span><span class="c1"></span>	<span class="nx">txs</span>      <span class="p">[]</span><span class="o">*</span><span class="nx">Tx</span>			<span class="c1">// 保存未完成的读事务的，读事务可以有多个，写事务一个时间只能有一个，就在rwtx里面
</span><span class="c1"></span><span class="p">}</span>  
</code></pre></div><p><img src="/media/imgs/20200725-boltdb-3/beginTx.png" alt="beginTx" title="beginTx"></p>
<p>了解了在<code>DB</code>中如何使用事务，下面来看事务结构体的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">type</span> <span class="nx">Tx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">writable</span>       <span class="kt">bool</span>	<span class="c1">// 是否写事务
</span><span class="c1"></span>	<span class="nx">managed</span>        <span class="kt">bool</span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nx">db</span>             <span class="o">*</span><span class="nx">DB</span>	<span class="c1">// 对应的db
</span><span class="c1"></span>	<span class="nx">meta</span>           <span class="o">*</span><span class="nx">meta</span>	<span class="c1">// 对应的meta数据指针
</span><span class="c1"></span>	<span class="nx">root</span>           <span class="nx">Bucket</span>	
	<span class="nx">pages</span>          <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span>	<span class="c1">// 涉及到的page
</span><span class="c1"></span>	<span class="nx">stats</span>          <span class="nx">TxStats</span>
	<span class="nx">commitHandlers</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>	<span class="c1">// commit回调函数数组
</span><span class="c1"></span>
	<span class="nx">WriteFlag</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>成员释义如下：</p>
<ul>
<li>writable：是否是可写的事务。</li>
<li>managed：表示当前的事务操作是否被db托管，即通过db的成员函数来读写数据库。boltdb还支持直接调用事务相关的成员函数来读写的，此时managed字段为false。</li>
<li>db：指向当前读写操作的db对象。</li>
<li>meta：开始事务时，会首先从db中初始化meta信息。</li>
<li>root：事务开始时的根Bucket，<a href="https://www.codedump.info/post/20200711-boltdb-2/">上一节</a>中介绍了Bucket相关信息。</li>
<li>pages：存储该事务操作中读写所涉及到page。</li>
<li>stats：事务操作统计相关。</li>
<li>commitHandlers：存储事务在提交之后的回调函数。</li>
<li>WriteFlag: 复制或移动数据库文件时，指定的文件打开模式。</li>
</ul>
<p>上面这些成员中，最重要的就是<code>meta</code>和<code>root</code>字段，下面接着看看事务的初始化流程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="nx">db</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// Copy the meta page since it can be changed by the writer.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">meta</span><span class="p">{}</span>
	<span class="c1">// tx的meta数据拷贝当前的db meta数据
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nf">meta</span><span class="p">().</span><span class="nb">copy</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span>

	<span class="c1">// Copy over the root bucket.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{}</span>
	<span class="o">*</span><span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span>

	<span class="c1">// Increment the transaction id and add a page cache for writable transactions.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="c1">// 如果是写操作，需要分配页面数组内存
</span><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
		<span class="c1">// 递增一个事务id
</span><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="o">+=</span> <span class="nf">txid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先来看<code>meta</code>的初始化流程。前面提到，<code>db</code>数据结构中，存在两个<code>meta</code>信息分别存储在数据库文件的第一和第二个页面，在<code>db.meta</code>函数中，将选择两者中校验有效且事务ID更大的<code>meta</code>返回：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">meta</span><span class="p">()</span> <span class="o">*</span><span class="nx">meta</span> <span class="p">{</span>
	<span class="c1">// We have to return the meta with the highest txid which doesn&#39;t fail
</span><span class="c1"></span>	<span class="c1">// validation. Otherwise, we can cause errors when in fact the database is
</span><span class="c1"></span>	<span class="c1">// in a consistent state. metaA is the one with the higher txid.
</span><span class="c1"></span>	<span class="nx">metaA</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span>
	<span class="nx">metaB</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span>
	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span><span class="p">.</span><span class="nx">txid</span> <span class="p">&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span><span class="p">.</span><span class="nx">txid</span> <span class="p">{</span>
		<span class="nx">metaA</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span>
		<span class="nx">metaB</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span>
	<span class="p">}</span>

	<span class="c1">// Use higher meta page if valid. Otherwise fallback to previous, if valid.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metaA</span><span class="p">.</span><span class="nf">validate</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">metaA</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metaB</span><span class="p">.</span><span class="nf">validate</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">metaB</span>
	<span class="p">}</span>

	<span class="c1">// This should never be reached, because both meta1 and meta0 were validated
</span><span class="c1"></span>	<span class="c1">// on mmap() and we do fsync() on every write.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bolt.DB.meta(): invalid meta pages&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>可以看到有两个<code>meta</code>页面的原因在于：由于轮换使用两个<code>meta</code>页面，这样两次不同的写事务操作，分别对应这两个<code>meta</code>页面中的一个，假如其中一次失败了，也只是影响了其中一个页面。</p>
<p>拿到了这一次操作的<code>meta</code>信息之后，就是根据这些信息来初始化<code>root</code>的Bucket信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ....
</span><span class="c1"></span>  <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
  <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{}</span>
  <span class="o">*</span><span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在这里，根据拷贝出来的<code>meta</code>信息，调用<code>newBucket</code>函数创建了<code>Bucket</code>返回到<code>tx.root</code>中。一个<code>Bucket</code>的<code>bucket</code>成员，其内容是<code>Bucket</code>的根节点page id以及序列号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">type</span> <span class="nx">bucket</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 根节点的page id
</span><span class="c1"></span>	<span class="nx">root</span> <span class="nx">pgid</span> <span class="c1">// page id of the bucket&#39;s root-level page
</span><span class="c1"></span>	<span class="c1">// 单调递增的序列号
</span><span class="c1"></span>	<span class="nx">sequence</span> <span class="kt">uint64</span> <span class="c1">// monotonically incrementing, used by NextSequence()
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>因此上面的流程就是：使用当前的<code>meta</code>元信息，创建了一个<code>Bucket</code>，该<code>Bucket</code>的根节点page id以及序列号也都是从当前db的根<code>Bucket</code>中拷贝的。</p>
<p><code>tx.init</code>函数的最后，根据是否写事务，将拷贝回来的<code>meta</code>信息的事务id递增1：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ....
</span><span class="c1"></span>	<span class="c1">// Increment the transaction id and add a page cache for writable transactions.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="c1">// 如果是写操作，需要分配页面数组内存
</span><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
		<span class="c1">// 递增一个事务id
</span><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="o">+=</span> <span class="nf">txid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这样，在最后写事务完成之后，将<code>meta</code>信息写回磁盘时，就比原先的事务ID加一。</p>
<h1 id="事务提交">事务提交</h1>
<p>前面介绍了事务的初始化流程，由于boltdb内部是一个B+树结构，所以boltdb中涉及到读写的流程就不再阐述，基本就是一个B+树的读写流程，如果不清楚这部分的原理，可以去补充一下B+树相关的知识：</p>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<p>在这一小节，只介绍读写流程完毕之后的事务提交流程，这部分内容在<code>Tx.Commit</code>函数中实现。boltdb的事务提交流程大体分为以下几步：</p>
<ul>
<li>B+树的重平衡及节点分裂。</li>
<li>调整freelist页面信息。</li>
<li>将meta信息写回磁盘。</li>
</ul>
<p><img src="/media/imgs/20200725-boltdb-3/commitTx.png" alt="commitTx" title="commitTx"></p>
<h2 id="b树的重平衡及节点分裂">B+树的重平衡及节点分裂</h2>
<p>在写操作过程中，中间可能会造成树的不平衡，因此在操作完毕之后，需要对整个B+树进行重平衡（rebalance）操作。重平衡操作的原理比较复杂，是一个从叶子节点一直往上进行重平衡操作，直到满足B+树平衡条件的流程。算法的原理不在这里阐述，具体可以参考 <a href="https://www.codedump.info/post/20200615-btree-2/#%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95">B树、B+树索引算法原理（下）#删除算法</a>。基本上boltdb的重平衡操作也是这个流程，也就不在这里展开了。</p>
<p>重平衡完毕之后，boltdb还会将大小超过阈值的节点，分裂成多个节点，其大体流程是：</p>
<ul>
<li>Bucket遍历自己的所有子Bucket，进行<code>spill</code>分裂操作。如果分裂成功，就需要在父Bucket中更新该子Bucket的信息。</li>
<li>Bucket从自己的根节点开始，进行<code>spill</code>分裂操作。</li>
<li>节点的<code>spill</code>操作，将遍历该节点的所有子节点，如果一个子节点大小超过阈值就进行分裂；否则分裂结束。</li>
</ul>
<p>如果在分裂操作中，产生了新的页面，则这个时候就会在<code>freelist</code>中分配页面给这些新的页面。由于每次写事务的<code>freelist</code>信息，在事务提交之前是在内存里的，所以一旦写失败，这些<code>freelist</code>信息就回退，并不影响其他的操作。</p>
<h2 id="调整freelist页面信息">调整freelist页面信息</h2>
<p>到了这一步，前面的两个调整：重平衡和分裂页面操作已经完成，过程中可能产生了新的页面，也就是<code>freelist</code>信息会有改变，因此要相应的调整<code>freelist</code>页面信息。</p>
<p>在这里首先来看看<code>freelist</code>中如何维护页面的分配信息，<code>freelist</code>中包括以下三个成员：</p>
<ul>
<li>ids：保存当前可用的页面ID数组。</li>
<li>pending：pending是一个map，键是事务id，值为页面ID数组，存储的是每个事务操作时候涉及到的页面ID。</li>
<li>cache：cache是一个map，键为页面ID，值为布尔值，可以从这里快速查看一个页面当前是否空闲。</li>
</ul>
<p>以上三个成员中，<code>cache</code>是方便快速查找页面空闲情况的数据，可以理解为可用页面的索引；<code>ids</code>是存储可用页面ID的数组，每次分配一个页面出去就要对应的修改这个数组；最后，<code>pending</code>就是存储一个事务操作过程中间的数据。</p>
<p><img src="/media/imgs/20200725-boltdb-3/freelist.png" alt="freelist" title="freelist"></p>
<p>在上图中，<code>freelist</code>页面在磁盘中存储的当前页面<code>id</code>的分配数组，每一次初始化时将可用页面ID读入<code>ids</code>数组之后，都会再调用<code>freelist.reindex</code>函数来重建索引数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">freelist</span><span class="p">)</span> <span class="nf">reindex</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">cache</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pendingIDs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">f</span><span class="p">.</span><span class="nx">pending</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pendingID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pendingIDs</span> <span class="p">{</span>
			<span class="nx">f</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">pendingID</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果事务需要回滚，实际上是将<code>pending</code>中的页面返还回去，重新变成空闲页面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="c1">// rollback removes the pages from a given pending tx.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">freelist</span><span class="p">)</span> <span class="nf">rollback</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">txid</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Remove page ids from cache.
</span><span class="c1"></span>	<span class="c1">// 回滚就是把所有待释放的id删除，表示不释放了
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">f</span><span class="p">.</span><span class="nx">pending</span><span class="p">[</span><span class="nx">txid</span><span class="p">]</span> <span class="p">{</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">cache</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Remove pages from pending list.
</span><span class="c1"></span>	<span class="c1">// 然后删除这个事务的pending数组
</span><span class="c1"></span>	<span class="nb">delete</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">pending</span><span class="p">,</span> <span class="nx">txid</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>有了对<code>freelist</code>相关的了解，回到事务提交操作修改<code>freelist</code>部分，其代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">Commit</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="c1">// 释放freelist
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="p">))</span>
	<span class="c1">// 分配一个freelist
</span><span class="c1"></span>	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">allocate</span><span class="p">((</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">/</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>  
</code></pre></div><p>在这里：</p>
<ul>
<li>首先根据事务ID将原有存储<code>freelist</code>页面信息的页面释放掉。</li>
<li>分配存储这一次写事务的页面信息页面。</li>
<li>写入这一次的页面信息。</li>
</ul>
<h2 id="将meta信息写回磁盘">将meta信息写回磁盘</h2>
<p>最后，在更新完毕新的<code>freelist</code>页面信息之后，就可以把本次操作之后的<code>meta</code>元信息也写回磁盘了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Go" data-lang="Go"><span class="c1">// writeMeta writes the meta to the disk.
</span><span class="c1">// 更新meta数据到磁盘
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">writeMeta</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Create a temporary buffer for the meta page.
</span><span class="c1"></span>	<span class="c1">// 分配缓冲区，大小为一个页面
</span><span class="c1"></span>	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span>
	<span class="c1">// 转换成page结构体
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">pageInBuffer</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 将事务的meta数据写入page中
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>

	<span class="c1">// Write the meta page to file.
</span><span class="c1"></span>	<span class="c1">// 缓冲的数据写入文件
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">ops</span><span class="p">.</span><span class="nf">writeAt</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">NoSync</span> <span class="o">||</span> <span class="nx">IgnoreNoSync</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fdatasync</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Update statistics.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Write</span><span class="o">++</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h1 id="总结">总结</h1>
<p>总结下来，boltdb的写事务操作流程大体如下：</p>
<ul>
<li>使用当前db数据来初始化事务：复制一份当前的meta元信息、初始化根Bucket信息、自增事务ID。</li>
<li>对B+树进行写操作，这部分在未提交之前都是存储在内存中的数据。</li>
<li>写操作完成之后，提交写事务：
<ul>
<li>平衡B+树、对超过阈值的节点进行分裂操作。分裂过程中产生的新页面将从<code>freelist</code>中分配出来。</li>
<li>给<code>freelist</code>分配新的页面。</li>
<li>到了这里，将B+树和<code>freelist</code>数据写入文件。</li>
<li>更新meta元信息写入文件。</li>
</ul>
</li>
</ul>

</article>


      
        <div class="my-4">
    
    <a href="https://www.codedump.info/tags/%E5%AD%98%E5%82%A8/" class="inline-block text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#存储</a>
    
    <a href="https://www.codedump.info/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="inline-block text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#存储引擎</a>
    
</div>
      



      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >上一页</span
        >
        <a href="https://www.codedump.info/post/20200726-boltdb-4/" class="block">boltdb 1.3.0实现分析（四）</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://www.codedump.info/post/20200711-boltdb-2/" class="block">boltdb 1.3.0实现分析（二）</a>
      
    </div>
  </div>


    </div>
    
      <div class="col-span-2">

        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页目录</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#事务初始化">事务初始化</a></li>
    <li><a href="#事务提交">事务提交</a>
      <ul>
        <li><a href="#b树的重平衡及节点分裂">B+树的重平衡及节点分裂</a></li>
        <li><a href="#调整freelist页面信息">调整freelist页面信息</a></li>
        <li><a href="#将meta信息写回磁盘">将meta信息写回磁盘</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="https://www.codedump.info/post/20200711-boltdb-2/" class="no-underline">boltdb 1.3.0实现分析（二）</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200625-boltdb-1/" class="no-underline">boltdb 1.3.0实现分析（一）</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200615-btree-2/" class="no-underline">B树、B&#43;树索引算法原理（下）</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200609-btree-1/" class="no-underline">B树、B&#43;树索引算法原理（上）</a>
          <br />
        
          <a href="https://www.codedump.info/post/20190215-leveldb/" class="no-underline">Leveldb代码阅读笔记</a>
          <br />
        
      </div>
    

    <div
    class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
  >      
      



  <script src="https://utteranc.es/client.js"
  repo="lichuang/lichuang.github.io"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>

<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
  </div>


  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center">
      <a href="https://github.com/lichuang" class="me-2" target="_blank" title="github">
        <i class="fab fa-github"></i>
      </a>
      <a href="https://www.zhihu.com/people/codedump" class="me-2" target="_blank" title="zhihu">
        <i class="fab fa-zhihu"></i>
      </a>
      <a href="https://weibo.com/lichuang" class="me-2" target="_blank" title="weibo">
        <i class="fab fa-weibo"></i>
      </a>
      <a href="https://twitter.com/lichuang" class="me-2" target="_blank" title="twitter">
        <i class="fab fa-twitter"></i>
      </a>


  <a href="https://www.codedump.info/index.xml" type="application/rss+xml" class="me-2" target="_blank" title="rss">
      <i class="fas fa-rss"></i> 
    </a>
</div>


<div class="text-center">
    <p class="text-sm text-tertiary-text">&copy; 2018 <a href="https://www.codedump.info/">codedump</a>   
  <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
</span>
 &middot; 
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/wangchucheng/hugo-eureka" rel="noopener" target="_blank">Eureka</a>
</div>

</div>
    </footer>
  </body>
</html>
