<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="codedump">

  
  
  <meta name="description" content="boltdb 1.3.0实现分析">
  

  
  <link rel="icon" href="https://www.codedump.info/favicon.ico">

  
  
  <meta name="keywords" content=" boltdb  存储引擎 ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:title" content="boltdb 1.3.0实现分析（三）" />
<meta property="og:description" content="boltdb 1.3.0实现分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20200725-boltdb-3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-25T11:26:33+08:00" />
<meta property="article:modified_time" content="2020-07-25T11:26:33+08:00" />



  
  <link rel="canonical" href="https://www.codedump.info/post/20200725-boltdb-3/">

  
  
  <meta itemprop="name" content="boltdb 1.3.0实现分析（三）">
<meta itemprop="description" content="boltdb 1.3.0实现分析"><meta itemprop="datePublished" content="2020-07-25T11:26:33+08:00" />
<meta itemprop="dateModified" content="2020-07-25T11:26:33+08:00" />
<meta itemprop="wordCount" content="4127">
<meta itemprop="keywords" content="存储,存储引擎," />

  
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/content.css'>

  
  
  <title>boltdb 1.3.0实现分析（三） - codedump的网络日志</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="boltdb 1.3.0实现分析（三）"/>
<meta name="twitter:description" content="boltdb 1.3.0实现分析"/>


  
<link rel="stylesheet" href='https://www.codedump.info/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://www.codedump.info">codedump的网络日志</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">发表</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/20200122-series-pages/">系列文章索引</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/weekly">周刊</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="https://www.codedump.info/index.xml">订阅</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/about">关于</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>boltdb 1.3.0实现分析（三）</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8'>#存储</a>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E'>#存储引擎</a>
    
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#b树的重平衡及节点分裂">B+树的重平衡及节点分裂</a></li>
    <li><a href="#调整freelist页面信息">调整freelist页面信息</a></li>
    <li><a href="#将meta信息写回磁盘">将meta信息写回磁盘</a></li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <blockquote>
<p>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结构体。关于etcd、raft协议以及B+树，可以参考之前的文章：</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<blockquote>
<p>本文的写作，主要参考了<a href="https://www.jianshu.com/p/b86a69892990">《区块的持久化之BoltDB》系列文章</a>以及<a href="https://youjiali1995.github.io/storage/boltdb">boltdb 源码分析</a></p>
</blockquote>
<p>在前面的文章里，分别介绍了boltdb的几种页面格式、Bucket以及Cursor结构，本文介绍boltdb的事务（Transaction）。</p>
<h1 id="概述">概述</h1>
<p>boltdb支持事务的<code>ACID</code>特性，使用<code>MVCC</code>来做并发控制，同时可以执行一个写事务和多个读事务：</p>
<ul>
<li>原子性（Atomicity）：未提交的写事务操作都在内存中。在提交写事务的时候，按照B+树数据、freelist、meta元数据的顺序写入文件。在meta元信息写入之前，都可以进行回滚（rollback）操作，只有meta元信息写入成功才能认为写操作执行成功。</li>
<li>隔离性（Isolation）：每个读事务开始的时候获得一个版本号，读事务涉及到的页面不会被同时进行的写事务所覆盖；而每次写事务都会更新一个版本号。</li>
<li>持久性（Durability）：写事务在提交的时候，会将这次写操作修改的数据（dirty page）分配新的页面，写入文件持久化。</li>
</ul>
<p>本节首先讲解boltdb的事务基本实现，下一节讲解boltdb事务如何实现<code>MVCC</code>。</p>
<h1 id="事务初始化">事务初始化</h1>
<p>boltdb中，任何一次读写操作，都有一个事务与之对应。这时候首先会调用<code>DB.Begin</code>函数返回一个事务，而传入的参数会根据情况分别创建写和读事务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (db <span style="color:#666">*</span>DB) <span style="color:#00a000">Begin</span>(writable <span style="color:#0b0;font-weight:bold">bool</span>) (<span style="color:#666">*</span>Tx, <span style="color:#0b0;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> writable {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> db.<span style="color:#00a000">beginRWTx</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> db.<span style="color:#00a000">beginTx</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，根据是否是写事务，会分别调用<code>beginRWTx</code>和<code>beginTx</code>来创建读写事务和只读事务。</p>
<p><code>DB</code>结构体中，仅有一个写事务成员，而读事务则可以同时存在多个，因此同一个时间只能有一个写事务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> DB <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	rwtx     <span style="color:#666">*</span>Tx				<span style="color:#080;font-style:italic">// 同一时间只能有一个未完成的写事务
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	txs      []<span style="color:#666">*</span>Tx			<span style="color:#080;font-style:italic">// 保存未完成的读事务的，读事务可以有多个，写事务一个时间只能有一个，就在rwtx里面
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}  
</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200725-boltdb-3/beginTx.png" alt="beginTx" title="beginTx"></p>
<p>了解了在<code>DB</code>中如何使用事务，下面来看事务结构体的定义：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> Tx <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	writable       <span style="color:#0b0;font-weight:bold">bool</span>	<span style="color:#080;font-style:italic">// 是否写事务
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	managed        <span style="color:#0b0;font-weight:bold">bool</span>	<span style="color:#080;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	db             <span style="color:#666">*</span>DB	<span style="color:#080;font-style:italic">// 对应的db
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	meta           <span style="color:#666">*</span>meta	<span style="color:#080;font-style:italic">// 对应的meta数据指针
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	root           Bucket	
</span></span><span style="display:flex;"><span>	pages          <span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#666">*</span>page	<span style="color:#080;font-style:italic">// 涉及到的page
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	stats          TxStats
</span></span><span style="display:flex;"><span>	commitHandlers []<span style="color:#a2f;font-weight:bold">func</span>()	<span style="color:#080;font-style:italic">// commit回调函数数组
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	WriteFlag <span style="color:#0b0;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>成员释义如下：</p>
<ul>
<li>writable：是否是可写的事务。</li>
<li>managed：表示当前的事务操作是否被db托管，即通过db的成员函数来读写数据库。boltdb还支持直接调用事务相关的成员函数来读写的，此时managed字段为false。</li>
<li>db：指向当前读写操作的db对象。</li>
<li>meta：开始事务时，会首先从db中初始化meta信息。</li>
<li>root：事务开始时的根Bucket，<a href="https://www.codedump.info/post/20200711-boltdb-2/">上一节</a>中介绍了Bucket相关信息。</li>
<li>pages：存储该事务操作中读写所涉及到page。</li>
<li>stats：事务操作统计相关。</li>
<li>commitHandlers：存储事务在提交之后的回调函数。</li>
<li>WriteFlag: 复制或移动数据库文件时，指定的文件打开模式。</li>
</ul>
<p>上面这些成员中，最重要的就是<code>meta</code>和<code>root</code>字段，下面接着看看事务的初始化流程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (tx <span style="color:#666">*</span>Tx) <span style="color:#00a000">init</span>(db <span style="color:#666">*</span>DB) {
</span></span><span style="display:flex;"><span>	tx.db = db
</span></span><span style="display:flex;"><span>	tx.pages = <span style="color:#a2f;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Copy the meta page since it can be changed by the writer.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	tx.meta = <span style="color:#666">&amp;</span>meta{}
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// tx的meta数据拷贝当前的db meta数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	db.<span style="color:#00a000">meta</span>().<span style="color:#a2f">copy</span>(tx.meta)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Copy over the root bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	tx.root = <span style="color:#00a000">newBucket</span>(tx)
</span></span><span style="display:flex;"><span>	tx.root.bucket = <span style="color:#666">&amp;</span>bucket{}
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>tx.root.bucket = tx.meta.root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Increment the transaction id and add a page cache for writable transactions.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> tx.writable {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 如果是写操作，需要分配页面数组内存
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		tx.pages = <span style="color:#a2f">make</span>(<span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#666">*</span>page)
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 递增一个事务id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		tx.meta.txid <span style="color:#666">+=</span> <span style="color:#00a000">txid</span>(<span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先来看<code>meta</code>的初始化流程。前面提到，<code>db</code>数据结构中，存在两个<code>meta</code>信息分别存储在数据库文件的第一和第二个页面，在<code>db.meta</code>函数中，将选择两者中校验有效且事务ID更大的<code>meta</code>返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (db <span style="color:#666">*</span>DB) <span style="color:#00a000">meta</span>() <span style="color:#666">*</span>meta {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// We have to return the meta with the highest txid which doesn&#39;t fail
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// validation. Otherwise, we can cause errors when in fact the database is
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// in a consistent state. metaA is the one with the higher txid.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	metaA <span style="color:#666">:=</span> db.meta0
</span></span><span style="display:flex;"><span>	metaB <span style="color:#666">:=</span> db.meta1
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> db.meta1.txid &gt; db.meta0.txid {
</span></span><span style="display:flex;"><span>		metaA = db.meta1
</span></span><span style="display:flex;"><span>		metaB = db.meta0
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Use higher meta page if valid. Otherwise fallback to previous, if valid.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">:=</span> metaA.<span style="color:#00a000">validate</span>(); err <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> metaA
</span></span><span style="display:flex;"><span>	} <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">:=</span> metaB.<span style="color:#00a000">validate</span>(); err <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> metaB
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// This should never be reached, because both meta1 and meta0 were validated
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// on mmap() and we do fsync() on every write.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f">panic</span>(<span style="color:#b44">&#34;bolt.DB.meta(): invalid meta pages&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到有两个<code>meta</code>页面的原因在于：由于轮换使用两个<code>meta</code>页面，这样两次不同的写事务操作，分别对应这两个<code>meta</code>页面中的一个，假如其中一次失败了，也只是影响了其中一个页面。</p>
<p>拿到了这一次操作的<code>meta</code>信息之后，就是根据这些信息来初始化<code>root</code>的Bucket信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (tx <span style="color:#666">*</span>Tx) <span style="color:#00a000">init</span>(db <span style="color:#666">*</span>DB) {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  tx.root = <span style="color:#00a000">newBucket</span>(tx)
</span></span><span style="display:flex;"><span>  tx.root.bucket = <span style="color:#666">&amp;</span>bucket{}
</span></span><span style="display:flex;"><span>  <span style="color:#666">*</span>tx.root.bucket = tx.meta.root
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>在这里，根据拷贝出来的<code>meta</code>信息，调用<code>newBucket</code>函数创建了<code>Bucket</code>返回到<code>tx.root</code>中。一个<code>Bucket</code>的<code>bucket</code>成员，其内容是<code>Bucket</code>的根节点page id以及序列号：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> bucket <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 根节点的page id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	root pgid <span style="color:#080;font-style:italic">// page id of the bucket&#39;s root-level page
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 单调递增的序列号
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	sequence <span style="color:#0b0;font-weight:bold">uint64</span> <span style="color:#080;font-style:italic">// monotonically incrementing, used by NextSequence()
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>因此上面的流程就是：使用当前的<code>meta</code>元信息，创建了一个<code>Bucket</code>，该<code>Bucket</code>的根节点page id以及序列号也都是从当前db的根<code>Bucket</code>中拷贝的。</p>
<p><code>tx.init</code>函数的最后，根据是否写事务，将拷贝回来的<code>meta</code>信息的事务id递增1：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (tx <span style="color:#666">*</span>Tx) <span style="color:#00a000">init</span>(db <span style="color:#666">*</span>DB) {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// Increment the transaction id and add a page cache for writable transactions.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> tx.writable {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 如果是写操作，需要分配页面数组内存
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		tx.pages = <span style="color:#a2f">make</span>(<span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#666">*</span>page)
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 递增一个事务id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		tx.meta.txid <span style="color:#666">+=</span> <span style="color:#00a000">txid</span>(<span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>这样，在最后写事务完成之后，将<code>meta</code>信息写回磁盘时，就比原先的事务ID加一。</p>
<h1 id="事务提交">事务提交</h1>
<p>前面介绍了事务的初始化流程，由于boltdb内部是一个B+树结构，所以boltdb中涉及到读写的流程就不再阐述，基本就是一个B+树的读写流程，如果不清楚这部分的原理，可以去补充一下B+树相关的知识：</p>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<p>在这一小节，只介绍读写流程完毕之后的事务提交流程，这部分内容在<code>Tx.Commit</code>函数中实现。boltdb的事务提交流程大体分为以下几步：</p>
<ul>
<li>B+树的重平衡及节点分裂。</li>
<li>调整freelist页面信息。</li>
<li>将meta信息写回磁盘。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200725-boltdb-3/commitTx.png" alt="commitTx" title="commitTx"></p>
<h2 id="b树的重平衡及节点分裂">B+树的重平衡及节点分裂</h2>
<p>在写操作过程中，中间可能会造成树的不平衡，因此在操作完毕之后，需要对整个B+树进行重平衡（rebalance）操作。重平衡操作的原理比较复杂，是一个从叶子节点一直往上进行重平衡操作，直到满足B+树平衡条件的流程。算法的原理不在这里阐述，具体可以参考 <a href="https://www.codedump.info/post/20200615-btree-2/#%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95">B树、B+树索引算法原理（下）#删除算法</a>。基本上boltdb的重平衡操作也是这个流程，也就不在这里展开了。</p>
<p>重平衡完毕之后，boltdb还会将大小超过阈值的节点，分裂成多个节点，其大体流程是：</p>
<ul>
<li>Bucket遍历自己的所有子Bucket，进行<code>spill</code>分裂操作。如果分裂成功，就需要在父Bucket中更新该子Bucket的信息。</li>
<li>Bucket从自己的根节点开始，进行<code>spill</code>分裂操作。</li>
<li>节点的<code>spill</code>操作，将遍历该节点的所有子节点，如果一个子节点大小超过阈值就进行分裂；否则分裂结束。</li>
</ul>
<p>如果在分裂操作中，产生了新的页面，则这个时候就会在<code>freelist</code>中分配页面给这些新的页面。由于每次写事务的<code>freelist</code>信息，在事务提交之前是在内存里的，所以一旦写失败，这些<code>freelist</code>信息就回退，并不影响其他的操作。</p>
<h2 id="调整freelist页面信息">调整freelist页面信息</h2>
<p>到了这一步，前面的两个调整：重平衡和分裂页面操作已经完成，过程中可能产生了新的页面，也就是<code>freelist</code>信息会有改变，因此要相应的调整<code>freelist</code>页面信息。</p>
<p>在这里首先来看看<code>freelist</code>中如何维护页面的分配信息，<code>freelist</code>中包括以下三个成员：</p>
<ul>
<li>ids：保存当前可用的页面ID数组。</li>
<li>pending：pending是一个map，键是事务id，值为页面ID数组，存储的是每个事务操作时候涉及到的页面ID。</li>
<li>cache：cache是一个map，键为页面ID，值为布尔值，可以从这里快速查看一个页面当前是否空闲。</li>
</ul>
<p>以上三个成员中，<code>cache</code>是方便快速查找页面空闲情况的数据，可以理解为可用页面的索引；<code>ids</code>是存储可用页面ID的数组，每次分配一个页面出去就要对应的修改这个数组；最后，<code>pending</code>就是存储一个事务操作过程中间的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200725-boltdb-3/freelist.png" alt="freelist" title="freelist"></p>
<p>在上图中，<code>freelist</code>页面在磁盘中存储的当前页面<code>id</code>的分配数组，每一次初始化时将可用页面ID读入<code>ids</code>数组之后，都会再调用<code>freelist.reindex</code>函数来重建索引数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (f <span style="color:#666">*</span>freelist) <span style="color:#00a000">reindex</span>() {
</span></span><span style="display:flex;"><span>	f.cache = <span style="color:#a2f">make</span>(<span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#0b0;font-weight:bold">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">for</span> _, id <span style="color:#666">:=</span> <span style="color:#a2f;font-weight:bold">range</span> f.ids {
</span></span><span style="display:flex;"><span>		f.cache[id] = <span style="color:#a2f;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">for</span> _, pendingIDs <span style="color:#666">:=</span> <span style="color:#a2f;font-weight:bold">range</span> f.pending {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">for</span> _, pendingID <span style="color:#666">:=</span> <span style="color:#a2f;font-weight:bold">range</span> pendingIDs {
</span></span><span style="display:flex;"><span>			f.cache[pendingID] = <span style="color:#a2f;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果事务需要回滚，实际上是将<code>pending</code>中的页面返还回去，重新变成空闲页面：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// rollback removes the pages from a given pending tx.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (f <span style="color:#666">*</span>freelist) <span style="color:#00a000">rollback</span>(txid txid) {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Remove page ids from cache.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 回滚就是把所有待释放的id删除，表示不释放了
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">for</span> _, id <span style="color:#666">:=</span> <span style="color:#a2f;font-weight:bold">range</span> f.pending[txid] {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f">delete</span>(f.cache, id)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Remove pages from pending list.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 然后删除这个事务的pending数组
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f">delete</span>(f.pending, txid)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有了对<code>freelist</code>相关的了解，回到事务提交操作修改<code>freelist</code>部分，其代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (tx <span style="color:#666">*</span>Tx) <span style="color:#00a000">Commit</span>() <span style="color:#0b0;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  <span style="color:#080;font-style:italic">// 释放freelist
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	tx.db.freelist.<span style="color:#00a000">free</span>(tx.meta.txid, tx.db.<span style="color:#00a000">page</span>(tx.meta.freelist))
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 分配一个freelist
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	p, err <span style="color:#666">:=</span> tx.<span style="color:#00a000">allocate</span>((tx.db.freelist.<span style="color:#00a000">size</span>() <span style="color:#666">/</span> tx.db.pageSize) <span style="color:#666">+</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		tx.<span style="color:#00a000">rollback</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">:=</span> tx.db.freelist.<span style="color:#00a000">write</span>(p); err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		tx.<span style="color:#00a000">rollback</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}  
</span></span></code></pre></div><p>在这里：</p>
<ul>
<li>首先根据事务ID将原有存储<code>freelist</code>页面信息的页面释放掉。</li>
<li>分配存储这一次写事务的页面信息页面。</li>
<li>写入这一次的页面信息。</li>
</ul>
<h2 id="将meta信息写回磁盘">将meta信息写回磁盘</h2>
<p>最后，在更新完毕新的<code>freelist</code>页面信息之后，就可以把本次操作之后的<code>meta</code>元信息也写回磁盘了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// writeMeta writes the meta to the disk.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 更新meta数据到磁盘
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (tx <span style="color:#666">*</span>Tx) <span style="color:#00a000">writeMeta</span>() <span style="color:#0b0;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Create a temporary buffer for the meta page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 分配缓冲区，大小为一个页面
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	buf <span style="color:#666">:=</span> <span style="color:#a2f">make</span>([]<span style="color:#0b0;font-weight:bold">byte</span>, tx.db.pageSize)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 转换成page结构体
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	p <span style="color:#666">:=</span> tx.db.<span style="color:#00a000">pageInBuffer</span>(buf, <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 将事务的meta数据写入page中
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	tx.meta.<span style="color:#00a000">write</span>(p)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Write the meta page to file.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 缓冲的数据写入文件
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> _, err <span style="color:#666">:=</span> tx.db.ops.<span style="color:#00a000">writeAt</span>(buf, <span style="color:#a2f">int64</span>(p.id)<span style="color:#666">*</span><span style="color:#a2f">int64</span>(tx.db.pageSize)); err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> !tx.db.NoSync <span style="color:#666">||</span> IgnoreNoSync {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">:=</span> <span style="color:#00a000">fdatasync</span>(tx.db); err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Update statistics.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	tx.stats.Write<span style="color:#666">++</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="总结">总结</h1>
<p>总结下来，boltdb的写事务操作流程大体如下：</p>
<ul>
<li>使用当前db数据来初始化事务：复制一份当前的meta元信息、初始化根Bucket信息、自增事务ID。</li>
<li>对B+树进行写操作，这部分在未提交之前都是存储在内存中的数据。</li>
<li>写操作完成之后，提交写事务：
<ul>
<li>平衡B+树、对超过阈值的节点进行分裂操作。分裂过程中产生的新页面将从<code>freelist</code>中分配出来。</li>
<li>给<code>freelist</code>分配新的页面。</li>
<li>到了这里，将B+树和<code>freelist</code>数据写入文件。</li>
<li>更新meta元信息写入文件。</li>
</ul>
</li>
</ul>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://www.codedump.info/post/20200711-boltdb-2/">← prev</a>
    
    
    <a class="link" href="https://www.codedump.info/post/20200726-boltdb-4/">next →</a>
    
  </div>

    
<h1>相关文章</h1><li><strong> 1029-02-01: </strong> <a href="https://www.codedump.info/post/20220201-sqlite-btree-5-btree/">sqlite3.36版本 btree实现（五）- Btree的实现</a>  </li><li><strong> 6019-01-06: </strong> <a href="https://www.codedump.info/post/20220106-sqlite-btree-4-wal/">sqlite3.36版本 btree实现（四）- WAL的实现</a>  </li><li><strong> 22129-12-22: </strong> <a href="https://www.codedump.info/post/20211222-sqlite-btree-3-journal/">sqlite3.36版本 btree实现（三）- journal文件备份机制</a>  </li><li><strong> 18129-12-18: </strong> <a href="https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/">sqlite3.36版本 btree实现（二）- 并发控制框架</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/">sqlite3.36版本 btree实现（一）- 管理页面缓存</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-0/">sqlite3.36版本 btree实现（零）- 起步及概述</a>  </li><li><strong> 26079-07-26: </strong> <a href="https://www.codedump.info/post/20200726-boltdb-4/">boltdb 1.3.0实现分析（四）</a>  </li><li><strong> 11079-07-11: </strong> <a href="https://www.codedump.info/post/20200711-boltdb-2/">boltdb 1.3.0实现分析（二）</a>  </li><li><strong> 25069-06-25: </strong> <a href="https://www.codedump.info/post/20200625-boltdb-1/">boltdb 1.3.0实现分析（一）</a>  </li><li><strong> 15069-06-15: </strong> <a href="https://www.codedump.info/post/20200615-btree-2/">B树、B&#43;树索引算法原理（下）</a>  </li><li><strong> 9069-06-09: </strong> <a href="https://www.codedump.info/post/20200609-btree-1/">B树、B&#43;树索引算法原理（上）</a>  </li><li><strong> 15029-02-15: </strong> <a href="https://www.codedump.info/post/20190215-leveldb/">Leveldb代码阅读笔记</a>  </li>

<h1>邮件订阅</h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>

<img align="center" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">
    <footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AD%98%E5%82%A8/">存储</a>
          <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</a>
          </div><div class="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lichuang-codedump" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    
    
    
        <script src="https://utteranc.es/client.js"
            repo="{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
  
    
  </div>

  <main id="main" class="main">
    <div class="content-wrapper">
      <div id="content" class="content">
        
      </div>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
    <script src="https://utteranc.es/client.js"
            repo="lichuang/lichuang.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
  </main>


  
</main>

    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/lichuang>GitHub</a>,
<a class=link href=https://twitter.com/lichuang>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  



  
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>

</html>
