<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="codedump" /><meta name="description" content="sqlite3.36版本 btree实现（一）- 管理页面缓存" />
<meta name="keywords" content="Btree, 存储引擎, sqlite" />


<meta property="og:title" content="sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志">
<meta name="apple-mobile-web-app-title" content="sqlite3.36版本 btree实现（一）- 管理页面缓存 - codedump的网络日志">



<meta name="google-site-verification" content="UA-126255685-1" />


<meta name="generator" content="Hugo 0.56.0" />


<link rel="canonical" href="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="sqlite3.36版本 btree实现（一）- 管理页面缓存" />
<meta property="og:description" content="sqlite3.36版本 btree实现（一）- 管理页面缓存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/" />
<meta property="article:published_time" content="2021-12-17T14:22:06+08:00" />
<meta property="article:modified_time" content="2021-12-17T14:22:06+08:00" />
<meta itemprop="name" content="sqlite3.36版本 btree实现（一）- 管理页面缓存">
<meta itemprop="description" content="sqlite3.36版本 btree实现（一）- 管理页面缓存">


<meta itemprop="datePublished" content="2021-12-17T14:22:06&#43;08:00" />
<meta itemprop="dateModified" content="2021-12-17T14:22:06&#43;08:00" />
<meta itemprop="wordCount" content="6512">



<meta itemprop="keywords" content="存储,存储引擎,sqlite,btree," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="sqlite3.36版本 btree实现（一）- 管理页面缓存"/>
<meta name="twitter:description" content="sqlite3.36版本 btree实现（一）- 管理页面缓存"/>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">codedump的网络日志</a>
  </div>
  <div class="mobile-navbar-icon">    
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/20200122-series-pages/">
        <li class="mobile-menu-item">系列文章索引</li>
      </a><a href="/page/about">
        <li class="mobile-menu-item">关于</li>
      </a><a href="https://www.codedump.info">
        <li class="mobile-menu-item">订阅</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">codedump的网络日志</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/20200122-series-pages/">系列文章索引</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/page/about">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://www.codedump.info">订阅</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">sqlite3.36版本 btree实现（一）- 管理页面缓存</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-17 </span>
        <div class="post-category">
            
              <a href="/categories/%E5%AD%98%E5%82%A8/"> 存储 </a>
            
              <a href="/categories/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"> 存储引擎 </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#管理页面">管理页面</a>
<ul>
<li><a href="#页面相关的数据数据结构">页面相关的数据数据结构</a>
<ul>
<li><a href="#sqlite3-pcache-page数据结构">sqlite3_pcache_page数据结构</a></li>
</ul></li>
<li><a href="#页面所在的数据结构">页面所在的数据结构</a>
<ul>
<li><a href="#脏页面链表">脏页面链表</a></li>
<li><a href="#hash数组">hash数组</a></li>
<li><a href="#lru链表">LRU链表</a></li>
<li><a href="#pin和unpin操作">pin和unpin操作</a></li>
</ul></li>
<li><a href="#页面缓存管理器">页面缓存管理器</a>
<ul>
<li><a href="#页面缓存管理器的数据结构">页面缓存管理器的数据结构</a></li>
</ul></li>
<li><a href="#页面缓存算法结构体">页面缓存算法结构体</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="概述">概述</h1>

<p><code>页面管理</code>模块中，很重要的一个功能是缓存页面的内容在内存中：</p>

<ul>
<li>读页面：如果页面已经在内存，就不需要到文件中读出页面内容。</li>
<li>写页面：如果页面已经在内存，那么对页面的修改就只需要修改页面在内存中的数据即可，被修改了但是还没有落盘的页面，被称为“脏页面”（dirty page）。这样，多次对某个页面的修改，可能最后只需要一次落盘即可。当然，对页面的修改，如果在还没有落盘之前，系统就崩溃了，这种情况下应该如何处理，这就是“崩溃恢复”模块做的事情了。本节中，将专注在“页面缓存”这个子模块的实现。</li>
</ul>

<p>既然要将页面缓存在内存中，就会涉及到几个功能：</p>

<ul>
<li>如何知道哪些页面已经被缓存在内存里了？</li>
<li>缓存在内存中的页面如何组织管理？</li>
<li>缓存页面使用的内存不够用时，应该如何处理？</li>
</ul>

<p>我们首先来了解一下“页面缓存”模块的总体划分：</p>

<p><center>
<img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20211217-sqlite-btree-1-pagecache/pagecache.png" alt="页面缓存功能的模块划分" title="页面缓存功能的模块划分" />
</center></p>

<p>按照上图的划分，页面缓存模块分为以下几部分：</p>

<ul>
<li>页面缓存管理器：实现了页面缓存的总体算法流程，以及提供对外的接口，但是具体到“页面缓存算法”的实现，则有赖于下面这个可用户定制的<code>sqlite3_pcache_methods2</code>。这部分功能在代码<code>pcache.c</code>中。</li>
<li>页面缓存算法：用户可自己定制，只要实现<code>sqlite3_pcache_methods2</code>结构体中的接口即可。系统中的默认实现，在文件<code>pcache1.c</code>中。</li>
<li>除此以外，还需要快速根据页面编号就能知道哪些页面已经被缓存的功能，这部分sqlite使用位图数据结构来实现，在文件<code>bitvec.c</code>中。</li>
</ul>

<p>页面缓存管理器，核心功能就是维护脏页面链表，缓存页面的管理，诸如根据页面编号查找页面、淘汰页面算法等，都由“页面缓存算法”来维护。可以这样来简单的理解上面的功能划分：</p>

<ul>
<li>“页面缓存管理器”：定义了管理页面缓存的接口、总体流程，维护管理目前在用的脏页面。</li>
<li>“页面缓存算法”：维护其它不在使用但还在内存中的页面，负责其淘汰、回收等实现。由“sqlite3_pcache_methods2”结构体实现，用户可以定制自己实现的“sqlite3_pcache_methods2”，系统也提供默认的实现。</li>
</ul>

<p><center>
<img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20211217-sqlite-btree-1-pagecache/page_cache_memory.png" alt="两种页面的划分" title="两种页面的划分" />
</center></p>

<p>简而言之，如果把当前在内存中的页面划分为以下两类，那么：</p>

<ul>
<li>当前在使用的页面：即与页面编号对应的页面，由“页面缓存管理器”维护。</li>
<li>当前还未使用、但也在内存中的页面：即随时准备拿出来存储从磁盘中读出来的数据的页面，由“页面缓存算法”维护，比如淘汰、回收、复用等。</li>
</ul>

<p>下面，就开始“页面缓存”这几部分功能的具体讲解。</p>

<h1 id="管理页面">管理页面</h1>

<h2 id="页面相关的数据数据结构">页面相关的数据数据结构</h2>

<p>首先来看页面相关的数据结构，sqlite中使用<code>PgHdr</code>结构体来在内存中描述一个页面：</p>

<pre><code>/*
** Every page in the cache is controlled by an instance of the following
** structure.
*/
struct PgHdr {
  sqlite3_pcache_page *pPage;    /* Pcache object page handle */
  void *pData;                   /* Page data */
  void *pExtra;                  /* Extra content */
  PCache *pCache;                /* PRIVATE: Cache that owns this page */
  PgHdr *pDirty;                 /* Transient list of dirty sorted by pgno */
  Pager *pPager;                 /* The pager this page is part of */
  Pgno pgno;                     /* Page number for this page */
#ifdef SQLITE_CHECK_PAGES
  u32 pageHash;                  /* Hash of page content */
#endif
  u16 flags;                     /* PGHDR flags defined below */

  /**********************************************************************
  ** Elements above, except pCache, are public.  All that follow are 
  ** private to pcache.c and should not be accessed by other modules.
  ** pCache is grouped with the public elements for efficiency.
  */
  i16 nRef;                      /* Number of users of this page */
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
};
</code></pre>

<p>其中的信息，大部分在注释中已经自解释：</p>

<ul>
<li>pPage：这个字段稍显复杂，后面展开详细解释。</li>
<li>pData，pExtra：pData指向了页面实际的内容，pExtra指向页面额外数据，大部分时候，后者的内容可以忽视。</li>
<li>pCache：页面缓存管理器对象指针。</li>
<li>pDirty：脏页面链表指针。</li>
<li>pPager：页面管理器对象指针。（注意和pCache进行区分，pCache是“页面缓存管理器”）。</li>
<li>pgno：存储该页面的页面编号。</li>
<li>flags：页面标志位，有如下几种，可以通过位操作来加上多个标志位：

<ul>
<li>PGHDR_CLEAN：干净的页面。</li>
<li>PGHDR_DIRTY：脏页面。</li>
<li>PGHDR_WRITEABLE：已经记录下来修改之前的页面内容，所以此时可以对内存中的页面内容进行修改了。</li>
<li>PGHDR_NEED_SYNC：将该页面内容写入数据库文件之前，需要sync journal文件中的页面内容。</li>
<li>PGHDR_DONT_WRITE：不需要写页面内容到磁盘。</li>
<li>PGHDR_MMAP：该页面内容是通过mmap到内存中的。</li>
<li>PGHDR_WAL_APPEND：页面内容已经添加到WAL文件中了。</li>
</ul></li>
<li>nRef：页面引用计数。</li>
<li>pDirtyNext、pDirtyPrev：存储脏页面链表中前、后页面指针，如果该页面不是脏页面，则这两个字段未定义。</li>
</ul>

<p>可以简略的总结该结构体中的内容，最重要的莫过于以下几项：</p>

<ul>
<li>pData存储的页面内容，所谓的读、写页面内容实际上操作的是这个成员指向的内容。</li>
<li>pDirty、pDirtyNext、pDirtyPrev这几个成员维护的脏页面相关的指针。</li>
<li>flags维护的页面标志位，通过这些标志位来区分应该对页面进行什么操作。</li>
</ul>

<p><center>
<img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20211217-sqlite-btree-1-pagecache/PgHdr.png" alt="内存中脏页面的组织" title="内存中脏页面的组织" />
</center></p>

<h3 id="sqlite3-pcache-page数据结构">sqlite3_pcache_page数据结构</h3>

<p>上面的<code>PgHdr</code>结构体中，还有第一个成员，即<code>sqlite3_pcache_page</code>类型的pPage指针没有讲解，这里展开解释。</p>

<p>前面概述部分提到，“页面缓存算法”的实现，是可以交给用户自定义的，这就带来一个问题：每个自定义的实现，内部实现的管理页面的结构体可能并不相同。于是，就要类似C++中的面向对象机制一样，先声明一个“页面”的基类，基类中定义最基础的成员变量，这样做之后有这样的好处：页面管理模块，所有的操作都能针对这个基类来进行，而不需要管具体实现中的差异。</p>

<p>在这里，这个基类就是成员<code>sqlite3_pcache_page</code>，其定义如下：</p>

<pre><code>typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;        /* The content of the page */
  void *pExtra;      /* Extra information associated with the page */
};
</code></pre>

<p>成员中的用途，注释中也写得挺清楚了：</p>

<ul>
<li>pBuf：指向页面内容。</li>
<li>pExtra：保存页面的额外信息。</li>
</ul>

<p>既然是“基类”，就要求每个子类都要有该基类的信息，实际上也是这样做的，比如“页面缓存算法”的默认实现中，其管理页面的结构体是<code>PgHdr1</code>（后面会展开解释这个结构体），其初始定义如下：</p>

<pre><code>struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp; pExtra */
  ...
}
</code></pre>

<p>从注释可以看到，sqlite中要求所有实现页面缓存算法中管理页面的数据结构体，都要以<code>sqlite3_pcache_page</code>结构体开始做为第一个成员。</p>

<p>实际上，<code>sqlite3_pcache_page</code>结构体中，<code>pExtra</code>成员包括如下两部分：</p>

<ul>
<li>额外内容：由系统指定<code>szExtra</code>大小来指定这部分内容大小，简单起见，目前可以认为这部分为0。</li>
<li>PgHdr结构体：即前面讲解的<code>页面缓存模块</code>中描述一个页面的结构体大小。</li>
</ul>

<p>读到这里，有可能把读者绕晕了，我们以代码和图示为引子详细看一下。</p>

<p>首先，创建一个“页面缓存算法”模块时，要调用<code>sqlite3_pcache_methods2</code>结构体中定义的<code>xCreate</code>函数指针来完成，其函数定义如下：</p>

<pre><code>sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
</code></pre>

<p>传入的第二个参数<code>szExtra</code>需要指定额外部分的内容大小，实际在调用时，这个参数的大小就是我们上面说的<code>szExtra</code>和PgHdr结构体大小之和（做了8字节对齐）：</p>

<pre><code>    sqlite3_pcache *pNew;
    pNew = sqlite3GlobalConfig.pcache2.xCreate(
                szPage, pCache-&gt;szExtra + ROUND8(sizeof(PgHdr)),
                pCache-&gt;bPurgeable
</code></pre>

<p>于是，“页面缓存模块”中要获取一个页面时，是通过<code>sqlite3_pcache_methods2</code>结构体中定义的<code>xFetch</code>函数指针来完成的，这个函数指针的定义是：</p>

<pre><code>sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
</code></pre>

<p>可以看到，这里返回的就是上面说的“基类”，即<code>sqlite3_pcache_page</code>结构体指针。而在内部的默认实现中，其实返回的是<code>PgHdr1</code>指针进行强制转换之后的结果，即<code>sqlite3_pcache_page</code>这一基类的子类，之所以能够做，完全是因为在<code>PgHdr1</code>结构体定义时，把<code>sqlite3_pcache_page</code>结构体成员放在第一个成员：</p>

<pre><code>struct PgHdr1 {
  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf &amp; pExtra */
  ...
}
</code></pre>

<p>得到返回的<code>sqlite3_pcache_page</code>指针之后，就能通过其中的<code>pExtra</code>指针拿到<code>PgHdr</code>：</p>

<pre><code>PgHdr *sqlite3PcacheFetchFinish(
  PCache *pCache,             /* Obtain the page from this cache */
  Pgno pgno,                  /* Page number obtained */
  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */
){
  PgHdr *pPgHdr;

  pPgHdr = (PgHdr *)pPage-&gt;pExtra;
  // ...
}
</code></pre>

<p>总结起来，如下图所示：</p>

<p><center>
<img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20211217-sqlite-btree-1-pagecache/sqlite3_pcache_page.png" alt="sqlite3_pcache_page" title="sqlite3_pcache_page" />
</center></p>

<h2 id="页面所在的数据结构">页面所在的数据结构</h2>

<p>缓存中的页面，可能存在于以下三种数据结构中：</p>

<ul>
<li>脏页面链表：该链表维护所有当前在使用的页面，由“页面缓存管理器”维护。</li>
<li>hash数组：作用是以页面编号为键来查询页面，由默认的“页面缓存算法”来维护。</li>
<li>LRU链表：越是常被访问的页面，在LRU链表中就越往前，从LRU链表中淘汰数据都是从链表尾部开始的，也是由默认的“页面缓存算法”来维护。</li>
</ul>

<p><center>
<img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20211217-sqlite-btree-1-pagecache/page_ds.png" alt="页面所在的三种数据结构" title="页面所在的三种数据结构" />
</center></p>

<h3 id="脏页面链表">脏页面链表</h3>

<p>这个页面链表叫“脏页面（dirty page）链表”实际上并不十分准确，这会让人误以为这个链表上的页面全都是脏页面，实际上是可能存在干净的页面的。更准确的说法，是当前系统在使用的页面，都维护在这个页面链表中。</p>

<p>操作这个链表的入口函数是<code>pcacheManageDirtyList</code>，其传入的参数一个是<code>PgHdr</code>类型的指针，另一个用于指定行为，有以下三种：</p>

<pre><code>#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */
#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */
#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */
</code></pre>

<p>在<code>pcacheManageDirtyList</code>函数实现中，也是根据这个参数进行与操作判断来做不同的行为的：</p>

<pre><code>pcacheManageDirtyList实现：
  如果 addRemove &amp; PCACHE_DIRTYLIST_REMOVE:
    从链表上删除
  如果 addRemove &amp; PCACHE_DIRTYLIST_ADD：
    添加到链表头
</code></pre>

<p>这里需要注意的是，参数<code>PCACHE_DIRTYLIST_FRONT</code>为3，而另外两个参数一个是1（删除）一个是2，所以当传入<code>PCACHE_DIRTYLIST_FRONT</code>的时候，按照上面的流程，就是首先从链表上删除，再放到链表头。</p>

<p>由于脏页面链表是由“页面缓存管理器”来管理的，所以描述页面的结构体与这个链表相关的数据结构，都在<code>PgHdr</code>上：</p>

<pre><code>struct PgHdr {
  ...
  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */
  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */
                          /* NB: pDirtyNext and pDirtyPrev are undefined if the
                          ** PgHdr object is not dirty */
}; 
</code></pre>

<h3 id="hash数组">hash数组</h3>

<p>为了快速根据页面编号，查找到该编号的页面是否已经加载到页面中，每个页面的数据还存在于一个hash数组中。</p>

<p>如前所述，这个数据结构由默认的“页面缓存算法”维护，所以与之相关的数据结构，都在结构体<code>PgHdr1</code>上：</p>

<pre><code>struct PgHdr1 {
  ...
  PgHdr1 *pNext;                 /* Next in hash table chain */
};
</code></pre>

<p>hash数组的实现，与一般的实现并没有太大区别，这里就不展开说了。</p>

<h3 id="lru链表">LRU链表</h3>

<p>当需要加载当前还不在内存中的页面时，需要首先分配出一块空间，用于保存从文件中加载的页面数据。如前所述，“页面缓存管理器”管理的是还在使用的页面，而“页面缓存算法”管理的是当前没有被使用的页面，所以这部分功能也是由默认的“页面缓存算法”来实现的，与之相关的数据结构，和hash数组的实现一样，也在结构体<code>PgHdr1</code>上：</p>

<pre><code>struct PgHdr1 {
  ...
  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */
  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */
                                 /* NB: pLruPrev is only valid if pLruNext!=0 */
};
</code></pre>

<p>当需要从“没有被使用的页面”中，分配出来一个页面数据用于保存加载的页面时，就涉及到淘汰问题：如果一个页面虽然当前没有被使用，但是由于经常被访问，所以不应该淘汰这个页面，因为很有可能它马上又会被访问到，应该首先淘汰那些不常被访问的页面，用来加载页面数据。</p>

<p>维护这些信息的数据结构，就是LRU链表：在链表中越往前的数据，意味着被访问的越频繁；反之，淘汰都是从链表尾部开始。</p>

<h3 id="pin和unpin操作">pin和unpin操作</h3>

<p><code>pin</code>和<code>unpin</code>操作，在默认的缓存算法中，是针对LRU链表而言的：一个页面数据，如果执行了<code>pin</code>操作，就是将这个页面从LRU链表上摘下来。而<code>unpin</code>操作则反之，将页面放入LRU链表。</p>

<p>为什么需要这两个操作？</p>

<p>再复习一下前面提到的分工：</p>

<ul>
<li>页面缓存管理器：负责维护在使用的页面。</li>
<li>页面缓存算法：负责维护未使用的页面。</li>
</ul>

<p>假设一个页面编号为N的页面，被访问时需要加载到内存，此时就会由“页面缓存管理器”加载到内存中，放入脏页面链表；而一旦访问完成，就会调用页面缓存算法的<code>xUnpin</code>函数指针执行<code>unpin</code>操作（实现页面缓存算法的<code>sqlite3_pcache_methods2</code>结构体在后面解释）。</p>

<p>在默认的缓存算法中，执行<code>unpin</code>操作，就是将页面放入LRU链表，并不会将页面从hash数组中删除，也就是说：<code>unpin</code>操作，并不妨碍这个能够以页面编号从hash数组中再次查到该页面的数据。</p>

<p>换言之，<code>unpin</code>操作是在“页面缓存算法”使用完毕某个页面时执行的，只是用来通知“页面缓存算法”：这个页面我已经用不上了，后续怎么处理，可以由“页面缓存算法”自行决定。</p>

<p>于是，对于那些经常被访问的页面，即便当前没有被使用，真正到需要它的时候，只要没有被淘汰出去分配给其他页面，就不再需要再次从文件中加载出来。</p>

<h2 id="页面缓存管理器">页面缓存管理器</h2>

<h3 id="页面缓存管理器的数据结构">页面缓存管理器的数据结构</h3>

<p>页面缓存管理器，核心功能就是维护脏页面链表，页面缓存管理器的数据结构中最重要的莫过于以下几个成员：</p>

<pre><code>struct PCache {
  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */
  PgHdr *pSynced;                     /* Last synced page in dirty page list */
  ...

  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */
  void *pStress;                      /* Argument to xStress */
  sqlite3_pcache *pCache;             /* Pluggable cache module */
}
</code></pre>

<p>可以看到，有两个维护页面链表相关的指针：</p>

<ul>
<li>脏页面链表：由成员pDirty, pDirtyTail指向该链表的一头一尾。脏页面链表中，页面是按照LRU的顺序进行排列的，即：越靠近链表尾的页面最可能被淘汰。</li>
<li>最后进行sync的页面指针：在脏页面链表中，pSynced始终指向最后一个已经进行sync操作的页面。</li>
</ul>

<p>为什么需要多一个<code>pSynced</code>指针？因为在页面缓存紧张的时候，需要快速知道哪些页面已经sync了，这样的页面淘汰的代价最低，具体可以看函数<code>sqlite3PcacheFetchStress</code>的实现，该函数的大体流程是：</p>

<pre><code>分为两步寻找可以淘汰的页面：
  首先在pSynced指针开始往前找不需要sync且引用计数为0的页面
  如果找不到就继续在脏页面链表中寻找引用计数为0的页面
  找到之后，调用注册的xStress进行淘汰操作
</code></pre>

<p>除了这几个和脏页面链表相关的数据结构之外，上面还列举出来了其他几个成员：</p>

<ul>
<li>xStress和pStress：在页面缓存出现压力时，需要将页面淘汰同时进行清理，清理页面的操作最终由<code>xStress</code>函数指针来完成。</li>
<li>sqlite3_pcache：下面会提到，实现“页面缓存算法”的<code>sqlite3_pcache_methods2</code>结构体，其内部的<code>xCreate</code>函数指针最终会创建出一个<code>sqlite3_pcache</code>返回，后续调用<code>页面缓存算法</code>时，传入的都是这个返回的指针。</li>
</ul>

<h2 id="页面缓存算法结构体">页面缓存算法结构体</h2>

<p>页面缓存算法，需要实现<code>sqlite3_pcache_methods2</code>接口并且注册到系统中，来看<code>sqlite3_pcache_methods2</code>的定义：</p>

<pre><code>typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*, 
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};
</code></pre>

<p>逐个解释：</p>

<ul>
<li>iVersion：版本号。</li>
<li>pArg：参数。</li>
<li>xInit：初始化模块的函数指针，这在模块初始化时一次性调用即可。</li>
<li>xShutdown：停止模块的函数指针。</li>
<li>xCreate：创建一个“页面缓存算法”的指针<code>sqlite3_pcache</code>返回，注意这个函数里传入了页面大小、额外空间大小，这些都在上面有说明。后续的其他函数指针，传入的第一个参数都是这里返回的<code>sqlite3_pcache</code>指针。</li>
<li>xCachesize：返回当前cache大小。</li>
<li>xPagecount：返回页面数量。</li>
<li>xFetch：核心函数，根据传入的<code>key</code>在缓存中查找页面，如果没有找到则按照<code>createFlag</code>参数来决定后面的行为。</li>
<li>xUnpin：页面的引用计数为0时就会调用这个函数。</li>
<li>xRekey：表示把页面的key进行修改，这里key其实就是页面编号。</li>
<li>xTruncate：将所有页面编号&gt;=iLimit的页面都释放，回收内存。</li>
<li>xDestroy：销毁前面<code>xCreate</code>函数返回的<code>sqlite3_pcache</code>指针。</li>
<li>xShrink：尽可能的回收内存。</li>
</ul>

<p>需要说明的是：</p>

<ul>
<li>xInit函数：完成初始化这个模块的工作。</li>
<li>xCreate：返回创建一个“页面缓存算法”的指针<code>sqlite3_pcache</code>，后续的所有操作，都使用这个指针。</li>
</ul>

<p>而sqlite中，其实并没有定义<code>sqlite3_pcache</code>的具体结构，仅仅只是声明了这个类型，可以理解为是一个类似于<code>void*</code>这样的泛型指针：</p>

<pre><code>/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache type is opaque.  It is implemented by
** the pluggable module.  The SQLite core has no knowledge of
** its size or internal structure and never deals with the
** sqlite3_pcache object except by holding and passing pointers
** to the object.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache sqlite3_pcache;
</code></pre>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">codedump</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2021-12-17</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。 转载时请注明原文链接，图片使用<a href="https://www.omnigroup.com/omnigraffle/">OmniGraffle</a>进行绘制。</span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">打赏</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/wechat.png">
        <span>微信支付</span>
      </label>
    
  </div>
</div>
        
      
      <h1>相关文章</h1><li><strong> 2021-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-0/">sqlite3.36版本 btree实现（零）- 起步及概述</a>  </li><li><strong> 2020-07-26: </strong> <a href="https://www.codedump.info/post/20200726-boltdb-4/">boltdb 1.3.0实现分析（四）</a>  </li><li><strong> 2020-07-25: </strong> <a href="https://www.codedump.info/post/20200725-boltdb-3/">boltdb 1.3.0实现分析（三）</a>  </li><li><strong> 2020-07-11: </strong> <a href="https://www.codedump.info/post/20200711-boltdb-2/">boltdb 1.3.0实现分析（二）</a>  </li><li><strong> 2020-06-25: </strong> <a href="https://www.codedump.info/post/20200625-boltdb-1/">boltdb 1.3.0实现分析（一）</a>  </li><li><strong> 2020-06-15: </strong> <a href="https://www.codedump.info/post/20200615-btree-2/">B树、B&#43;树索引算法原理（下）</a>  </li><li><strong> 2020-06-09: </strong> <a href="https://www.codedump.info/post/20200609-btree-1/">B树、B&#43;树索引算法原理（上）</a>  </li><li><strong> 2019-02-15: </strong> <a href="https://www.codedump.info/post/20190215-leveldb/">Leveldb代码阅读笔记</a>  </li>
<h1>微信公众号</h1>

<img align="center" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">

<footer class="post-footer">
  <div class="post-tags">
      
      <a href="/tags/%E5%AD%98%E5%82%A8/">存储</a>
      
      <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</a>
      
      <a href="/tags/sqlite/">sqlite</a>
      
      <a href="/tags/btree/">btree</a>
      
    </div>



      
      <nav class="post-nav">
        
          <a class="prev" href="/post/20200122-series-pages/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">博客系列文章索引</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/20211217-sqlite-btree-0/">
            <span class="next-text nav-default">sqlite3.36版本 btree实现（零）- 起步及概述</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>


  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

	
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
          repo="lichuang/lichuang.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
    </script>
  </div>    
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/lichuang" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/lichuang" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/codedump" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/Lichuang/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://www.codedump.info/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2018 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">codedump</span>
  </span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?f23d5f22e2f2472e1e8f23afb0523e40";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
