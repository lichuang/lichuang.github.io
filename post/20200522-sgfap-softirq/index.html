<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="codedump">

  
  
  <meta name="description" content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 中断（interrupt）通常被定义为一">
  

  
  <link rel="icon" href="https://www.codedump.info/favicon.ico">

  
  
  <meta name="keywords" content=" linux  systemtap ">
  

  
  

  
  <meta property="og:title" content="《面向应用开发者的系统指南》CPU篇之软中断" />
<meta property="og:description" content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 中断（interrupt）通常被定义为一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20200522-sgfap-softirq/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-22T21:52:58+08:00" />
<meta property="article:modified_time" content="2020-05-22T21:52:58+08:00" />



  
  <link rel="canonical" href="https://www.codedump.info/post/20200522-sgfap-softirq/">

  
  
  <meta itemprop="name" content="《面向应用开发者的系统指南》CPU篇之软中断">
<meta itemprop="description" content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 中断（interrupt）通常被定义为一"><meta itemprop="datePublished" content="2020-05-22T21:52:58+08:00" />
<meta itemprop="dateModified" content="2020-05-22T21:52:58+08:00" />
<meta itemprop="wordCount" content="5359">
<meta itemprop="keywords" content="Linux系统," />

  
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/content.css'>

  
  
  <title>《面向应用开发者的系统指南》CPU篇之软中断 - codedump的网络日志</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《面向应用开发者的系统指南》CPU篇之软中断"/>
<meta name="twitter:description" content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 中断（interrupt）通常被定义为一"/>


  
<link rel="stylesheet" href='https://www.codedump.info/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://www.codedump.info">codedump的网络日志</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">归档</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/tags/">标签</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/categories/">分类</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/20200122-series-pages/">系列文章索引</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/about">关于</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/weekly">周刊</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="https://www.codedump.info/index.xml">订阅</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>《面向应用开发者的系统指南》CPU篇之软中断</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://www.codedump.info/tags/linux%E7%B3%BB%E7%BB%9F'>#Linux系统</a>
    
  </div>
  
  
  <article class="content">
    
    <blockquote>
<p>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见<a href="https://www.codedump.info/post/20200501-system-guide-for-application-programmer/">《面向应用开发者的系统指南》导论</a>。</p>
</blockquote>
<h1 id="概述">概述</h1>
<p>中断（interrupt）通常被定义为一个事件，该事件改变处理器执行的指令顺序。中断分为同步和异步两种：</p>
<ul>
<li>同步中断在指令执行时由CPU控制单元产生，之所以称为同步，是因为只有在一条指令终止执行后CPU才发生中断。</li>
<li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li>
</ul>
<p>在Intel的处理器手册中，将同步中断称为“异常（exception）”，异步中断称为“中断”。</p>
<p>异常通常由程序的错误产生，或者是由内核必须处理的异常条件产生的。比如程序中有除零异常，比如进程运行过程中产生的“缺页异常（pagefault）”等，都属于异常。</p>
<p>而中断是由定时器和I/O设备产生的，比如用户的一次按键、网卡收到数据，都会产生中断。</p>
<p><img src="/media/imgs/20200522-sgfap-softirq/interrupt-type.png" alt="interrupt-type" title="interrupt-type"></p>
<p>处理器一旦收到中断，就必须打断当前的执行，转而去执行中断处理函数。中断处理函数，本身有一些缺陷：</p>
<ul>
<li>不能在进程上下文中执行，因此不能阻塞。</li>
<li>中断处理程序会打断程序执行，为了避免这个打断的流程停止时间过长，所以应该执行的越短越好。</li>
</ul>
<p>因为以上的原因，Linux内核将中断的处理分为了上下两部分，其中上半部就是前面提到的中断处理函数，这部分能够最快的响应中断，并且做一些中断后必须要做的事情，而一些可以在中断处理函数后继续执行的操作，则可以放在下半部中。</p>
<p>以网卡接收到数据来举例，网卡通过中断告诉内核有数据可以接收，此时内核就会到网卡的中断处理程序中执行一些网卡硬件的必要设置，而对应的下半部就是处理网卡收到的数据，因为处理网卡数据没有必要在中断处理函数里面马上执行。</p>
<p>两者的主要区别在于：中断不能被相同类型的中断打断，而下半部依然可以被中断打断；中断对于时间非常敏感，而下半部基本上都是一些可以延迟的工作。由于二者的这种区别，所以对于一个工作是放在上半部还是放在下半部去执行，可以参考下面4条：</p>
<ul>
<li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li>
<li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li>
<li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li>
<li>其他所有任务，考虑放在下半部去执行。</li>
</ul>
<p>有写内核任务需要延后执行，因此才有的下半部，进而实现了三种实现下半部的方法。这就是本文要讨论的软中断、tasklet和工作队列。</p>
<h1 id="软中断">软中断</h1>
<p>软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）。软中断一般是“可延迟函数”的总称，有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：</p>
<p>产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断(即单个cpu上软中断不能嵌套执行)，只能被硬件中断打断（上半部）。
可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保其数据结构。</p>
<h2 id="数据结构">数据结构</h2>
<p>软中断由系统在启动的时候注册到内核中，由一个全局数组来维护软中断：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> softirq_action
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">void</span>	(<span style="color:#666">*</span>action)(<span style="color:#a2f;font-weight:bold">struct</span> softirq_action <span style="color:#666">*</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#a2f;font-weight:bold">struct</span> softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
</span></span></code></pre></div><p>可以看到，本质上结构体softirq_action存储的是函数指针而已，软中断有以下类型：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">enum</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HI_SOFTIRQ<span style="color:#666">=</span><span style="color:#666">0</span>,     <span style="color:#080;font-style:italic">// 处理高优先级的tasklet
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	TIMER_SOFTIRQ,    <span style="color:#080;font-style:italic">// 定时器的下半部
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	NET_TX_SOFTIRQ,   <span style="color:#080;font-style:italic">// 网卡发送数据包
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	NET_RX_SOFTIRQ,   <span style="color:#080;font-style:italic">// 网卡接收数据包
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	BLOCK_SOFTIRQ,    <span style="color:#080;font-style:italic">// BLOCK装置     
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	IRQ_POLL_SOFTIRQ, 
</span></span><span style="display:flex;"><span>	TASKLET_SOFTIRQ,  <span style="color:#080;font-style:italic">// 处理常规的tasklet
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	SCHED_SOFTIRQ,
</span></span><span style="display:flex;"><span>	HRTIMER_SOFTIRQ, 
</span></span><span style="display:flex;"><span>	RCU_SOFTIRQ,
</span></span><span style="display:flex;"><span>	NR_SOFTIRQS
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>系统提供了open_softirq函数用于各个需要使用到软中断的系统注册对应的软中断处理函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">open_softirq</span>(<span style="color:#0b0;font-weight:bold">int</span> nr, <span style="color:#0b0;font-weight:bold">void</span> (<span style="color:#666">*</span>action)(<span style="color:#a2f;font-weight:bold">struct</span> softirq_action <span style="color:#666">*</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	softirq_vec[nr].action <span style="color:#666">=</span> action;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同时，还提供了softirq_to_name数组，用于把软中断的索引映射到对应的软中断名称：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">*</span> <span style="color:#a2f;font-weight:bold">const</span> softirq_to_name[NR_SOFTIRQS] <span style="color:#666">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#b44">&#34;HI&#34;</span>, <span style="color:#b44">&#34;TIMER&#34;</span>, <span style="color:#b44">&#34;NET_TX&#34;</span>, <span style="color:#b44">&#34;NET_RX&#34;</span>, <span style="color:#b44">&#34;BLOCK&#34;</span>, <span style="color:#b44">&#34;IRQ_POLL&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#b44">&#34;TASKLET&#34;</span>, <span style="color:#b44">&#34;SCHED&#34;</span>, <span style="color:#b44">&#34;HRTIMER&#34;</span>, <span style="color:#b44">&#34;RCU&#34;</span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在Linux下面，可以通过查看<code>/proc/softirqs</code>文件知道当前系统软中断的情况：</p>
<pre tabindex="0"><code>$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:     276180     286764    2509097     254357
       TIMER:    1550133    1285854    1440533    1812909
      NET_TX:     102895         16         15         57
      NET_RX:        155        178        115    1619192
       BLOCK:       1713      15048     251826       1082
    IRQ_POLL:          0          0          0          0
     TASKLET:          9         63          6       2830
       SCHED:    1484942    1207449    1310735    1724911
     HRTIMER:          0          0          0          0
         RCU:     690954     685825     787447     878963
</code></pre><h2 id="触发软中断">触发软中断</h2>
<p>触发软中断的入口函数是raise_softirq：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">raise_softirq</span>(<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">int</span> nr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">long</span> flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	local_irq_save(flags);
</span></span><span style="display:flex;"><span>	raise_softirq_irqoff(nr);
</span></span><span style="display:flex;"><span>	local_irq_restore(flags);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先，由于调用软中断处理函数必须禁用中断，所以local_irq_save宏将保存在eflags寄存器中的IF标志，同时禁用本地处理器的中断。对应的，local_irq_restore宏将保存下来的flags标志位恢复回去，同时打开本地处理器的中断。</p>
<p>接着看raise_softirq_irqoff函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">inline</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">raise_softirq_irqoff</span>(<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">int</span> nr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__raise_softirq_irqoff(nr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>in_interrupt())
</span></span><span style="display:flex;"><span>		wakeup_softirqd();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>首先，调用<code>__raise_softirq_irqoff</code>将本地处理器的中<code>__softirq_pending</code>变量对应nr这个软中断的位置为1，表示该类型的软中断被触发了。</p>
</li>
<li>
<p>然后，通过<code>in_interrupt</code>函数来判断处理器当前是否在处理中断状态，如果没有则调用<code>wakeup_softirqd</code>函数唤醒本处理器的<code>ksoftirqd</code>内核进程：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">wakeup_softirqd</span>(<span style="color:#0b0;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> task_struct <span style="color:#666">*</span>tsk <span style="color:#666">=</span> __this_cpu_read(ksoftirqd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (tsk <span style="color:#666">&amp;&amp;</span> tsk<span style="color:#666">-&gt;</span>state <span style="color:#666">!=</span> TASK_RUNNING)
</span></span><span style="display:flex;"><span>		wake_up_process(tsk);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在Linux系统中，每个CPU都会运行一个<code>ksoftirqd</code>内核进程，专门由这个进程来处理本CPU的软中断。<code>ksoftirqd</code>内核进程的主要流程在函数<code>__do_softirq</code>中完成，其核心是一个循环，用来检测当前有哪些未处理的软中断，调用其注册的处理函数来处理软中断：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>asmlinkage __visible <span style="color:#0b0;font-weight:bold">void</span> __softirq_entry <span style="color:#00a000">__do_softirq</span>(<span style="color:#0b0;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">while</span> ((softirq_bit <span style="color:#666">=</span> ffs(pending))) {
</span></span><span style="display:flex;"><span>		trace_softirq_entry(vec_nr);	<span style="color:#080;font-style:italic">// 记录开始处理软中断的trace event
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		h<span style="color:#666">-&gt;</span>action(h);									<span style="color:#080;font-style:italic">// 调用注册的软中断处理函数
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		trace_softirq_exit(vec_nr);		<span style="color:#080;font-style:italic">// 记录结束处理软中断的trace event
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/media/imgs/20200522-sgfap-softirq/softirq.png" alt="softirq" title="softirq"></p>
<p>总结来说，要触发一个软中断只需要以下几步：</p>
<ol>
<li>保存IF标志，禁用中断。</li>
<li>将这个软中断对应的位置为1。</li>
<li>通知本CPU的ksoftirqd内核进程，有软中断需要处理。</li>
<li>恢复IF标志，开启中断。</li>
</ol>
<p>可以看到，有了软中断机制，内核在禁用中断的状态中实际上并没有耗费太多时间，仅仅修改了一个标记然后唤醒<code>ksoftirqd</code>内核进程就可以返回了。</p>
<h1 id="tasklet">tasklet</h1>
<p>软中断有以下问题：</p>
<ul>
<li>只能在系统启动时注册，另外数量和类型不能动态变更。</li>
<li>因为每个处理器上都有一个<code>ksoftirqd</code>内核进程，可能同时在处理同一种类型的软中断，软中断必须实现为可重入函数，导致开发上的复杂度提高。如果某种应用并不需要在多个CPU上并行执行，那么软中断是没有必要的。</li>
</ul>
<p>因此基于软中断之上又实现tasklet，这是最常见的实现延迟中断处理的机制。它具有以下特性：</p>
<ul>
<li>一种类型的tasklet只能运行在一个CPU上，不能并行而只能串行执行。</li>
<li>多个不同类型的tasklet可以并行在多个CPU上。</li>
<li>软中断是静态，只能支持有限的几种软中断类型，一旦内核编译好之后就不能改变；而tasklet灵活很多，可以通过添加内核模块的方式在运行时修改。</li>
</ul>
<p>tasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行。</p>
<p>首先来看初始化，对应的是softirq_init函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> __init <span style="color:#00a000">softirq_init</span>(<span style="color:#0b0;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">int</span> cpu;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	for_each_possible_cpu(cpu) {
</span></span><span style="display:flex;"><span>		per_cpu(tasklet_vec, cpu).tail <span style="color:#666">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#666">&amp;</span>per_cpu(tasklet_vec, cpu).head;
</span></span><span style="display:flex;"><span>		per_cpu(tasklet_hi_vec, cpu).tail <span style="color:#666">=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#666">&amp;</span>per_cpu(tasklet_hi_vec, cpu).head;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
</span></span><span style="display:flex;"><span>	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看到，tasklet各有一个基于TASKLET_SOFTIRQ和HI_SOFTIRQ两个类型软中断的tasklet，这两个类型分别对应低优先级和高优先级的tasklet，变量tasklet_vec和tasklet_hi_vec的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> tasklet_head {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">*</span>head;
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">**</span>tail;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#00a000">DEFINE_PER_CPU</span>(<span style="color:#a2f;font-weight:bold">struct</span> tasklet_head, tasklet_vec);
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#00a000">DEFINE_PER_CPU</span>(<span style="color:#a2f;font-weight:bold">struct</span> tasklet_head, tasklet_hi_vec);
</span></span></code></pre></div><p>这两个变量分别定义了两个存储tasklet_struct结构体的链表。结构体tasklet_struct定义如下：</p>
<pre tabindex="0"><code>struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state;
	atomic_t count;
	void (*func)(unsigned long);
	unsigned long data;
};
</code></pre><p>其中包含了五个成员变量，分别是：</p>
<ul>
<li>struct tasklet_struct *next：链表中下一个成员的指针。</li>
<li>unsigned long state：tasklet的状态。</li>
<li>atomic_t count：原子变量，表示这个tasklet当前是否活跃。</li>
<li>void (*func)(unsigned long)：处理这个tasklet的回调函数。</li>
<li>unsigned long data：回调函数参数。</li>
</ul>
<h2 id="触发tasklet">触发tasklet</h2>
<p>内核通过函数tasklet_schedule触发一个tasklet被执行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#a2f;font-weight:bold">inline</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">tasklet_schedule</span>(<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">*</span>t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>test_and_set_bit(TASKLET_STATE_SCHED, <span style="color:#666">&amp;</span>t<span style="color:#666">-&gt;</span>state))
</span></span><span style="display:flex;"><span>		__tasklet_schedule(t);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先，使用test_and_set_bit函数判断t-&gt;state中的TASKLET_STATE_SCHED是否被置为1，如果没有则调用函数__tasklet_schedule调度tasklet来执行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">__tasklet_schedule</span>(<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">*</span>t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">long</span> flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	local_irq_save(flags);
</span></span><span style="display:flex;"><span>	t<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>__this_cpu_read(tasklet_vec.tail) <span style="color:#666">=</span> t;
</span></span><span style="display:flex;"><span>	__this_cpu_write(tasklet_vec.tail, <span style="color:#666">&amp;</span>(t<span style="color:#666">-&gt;</span>next));
</span></span><span style="display:flex;"><span>	raise_softirq_irqoff(TASKLET_SOFTIRQ);
</span></span><span style="display:flex;"><span>	local_irq_restore(flags);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该函数首先和前面软中断的处理一样，保存IF标志位同时禁用中断，然后修改tasklet_vec链表将新增的tasklet添加到链表尾部，调用raise_softirq_irqoff触发TASKLET_SOFTIRQ类型的软中断执行，最后恢复IF标志位同时启用中断。</p>
<p>在函数softirq_init中，两类用于处理tasklet的处理函数分别是：</p>
<pre tabindex="0"><code>	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
</code></pre><p>接着看函数tasklet_action的实现，其核心就是从前面的链表中依次取出tasklet_struct结构体数据调用其处理函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/softirq.c
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">static</span> __latent_entropy <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">tasklet_action</span>(<span style="color:#a2f;font-weight:bold">struct</span> softirq_action <span style="color:#666">*</span>a)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">*</span>list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">while</span> (list) {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">struct</span> tasklet_struct <span style="color:#666">*</span>t <span style="color:#666">=</span> list;
</span></span><span style="display:flex;"><span>		t<span style="color:#666">-&gt;</span>func(t<span style="color:#666">-&gt;</span>data);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该函数的工作流程是：</p>
<ol>
<li>调用local_irq_disable禁用本地CPU的中断。</li>
<li>从tasklet_vec链表头取出头元素list。</li>
<li>调用local_irq_enable启用本地CPU的中断。</li>
<li>接着，就是遍历整个tasklet_vec链表，依次处理这些tasklet了。每次取出一个tasklet的时候，也是像前面一样应用本地CPU的中断，取出之后再开启中断。</li>
</ol>
<h1 id="workqueue">workqueue</h1>
<p>workqueue是另外一种延迟处理中断的机制。与tasklet相比，两者有以下的区别：</p>
<ul>
<li>workqueue函数运行在内核进程上下文中（context of kernel process），而tasklet运行在中断上下文中。</li>
<li>tasklet都在它最初被触发的CPU中执行，而workqueue则没有这个限制。</li>
<li>如果处理函数执行过程中需要睡眠和阻塞，那就必须使用工作队列了。软中断运行在中断上下文中，因此不能阻塞和睡眠，而tasklet使用软中断实现，所以也不能阻塞和睡眠。</li>
</ul>
<h2 id="数据结构-1">数据结构</h2>
<p>内核使用结构体worker_pool来管理所有CPU上面的worker，在这里仅列举其中的一部分成员：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/workqueue.c
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">struct</span> worker_pool {
</span></span><span style="display:flex;"><span>	spinlock_t		lock;		<span style="color:#080;font-style:italic">/* the pool lock */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">int</span>			cpu;		<span style="color:#080;font-style:italic">/* I: the associated cpu */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">int</span>			node;		<span style="color:#080;font-style:italic">/* I: the associated node ID */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">int</span>			id;		<span style="color:#080;font-style:italic">/* I: pool ID */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">int</span>		flags;		<span style="color:#080;font-style:italic">/* X: flags */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">long</span>		watchdog_ts;	<span style="color:#080;font-style:italic">/* L: watchdog timestamp */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> list_head	worklist;	<span style="color:#080;font-style:italic">/* L: list of pending works */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">int</span>			nr_workers;	<span style="color:#080;font-style:italic">/* L: total number of workers */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	....
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>worker_pool中管理的每个worker如下定义：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/workqueue_internal.h
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">struct</span> worker {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">/* on idle list while idle, on busy hash table while busy */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">union</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">struct</span> list_head	entry;	<span style="color:#080;font-style:italic">/* L: while idle */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">struct</span> hlist_node	hentry;	<span style="color:#080;font-style:italic">/* L: while busy */</span>
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> work_struct	<span style="color:#666">*</span>current_work;	<span style="color:#080;font-style:italic">/* L: work being processed */</span>
</span></span><span style="display:flex;"><span>	work_func_t		current_func;	<span style="color:#080;font-style:italic">/* L: current_work&#39;s fn */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> pool_workqueue	<span style="color:#666">*</span>current_pwq; <span style="color:#080;font-style:italic">/* L: current_work&#39;s pwq */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">bool</span>			desc_valid;	<span style="color:#080;font-style:italic">/* -&gt;desc is valid */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">struct</span> list_head	scheduled;	<span style="color:#080;font-style:italic">/* L: scheduled works */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	....
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>每个CPU上运行的kworker进程：</p>
<pre tabindex="0"><code>$ ps aux | grep kworker
root         4  0.0  0.0      0     0 ?        I&lt;   1月30   0:00 [kworker/0:0H]
root        18  0.0  0.0      0     0 ?        I&lt;   1月30   0:00 [kworker/1:0H]
root        24  0.0  0.0      0     0 ?        I&lt;   1月30   0:00 [kworker/2:0H]
</code></pre><h2 id="添加任务到workqueue">添加任务到workqueue</h2>
<p>内核提供函数queue_work将任务放入workqueue中：</p>
<pre tabindex="0"><code>// include/linux/workqueue.h
static inline bool queue_work(struct workqueue_struct *wq,
			      struct work_struct *work)
{
	return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
</code></pre><p>接着看函数queue_work_on：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/workqueue.c
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">queue_work_on</span>(<span style="color:#0b0;font-weight:bold">int</span> cpu, <span style="color:#a2f;font-weight:bold">struct</span> workqueue_struct <span style="color:#666">*</span>wq,
</span></span><span style="display:flex;"><span>		   <span style="color:#a2f;font-weight:bold">struct</span> work_struct <span style="color:#666">*</span>work)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">bool</span> ret <span style="color:#666">=</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#0b0;font-weight:bold">unsigned</span> <span style="color:#0b0;font-weight:bold">long</span> flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	local_irq_save(flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
</span></span><span style="display:flex;"><span>		__queue_work(cpu, wq, work);
</span></span><span style="display:flex;"><span>		ret <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	local_irq_restore(flags);
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它做的事情很简单，同样也是前后禁用、启用中断，在判断WORK_STRUCT_PENDING_BIT被置为1失败之后，调用__queue_work将任务放入workqueue：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">__queue_work</span>(<span style="color:#0b0;font-weight:bold">int</span> cpu, <span style="color:#a2f;font-weight:bold">struct</span> workqueue_struct <span style="color:#666">*</span>wq,
</span></span><span style="display:flex;"><span>			 <span style="color:#a2f;font-weight:bold">struct</span> work_struct <span style="color:#666">*</span>work)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (req_cpu <span style="color:#666">==</span> WORK_CPU_UNBOUND)
</span></span><span style="display:flex;"><span>		cpu <span style="color:#666">=</span> wq_select_unbound_cpu(raw_smp_processor_id());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>(wq<span style="color:#666">-&gt;</span>flags <span style="color:#666">&amp;</span> WQ_UNBOUND))
</span></span><span style="display:flex;"><span>		pwq <span style="color:#666">=</span> per_cpu_ptr(wq<span style="color:#666">-&gt;</span>cpu_pwqs, cpu);
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>		pwq <span style="color:#666">=</span> unbound_pwq_by_node(wq, cpu_to_node(cpu));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	insert_work(pwq, work, worklist, work_flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>这里裁剪掉无关的代码，来看核心的部分：</p>
<ul>
<li>首先，如果work加入时未指定要运行的CPU，通过wq_select_unbound_cpu进行选择，默认使用当前CPU。如果该CPU不在wq_unbound_cpumask (全局 cpumask)内，则从wq_unbound_cpumask中通过round robin方式选择。</li>
<li>对于 bound workqueue ，取出当前 per CPU变量中的pool_workqueue 。对于unbound workqueue，取出当前CPU 所在node对应的pool_workqueue。</li>
</ul>
<p>在kwork内核进程内部，最终会在函数<code>process_one_work</code>中处理work：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// kernel/workqueue.c
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">process_one_work</span>(<span style="color:#a2f;font-weight:bold">struct</span> worker <span style="color:#666">*</span>worker, <span style="color:#a2f;font-weight:bold">struct</span> work_struct <span style="color:#666">*</span>work)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	trace_workqueue_execute_start(work);	<span style="color:#080;font-style:italic">// 记录开始处理work的trace event
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	worker<span style="color:#666">-&gt;</span>current_func(work);						<span style="color:#080;font-style:italic">// 调用work的处理函数
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	trace_workqueue_execute_end(work);		<span style="color:#080;font-style:italic">// 记录结束处理work的trace event
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><h1 id="使用systemtap追踪软中断">使用systemtap追踪软中断</h1>
<p><code>systemtap</code>上提供了可以跟踪软中断以及工作队列的<code>probe</code>事件，可以在<code>systemtap</code>的<code>tapset\linux\irq.stp</code>中看到相关的定义，比较简单这里就不做解释，这里仅列举网上看到的一个使用这些tapset来追踪软中断事件的例子：</p>
<pre tabindex="0"><code>global hard, soft, wq
 
// 记录硬中断
probe irq_handler.entry {
  hard[irq, dev_name]++;
}
 
// 每隔一秒打印中断、软中断、工作队列的统计信息
probe timer.s(1) {
  println(&#34;==irq number:dev_name&#34;)
  foreach( [irq, dev_name] in hard- limit 5) {
    printf(&#34;%d,%s-&gt;%d\n&#34;, irq, kernel_string(dev_name), hard[irq, dev_name]);       
  }
 
  println(&#34;==softirq cpu:h:vec:action&#34;)
  foreach(  in soft- limit 5) {
    printf(&#34;%d:%x:%x:%s-&gt;%d\n&#34;, c, h, vec, symdata(action), soft);       
  }
 
  println(&#34;==workqueue wq_thread:work_func&#34;)
  foreach( [wq_thread,work_func] in wq- limit 5) {
    printf(&#34;%x:%x-&gt;%d\n&#34;, wq_thread, work_func, wq[wq_thread, work_func]);  
  }
 
  println(&#34;\n&#34;)
  delete hard
  delete soft
  delete wq
}
 
// 统计软中断
probe softirq.entry {
  soft[cpu(), h,vec,action]++;
}
 
// 统计工作队列执行信息
probe workqueue.execute {
  wq[wq_thread, work_func]++
}
 
 
probe begin {
  println(&#34;~&#34;)
}
</code></pre><h1 id="参考文献">参考文献</h1>
<ul>
<li><a href="https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html">Redis 高负载下的中断优化</a></li>
<li><a href="http://blog.yufeng.info/archives/2037">MYSQL数据库网卡软中断不平衡问题及解决方案</a></li>
<li><a href="https://www.cnblogs.com/alantu2018/p/8527205.html">Linux内核中的软中断、tasklet和工作队列详解</a></li>
</ul>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://www.codedump.info/post/20200516-sgfap-syscall/">← prev</a>
    
    
    <a class="link" href="https://www.codedump.info/post/20200605-how-to-read-code-v2020/">next →</a>
    
  </div>

    
<h1>相关文章</h1>
<li><strong> 20069-06-20: </strong> <a href="https://www.codedump.info/post/20200620-sgfap-loadavg/">《面向应用开发者的系统指南》CPU篇之Linux系统平均负载</a>  </li><li><strong> 16059-05-16: </strong> <a href="https://www.codedump.info/post/20200516-sgfap-syscall/">《面向应用开发者的系统指南》CPU篇之系统调用</a>  </li><li><strong> 3059-05-03: </strong> <a href="https://www.codedump.info/post/20200503-sgfap-process-systemtap/">《面向应用开发者的系统指南》CPU篇之使用systemtap分析进程的行为</a>  </li><li><strong> 3059-05-03: </strong> <a href="https://www.codedump.info/post/20200503-sgfap-process-schedule/">《面向应用开发者的系统指南》CPU篇之进程调度</a>  </li><li><strong> 2059-05-02: </strong> <a href="https://www.codedump.info/post/20200502-sgfap-process/">《面向应用开发者的系统指南》CPU篇之进程</a>  </li>
<h1>邮件订阅</h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>

<img align="center" src="https://www.codedump.info/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">
    <footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux%E7%B3%BB%E7%BB%9F/">Linux系统</a>
          </div><div class="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lichuang-codedump" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    
    

        <script src="https://utteranc.es/client.js"
            repo="{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
  

  </div>

  <main id="main" class="main">
    <div class="content-wrapper">
      <div id="content" class="content">
        
      </div>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
    <script src="https://utteranc.es/client.js"
            repo="lichuang/lichuang.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
  </main>


  
</main>

    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/lichuang>GitHub</a>,
<a class=link href=https://twitter.com/lichuang>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  



  
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>

</html>
