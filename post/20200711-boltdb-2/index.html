<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="codedump">

  
  
  <meta name="description" content="boltdb 1.3.0实现分析">
  

  
  <link rel="icon" href="https://www.codedump.info/favicon.ico">

  
  
  <meta name="keywords" content=" boltdb  存储引擎 ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:title" content="boltdb 1.3.0实现分析（二）" />
<meta property="og:description" content="boltdb 1.3.0实现分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20200711-boltdb-2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-11T09:33:06+08:00" />
<meta property="article:modified_time" content="2020-07-11T09:33:06+08:00" />



  
  <link rel="canonical" href="https://www.codedump.info/post/20200711-boltdb-2/">

  
  
  <meta itemprop="name" content="boltdb 1.3.0实现分析（二）">
<meta itemprop="description" content="boltdb 1.3.0实现分析"><meta itemprop="datePublished" content="2020-07-11T09:33:06+08:00" />
<meta itemprop="dateModified" content="2020-07-11T09:33:06+08:00" />
<meta itemprop="wordCount" content="4014">
<meta itemprop="keywords" content="存储,存储引擎," />

  
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/content.css'>

  
  
  <title>boltdb 1.3.0实现分析（二） - codedump的网络日志</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="boltdb 1.3.0实现分析（二）"/>
<meta name="twitter:description" content="boltdb 1.3.0实现分析"/>


  
<link rel="stylesheet" href='https://www.codedump.info/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://www.codedump.info">codedump的网络日志</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">发表</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/20200122-series-pages/">系列文章索引</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/weekly">周刊</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="https://www.codedump.info/index.xml">订阅</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/about">关于</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>boltdb 1.3.0实现分析（二）</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8'>#存储</a>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E'>#存储引擎</a>
    
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#bucket结构体定义">Bucket结构体定义</a></li>
    <li><a href="#子bucket">子Bucket</a></li>
    <li><a href="#inline-page">inline page</a></li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <blockquote>
<p>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结构体。关于etcd、raft协议以及B+树，可以参考之前的文章：</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<blockquote>
<p>本文的写作，主要参考了<a href="https://www.jianshu.com/p/b86a69892990">《区块的持久化之BoltDB》系列文章</a>以及<a href="https://youjiali1995.github.io/storage/boltdb">boltdb 源码分析</a></p>
</blockquote>
<p>在<a href="https://www.codedump.info/post/20200625-boltdb-1/">上一节</a>里面，系统的介绍了Boltdb中几种类型页面的格式，有了这些基础，本节开始介绍boltdb中的Bucket结构。</p>
<h1 id="bucket">Bucket</h1>
<h2 id="概述">概述</h2>
<p>在上一节中，Bucket类比于mysql中的table，在boltdb中，<code>meta</code>页面中有一个成员<code>bucket</code>，其存储了整个数据库根bucket的信息，而一个数据库中存储的其他table的信息，则作为子bucket存储到Bucket中。这几个数据结构的关系如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> DB <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	meta0    <span style="color:#666">*</span>meta
</span></span><span style="display:flex;"><span>	meta1    <span style="color:#666">*</span>meta  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> meta <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	root     bucket	<span style="color:#080;font-style:italic">// 根bucket的信息
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> Bucket <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>bucket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  buckets  <span style="color:#a2f;font-weight:bold">map</span>[<span style="color:#0b0;font-weight:bold">string</span>]<span style="color:#666">*</span>Bucket <span style="color:#080;font-style:italic">// 存储子bucket的对应关系
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> bucket <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 根节点的page id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	root pgid <span style="color:#080;font-style:italic">// page id of the bucket&#39;s root-level page
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 单调递增的序列号
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	sequence <span style="color:#0b0;font-weight:bold">uint64</span> <span style="color:#080;font-style:italic">// monotonically incrementing, used by NextSequence()
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>在<code>bucket</code>数据结构中，两个成员的作用是：</p>
<ul>
<li>root：该bucket的根节点的page id。</li>
<li>sequence：该bucket当前的序列号，单调递增，在函数<code>NextSequence</code>中使用。</li>
</ul>
<p>每个<code>Bucket</code>数据结构，都继承自<code>bucket</code>，同时其中的<code>buckets</code>存储了该<code>Bucket</code>中子Bucket名字的对应关系。</p>
<p>最后，<code>meta</code>页面的<code>root</code>成员，存储的就是这个db的根<code>bucket</code>页面信息。这几个数据结构之间的关系如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200711-boltdb-2/buckets.png" alt="buckets" title="buckets"></p>
<p>在上图中：</p>
<ul>
<li><code>DB</code>结构体是表示整一个boltdb数据库的结构体，其中有<code>meta0</code>和<code>meta1</code>两个<code>meta</code>类型的成员，用于保存<code>meta</code>页面信息。</li>
<li><code>meta</code>页面中，其中的<code>root</code>是一个<code>bucket</code>类型成员，保存了根bucket的页面信息。</li>
<li>根据<code>bucket</code>中的页面信息，就能找到DB的根<code>Bucket</code>信息，其中的<code>buckets</code>成员保存了该数据库中所有子<code>bucket</code>名字与实体之间的映射关系。</li>
</ul>
<h2 id="bucket结构体定义">Bucket结构体定义</h2>
<p>接下来介绍<code>Bucket</code>结构体成员，其定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> Bucket <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>bucket
</span></span><span style="display:flex;"><span>	tx       <span style="color:#666">*</span>Tx                <span style="color:#080;font-style:italic">// the associated transaction
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	buckets  <span style="color:#a2f;font-weight:bold">map</span>[<span style="color:#0b0;font-weight:bold">string</span>]<span style="color:#666">*</span>Bucket <span style="color:#080;font-style:italic">// subbucket cache
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	page     <span style="color:#666">*</span>page              <span style="color:#080;font-style:italic">// inline page reference
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	rootNode <span style="color:#666">*</span>node              <span style="color:#080;font-style:italic">// materialized node for the root page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	nodes    <span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#666">*</span>node     <span style="color:#080;font-style:italic">// node cache
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Sets the threshold for filling nodes when they split. By default,
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// the bucket will fill to 50% but it can be useful to increase this
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// amount if you know that your write workloads are mostly append-only.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// This is non-persisted across transactions so it must be set in every Tx.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	FillPercent <span style="color:#0b0;font-weight:bold">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>bucket：存储该<code>Bucket</code>所在页面ID，以及当前序列号。</li>
<li>tx：当前Bucket关联的事务。</li>
<li>buckets：前面已经介绍过，维护子<code>bucket</code>的映射关系。</li>
<li>page：存储inline页面信息。</li>
<li>rootNode：该Bucket的B+树根节点指针。</li>
<li>nodes：缓存已经读入内存的<code>page</code>对应的<code>node</code>信息。</li>
<li>FillPercent：这是一个阈值，每个节点的数据量超过该阈值时进行分裂操作，默认值为DefaultFillPercent=0.5。至于B+树分裂操作的流程，可以参考文章最开始的B+树原理链接。</li>
</ul>
<h2 id="子bucket">子Bucket</h2>
<p>按照上面的分析，一个bolt的DB存在一个唯一的根Bucket，而DB中不同的table就是该根Bucket的子Bucket，其对应关系存储在<code>Bucket.buckets</code>成员中。那么，子Bucket信息保存在哪里呢？</p>
<p>答案是保存在叶子节点，也就是<code>leafPageElement</code>中，回顾一下这个数据结构的定义：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// leafPageElement represents a node on a leaf page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">type</span> leafPageElement <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	flags <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	pos   <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	ksize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	vsize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中的<code>flags</code>成员，含义如下：</p>
<ul>
<li>0：表示就是普通的叶子节点。</li>
<li>1：表示是子bucket。</li>
</ul>
<p>即在boltdb中，子Bucket的信息，是做为一种特殊的叶子节点信息存储下来的。boltdb使用了常量来表示这种类型的叶子节点标志位：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>	bucketLeafFlag = <span style="color:#666">0x01</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>即：</p>
<ul>
<li>对于一个标志位为0的叶子页面：其内容就是B+树叶子页面的内容，存储的是数据的键值，boltdb中叶子页面的格式示意图在<a href="https://www.codedump.info/post/20200625-boltdb-1/#leaf%E9%A1%B5%E9%9D%A2">上一节中</a>已经给出。</li>
<li>对于一个标志位为1的叶子页面：其内存存储的是Bucket结构体的信息。</li>
</ul>
<p>有了以上的介绍，理解起来返回一个子Bucket的相关代码就不难了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (b <span style="color:#666">*</span>Bucket) <span style="color:#00a000">Bucket</span>(name []<span style="color:#0b0;font-weight:bold">byte</span>) <span style="color:#666">*</span>Bucket {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Move cursor to key.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 否则创建一个Cursor查询
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	c <span style="color:#666">:=</span> b.<span style="color:#00a000">Cursor</span>()
</span></span><span style="display:flex;"><span>	k, v, flags <span style="color:#666">:=</span> c.<span style="color:#00a000">seek</span>(name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Return nil if the key doesn&#39;t exist or it is not a bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 查询不到，或者不是子bucket节点，都返回nil
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> !bytes.<span style="color:#00a000">Equal</span>(name, k) <span style="color:#666">||</span> (flags<span style="color:#666">&amp;</span>bucketLeafFlag) <span style="color:#666">==</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Otherwise create a bucket and cache it.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 打开这个bucket并且cache到buckets map中
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">var</span> child = b.<span style="color:#00a000">openBucket</span>(v)
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> b.buckets <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		b.buckets[<span style="color:#a2f">string</span>(name)] = child
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> child
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (b <span style="color:#666">*</span>Bucket) <span style="color:#00a000">openBucket</span>(value []<span style="color:#0b0;font-weight:bold">byte</span>) <span style="color:#666">*</span>Bucket {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 创建一个bucket
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">var</span> child = <span style="color:#00a000">newBucket</span>(b.tx)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// If this is a writable transaction then we need to copy the bucket entry.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// Read-only transactions can point directly at the mmap entry.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> b.tx.writable {
</span></span><span style="display:flex;"><span>		child.bucket = <span style="color:#666">&amp;</span>bucket{}
</span></span><span style="display:flex;"><span>		<span style="color:#666">*</span>child.bucket = <span style="color:#666">*</span>(<span style="color:#666">*</span>bucket)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>value[<span style="color:#666">0</span>]))
</span></span><span style="display:flex;"><span>	} <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		child.bucket = (<span style="color:#666">*</span>bucket)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>value[<span style="color:#666">0</span>]))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Save a reference to the inline page if the bucket is inline.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// inline bucket
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> child.root <span style="color:#666">==</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// bucket的page
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		child.page = (<span style="color:#666">*</span>page)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>value[bucketHeaderSize]))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">&amp;</span>child
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Bucket.Bucket</code>用于根据名字返回一个子Bucket的指针，其流程如下：</p>
<ul>
<li>首先根据子Bucket名字查找到叶子页面的数据、标志位，如果查找失败，说明不存在该子Bucket；或者其标志位不是<code>bucketLeafFlag</code>，说明这个名字已经被普通数据占用，即：boltdb中不允许子Bucket与其父Bucket中写入的键同名。</li>
<li>以上查找成功，就以该叶子页面的数据为参数，调用<code>Bucket.openBucket</code>函数，根据<code>Bucket</code>结构体格式，反序列化出来<code>Bucket</code>结构体信息返回。</li>
</ul>
<h2 id="inline-page">inline page</h2>
<p>从上面的分析可以看到，子Bucket的信息是独占一个叶子页面来存储的，该页面大部分的内容都是冗余的。如果子Bucket中的数据量很少，就会造成磁盘空间的浪费。为了针对这类型Bucket进行优化，boltdb提供了<code>inline page</code>这个特殊的页面，将小的子Bucket数据存放在这里。</p>
<p>这类型的子Bucket需要满足以下两个条件：</p>
<ul>
<li>该子Bucket再没有嵌套的子Bucket了。</li>
<li>整个子Bucket的大小不能超过page size/4。</li>
</ul>
<p><code>Bucket.inlineable</code>函数就是用来做<code>inline</code>操作的判断的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// inlineable returns true if a bucket is small enough to be written inline
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// and if it contains no subbuckets. Otherwise returns false.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 返回这个bucket是否能够inline操作
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (b <span style="color:#666">*</span>Bucket) <span style="color:#00a000">inlineable</span>() <span style="color:#0b0;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">var</span> n = b.rootNode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Bucket must only contain a single leaf node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 如果没有根节点，或者根节点不是叶子节点的不能进行inline操作
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> n <span style="color:#666">==</span> <span style="color:#a2f;font-weight:bold">nil</span> <span style="color:#666">||</span> !n.isLeaf {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Bucket is not inlineable if it contains subbuckets or if it goes beyond
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// our threshold for inline bucket size.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 有子bucket，或者大小超过maxInlineBucketSize阈值的，都不能进行inline操作
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">var</span> size = pageHeaderSize
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">for</span> _, inode <span style="color:#666">:=</span> <span style="color:#a2f;font-weight:bold">range</span> n.inodes {
</span></span><span style="display:flex;"><span>		size <span style="color:#666">+=</span> leafPageElementSize <span style="color:#666">+</span> <span style="color:#a2f">len</span>(inode.key) <span style="color:#666">+</span> <span style="color:#a2f">len</span>(inode.value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> inode.flags<span style="color:#666">&amp;</span>bucketLeafFlag <span style="color:#666">!=</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> size &gt; b.<span style="color:#00a000">maxInlineBucketSize</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Returns the maximum total size of a bucket to make it a candidate for inlining.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (b <span style="color:#666">*</span>Bucket) <span style="color:#00a000">maxInlineBucketSize</span>() <span style="color:#0b0;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> b.tx.db.pageSize <span style="color:#666">/</span> <span style="color:#666">4</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="cursor">Cursor</h1>
<p>以上已经大体了解<code>Bucket</code>的结构，在boltdb查找数据流程中，还是使用了<code>Cursor</code>结构体来做为游标（iterator），保存查找流程中的中间数据，下面也来简单了解一下。</p>
<p><code>Cursor</code>结构体的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> Cursor <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	bucket <span style="color:#666">*</span>Bucket		<span style="color:#080;font-style:italic">// 对应的bucket
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	stack  []elemRef	<span style="color:#080;font-style:italic">// 存储递归遍历时中间过程的栈，由于栈是先进后出结构，所以遍历的过程中层次高的在栈的低端。
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 光标移动过程中，中间过程的信息
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">type</span> elemRef <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	page  <span style="color:#666">*</span>page	<span style="color:#080;font-style:italic">// 页面
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	node  <span style="color:#666">*</span>node	<span style="color:#080;font-style:italic">// 内存中的页面信息
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	index <span style="color:#0b0;font-weight:bold">int</span>		<span style="color:#080;font-style:italic">// 保存在当前page、node遍历到了哪个节点
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p><code>Cursor</code>有以下成员：</p>
<ul>
<li>bucket：游标操作所对应的<code>Bucket</code>指针。</li>
<li>stack：存储递归遍历过程中的栈，由于栈是先进后出结构，所以遍历的过程中层次高的节点在栈的低端。</li>
</ul>
<p>每个stack成员类型是<code>elemRef</code>，其成员如下：</p>
<ul>
<li>page：页面指针。</li>
<li>node：内存中的页面信息。</li>
<li>index：保存遍历到当前页面的索引位置。</li>
</ul>
<p>由于<code>node</code>是<code>page</code>在内存中的表示，所以实际上在<code>elemRef</code>结构体中，<code>page</code>和<code>node</code>成员同时只会有一个成员不为NULL。</p>
<p><code>Cursor</code>结构体做为一个迭代器，对外提供的就是常规迭代器所支持的操作：</p>
<ul>
<li>First：返回当前Bucket的第一个数据。</li>
<li>Last：返回当前Bucket的最后一个数据。</li>
<li>Next：返回当前游标位置的下一个数据。</li>
<li>Prev：返回当前游标位置的上一个数据。</li>
<li>Seek：查找到对应的叶子节点返回其键、值。</li>
<li>keyValue：返回当前游标位置的键、值、标志位。</li>
<li>Delete：删除当前游标位置的数据。</li>
</ul>
<p>在这里，不打算讨论其中的所有实现，如果读者对B+树的实现并不了解，可以看最开始介绍B+树原理的连接。</p>
<p>这里以<code>First</code>函数为例简单的讲解其实现，由于B+树是中序遍历的树结构，因此<code>First</code>元素一定是最左边叶子节点的左边第一个元素。带注释的代码实现如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 移动到bucket的第一个元素上，返回其key value数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (c <span style="color:#666">*</span>Cursor) <span style="color:#00a000">First</span>() (key []<span style="color:#0b0;font-weight:bold">byte</span>, value []<span style="color:#0b0;font-weight:bold">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#00a000">_assert</span>(c.bucket.tx.db <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span>, <span style="color:#b44">&#34;tx closed&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 修改stack只保存第一个stack，及栈底部
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	c.stack = c.stack[:<span style="color:#666">0</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 返回root节点的page、node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	p, n <span style="color:#666">:=</span> c.bucket.<span style="color:#00a000">pageNode</span>(c.bucket.root)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 将root节点所在的page、node信息放到栈顶，index为0，表示从第一个子节点开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	c.stack = <span style="color:#a2f">append</span>(c.stack, elemRef{page: p, node: n, index: <span style="color:#666">0</span>})
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 移动到当前的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// first函数做的事情：从树顶端开始，从最左边一直往下遍历到叶子节点为止
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 因为B树是中序遍历的，所以最左边的节点数据最小
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	c.<span style="color:#00a000">first</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// If we land on an empty page then move to the next value.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// https://github.com/boltdb/bolt/issues/450
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 如果没有元素，就移动到下一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> c.stack[<span style="color:#a2f">len</span>(c.stack)<span style="color:#666">-</span><span style="color:#666">1</span>].<span style="color:#00a000">count</span>() <span style="color:#666">==</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		c.<span style="color:#00a000">next</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 拿到k、v、flags
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	k, v, flags <span style="color:#666">:=</span> c.<span style="color:#00a000">keyValue</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 如果是子bucket，就返回k以及nil
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> (flags <span style="color:#666">&amp;</span> <span style="color:#a2f">uint32</span>(bucketLeafFlag)) <span style="color:#666">!=</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> k, <span style="color:#a2f;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> k, v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// first moves the cursor to the first leaf element under the last page in the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 找到stack最后一个页面中的第一个叶子节点
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (c <span style="color:#666">*</span>Cursor) <span style="color:#00a000">first</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">for</span> {	<span style="color:#080;font-style:italic">// 找到最左边第一个叶子节点
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// Exit when we hit a leaf page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// 每次循环取出最后一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#a2f;font-weight:bold">var</span> ref = <span style="color:#666">&amp;</span>c.stack[<span style="color:#a2f">len</span>(c.stack)<span style="color:#666">-</span><span style="color:#666">1</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> ref.<span style="color:#00a000">isLeaf</span>() {	<span style="color:#080;font-style:italic">// 如果是叶子节点就退出循环，即这个循环终止的条件是向下一直找到叶子节点为止
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>			<span style="color:#a2f;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// Keep adding pages pointing to the first element to the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// 根据ref.index拿到pgid
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#a2f;font-weight:bold">var</span> pgid pgid
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> ref.node <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			pgid = ref.node.inodes[ref.index].pgid
</span></span><span style="display:flex;"><span>		} <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			pgid = ref.page.<span style="color:#00a000">branchPageElement</span>(<span style="color:#a2f">uint16</span>(ref.index)).pgid
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 拿到对应的page、node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		p, n <span style="color:#666">:=</span> c.bucket.<span style="color:#00a000">pageNode</span>(pgid)
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 放到栈顶，注意这里的index是0
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// 即向下查找的时候取的都是最左边的节点
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		c.stack = <span style="color:#a2f">append</span>(c.stack, elemRef{page: p, node: n, index: <span style="color:#666">0</span>})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://www.codedump.info/post/20200625-boltdb-1/">← prev</a>
    
    
    <a class="link" href="https://www.codedump.info/post/20200725-boltdb-3/">next →</a>
    
  </div>

    
<h1>相关文章</h1><li><strong> 1029-02-01: </strong> <a href="https://www.codedump.info/post/20220201-sqlite-btree-5-btree/">sqlite3.36版本 btree实现（五）- Btree的实现</a>  </li><li><strong> 6019-01-06: </strong> <a href="https://www.codedump.info/post/20220106-sqlite-btree-4-wal/">sqlite3.36版本 btree实现（四）- WAL的实现</a>  </li><li><strong> 22129-12-22: </strong> <a href="https://www.codedump.info/post/20211222-sqlite-btree-3-journal/">sqlite3.36版本 btree实现（三）- journal文件备份机制</a>  </li><li><strong> 18129-12-18: </strong> <a href="https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/">sqlite3.36版本 btree实现（二）- 并发控制框架</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/">sqlite3.36版本 btree实现（一）- 管理页面缓存</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-0/">sqlite3.36版本 btree实现（零）- 起步及概述</a>  </li><li><strong> 26079-07-26: </strong> <a href="https://www.codedump.info/post/20200726-boltdb-4/">boltdb 1.3.0实现分析（四）</a>  </li><li><strong> 25079-07-25: </strong> <a href="https://www.codedump.info/post/20200725-boltdb-3/">boltdb 1.3.0实现分析（三）</a>  </li><li><strong> 25069-06-25: </strong> <a href="https://www.codedump.info/post/20200625-boltdb-1/">boltdb 1.3.0实现分析（一）</a>  </li><li><strong> 15069-06-15: </strong> <a href="https://www.codedump.info/post/20200615-btree-2/">B树、B&#43;树索引算法原理（下）</a>  </li><li><strong> 9069-06-09: </strong> <a href="https://www.codedump.info/post/20200609-btree-1/">B树、B&#43;树索引算法原理（上）</a>  </li><li><strong> 15029-02-15: </strong> <a href="https://www.codedump.info/post/20190215-leveldb/">Leveldb代码阅读笔记</a>  </li>

<h1>邮件订阅</h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>

<img align="center" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">
    <footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AD%98%E5%82%A8/">存储</a>
          <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</a>
          </div><div class="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lichuang-codedump" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    
    
    
        <script src="https://utteranc.es/client.js"
            repo="{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
  
    
  </div>

  <main id="main" class="main">
    <div class="content-wrapper">
      <div id="content" class="content">
        
      </div>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
    <script src="https://utteranc.es/client.js"
            repo="lichuang/lichuang.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
  </main>


  
</main>

    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/lichuang>GitHub</a>,
<a class=link href=https://twitter.com/lichuang>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  



  
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>

</html>
