<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>etcd Raft库解析 - codedump</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="codedump" />
  <meta name="description" content="序言 今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.48" />


<link rel="canonical" href="https://lichuang.github.io/post/20180922-etcd-raft/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="etcd Raft库解析" />
<meta property="og:description" content="序言 今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lichuang.github.io/post/20180922-etcd-raft/" /><meta property="article:published_time" content="2018-09-22T11:01:02&#43;08:00"/>
<meta property="article:modified_time" content="2018-09-22T11:01:02&#43;08:00"/>
<meta itemprop="name" content="etcd Raft库解析">
<meta itemprop="description" content="序言 今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现">


<meta itemprop="datePublished" content="2018-09-22T11:01:02&#43;08:00" />
<meta itemprop="dateModified" content="2018-09-22T11:01:02&#43;08:00" />
<meta itemprop="wordCount" content="10028">



<meta itemprop="keywords" content="etcd,Raft,分布式," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="etcd Raft库解析"/>
<meta name="twitter:description" content="序言 今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="page/about">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="page/about">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">etcd Raft库解析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-09-22 </span>
        <div class="post-category">
            
              <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"> 分布式 </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#序言">序言</a></li>
<li><a href="#输入及输出">输入及输出</a></li>
<li><a href="#raft库代码结构及核心数据结构">raft库代码结构及核心数据结构</a></li>
<li><a href="#节点状态">节点状态</a></li>
<li><a href="#选举流程">选举流程</a>
<ul>
<li><a href="#发起选举的节点">发起选举的节点</a></li>
<li><a href="#收到选举消息的节点">收到选举消息的节点</a></li>
</ul></li>
<li><a href="#集群成员变化流程">集群成员变化流程</a>
<ul>
<li><a href="#一般的成员删减">一般的成员删减</a></li>
<li><a href="#leader转让">leader转让</a></li>
</ul></li>
<li><a href="#如何做到线性一致性">如何做到线性一致性？</a>
<ul>
<li><a href="#readonlysafe方式">ReadOnlySafe方式</a></li>
</ul></li>
<li><a href="#杂项">杂项</a>
<ul>
<li><a href="#节点的几种状态">节点的几种状态</a>
<ul>
<li><a href="#progressstateprobe">ProgressStateProbe</a></li>
<li><a href="#progressstatereplicate">ProgressStateReplicate</a></li>
<li><a href="#progressstatesnapshot">ProgressStateSnapshot</a></li>
</ul></li>
<li><a href="#progress上的数据索引">Progress上的数据索引</a></li>
<li><a href="#流量控制">流量控制</a></li>
</ul></li>
<li><a href="#疑问采集">疑问采集</a>
<ul>
<li><a href="#为什么不能通过计算日志条目数量的方式来提交任期之前的日志条目">为什么不能通过计算日志条目数量的方式来提交任期之前的日志条目？</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<h1 id="序言">序言</h1>

<p>今年初开始学习了解Raft协议，论文读下来之后还是决定结合一个成熟的代码进行更深的理解。etcd做为一个非常成熟的作品，其Raft库实现也非常精妙，屏蔽了网络、存储等模块，提供接口由上层应用者来实现。</p>

<p>本篇文章解析etcd的Raft库实现，基于etcd 3.1.10版本。etcd的Raft库，位于其代码目录的Raft中。</p>

<p>我自己也单独将3.1.10的代码拉出了一个专门添加了我阅读代码注释的版本，目前Raft这部分基本都做了注释，见：
<a href="https://github.com/lichuang/etcd-3.1.10-codedump">https://github.com/lichuang/etcd-3.1.10-codedump</a></p>

<p>以下在介绍的时候，可能会混用中文和英文术语，这里先列举出来：</p>

<table>
<thead>
<tr>
<th align="left">英文</th>
<th align="right">中文</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">Term</td>
<td align="right">选举任期，每次选举之后递增1</td>
</tr>

<tr>
<td align="left">Vote</td>
<td align="right">选举投票(的ID)</td>
</tr>

<tr>
<td align="left">Entry</td>
<td align="right">Raft算法的日志数据条目</td>
</tr>

<tr>
<td align="left">candidate</td>
<td align="right">候选人</td>
</tr>

<tr>
<td align="left">leader</td>
<td align="right">领导者</td>
</tr>

<tr>
<td align="left">follower</td>
<td align="right">跟随者</td>
</tr>
</tbody>
</table>

<h1 id="输入及输出">输入及输出</h1>

<p>既然做为一个库使用，就有其确定的输入和输出接口，先来了解这部分再进行后续的展开讨论。</p>

<p>作为一个一致性算法的库，不难想象使用的一般场景是这样的：</p>

<ol>
<li>应用层接收到新的写入数据请求，向该算法库写入一个数据。</li>
<li>算法库返回是否写入成功。</li>
<li>应用层根据写入结果进行下一步的操作。</li>
</ol>

<p>然而，Raft库却相对而言更复杂一些，因为还有以下的问题存在：</p>

<ol>
<li>写入的数据，可能是集群状态变更的数据，Raft库在执行写入这类数据之后，需要返回新的状态给应用层。</li>
<li>Raft库中的数据不可能一直以日志的形式存在，这样会导致数据越来越大，所以有可能被压缩成快照（snapshot）的数据形式，这种情况下也需要返回这部分快照数据。</li>
<li>由于etcd的Raft库不包括持久化数据存储相关的模块，而是由应用层自己来做实现，所以也需要返回在某次写入成功之后，哪些数据可以进行持久化保存了。</li>
<li>同样的，etcd的Raft库也不自己实现网络传输，所以同样需要返回哪些数据需要进行网络传输给集群中的其他节点。</li>
</ol>

<p>以上的这些，集中在raft/node.go的Ready结构体中，其包括以下成员：</p>

<table>
<thead>
<tr>
<th align="left">成员名称</th>
<th align="right">类型</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">SoftState</td>
<td align="right">SoftState</td>
<td align="center">软状态，软状态易变且不需要保存在WAL日志中的状态数据，包括：集群leader、节点的当前状态</td>
</tr>

<tr>
<td align="left">HardState</td>
<td align="right">HardState</td>
<td align="center">硬状态，与软状态相反，需要写入持久化存储中，包括：节点当前Term、Vote、Commit</td>
</tr>

<tr>
<td align="left">ReadStates</td>
<td align="right">[]ReadStates</td>
<td align="center">用于读一致性的数据，后续会详细介绍</td>
</tr>

<tr>
<td align="left">Entries</td>
<td align="right">[]pb.Entry</td>
<td align="center">在向其他集群发送消息之前需要先写入持久化存储的日志数据</td>
</tr>

<tr>
<td align="left">Snapshot</td>
<td align="right">pb.Snapshot</td>
<td align="center">需要写入持久化存储中的快照数据</td>
</tr>

<tr>
<td align="left">CommittedEntries</td>
<td align="right">[]pb.Entry</td>
<td align="center">需要输入到状态机中的数据，这些数据之前已经被保存到持久化存储中了</td>
</tr>

<tr>
<td align="left">Messages</td>
<td align="right">[]pb.Message</td>
<td align="center">在entries被写入持久化存储中以后，需要发送出去的数据</td>
</tr>
</tbody>
</table>

<p>以上的成员说明，最开始看不一定能理解其含义和用法，不过在后续会慢慢展开讨论。</p>

<p>根据上面的分析，应用层在写入一段数据之后，Raft库将返回这样一个Ready结构体，其中可能某些字段是空的，毕竟不是每次改动都会导致Ready结构体中的成员都发生变化，此时使用者就需要根据情况，取出其中不为空的成员进行操作了。</p>

<p>在etcd项目中，也提供了使用Raft库的demo例子，在contrib/raftexample目录中，这里简单的演示了一下如何根据这个raft库实现一个简单的KV存储服务器，下面根据这里的代码结合着上面的Ready结构体，来分析如何使用etcd的Raft库。</p>

<p>raft库对外提供一个Node的interface，其实现有raft/node.go中的node结构体实现，这也是应用层唯一需要与这个raft库直接打交道的结构体，简单的来看看Node接口需要实现的函数：</p>

<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="right">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">Tick</td>
<td align="right">应用层每次tick时需要调用该函数，将会由这里驱动raft的一些操作比如选举等。至于tick的单位是多少由应用层自己决定，只要保证是恒定时间都会来调用一次就好了。</td>
</tr>

<tr>
<td align="left">Campaign</td>
<td align="right">调用该函数将驱动节点进入候选人状态，进而将竞争leader。</td>
</tr>

<tr>
<td align="left">Propose</td>
<td align="right">提议写入数据到日志中，可能会返回错误。</td>
</tr>

<tr>
<td align="left">ProposeConfChange</td>
<td align="right">提交配置变更</td>
</tr>

<tr>
<td align="left">Step</td>
<td align="right">将消息msg灌入状态机中</td>
</tr>

<tr>
<td align="left">Ready</td>
<td align="right">这里是核心函数，将返回Ready的channel，应用层需要关注这个channel，当发生变更时将其中的数据进行操作</td>
</tr>

<tr>
<td align="left">Advance</td>
<td align="right">Advance函数是当使用者已经将上一次Ready数据处理之后，调用该函数告诉raft库可以进行下一步的操作</td>
</tr>
</tbody>
</table>

<p>这里大部分函数在这个demo中不需要进行关心，我们只看如何对接Ready结构体就好了。</p>

<p>raftexample中，首先在main.go中创建了两个channel：</p>

<ol>
<li>proposeC：用于提交写入的数据。</li>
<li>confChangeC：用于提交配置改动数据。</li>
</ol>

<p>然后分别启动如下核心的协程：</p>

<ol>
<li>启动HTTP服务器，用于接收用户的请求数据，最终会将用户请求的数据写入前面的proposeC/confChangeC channel中。</li>
<li>启动raftNode结构体，该结构体中有上面提到的raft/node.go中的node结构体，也就是通过该结构体实现的Node接口与raft库进行交互。同时，raftNode还会启动协程监听前面的两个channel，收到数据之后通过Node接口的函数调用raft库对应的接口。</li>
</ol>

<p>以上的交互流程就很清楚了，HTTP服务负责接收用户数据，再写入到两个核心channel中，而raftNode负责监听这两个channel：</p>

<ol>
<li>如果收到proposeC channel的消息，说明有数据提交，则调用Node.Propose函数进行数据的提交。</li>
<li>如果收到confChangeC channel的消息，说明有配置变更，则调用Node.ProposeConfChange函数进行配置变更。</li>
<li>设置一个定时器tick，每次定时器到时时，调用Node.Tick函数。</li>
<li>监听Node.Ready函数返回的Ready结构体channel，有数据变更时根据Ready结构体的不同数据类型进行相应的操作，完成了之后需要调用Node.Advance函数进行收尾。</li>
</ol>

<p>将以上流程用伪代码实现如下：</p>

<pre><code class="language-Go">// HTTP server
HttpServer:
  接收用户提交的数据：
    如果是PUT请求：
      将数据写入到proposeC中
    如果是POST请求：
      将配置变更数据写入到confChangeC中

// raft Node
raftNode结构体主循环：
  如果proposeC中有数据写入：
    调用node.Propose向raft库提交数据
  如果confChangeC中有数据写入：
    调用node.Node.ProposeConfChange向raft库提交配置变更数据
  如果tick定时器到期：
    调用node.Tick函数进行raft库的定时操作
  如果node.Ready()函数返回的Ready结构体channel有数据变更：
    依次处理Ready结构体中各成员数据
    处理完毕之后调用node.Advance函数进行收尾处理
</code></pre>

<p>到了这里，已经对raft的使用有一个基本的概念了，即通过node结构体实现的Node接口与raft库进行交互，涉及数据变更的核心数据结构就是Ready结构体，接下来可以进一步来分析该库的实现了。</p>

<h1 id="raft库代码结构及核心数据结构">raft库代码结构及核心数据结构</h1>

<p>现在可以来看看raft库的代码组织了。</p>

<p>前面已经看到了raft/node.go文件中，提供出去的是Node接口及其实现node结构体，这是外界与raft库打交道的唯一接口，除此之外该路径下的其他文件并不直接与外界打交道。</p>

<p>接着是raft算法的实现文件，raft/raft.go文件，其中包含两个核心数据结构：</p>

<ol>
<li>Config：与raft算法相关的配置参数都包装在该结构体中。从这个结构体的命名是大写字母开头，就可以知道是提供给外部调用的。</li>
<li>raft：具体实现raft算法的结构体。</li>
</ol>

<p>除去以上两个文件之外，raft目录下的其他文件，都是间接给raft结构体服务的，下面的表格做一个总结和罗列：</p>

<table>
<thead>
<tr>
<th align="left">结构体/接口</th>
<th align="right">所在文件</th>
<th align="right">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">Node接口</td>
<td align="right">node.go</td>
<td align="right">提供raft库与外界交互的接口</td>
</tr>

<tr>
<td align="left">node</td>
<td align="right">node.go</td>
<td align="right">实现Node接口</td>
</tr>

<tr>
<td align="left">Config</td>
<td align="right">raft.go</td>
<td align="right">封装raft算法相关配置参数</td>
</tr>

<tr>
<td align="left">raft</td>
<td align="right">raft.go</td>
<td align="right">raft算法的实现</td>
</tr>

<tr>
<td align="left">ReadState</td>
<td align="right">read_only.go</td>
<td align="right">线性一致性读相关</td>
</tr>

<tr>
<td align="left">readOnly</td>
<td align="right">read_only.go</td>
<td align="right">线性一致性读相关</td>
</tr>

<tr>
<td align="left">raftLog</td>
<td align="right">log.go</td>
<td align="right">实现raft日志操作</td>
</tr>

<tr>
<td align="left">Progress</td>
<td align="right">progress.go</td>
<td align="right">该数据结构用于在leader中保存每个follower的状态信息，leader将根据这些信息决定发送给节点的日志</td>
</tr>

<tr>
<td align="left">Storage接口</td>
<td align="right">storage.go</td>
<td align="right">提供存储接口，应用层可以按照自己的需求实现该接口</td>
</tr>
</tbody>
</table>

<h1 id="节点状态">节点状态</h1>

<p>每个raft的节点，分为以下三种状态：</p>

<ol>
<li>candidate：候选人状态，节点切换到这个状态时，意味着将进行一次新的选举。</li>
<li>follower：跟随者状态，节点切换到这个状态时，意味着选举结束。</li>
<li>leader：领导者状态，所有数据提交都必须先提交到leader上。</li>
</ol>

<p>每一个状态都有其对应的状态机，每次收到一条提交的数据时，都会根据其不同的状态将消息输入到不同状态的状态机中。同时，在进行tick操作时，每种状态对应的处理函数也是不一样的。</p>

<p>所以raft结构体中将不同的状态，及其不同的处理函数独立出来几个成员变量：</p>

<table>
<thead>
<tr>
<th align="left">成员</th>
<th align="right">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">state</td>
<td align="right">保存当前节点状态</td>
</tr>

<tr>
<td align="left">tick函数</td>
<td align="right">tick函数，每个状态对应的tick函数不同</td>
</tr>

<tr>
<td align="left">step函数</td>
<td align="right">状态机函数，同样每个状态对应的状态机也不相同</td>
</tr>
</tbody>
</table>

<p>raft库中提供几个成员函数becomeCandidate、becomeFollower、becomeLeader分别进入这几种状态的，这些函数中做的事情，概况起来就是：</p>

<ol>
<li>切换raft.state成员到对应状态。</li>
<li>切换raft.tick函数到对应状态的处理函数。</li>
<li>切换raft.step函数到对应状态的状态机。</li>
</ol>

<h1 id="选举流程">选举流程</h1>

<p>raft算法的第一步是首先选举出一个leader出来，在没有产生leader的情况下，其他数据提交等操作都无从谈起，所以这里首先从选举的流程开始谈起。</p>

<h2 id="发起选举的节点">发起选举的节点</h2>

<p>只有在candidate或者follower状态下的节点，才有可能发起一个选举流程，而这两种状态的节点，其对应的tick函数都是raft.tickElection函数，这个函数的主要流程是：</p>

<ol>
<li>将选举超时递增1。</li>
<li>当选举超时到期，同时该节点又在集群中时，说明此时可以进行一轮新的选举。此时会向本节点发送HUP消息，这个消息最终会走到状态机函数raft.Step中进行处理。</li>
</ol>

<p>明白了raft.tickElection函数的作用，可以来看选举流程了：</p>

<ul>
<li><p>节点启动时都以follower状态启动，同时随机选择自己的选举超时时间。之所以每个节点随机选择自己的超时时间，是为了避免同时有两个节点同时进行选举，这种情况下会出现没有任何一个节点赢得半数以上的投票从而这一轮选举失败，继续再进行下一轮选举</p></li>

<li><p>在follower的tick函数tickElection函数中，当选举超时到时，节点向自己发送HUP消息。</p></li>

<li><p>在状态机函数raft.Step函数中，在收到HUP消息之后，节点首先判断当前有没有没有apply的配置变更消息，如果有就忽略该消息。其原因在于，当有配置更新的情况下不能进行选举操作，即要保证每一次集群成员变化时只能同时变化一个，不能同时有多个集群成员的状态发生变化。</p></li>

<li><p>否则进入campaign函数中进行选举：首先将任期号+1，然后广播给其他节点选举消息，带上的其它字段包括：节点当前的最后一条日志索引（Index字段），最后一条日志对应的任期号（LogTerm字段），选举任期号（Term字段，即前面已经进行+1之后的任期号），Context字段（目的是为了告知这一次是否是leader转让类需要强制进行选举的消息）。</p></li>

<li><p>如果在一个选举超时之内，该发起新的选举流程的节点，得到了超过半数的节点投票，那么状态就切换到leader状态，成为leader的同时，leader将发送一条dummy的append消息，目的是为了提交该节点上在此任期之前的值（见疑问部分如何提交之前任期的值）</p></li>
</ul>

<h2 id="收到选举消息的节点">收到选举消息的节点</h2>

<ul>
<li><p>当收到任期号大于当前节点任期号的消息，同时该消息类型如果是选举类的消息（类型为prevote或者vote）时，会做以下判断：</p>

<ol>
<li><p>首先会判断一下该消息是否为强制要求进行选举的类型（context为campaignTransfer，context为这种类型时表示在进行leader转让，流程见下面的leader转让流程）</p></li>

<li><p>判断当前是否在租约期以内，判断的条件包括：checkQuorum为true，当前节点保存的leader不为空，没有到选举超时，前面这三个条件同时满足。</p></li>
</ol></li>
</ul>

<p>如果不是强制要求选举，同时又在租约期以内，那么就忽略该选举消息返回不进行处理，这么做是为了避免出现那些离开集群的节点，频繁发起新的选举请求（见论文4.2.3）。</p>

<ul>
<li><p>如果不是前面的忽略选举消息的情况，那么除非是prevote类的选举消息，在收到其他消息的情况下，该节点都切换为follower状态。</p></li>

<li><p>此时需要针对投票类型中带来的其他字段进行处理了，需要同时满足以下两个条件：</p>

<ol>
<li><p>只有在没有给其他节点进行过投票，或者消息的term任期号大于当前节点的任期号，或者之前的投票给的就是这个发出消息的节点</p></li>

<li><p>进行选举的节点，它的日志是更新的，条件为：logterm比本节点最新日志的任期号大，在两者相同的情况下，消息的index大于等于当前节点最新日志的index，即总要保证该选举节点的日志比自己的大。</p></li>
</ol></li>
</ul>

<p>只有在同时满足以上两个条件的情况下，才能同意该节点的选举，否则都会被拒绝。这么做的原因是：保证最后能胜出来当新的leader的节点，它上面的日志都是最新的。</p>

<h1 id="集群成员变化流程">集群成员变化流程</h1>

<p><strong>大原则是不能同时进行两个以上的成员变更</strong>，因为同时进行两个以上的成员变更，可能会出现集群中有两个leader即导致了集群分裂的情况出现。</p>

<p>成员变化分为以下几种情况：成员删减、leader转让，下面分开讲解。</p>

<h2 id="一般的成员删减">一般的成员删减</h2>

<p>成员变化操作做为日志的特殊类型，当可以进行commit的情况下，各个节点拿出该消息进行节点内部的成员删减操作。</p>

<h2 id="leader转让">leader转让</h2>

<ul>
<li><p>旧leader在接收到转让leader消息之后，会做如下的判断：
a.  如果新的leader上的日志，已经跟当前leader上的日志同步了，那么发送timeout消息。
b.  否则继续发append消息到新的leader上，目的为了让其能够与旧leader日志同步。</p></li>

<li><p>当旧leader处于转让leader状态时，将停止接收新的prop消息，这样就避免出现在转让过程中新旧leader一直日志不能同步的情况。</p></li>

<li><p>当旧leader收到append消息应答时，如果当前处于leader转让状态，那么会判断新的leader日志是否已经与当前leader同步，如果是将发送timeout消息。</p></li>

<li><p>新的leader当收到timeout消息时，将使用context为campaignTransfer的选举消息发起新一轮选举，当context为该类型时，此时的选举是强制进行的（见前面的选举流程）。</p></li>
</ul>

<h1 id="如何做到线性一致性">如何做到线性一致性？</h1>

<p>线性一致性（Linearizable Read）通俗来讲，就是读请求需要读到最新的已经commit的数据，不会读到老数据。</p>

<p>由于所有的leader和follower都能处理客户端的读请求，所以存在可能造成返回读出的旧数据的情况：</p>

<ul>
<li><p>leader和follower之间存在状态差，因为follower总是由leader同步过去的，可能会返回同步之前的数据。</p></li>

<li><p>如果发生了网络分区，某个leader实际上已经被隔离出了集群之外，但是该leader并不知道，如果还继续响应客户端的读请求，也可能会返回旧的数据。</p></li>
</ul>

<p>因此，在接收到客户端的读请求时，需要保证返回的数据都是当前最新的。</p>

<h2 id="readonlysafe方式">ReadOnlySafe方式</h2>

<p>leader在接收到读请求时，需要向集群中的超半数server确认自己仍然是当前的leader，这样它返回的就是最新的数据。</p>

<p>在etcd-raft中，为了实现ReadOnlySafe，有如下的数据结构：</p>

<pre><code class="language-Go">type ReadState struct {
  Index uint64
  RequestCtx []byte
}
</code></pre>

<p>其中：</p>

<ol>
<li>Index：接收到该读请求时，当前节点的commit索引。</li>
<li>RequestCtx：客户端读请求的唯一标识。</li>
</ol>

<p>ReadState结构体用于保存读请求到来时的节点状态。</p>

<pre><code class="language-Go">type readIndexStatus struct {
 req pb.Message
 index uint64
 acks map[uint64]struct{}
}
</code></pre>

<p>readIndexStatus数据结构用于追踪leader向follower发送的心跳信息，其中：
1. req：保存原始的readIndex请求。
2. index：leader当前的commit信息。
3. acks：存放该readIndex请求有哪些节点进行了应答。</p>

<pre><code class="language-Go">type readOnly struct {
 option ReadOnlyOption
 pendingReadIndex map[string]*readIndexStatus
 readIndexQueue []string
}
</code></pre>

<p>readOnly用于管理全局的readIndx数据，其中：</p>

<ol>
<li>option：readOnly选项。</li>
<li>pendingReadIndex：当前所有待处理的readIndex请求，其中key为客户端读请求的唯一标识。</li>
<li>readIndexQueue：保存所有readIndex请求的请求唯一标识数组。</li>
</ol>

<p>有了以上的数据结构介绍，后面是流程介绍：</p>

<ol>
<li><p>server收到客户端的读请求，此时会调用raft.ReadIndex函数发起一个MsgReadIndex的请求，带上的参数是客户端读请求的唯一标识。</p></li>

<li><p>follower将向leader直接转发MsgReadIndex消息，而leader收到不论是本节点还是由其他server发来的MsgReadIndex消息，其处理都是：</p>

<p>a. 首先如果该leader在成为新的leader之后没有提交过任何值，那么会直接返回不做处理。</p>

<p>b. 调用r.readOnly.addRequest(r.raftLog.committed, m)保存该MsgreadIndex请求到来时的commit索引。</p>

<p>c. r.bcastHeartbeatWithCtx(m.Entries[0].Data)，向集群中所有其他节点广播一个心跳消息MsgHeartbeat，并且在其中带上该读请求的唯一标识。</p>

<p>d. follower在收到leader发送过来的MsgHeartbeat，将应答MsgHeartbeatResp消息，并且如果MsgHeartbeat消息中有ctx数据，MsgHeartbeatResp消息将原样返回这个ctx数据。</p>

<p>e. leader在接收到MsgHeartbeatResp消息后，如果其中有ctx字段，说明该MsgHeartbeatResp消息对应的MsgHeartbeat消息，是收到ReadIndex时leader消息为了确认自己还是集群leader发送的心跳消息。首先会调用r.readOnly.recvAck(m)函数，根据消息中的ctx字段，到全局的pendingReadIndex中查找是否有保存该ctx的带处理的readIndex请求，如果有就在acks map中记录下该follower已经进行了应答。</p>

<p>f. 当ack数量超过了集群半数时，意味着该leader仍然还是集群的leader，此时调用r.readOnly.advance(m)函数，将该readIndex之前的所有readIndex请求都认为是已经成功进行确认的了，所有成功确认的readIndex请求，将会加入到readStates数组中，同时leader也会向follower发送MsgReadIndexResp。</p>

<p>g. follower收到MsgReadIndexResp消息时，同样也会更新自己的readStates数组信息。</p>

<p>h. readStates数组的信息，将做为ready结构体的信息更新给上层的raft协议库的使用者。</p></li>
</ol>

<p>需要特别说明的是，处理读请求时，实际上leader需要确保当前自己是不是leader、该读请求对应的commit索引是否得到了半数投票，而当一个节点刚成为leader的时候，如果没有提交过任何数据，那么在它所在的这个任期（term）内的commit索引当时是并不知道的，因此在成为leader之后，需要马上提交一个no-op的空日志，这样拿到该任期的第一个commit索引。</p>

<h1 id="杂项">杂项</h1>

<h2 id="节点的几种状态">节点的几种状态</h2>

<p>一个节点在leader上保存的状态有:</p>

<pre><code class="language-Go">const (
    ProgressStateProbe ProgressStateType = iota
    ProgressStateReplicate
    ProgressStateSnapshot
)
</code></pre>

<p>以下来分开解释这几种状态。</p>

<h3 id="progressstateprobe">ProgressStateProbe</h3>

<p>探测状态，当节点拒绝了最近的append消息时，那么就会进入探测状态，此时leader会试图继续往前追述该节点的日志从哪里开始丢失的，让该节点的日志能跟leader同步上。在probe状态时，只能向它发送一次append消息，此后除非状态发生变化，否则就暂停向该节点发送新的append消息了。</p>

<p>只有在以下情况才会恢复取消暂停状态（调用Progress的resume函数）：</p>

<ol>
<li>收到该节点的心跳消息。</li>
<li>该节点成功应答了前面的最后一条append消息。</li>
</ol>

<p>至于Probe状态，只有在该节点成功应答了Append消息之后，在leader上保存的索引值发生了变化，才会修改其状态切换到Replicate状态。</p>

<h3 id="progressstatereplicate">ProgressStateReplicate</h3>

<p>正常接收副本数据的状态，当处于该状态时，leader在发送副本消息之后，就修改该节点的next索引为发送消息的最大索引+1</p>

<h3 id="progressstatesnapshot">ProgressStateSnapshot</h3>

<p>接收快照状态。
当leader向某个follower发送append消息，试图让该follower状态跟上leader时，发现此时leader上保存的索引数据已经对不上了，比如leader在index为10之前的数据都已经写入快照中了，但是该follower需要的是10之前的数据，此时就会切换到该状态下，发送快照给该follower。</p>

<p>因为快照数据可能很多，不知道会同步多久，所以单独把这个状态抽象出来。</p>

<p>当快照数据同步追上之后，并不是直接切换到Replicate状态，而是首先切换到Probe状态。</p>

<h2 id="progress上的数据索引">Progress上的数据索引</h2>

<p>Progress结构体中有两个保存该follower节点日志索引的数据，其中：</p>

<ul>
<li>Next：保存下一次leader发送append消息给该follower时的日志索引。</li>
<li>Match：保存该follower节点上的最大日志索引。</li>
</ul>

<p>在正常情况下，Next = Match + 1，也就是Next总是节点当前保存最大日志索引的下一条索引。</p>

<p>有两种情况除外：</p>

<ul>
<li>接收快照状态：此时Next = max(pr.Match+1, pendingSnapshot+1)</li>
<li>当该follower不在Replicate状态时，说明不是正常的接收副本状态。此时当leader与follower同步leader上的日志时，可能出现覆盖的情况，即此时follower上面假设Match为3，但是索引为3的数据会被leader覆盖，此时Next指针可能会一直回溯到与leader上日志匹配的位置，再开始正常同步日志，此时也会出现Next != Match + 1的情况出现。</li>
</ul>

<p><img src="/media/imgs/20180922-etcd-raft/next-match.jpg" alt="Alt text" title="Optional title" /></p>

<p>如上图所示，节点s1上最大日志索引为2，即Match = 2，Next = 3。
但是，由于新选出来的leader s2，其最大日志索引为3，此时s3需要同步日志到s1上，发现s1上的日志与自己的不匹配，所以会一直找到两者最开始匹配的索引位置，即最终找到索引1，因此会保存s1的Next索引为1，而Match还是2（因为此时还没有修改s1上的日志）。当最终s1上的数据与s2同步时，此时Next = 4，Match=3。</p>

<h2 id="流量控制">流量控制</h2>

<p>Progress结构体中，使用另一个inflights的数据结构用于流量控制。
该结构体使用一个固定大小的循环缓冲区来控制给一个节点同步数据的流量控制，每当给该follower发送同步消息时，就占用该缓冲区的一个空间；反之，当收到该follower的成功接收了该同步消息的应答之后，就释放缓冲区的空间。</p>

<p>当该缓冲区数据饱和时，将暂停继续同步数据到该follower。</p>

<p>##快照、日志的存储</p>

<h1 id="疑问采集">疑问采集</h1>

<h2 id="为什么不能通过计算日志条目数量的方式来提交任期之前的日志条目">为什么不能通过计算日志条目数量的方式来提交任期之前的日志条目？</h2>

<p>论文中专门有一段，论述了为什么在选举完成之后，不能通过计算日志条目数量的方式来提交任期之前的日志条目。</p>

<p>如果leader在写入但是还没有提交一条日志之前崩溃，那么这条没有提交的日志是否能提交？</p>

<p><img src="/media/imgs/20180922-etcd-raft/etcd-log.jpeg" alt="Alt text" title="Optional title" /></p>

<p>如上图所示：</p>

<ul>
<li><p>情况a：s1是leader，index 2位置写入了数据2，该值只写在了s1，s2上，但是还没有被提交。</p></li>

<li><p>情况b: s1崩溃，s5成为新的leader，该节点在index 2上面提交了另外一个值3，但是这个值只写在了s5上面，并没有被提交。</p></li>

<li><p>情况c: s5崩溃，s1重新成为leader，这一次，index 2的值2写到了集群的大多数节点上。</p></li>
</ul>

<p>此时可能存在以下两种情况：</p>

<ul>
<li>情况d1: s1崩溃，s5重新成为leader（投票给s5的是s4，s2和s5自身），那么index 2上的值3这一次成功的写入到集群的半数以上节点之上，并成功提交。</li>
<li>情况d2: s1不崩溃，而是将index 2为2的值成功提交。</li>
</ul>

<p>从情况d的两种场景可以看出，在index 2值为2，且已经被写入到半数以上节点的情况下，同样存在被新的leader覆盖的可能性。</p>

<p>由于以上的原因，对于当前任期之前任期提交的日志，并不通过判断是否已经在半数以上集群节点写入成功来作为能否提交的依据。只有当前leader任期内的日志是通过比较写入数量是否超过半数来决定是否可以提交的。</p>

<p>对于任期之前的日志，Raft采用的方式，是只要提交成功了当前任期的日志，那么在日志之前的日志就认为提交成功了。这也是为什么etcd-Raft代码中，在成为leader之后，需要再提交一条dummy的日志的原因&ndash;只要该日志提交成功，leader上该日志之前的日志就可以提交成功。</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">codedump</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-09-22</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/etcd/">etcd</a>
          
          <a href="/tags/raft/">Raft</a>
          
          <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          
        </div>

      
      <nav class="post-nav">
        
        
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="lichuang1982@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/lichuang" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/lichuang" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/codedump" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/Lichuang/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://lichuang.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">codedump</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
