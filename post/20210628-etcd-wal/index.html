<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Etcd Raft库的日志存储 - codedump的网络日志</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="https://www.codedump.info/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="https://www.codedump.info/js/eureka.min.a3e627c430c1281e6e0f18283a36c9cd4ddd90b993c45656c2290b897d81d6b0753b8fd02dc595974e0b8afcb4e8e1ea.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://www.codedump.info/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://www.codedump.info/js/fontawesome.min.30595d8a9ed7468eba3aa95ad3a1030aec262644fb8e8c8a2ac064630c5a2b4aebf09c5105e5497b5e596c982d93cf45.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126255685-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-126255685-1');
</script>


<link rel="icon" type="image/png" href="/images/C.png" >

<meta name="description"
  content="Etcd Raft库的日志存储">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://www.codedump.info/post/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Etcd Raft库的日志存储",
      "item":"https://www.codedump.info/post/20210628-etcd-wal/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.codedump.info/post/20210628-etcd-wal/"
    },
    "headline": "Etcd Raft库的日志存储 - codedump的网络日志","datePublished": "2021-06-28T17:01:53+08:00",
    "dateModified": "2021-06-28T17:01:53+08:00",
    "wordCount":  6992 ,
    "publisher": {
        "@type": "Person",
        "name": "lichuang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.codedump.info/images/C.png"
        }
        },
    "description": "Etcd Raft库的日志存储"
}
</script><meta property="og:title" content="Etcd Raft库的日志存储 - codedump的网络日志" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://www.codedump.info/images/C.png">


<meta property="og:url" content="https://www.codedump.info/post/20210628-etcd-wal/" />



<meta property="og:description" content="Etcd Raft库的日志存储" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="codedump的网络日志" />






<meta property="article:published_time" content="2021-06-28T17:01:53&#43;08:00" />


<meta property="article:modified_time" content="2021-06-28T17:01:53&#43;08:00" />



<meta property="article:section" content="post" />


<meta property="article:tag" content="etcd" />

<meta property="article:tag" content="raft" />

<meta property="article:tag" content="分布式" />





<meta property="og:see_also" content="https://www.codedump.info/post/20210515-raft/" />

<meta property="og:see_also" content="https://www.codedump.info/post/20180922-etcd-raft/" />

<meta property="og:see_also" content="https://www.codedump.info/post/20181125-etcd-server/" />

<meta property="og:see_also" content="https://www.codedump.info/post/20180921-raft/" />

<meta property="og:see_also" content="https://www.codedump.info/post/20190629-service-history/" />

<meta property="og:see_also" content="https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/" />




  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">codedump的网络日志</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
            <a href="/post/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">分类</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/index.xml" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">RSS</a>
            <a href="https://www.getrevue.co/profile/lichuang" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">邮件订阅</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">Etcd Raft库的日志存储</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2021-06-28</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>14分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="https://www.codedump.info/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="hover:text-eureka"
          >分布式</a
        >
      
    </div>
  

  
</div>


  
  

  <h1 id="概述">概述</h1>
<p>之前看etcd raft实现的时候，由于wal以及日志的落盘存储部分，没有放在raft模块中，对这部分没有扣的特别细致。而且，以前我的观点认为etcd raft把WAL这部分留给了上层的应用去实现，自身通过<code>Ready</code>结构体来通知应用层落盘的数据，这个观点也有失偏颇，etcd只是没有把这部分代码放在raft模块中，属于代码组织的范畴问题，并不是需要应用层自己来实现。</p>
<p>于是，决定专门写一篇文章把这部分内容给讲解一下，主要涉及以下内容：</p>
<ul>
<li>日志（包括快照）文件的格式。</li>
<li>日志（包括快照）内容的落盘、恢复。</li>
</ul>
<p>以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：</p>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20210515-raft/">Etcd Raft库的工程化实现 - codedump的网络日志</a></li>
</ul>
<h1 id="wal及快照文件格式">WAL及快照文件格式</h1>
<p>首先来讲解这两种文件的格式，了解了格式才能继续展开下面的讲述。</p>
<h2 id="wal文件格式">WAL文件格式</h2>
<p>wal文件的文件名格式为：seq-index.wal（见函数<code>walName</code>）。其中：</p>
<ul>
<li>seq：序列号，从0开始递增。</li>
<li>index：该wal文件存储的第一条日志数据的索引。</li>
</ul>
<p>因此，如果将一个目录下的所有wal文件按照名称排序之后，给定一个日志索引，很快就能知道该索引的日志落在哪个wal文件之中的。</p>
<p>WAL文件中每条记录的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">Record</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">int64</span> <span class="n">type</span>  <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint32</span> <span class="n">crc</span>  <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">bytes</span> <span class="n">data</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><ul>
<li>type：记录的类型，下面解释。</li>
<li>crc：后面data部分数据的crc32校验值。</li>
<li>data：数据部分，根据类型的不同有不同格式的数据。</li>
</ul>
<p>记录数据的类型如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 以下是WAL存放的数据类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">metadataType</span> <span class="kt">int64</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 日志数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entryType</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 状态数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stateType</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 校验初始值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">crcType</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">snapshotType</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>下面展开解释。</p>
<h3 id="元数据">元数据</h3>
<p>元数据就是应用层自定义的数据，需要注意的是，一个服务中如果有多个wal文件，且这些文件中有多份元数据，那么这些元数据都必须一致，否则报错。</p>
<p>对于etcd这个服务而言，存储的元数据就是节点ID以及集群ID：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">metadata</span> <span class="o">:=</span> <span class="nx">pbutil</span><span class="p">.</span><span class="nf">MustMarshal</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">NodeID</span><span class="p">:</span>    <span class="nb">uint64</span><span class="p">(</span><span class="nx">member</span><span class="p">.</span><span class="nx">ID</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ClusterID</span><span class="p">:</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">cl</span><span class="p">.</span><span class="nf">ID</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">wal</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">cfg</span><span class="p">.</span><span class="nf">WALDir</span><span class="p">(),</span> <span class="nx">metadata</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">plog</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;create wal error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><h3 id="日志数据">日志数据</h3>
<p>日志数据的格式，就是<code>raft.proto</code>中<code>Entry</code>的格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">Entry</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span>     <span class="n">Term</span>  <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span> <span class="c1">// must be 64-bit aligned for atomic operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">optional</span> <span class="kt">uint64</span>     <span class="n">Index</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span> <span class="c1">// must be 64-bit aligned for atomic operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">optional</span> <span class="n">EntryType</span>  <span class="n">Type</span>  <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">bytes</span>      <span class="n">Data</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h3 id="状态数据">状态数据</h3>
<p>保存当前“硬状态（HardState）”的记录，HardState包括：当前任期号、当前给哪个节点ID投票、当前提交的最大日志索引。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">HardState</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span> <span class="n">term</span>   <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span> <span class="n">vote</span>   <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span> <span class="n">commit</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h3 id="校验初始值">校验初始值</h3>
<p>校验数据这一块，挺有意思的，可以展开好好说一下。</p>
<p>使用CRC算法来计算数据的校验值，除了需要原始数据之外，还需要一个校验初始值（即校验种子seed），在每个wal文件中，类型为<code>校验初始值</code>的记录就用于存储这个值。其值和使用方式有以下几点需要注意：</p>
<ul>
<li>每个wal文件必须有<code>校验初始值</code>类型的数据，后续所有写入该wal文件的记录，都使用该初始值来计算CRC校验值。</li>
<li>第一个wal文件，即序列号为0的wal文件，其校验初始值为0（见wal.go的Create函数）。</li>
<li>当生成下一个wal文件时，以上一个wal文件的最后一条日志数据的CRC校验码来做为该文件的校验初始值，这样就要求类型为<code>校验初始值</code>的记录，必须存储在同一个wal文件中第一条日志数据的前面，否则计算出来该日志数据的crc校验码就不准。</li>
</ul>
<p><img src="/media/imgs/20210628-etcd-wal/wal-crc.png" alt="wal文件的校验初始值" title="wal文件的校验初始值"></p>
<p>可以看到，通过这个机制，将多个连续的wal文件“串联”了起来：使用上一个wal文件的最后一个日志数据的crc校验值，来做为下一个wal文件的校验初始值，可以有效的校验同一个项目中wal文件的正确性。</p>
<h3 id="快照数据">快照数据</h3>
<p>在wal文件中存储的快照数据类型的记录，其中仅存储了当前快照的索引和任期号，而快照的详细数据都放到快照数据文件中存储，下面讲到数据恢复时再展开讨论这部分内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">Snapshot</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint64</span> <span class="n">term</span>  <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h2 id="快照文件格式">快照文件格式</h2>
<p>快照文件的文件名格式为：任期号-索引号.snap（见函数<code>Snapshotter::save</code>）。每次来一个快照数据，都新建一个快照文件，文件中存储快照数据的格式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">snapshot</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">uint32</span> <span class="n">crc</span>  <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">bytes</span> <span class="n">data</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><p>即：只存储快照数据及其校验值，数据的具体格式由存储快照数据的使用方来解释。在etcd这个服务里，这份快照数据的格式就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-proto" data-lang="proto"><span class="line"><span class="cl"><span class="kd">message</span> <span class="nc">Snapshot</span> <span class="p">{</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="kt">bytes</span>            <span class="n">data</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>	<span class="k">optional</span> <span class="n">SnapshotMetadata</span> <span class="n">metadata</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[(</span><span class="n">gogoproto.nullable</span><span class="p">)</span> <span class="o">=</span> <span class="kc">false</span><span class="p">];</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">}</span><span class="err">
</span></span></span></code></pre></div><h1 id="数据恢复流程">数据恢复流程</h1>
<p>日志、快照数据的落盘，都是为了重启时恢复数据，了解了上面wal以及快照文件的格式，可以来看看数据的恢复流程。</p>
<p>其大体流程如下:</p>
<ul>
<li>到快照目录中取出最新的一份无错的快照文件，首先取出这个文件中存储的快照数据。（见函数<code>Snapshotter::Load</code>）</li>
<li>此时，从快照数据中可以反序列化出：快照数据、对应的任期号、索引号。</li>
<li>根据第二步拿到的快照数据，到wal目录中拿到日志索引号在快照数据索引号之后的日志，遍历满足条件的记录进行数据恢复。（见函数<code>WAL::ReadAll</code>）。</li>
</ul>
<p>下面具体来看每种wal记录格式数据在进行数据恢复时的流程：</p>
<ul>
<li>日志数据：由于还可能存在一小部分小于快照索引的日志，所以恢复时会忽略掉这部分数据。</li>
<li>状态数据：每一条状态数据都会反序列化出来，以最后一条状态数据为准。</li>
<li>元数据：前面提到过，同一个服务的元数据必须一致，所以这里会校验元数据前后是否一致，不一致将报错退出数据恢复流程。</li>
<li>校验初始值数据：可以参见前面关于该类型数据的讲解。</li>
<li>快照数据：下面详细解释。</li>
</ul>
<p>举一个例子来描述前面根据快照文件和WAL文件恢复数据的流程：</p>
<p><img src="/media/imgs/20210628-etcd-wal/wal-snap.png" alt="WAL与快照文件关系" title="WAL与快照文件关系"></p>
<p>如上图中：</p>
<ul>
<li>快照文件集合为<code>[1-50.snap,1-150.snap]</code>，取最新的快照文件，即<code>1-150.snap</code>，而<code>1-50.snap</code>文件的数据为过期数据。</li>
<li>由于快照文件中存储的日志索引到150，即在此之前的日志已经全部被压缩到了快照文件中，因此wal文件集合中：
<ul>
<li><code>0-100.wal</code>中的数据已经全部被压缩。</li>
<li><code>1-200.wal</code>中的数据部分被压缩，恢复数据时要忽略日志索引小于150的日志数据。</li>
<li><code>3-300.wal</code>中的数据都没有被压缩，恢复数据时要如实全部重放该文件的数据。</li>
</ul>
</li>
</ul>
<p>前面分析快照数据类型的时候，提到过这个类型的数据在wal文件中的记录，只会存储：</p>
<ul>
<li>当前快照时对应的任期号。</li>
<li>当前快照时对应的索引号。</li>
<li>而具体的快照数据内容存储在快照文件中。</li>
</ul>
<p>也就是说，当生成一份新的快照数据时，将会把这份快照数据相关的以上三部分内容存储到wal和快照文件中。</p>
<p>所以当恢复数据的时候，此时已经反序列化出快照数据了，这时拿着快照数据读wal文件时，如果读到了快照类型的数据，就会去对比起任期号和索引号是否一致，不一致报错停止恢复流程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">snapshotType</span><span class="p">:</span> <span class="c1">// 快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="kd">var</span> <span class="nx">snap</span> <span class="nx">walpb</span><span class="p">.</span><span class="nx">Snapshot</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pbutil</span><span class="p">.</span><span class="nf">MustUnmarshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">snap</span><span class="p">,</span> <span class="nx">rec</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">snap</span><span class="p">.</span><span class="nx">Index</span> <span class="o">==</span> <span class="nx">w</span><span class="p">.</span><span class="nx">start</span><span class="p">.</span><span class="nx">Index</span> <span class="p">{</span> <span class="c1">// 两者的索引相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">snap</span><span class="p">.</span><span class="nx">Term</span> <span class="o">!=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">start</span><span class="p">.</span><span class="nx">Term</span> <span class="p">{</span> <span class="c1">// 但是任期号不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">state</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// 返回ErrSnapshotMismatch错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrSnapshotMismatch</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 保存快照数据匹配的标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">match</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span></code></pre></div><p>以上，解释清楚了wal、快照文件的格式，以及数据恢复的流程。</p>
<p>因为wal文件和快照文件的读写，都与磁盘读写相关，所以在etcd服务中，将这两个结构体，统一到<code>etcdserver/storage.go</code>的<code>storage</code>结构体中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">storage</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">wal</span><span class="p">.</span><span class="nx">WAL</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">snap</span><span class="p">.</span><span class="nx">Snapshotter</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>由<code>storage</code>结构体统一对外提供wal、快照文件的读写接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Storage</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Save function saves ents and state to the underlying stable storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Save MUST block until st and ents are on stable storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Save</span><span class="p">(</span><span class="nx">st</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">,</span> <span class="nx">ents</span> <span class="p">[]</span><span class="nx">raftpb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// SaveSnap function saves snapshot to the underlying stable storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">SaveSnap</span><span class="p">(</span><span class="nx">snap</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// DBFilePath returns the file path of database snapshot saved with given
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// id.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">DBFilePath</span><span class="p">(</span><span class="nx">id</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Close closes the Storage and performs finalization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>下面，解释一下写wal文件中需要注意的一些细节。</p>
<h1 id="写优化问题">写优化问题</h1>
<h2 id="数据对齐">数据对齐</h2>
<p>每条写入wal的记录，都会将其大小向上8字节对齐，多出来的部分填零：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">encodeFrameSize</span><span class="p">(</span><span class="nx">dataBytes</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">lenField</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">padBytes</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lenField</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">dataBytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// force 8 byte alignment so length never gets a torn write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">padBytes</span> <span class="p">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="nx">dataBytes</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">%</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">padBytes</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lenField</span> <span class="o">|=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">|</span><span class="nx">padBytes</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img src="/media/imgs/20210628-etcd-wal/record.png" alt="WAL记录数据需8字节对齐" title="WAL记录数据需8字节对齐"></p>
<h2 id="写缓冲区">写缓冲区</h2>
<p>另外，为了缓解写文件的IO负担，etcd做了一个写优化：落盘的数据首先写到一个内存缓冲区中，只有每次填满了一个page的数据才会进行落盘操作。</p>
<p>etcd中定义了几个常量：</p>
<ul>
<li>const minSectorSize = 512</li>
<li>const walPageBytes = 8 * minSectorSize</li>
</ul>
<p>其中：<code>minSectorSize</code>表示一个sector的大小，而<code>walPageBytes</code>必须为<code>minSectorSize</code>的整数倍。</p>
<p>etcd中定义了一个<code>PageWriter</code>结构体，用于实现写入日志的操作，内部定义了一个循环缓冲区，只有填满一个<code>walPageBytes</code>大小的数据才会进行落盘。</p>
<p>下图是写入数据落盘后循环缓冲区的变化的示意图：</p>
<p><img src="/media/imgs/20210628-etcd-wal/cyclic-buffer.png" alt="写入数据落盘后循环缓冲区的变化" title="写入数据落盘后循环缓冲区的变化"></p>
<ul>
<li>黄色方块表示一个page的空闲空间，绿色方块表示待写入数据，红色方块表示当前已经写入数据的缓冲区。</li>
<li>刚开始，第一个page已经有部分数据写入，还剩余一部分空闲空间。因此，当写入数据时，只会把写入数据凑齐一个页面大小来落盘。</li>
<li>落盘完毕之后，第一个page重新变成黄色，即空闲页面，而第二个页面存储了写入数据中没有落盘的部分。</li>
</ul>
<p>代码流程见函数<code>PageWriter::Write</code>。</p>
<p>从上面的写入落盘流程可以看到，一次写入的数据可能会有一部分落盘，一部分还在内存中，这样当系统发生宕机这部分数据就是被损坏（corruption）的数据。</p>
<p>因此，etcd中还需要有办法来识别和恢复数据。</p>
<h2 id="识别部分写入partial-write数据">识别部分写入（partial write）数据</h2>
<p>函数<code>decoder::isTornEntry</code>用于判断一条记录是否为部分写的损坏数据。</p>
<p>其原理是：</p>
<ul>
<li>每次新创建用于写入记录的wal文件，都会将剩余文件清零。</li>
<li>读入记录的数据之后，将数据根据不大于每个chunk为<code>minSectorSize</code>大小的方式，存入chunk数组中。</li>
<li>遍历这些chunk，如果有一个chunk的数据全部是零，则认为这块数据是部分写入的损坏数据。</li>
</ul>
<p>这个地方要跟前面落盘流程来对照看：因为每次落盘都是以一个page为单位落盘，而page大小又是<code>minSectorSize</code>的整数倍，因此以<code>minSectorSize</code>为一个chunk的大小来判断是否损坏。</p>
<h2 id="修复wal文件流程">修复wal文件流程</h2>
<p>当进行数据恢复时，可能会出现前面的部分写导致数据损坏问题，etcd会进行如下的修复操作：</p>
<ul>
<li>部分写导致数据损坏都只会出现在最后一个wal文件，因此打开最后一个wal文件进行处理（见函数<code>openLast</code>）。</li>
<li>出现部分写导致损坏的记录，解析过程中都会返回<code>ErrUnexpectedEOF</code>错误，对于这样的文件：
<ul>
<li>将损坏的文件重命名为<code>原文件名.broken</code>。</li>
<li>记录下来最后一个无损记录的偏移量，将损坏之后的数据都截断（Truncate）。</li>
</ul>
</li>
</ul>
<h2 id="只读和只写文件的区别">只读和只写文件的区别</h2>
<p>在etcd中，wal文件有两种并不能同时共存的模式：对于同一个wal文件而言，要么处于只读模式，要么处于append写模式，这两种模式不能同时存在。见<code>WAL</code>结构体的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WAL is a logical representation of the stable storage.
</span></span></span><span class="line"><span class="cl"><span class="c1">// WAL is either in read mode or append mode but not both.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A newly created WAL is in append mode, and ready for appending records.
</span></span></span><span class="line"><span class="cl"><span class="c1">// A just opened WAL is in read mode, and ready for reading records.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The WAL will be ready for appending after reading out all the previous records.
</span></span></span></code></pre></div><p>根据上面可能使用缓冲区优化写操作可知，两种模式下在读记录时能容忍的错误级别也不一样：</p>
<ul>
<li>读模式：读模式下可能读到部分写的数据，所以可以容忍这种错误。</li>
<li>写模式：写模式下，不能容忍读到部分写的数据。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">w</span><span class="p">.</span><span class="nf">tail</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// We do not have to read out all entries in read mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// The last record maybe a partial written one, so
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// ErrunexpectedEOF might be returned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 在只读模式下，可能没有读完全部的记录。最后一条记录可能是只写了一部分，此时就会返回ErrunexpectedEOF错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ErrUnexpectedEOF</span> <span class="p">{</span> <span class="c1">// 如果不是EOF以及ErrunexpectedEOF错误的情况就返回错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">state</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 写模式下必须读完全部的记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// We must read all of the entries if WAL is opened in write mode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span> <span class="c1">// 如果不是EOF错误，说明没有读完数据就报错了，这种情况也是返回错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">state</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></div><h1 id="数据落盘的全流程">数据落盘的全流程</h1>
<p>以上了解了wal、快照文件的格式，以及写入流程，这里把之前写的不够好的数据落盘流程重新梳理一下。</p>
<p>在 <a href="https://www.codedump.info/post/20180922-etcd-raft/#%E8%BE%93%E5%85%A5%E5%8F%8A%E8%BE%93%E5%87%BA">etcd Raft库解析 - codedump的网络日志</a>中，曾经指出etcd raft库是通过<code>Ready</code>结构体，来通知应用层的当前的数据的，不清楚的话可以回看一下之前的内容。在这里，只解释该结构体中与数据落盘相关的几个成员的数据走向流程，即日志数据（成员<code>Entries</code>）、快照数据（<code>Snapshot</code>）、已提交日志（<code>CommittedEntries</code>）。</p>
<h2 id="日志数据-1">日志数据</h2>
<p>日志数据从客户端提交到落盘的走向是这样的：</p>
<ul>
<li>由客户端提交给服务器（注：只有leader节点才能接收客户端提交的日志数据，其他节点需转发给leader）。</li>
<li>服务器收到之后，首先调用<code>raftLog.append</code>函数保存到<code>unstable_log</code>中，此时日志还是在内存中的，并未落地。</li>
<li>通过<code>newReady</code>函数构建<code>Ready</code>结构体时，将上一步保存下来的日志数据保存到<code>Ready</code>结构体的<code>Entries</code>。</li>
<li>应用层收到<code>Ready</code>结构体之后，调用wal的<code>WAL.Save</code>接口保存日志数据。这一步做完之后，可以认为日志数据已经落盘了。</li>
<li>由于数据已经落盘到WAL日志中，所以在应用层通过<code>Node.Advance</code>接口回调通知raft库时，暂存在<code>unstable_log</code>中的日志就可以通过函数<code>raftLog.stableTo</code>删除了。</li>
</ul>
<p><img src="/media/imgs/20210628-etcd-wal/log-flow.png" alt="日志数据从提交到落盘的走向" title="日志数据从提交到落盘的走向"></p>
<h2 id="已提交日志">已提交日志</h2>
<p>raft日志中，需要保存两个日志索引：</p>
<ul>
<li>appliedIndex：通知到应用层目前为止最大的日志索引；</li>
<li>commitIndex：当前已提交日志的最大索引。</li>
</ul>
<p>在这里，总有<code>appliedIndex &lt;= commitIndex</code>条件成立，即日志总是先被提交成功（即达成一致），才会通知给应用层。</p>
<p>通知应用层已提交日志的流程如下：</p>
<ul>
<li>调用<code>raftLog.nextEnts()</code>函数获得当前满足<code>appliedIndex &lt;= commitIndex</code>条件的日志，存入到<code>Ready.CommittedEntries</code>通知应用层。</li>
<li>应用层处理这部分已提交日志。</li>
<li>调用<code>raftLog.appliedTo()</code>函数，这里会修改<code>appliedIndex = commitIndex</code>，即所有日志都已通知应用层。</li>
</ul>
<p><img src="/media/imgs/20210628-etcd-wal/appliedIndex.png" alt="通知应用层已提交日志流程" title="通知应用层已提交日志流程"></p>
<h2 id="快照数据-1">快照数据</h2>
<p>快照数据由应用层生成，然后将生成的快照数据、当前appliedIndex、配置状态一起交给存储层，保存之后就可以把在该快照之前的数据给删除了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">rc</span> <span class="o">*</span><span class="nx">raftNode</span><span class="p">)</span> <span class="nf">maybeTriggerSnapshot</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 生成快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nf">getSnapshot</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通知存储层快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rc</span><span class="p">.</span><span class="nx">raftStorage</span><span class="p">.</span><span class="nf">CreateSnapshot</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">appliedIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">rc</span><span class="p">.</span><span class="nx">confState</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 保存快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rc</span><span class="p">.</span><span class="nf">saveSnap</span><span class="p">(</span><span class="nx">snap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将快照之前的数据压缩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">compactIndex</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rc</span><span class="p">.</span><span class="nx">raftStorage</span><span class="p">.</span><span class="nf">Compact</span><span class="p">(</span><span class="nx">compactIndex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 更新快照数据索引，以便下一次生成新的快照数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rc</span><span class="p">.</span><span class="nx">snapshotIndex</span> <span class="p">=</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">appliedIndex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="数据的修复">数据的修复</h2>
<p>从上面的分析中可以看到，日志数据是在客户端提交之后，就马上落盘到WAL文件中的，不会等到日志在集群中达成一致。</p>
<p>这样会带来一个问题，比如：</p>
<ul>
<li>节点A认为自己还是集群的leader节点，此时收到客户端日志之后，将数据落盘到WAL文件中。</li>
<li>落盘之后，节点A将日志同步给集群的其它节点，但是发现自己已经不再是集群的leader节点了。</li>
</ul>
<p>在这种情况下，显然第一步已经落盘的日志是无效的，需要进行修复，这时候是怎么操作的呢？</p>
<p>etcd raft的做法是不回退日志，继续走正常的流程，用新的、正确的日志添加在错误的日志后面，这样回放数据的时候恢复数据。</p>
<p>继续以上面的例子为例：</p>
<ul>
<li>节点A在认为自己是leader的情况下落盘日志到本地WAL中，落盘完毕之后同步给集群内其他节点。</li>
<li>同步到集群其他节点的过程中，才发现节点A已经不是集群的leader，此时节点A降级为follower节点，并开始从正确的集群节点那里同步日志。</li>
<li>同步日志的流程中，节点A将收到来自leader节点的正确日志，这些日志也将落盘到节点A的WAL中。</li>
</ul>
<p>第二步中同步日志的流程可以参见 <a href="https://www.codedump.info/post/20180921-raft/#%E6%96%B0leader%E4%B8%8Efollower%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE">Raft算法原理 - codedump的网络日志</a>，这里不再阐述。</p>
<p>上面的流程之后，节点A的WAL中将存在：</p>
<ul>
<li>认为自己是leader时已落盘的日志；</li>
<li>集群leader纠正节点A同步过来的日志。</li>
</ul>
<p>这样，当重启恢复时，会一并将这些日志重放，应用层只要按顺序回放日志即可。</p>
<p><img src="/media/imgs/20210628-etcd-wal/wal-failback.png" alt="WAL日志的纠错机制" title="WAL日志的纠错机制"></p>
<p>如上图中：</p>
<ul>
<li>节点认为自己是leader节点时，落盘到WAL文件中的日志是<code>[(1,10),(1,11)]</code>，列表中的二元组数据中，第一个元素是任期号，第二个元素是日志索引号。</li>
<li>在落盘日志之后，节点将数据广播到集群，才发现自己已经不是集群的leader节点，此时集群的leader节点发现从日志10开始，该节点的数据就是不对的，开始同步正确的日志给节点，于是把正确的日志<code>[(2,10),(2,11)]</code>同步给了节点，这部分日志会添加到前面错误的日志之后。</li>
<li>假设节点重启恢复，那么会依次重放前面这四条日志，其中前两条日志是错误的日志，但是由于有后面的两条正确日志，最终节点的状态还是会恢复正确状态。</li>
<li>随着后面日志数据压缩成快照文件，冗余的错误日志的磁盘占用将被解决。</li>
</ul>
<p><strong>读者不妨在这里就着这个流程多思考一个问题：做为follower的节点，是什么时候将日志落盘到WAL文件中，是在收到leader节点同步过来的日志时，还是在leader节点通知某个日志已经在集群达成一致？为什么以及流程是怎样的？</strong></p>
<h1 id="总结">总结</h1>
<ul>
<li>etcd的wal模块，虽然并没有和raft模块放在一起，但并不是说这一部分就需要应用者来自己实现，这两部分其实是一起打包做为整个etcd raft算法库提供给使用者的。可以认为raft模块提供算法，wal和快照模块提供日志存储读写的接口。</li>
<li>日志落盘部分，包括wal文件以及快照文件读写这两部分内容，etcd将这两部分统一到<code>Storage</code>接口统一对外服务。</li>
<li>raft算法是在收到客户端日志之后就理解落盘日志到wal文件中保存的，如果后面发现出错，就走正常的同步正确日志的流程，将正确的日志添加到后面，这样恢复时重放整个日志，最终节点达成一致的正确状态。</li>
</ul>

</article>


      
        <div class="my-4">
    
    <a href="https://www.codedump.info/tags/etcd/" class="inline-block text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#etcd</a>
    
    <a href="https://www.codedump.info/tags/raft/" class="inline-block text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#raft</a>
    
    <a href="https://www.codedump.info/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="inline-block text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#分布式</a>
    
</div>
      



      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >上一页</span
        >
        <a href="https://www.codedump.info/post/20210701-memcached/" class="block">Memcached的存储原理解析</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://www.codedump.info/post/20210515-raft/" class="block">Etcd Raft库的工程化实现</a>
      
    </div>
  </div>


    </div>
    
      <div class="col-span-2">

        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页目录</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#概述">概述</a></li>
    <li><a href="#wal及快照文件格式">WAL及快照文件格式</a>
      <ul>
        <li><a href="#wal文件格式">WAL文件格式</a>
          <ul>
            <li><a href="#元数据">元数据</a></li>
            <li><a href="#日志数据">日志数据</a></li>
            <li><a href="#状态数据">状态数据</a></li>
            <li><a href="#校验初始值">校验初始值</a></li>
            <li><a href="#快照数据">快照数据</a></li>
          </ul>
        </li>
        <li><a href="#快照文件格式">快照文件格式</a></li>
      </ul>
    </li>
    <li><a href="#数据恢复流程">数据恢复流程</a></li>
    <li><a href="#写优化问题">写优化问题</a>
      <ul>
        <li><a href="#数据对齐">数据对齐</a></li>
        <li><a href="#写缓冲区">写缓冲区</a></li>
        <li><a href="#识别部分写入partial-write数据">识别部分写入（partial write）数据</a></li>
        <li><a href="#修复wal文件流程">修复wal文件流程</a></li>
        <li><a href="#只读和只写文件的区别">只读和只写文件的区别</a></li>
      </ul>
    </li>
    <li><a href="#数据落盘的全流程">数据落盘的全流程</a>
      <ul>
        <li><a href="#日志数据-1">日志数据</a></li>
        <li><a href="#已提交日志">已提交日志</a></li>
        <li><a href="#快照数据-1">快照数据</a></li>
        <li><a href="#数据的修复">数据的修复</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="https://www.codedump.info/post/20210515-raft/" class="no-underline">Etcd Raft库的工程化实现</a>
          <br />
        
          <a href="https://www.codedump.info/post/20180922-etcd-raft/" class="no-underline">etcd Raft库解析</a>
          <br />
        
          <a href="https://www.codedump.info/post/20181125-etcd-server/" class="no-underline">Etcd存储的实现</a>
          <br />
        
          <a href="https://www.codedump.info/post/20180921-raft/" class="no-underline">Raft算法原理</a>
          <br />
        
          <a href="https://www.codedump.info/post/20190629-service-history/" class="no-underline">服务调用的演进历史</a>
          <br />
        
          <a href="https://www.codedump.info/post/20190406-ddia-chapter09-consistency-and-consensus/" class="no-underline">《数据密集型应用系统设计》第九章《一致性与共识》笔记</a>
          <br />
        
      </div>
    

    <div
    class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
  >      
      



  <script src="https://utteranc.es/client.js"
  repo="lichuang/lichuang.github.io"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>

<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
  </div>


  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center">
      <div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
  </form>
</div>
      <a href="https://github.com/lichuang" class="me-2" target="_blank" title="github">
        <i class="fab fa-github"></i>
      </a>
      <a href="https://www.zhihu.com/people/codedump" class="me-2" target="_blank" title="zhihu">
        <i class="fab fa-zhihu"></i>
      </a>
      <a href="https://weibo.com/lichuang" class="me-2" target="_blank" title="weibo">
        <i class="fab fa-weibo"></i>
      </a>
      <a href="https://twitter.com/lichuang" class="me-2" target="_blank" title="twitter">
        <i class="fab fa-twitter"></i>
      </a>


  <a href="https://www.codedump.info/index.xml" type="application/rss+xml" class="me-2" target="_blank" title="rss">
      <i class="fas fa-rss"></i> 
    </a>
</div>


<div class="text-center">
    <p class="text-sm text-tertiary-text">&copy; 2018 <a href="https://www.codedump.info/">codedump</a>   
  <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
</span>
 &middot; 
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/wangchucheng/hugo-eureka" rel="noopener" target="_blank">Eureka</a>
</div>

</div>
    </footer>
  </body>
</html>
