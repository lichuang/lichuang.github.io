<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="codedump">

  
  
  <meta name="description" content="Etcd Raft库的日志存储">
  

  
  <link rel="icon" href="https://www.codedump.info/favicon.ico">

  
  
  <meta name="keywords" content=" Raft  Etcd  分布式 ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:title" content="Etcd Raft库的日志存储" />
<meta property="og:description" content="Etcd Raft库的日志存储" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20210628-etcd-wal/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-28T17:01:53+08:00" />
<meta property="article:modified_time" content="2021-06-28T17:01:53+08:00" />



  
  <link rel="canonical" href="https://www.codedump.info/post/20210628-etcd-wal/">

  
  
  <meta itemprop="name" content="Etcd Raft库的日志存储">
<meta itemprop="description" content="Etcd Raft库的日志存储"><meta itemprop="datePublished" content="2021-06-28T17:01:53+08:00" />
<meta itemprop="dateModified" content="2021-06-28T17:01:53+08:00" />
<meta itemprop="wordCount" content="6992">
<meta itemprop="keywords" content="etcd,raft,分布式," />

  
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/content.css'>

  
  
  <title>Etcd Raft库的日志存储 - codedump的网络日志</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Etcd Raft库的日志存储"/>
<meta name="twitter:description" content="Etcd Raft库的日志存储"/>


  
<link rel="stylesheet" href='https://www.codedump.info/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://www.codedump.info">codedump的网络日志</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">发表</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/20200122-series-pages/">系列文章索引</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/weekly">周刊</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="https://www.codedump.info/index.xml">订阅</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/about">关于</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>Etcd Raft库的日志存储</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://www.codedump.info/tags/etcd'>#etcd</a>
    
    <a class="link" href='https://www.codedump.info/tags/raft'>#raft</a>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%88%86%E5%B8%83%E5%BC%8F'>#分布式</a>
    
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#wal文件格式">WAL文件格式</a>
      <ul>
        <li><a href="#元数据">元数据</a></li>
        <li><a href="#日志数据">日志数据</a></li>
        <li><a href="#状态数据">状态数据</a></li>
        <li><a href="#校验初始值">校验初始值</a></li>
        <li><a href="#快照数据">快照数据</a></li>
      </ul>
    </li>
    <li><a href="#快照文件格式">快照文件格式</a></li>
  </ul>

  <ul>
    <li><a href="#数据对齐">数据对齐</a></li>
    <li><a href="#写缓冲区">写缓冲区</a></li>
    <li><a href="#识别部分写入partial-write数据">识别部分写入（partial write）数据</a></li>
    <li><a href="#修复wal文件流程">修复wal文件流程</a></li>
    <li><a href="#只读和只写文件的区别">只读和只写文件的区别</a></li>
  </ul>

  <ul>
    <li><a href="#日志数据-1">日志数据</a></li>
    <li><a href="#已提交日志">已提交日志</a></li>
    <li><a href="#快照数据-1">快照数据</a></li>
    <li><a href="#数据的修复">数据的修复</a></li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <h1 id="概述">概述</h1>
<p>之前看etcd raft实现的时候，由于wal以及日志的落盘存储部分，没有放在raft模块中，对这部分没有扣的特别细致。而且，以前我的观点认为etcd raft把WAL这部分留给了上层的应用去实现，自身通过<code>Ready</code>结构体来通知应用层落盘的数据，这个观点也有失偏颇，etcd只是没有把这部分代码放在raft模块中，属于代码组织的范畴问题，并不是需要应用层自己来实现。</p>
<p>于是，决定专门写一篇文章把这部分内容给讲解一下，主要涉及以下内容：</p>
<ul>
<li>日志（包括快照）文件的格式。</li>
<li>日志（包括快照）内容的落盘、恢复。</li>
</ul>
<p>以前的系列文章可以在下面的链接中找到，本文不打算过多重复原理性的内容：</p>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20210515-raft/">Etcd Raft库的工程化实现 - codedump的网络日志</a></li>
</ul>
<h1 id="wal及快照文件格式">WAL及快照文件格式</h1>
<p>首先来讲解这两种文件的格式，了解了格式才能继续展开下面的讲述。</p>
<h2 id="wal文件格式">WAL文件格式</h2>
<p>wal文件的文件名格式为：seq-index.wal（见函数<code>walName</code>）。其中：</p>
<ul>
<li>seq：序列号，从0开始递增。</li>
<li>index：该wal文件存储的第一条日志数据的索引。</li>
</ul>
<p>因此，如果将一个目录下的所有wal文件按照名称排序之后，给定一个日志索引，很快就能知道该索引的日志落在哪个wal文件之中的。</p>
<p>WAL文件中每条记录的格式如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">Record</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">int64</span> type  <span style="color:#666">=</span> <span style="color:#666">1</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint32</span> crc  <span style="color:#666">=</span> <span style="color:#666">2</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">bytes</span> data  <span style="color:#666">=</span> <span style="color:#666">3</span>;<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><ul>
<li>type：记录的类型，下面解释。</li>
<li>crc：后面data部分数据的crc32校验值。</li>
<li>data：数据部分，根据类型的不同有不同格式的数据。</li>
</ul>
<p>记录数据的类型如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 以下是WAL存放的数据类型
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 元数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	metadataType <span style="color:#0b0;font-weight:bold">int64</span> = <span style="color:#a2f;font-weight:bold">iota</span> <span style="color:#666">+</span> <span style="color:#666">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 日志数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	entryType
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 状态数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	stateType
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 校验初始值
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	crcType
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	snapshotType
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>下面展开解释。</p>
<h3 id="元数据">元数据</h3>
<p>元数据就是应用层自定义的数据，需要注意的是，一个服务中如果有多个wal文件，且这些文件中有多份元数据，那么这些元数据都必须一致，否则报错。</p>
<p>对于etcd这个服务而言，存储的元数据就是节点ID以及集群ID：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	metadata <span style="color:#666">:=</span> pbutil.<span style="color:#00a000">MustMarshal</span>(
</span></span><span style="display:flex;"><span>		<span style="color:#666">&amp;</span>pb.Metadata{
</span></span><span style="display:flex;"><span>			NodeID:    <span style="color:#a2f">uint64</span>(member.ID),
</span></span><span style="display:flex;"><span>			ClusterID: <span style="color:#a2f">uint64</span>(cl.<span style="color:#00a000">ID</span>()),
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> w, err = wal.<span style="color:#00a000">Create</span>(cfg.<span style="color:#00a000">WALDir</span>(), metadata); err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		plog.<span style="color:#00a000">Fatalf</span>(<span style="color:#b44">&#34;create wal error: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h3 id="日志数据">日志数据</h3>
<p>日志数据的格式，就是<code>raft.proto</code>中<code>Entry</code>的格式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">Entry</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span>     Term  <span style="color:#666">=</span> <span style="color:#666">2</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>]; <span style="color:#080;font-style:italic">// must be 64-bit aligned for atomic operations
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span>     Index <span style="color:#666">=</span> <span style="color:#666">3</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>]; <span style="color:#080;font-style:italic">// must be 64-bit aligned for atomic operations
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">optional</span> EntryType  Type  <span style="color:#666">=</span> <span style="color:#666">1</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">bytes</span>      Data  <span style="color:#666">=</span> <span style="color:#666">4</span>;<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><h3 id="状态数据">状态数据</h3>
<p>保存当前“硬状态（HardState）”的记录，HardState包括：当前任期号、当前给哪个节点ID投票、当前提交的最大日志索引。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">HardState</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span> term   <span style="color:#666">=</span> <span style="color:#666">1</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span> vote   <span style="color:#666">=</span> <span style="color:#666">2</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span> commit <span style="color:#666">=</span> <span style="color:#666">3</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><h3 id="校验初始值">校验初始值</h3>
<p>校验数据这一块，挺有意思的，可以展开好好说一下。</p>
<p>使用CRC算法来计算数据的校验值，除了需要原始数据之外，还需要一个校验初始值（即校验种子seed），在每个wal文件中，类型为<code>校验初始值</code>的记录就用于存储这个值。其值和使用方式有以下几点需要注意：</p>
<ul>
<li>每个wal文件必须有<code>校验初始值</code>类型的数据，后续所有写入该wal文件的记录，都使用该初始值来计算CRC校验值。</li>
<li>第一个wal文件，即序列号为0的wal文件，其校验初始值为0（见wal.go的Create函数）。</li>
<li>当生成下一个wal文件时，以上一个wal文件的最后一条日志数据的CRC校验码来做为该文件的校验初始值，这样就要求类型为<code>校验初始值</code>的记录，必须存储在同一个wal文件中第一条日志数据的前面，否则计算出来该日志数据的crc校验码就不准。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/wal-crc.png" alt="wal文件的校验初始值" title="wal文件的校验初始值"></p>
<p>可以看到，通过这个机制，将多个连续的wal文件“串联”了起来：使用上一个wal文件的最后一个日志数据的crc校验值，来做为下一个wal文件的校验初始值，可以有效的校验同一个项目中wal文件的正确性。</p>
<h3 id="快照数据">快照数据</h3>
<p>在wal文件中存储的快照数据类型的记录，其中仅存储了当前快照的索引和任期号，而快照的详细数据都放到快照数据文件中存储，下面讲到数据恢复时再展开讨论这部分内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">Snapshot</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span> index <span style="color:#666">=</span> <span style="color:#666">1</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint64</span> term  <span style="color:#666">=</span> <span style="color:#666">2</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><h2 id="快照文件格式">快照文件格式</h2>
<p>快照文件的文件名格式为：任期号-索引号.snap（见函数<code>Snapshotter::save</code>）。每次来一个快照数据，都新建一个快照文件，文件中存储快照数据的格式为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">snapshot</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">uint32</span> crc  <span style="color:#666">=</span> <span style="color:#666">1</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">bytes</span> data  <span style="color:#666">=</span> <span style="color:#666">2</span>;<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><p>即：只存储快照数据及其校验值，数据的具体格式由存储快照数据的使用方来解释。在etcd这个服务里，这份快照数据的格式就是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-proto" data-lang="proto"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">message</span> <span style="color:#00f">Snapshot</span> {<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> <span style="color:#0b0;font-weight:bold">bytes</span>            data     <span style="color:#666">=</span> <span style="color:#666">1</span>;<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>	<span style="color:#a2f;font-weight:bold">optional</span> SnapshotMetadata metadata <span style="color:#666">=</span> <span style="color:#666">2</span> [(gogoproto.nullable) <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">false</span>];<span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>}<span style="">
</span></span></span></code></pre></div><h1 id="数据恢复流程">数据恢复流程</h1>
<p>日志、快照数据的落盘，都是为了重启时恢复数据，了解了上面wal以及快照文件的格式，可以来看看数据的恢复流程。</p>
<p>其大体流程如下:</p>
<ul>
<li>到快照目录中取出最新的一份无错的快照文件，首先取出这个文件中存储的快照数据。（见函数<code>Snapshotter::Load</code>）</li>
<li>此时，从快照数据中可以反序列化出：快照数据、对应的任期号、索引号。</li>
<li>根据第二步拿到的快照数据，到wal目录中拿到日志索引号在快照数据索引号之后的日志，遍历满足条件的记录进行数据恢复。（见函数<code>WAL::ReadAll</code>）。</li>
</ul>
<p>下面具体来看每种wal记录格式数据在进行数据恢复时的流程：</p>
<ul>
<li>日志数据：由于还可能存在一小部分小于快照索引的日志，所以恢复时会忽略掉这部分数据。</li>
<li>状态数据：每一条状态数据都会反序列化出来，以最后一条状态数据为准。</li>
<li>元数据：前面提到过，同一个服务的元数据必须一致，所以这里会校验元数据前后是否一致，不一致将报错退出数据恢复流程。</li>
<li>校验初始值数据：可以参见前面关于该类型数据的讲解。</li>
<li>快照数据：下面详细解释。</li>
</ul>
<p>举一个例子来描述前面根据快照文件和WAL文件恢复数据的流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/wal-snap.png" alt="WAL与快照文件关系" title="WAL与快照文件关系"></p>
<p>如上图中：</p>
<ul>
<li>快照文件集合为<code>[1-50.snap,1-150.snap]</code>，取最新的快照文件，即<code>1-150.snap</code>，而<code>1-50.snap</code>文件的数据为过期数据。</li>
<li>由于快照文件中存储的日志索引到150，即在此之前的日志已经全部被压缩到了快照文件中，因此wal文件集合中：
<ul>
<li><code>0-100.wal</code>中的数据已经全部被压缩。</li>
<li><code>1-200.wal</code>中的数据部分被压缩，恢复数据时要忽略日志索引小于150的日志数据。</li>
<li><code>3-300.wal</code>中的数据都没有被压缩，恢复数据时要如实全部重放该文件的数据。</li>
</ul>
</li>
</ul>
<p>前面分析快照数据类型的时候，提到过这个类型的数据在wal文件中的记录，只会存储：</p>
<ul>
<li>当前快照时对应的任期号。</li>
<li>当前快照时对应的索引号。</li>
<li>而具体的快照数据内容存储在快照文件中。</li>
</ul>
<p>也就是说，当生成一份新的快照数据时，将会把这份快照数据相关的以上三部分内容存储到wal和快照文件中。</p>
<p>所以当恢复数据的时候，此时已经反序列化出快照数据了，这时拿着快照数据读wal文件时，如果读到了快照类型的数据，就会去对比起任期号和索引号是否一致，不一致报错停止恢复流程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">case</span> snapshotType: <span style="color:#080;font-style:italic">// 快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>			<span style="color:#a2f;font-weight:bold">var</span> snap walpb.Snapshot
</span></span><span style="display:flex;"><span>			pbutil.<span style="color:#00a000">MustUnmarshal</span>(<span style="color:#666">&amp;</span>snap, rec.Data)
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">if</span> snap.Index <span style="color:#666">==</span> w.start.Index { <span style="color:#080;font-style:italic">// 两者的索引相同
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>				<span style="color:#a2f;font-weight:bold">if</span> snap.Term <span style="color:#666">!=</span> w.start.Term { <span style="color:#080;font-style:italic">// 但是任期号不同
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>					state.<span style="color:#00a000">Reset</span>()
</span></span><span style="display:flex;"><span>					<span style="color:#080;font-style:italic">// 返回ErrSnapshotMismatch错误
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>					<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>, state, <span style="color:#a2f;font-weight:bold">nil</span>, ErrSnapshotMismatch
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#080;font-style:italic">// 保存快照数据匹配的标志位
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>				match = <span style="color:#a2f;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span></code></pre></div><p>以上，解释清楚了wal、快照文件的格式，以及数据恢复的流程。</p>
<p>因为wal文件和快照文件的读写，都与磁盘读写相关，所以在etcd服务中，将这两个结构体，统一到<code>etcdserver/storage.go</code>的<code>storage</code>结构体中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> storage <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>wal.WAL
</span></span><span style="display:flex;"><span>	<span style="color:#666">*</span>snap.Snapshotter
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由<code>storage</code>结构体统一对外提供wal、快照文件的读写接口：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> Storage <span style="color:#a2f;font-weight:bold">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Save function saves ents and state to the underlying stable storage.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// Save MUST block until st and ents are on stable storage.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#00a000">Save</span>(st raftpb.HardState, ents []raftpb.Entry) <span style="color:#0b0;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// SaveSnap function saves snapshot to the underlying stable storage.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#00a000">SaveSnap</span>(snap raftpb.Snapshot) <span style="color:#0b0;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// DBFilePath returns the file path of database snapshot saved with given
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// id.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#00a000">DBFilePath</span>(id <span style="color:#0b0;font-weight:bold">uint64</span>) (<span style="color:#0b0;font-weight:bold">string</span>, <span style="color:#0b0;font-weight:bold">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Close closes the Storage and performs finalization.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#00a000">Close</span>() <span style="color:#0b0;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面，解释一下写wal文件中需要注意的一些细节。</p>
<h1 id="写优化问题">写优化问题</h1>
<h2 id="数据对齐">数据对齐</h2>
<p>每条写入wal的记录，都会将其大小向上8字节对齐，多出来的部分填零：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> <span style="color:#00a000">encodeFrameSize</span>(dataBytes <span style="color:#0b0;font-weight:bold">int</span>) (lenField <span style="color:#0b0;font-weight:bold">uint64</span>, padBytes <span style="color:#0b0;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	lenField = <span style="color:#a2f">uint64</span>(dataBytes)
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// force 8 byte alignment so length never gets a torn write
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	padBytes = (<span style="color:#666">8</span> <span style="color:#666">-</span> (dataBytes <span style="color:#666">%</span> <span style="color:#666">8</span>)) <span style="color:#666">%</span> <span style="color:#666">8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span> padBytes <span style="color:#666">!=</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		lenField <span style="color:#666">|=</span> <span style="color:#a2f">uint64</span>(<span style="color:#666">0x80</span>|padBytes) <span style="color:#666">&lt;&lt;</span> <span style="color:#666">56</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/record.png" alt="WAL记录数据需8字节对齐" title="WAL记录数据需8字节对齐"></p>
<h2 id="写缓冲区">写缓冲区</h2>
<p>另外，为了缓解写文件的IO负担，etcd做了一个写优化：落盘的数据首先写到一个内存缓冲区中，只有每次填满了一个page的数据才会进行落盘操作。</p>
<p>etcd中定义了几个常量：</p>
<ul>
<li>const minSectorSize = 512</li>
<li>const walPageBytes = 8 * minSectorSize</li>
</ul>
<p>其中：<code>minSectorSize</code>表示一个sector的大小，而<code>walPageBytes</code>必须为<code>minSectorSize</code>的整数倍。</p>
<p>etcd中定义了一个<code>PageWriter</code>结构体，用于实现写入日志的操作，内部定义了一个循环缓冲区，只有填满一个<code>walPageBytes</code>大小的数据才会进行落盘。</p>
<p>下图是写入数据落盘后循环缓冲区的变化的示意图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/cyclic-buffer.png" alt="写入数据落盘后循环缓冲区的变化" title="写入数据落盘后循环缓冲区的变化"></p>
<ul>
<li>黄色方块表示一个page的空闲空间，绿色方块表示待写入数据，红色方块表示当前已经写入数据的缓冲区。</li>
<li>刚开始，第一个page已经有部分数据写入，还剩余一部分空闲空间。因此，当写入数据时，只会把写入数据凑齐一个页面大小来落盘。</li>
<li>落盘完毕之后，第一个page重新变成黄色，即空闲页面，而第二个页面存储了写入数据中没有落盘的部分。</li>
</ul>
<p>代码流程见函数<code>PageWriter::Write</code>。</p>
<p>从上面的写入落盘流程可以看到，一次写入的数据可能会有一部分落盘，一部分还在内存中，这样当系统发生宕机这部分数据就是被损坏（corruption）的数据。</p>
<p>因此，etcd中还需要有办法来识别和恢复数据。</p>
<h2 id="识别部分写入partial-write数据">识别部分写入（partial write）数据</h2>
<p>函数<code>decoder::isTornEntry</code>用于判断一条记录是否为部分写的损坏数据。</p>
<p>其原理是：</p>
<ul>
<li>每次新创建用于写入记录的wal文件，都会将剩余文件清零。</li>
<li>读入记录的数据之后，将数据根据不大于每个chunk为<code>minSectorSize</code>大小的方式，存入chunk数组中。</li>
<li>遍历这些chunk，如果有一个chunk的数据全部是零，则认为这块数据是部分写入的损坏数据。</li>
</ul>
<p>这个地方要跟前面落盘流程来对照看：因为每次落盘都是以一个page为单位落盘，而page大小又是<code>minSectorSize</code>的整数倍，因此以<code>minSectorSize</code>为一个chunk的大小来判断是否损坏。</p>
<h2 id="修复wal文件流程">修复wal文件流程</h2>
<p>当进行数据恢复时，可能会出现前面的部分写导致数据损坏问题，etcd会进行如下的修复操作：</p>
<ul>
<li>部分写导致数据损坏都只会出现在最后一个wal文件，因此打开最后一个wal文件进行处理（见函数<code>openLast</code>）。</li>
<li>出现部分写导致损坏的记录，解析过程中都会返回<code>ErrUnexpectedEOF</code>错误，对于这样的文件：
<ul>
<li>将损坏的文件重命名为<code>原文件名.broken</code>。</li>
<li>记录下来最后一个无损记录的偏移量，将损坏之后的数据都截断（Truncate）。</li>
</ul>
</li>
</ul>
<h2 id="只读和只写文件的区别">只读和只写文件的区别</h2>
<p>在etcd中，wal文件有两种并不能同时共存的模式：对于同一个wal文件而言，要么处于只读模式，要么处于append写模式，这两种模式不能同时存在。见<code>WAL</code>结构体的注释：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// WAL is a logical representation of the stable storage.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// WAL is either in read mode or append mode but not both.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// A newly created WAL is in append mode, and ready for appending records.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// A just opened WAL is in read mode, and ready for reading records.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// The WAL will be ready for appending after reading out all the previous records.
</span></span></span></code></pre></div><p>根据上面可能使用缓冲区优化写操作可知，两种模式下在读记录时能容忍的错误级别也不一样：</p>
<ul>
<li>读模式：读模式下可能读到部分写的数据，所以可以容忍这种错误。</li>
<li>写模式：写模式下，不能容忍读到部分写的数据。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">switch</span> w.<span style="color:#00a000">tail</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">case</span> <span style="color:#a2f;font-weight:bold">nil</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// We do not have to read out all entries in read mode.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// The last record maybe a partial written one, so
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// ErrunexpectedEOF might be returned.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// 在只读模式下，可能没有读完全部的记录。最后一条记录可能是只写了一部分，此时就会返回ErrunexpectedEOF错误
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">!=</span> io.EOF <span style="color:#666">&amp;&amp;</span> err <span style="color:#666">!=</span> io.ErrUnexpectedEOF { <span style="color:#080;font-style:italic">// 如果不是EOF以及ErrunexpectedEOF错误的情况就返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>			state.<span style="color:#00a000">Reset</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>, state, <span style="color:#a2f;font-weight:bold">nil</span>, err
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">// 写模式下必须读完全部的记录
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#080;font-style:italic">// We must read all of the entries if WAL is opened in write mode.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>		<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">!=</span> io.EOF { <span style="color:#080;font-style:italic">// 如果不是EOF错误，说明没有读完数据就报错了，这种情况也是返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>			state.<span style="color:#00a000">Reset</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>, state, <span style="color:#a2f;font-weight:bold">nil</span>, err
</span></span><span style="display:flex;"><span>		}
</span></span></code></pre></div><h1 id="数据落盘的全流程">数据落盘的全流程</h1>
<p>以上了解了wal、快照文件的格式，以及写入流程，这里把之前写的不够好的数据落盘流程重新梳理一下。</p>
<p>在 <a href="https://www.codedump.info/post/20180922-etcd-raft/#%E8%BE%93%E5%85%A5%E5%8F%8A%E8%BE%93%E5%87%BA">etcd Raft库解析 - codedump的网络日志</a>中，曾经指出etcd raft库是通过<code>Ready</code>结构体，来通知应用层的当前的数据的，不清楚的话可以回看一下之前的内容。在这里，只解释该结构体中与数据落盘相关的几个成员的数据走向流程，即日志数据（成员<code>Entries</code>）、快照数据（<code>Snapshot</code>）、已提交日志（<code>CommittedEntries</code>）。</p>
<h2 id="日志数据-1">日志数据</h2>
<p>日志数据从客户端提交到落盘的走向是这样的：</p>
<ul>
<li>由客户端提交给服务器（注：只有leader节点才能接收客户端提交的日志数据，其他节点需转发给leader）。</li>
<li>服务器收到之后，首先调用<code>raftLog.append</code>函数保存到<code>unstable_log</code>中，此时日志还是在内存中的，并未落地。</li>
<li>通过<code>newReady</code>函数构建<code>Ready</code>结构体时，将上一步保存下来的日志数据保存到<code>Ready</code>结构体的<code>Entries</code>。</li>
<li>应用层收到<code>Ready</code>结构体之后，调用wal的<code>WAL.Save</code>接口保存日志数据。这一步做完之后，可以认为日志数据已经落盘了。</li>
<li>由于数据已经落盘到WAL日志中，所以在应用层通过<code>Node.Advance</code>接口回调通知raft库时，暂存在<code>unstable_log</code>中的日志就可以通过函数<code>raftLog.stableTo</code>删除了。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/log-flow.png" alt="日志数据从提交到落盘的走向" title="日志数据从提交到落盘的走向"></p>
<h2 id="已提交日志">已提交日志</h2>
<p>raft日志中，需要保存两个日志索引：</p>
<ul>
<li>appliedIndex：通知到应用层目前为止最大的日志索引；</li>
<li>commitIndex：当前已提交日志的最大索引。</li>
</ul>
<p>在这里，总有<code>appliedIndex &lt;= commitIndex</code>条件成立，即日志总是先被提交成功（即达成一致），才会通知给应用层。</p>
<p>通知应用层已提交日志的流程如下：</p>
<ul>
<li>调用<code>raftLog.nextEnts()</code>函数获得当前满足<code>appliedIndex &lt;= commitIndex</code>条件的日志，存入到<code>Ready.CommittedEntries</code>通知应用层。</li>
<li>应用层处理这部分已提交日志。</li>
<li>调用<code>raftLog.appliedTo()</code>函数，这里会修改<code>appliedIndex = commitIndex</code>，即所有日志都已通知应用层。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/appliedIndex.png" alt="通知应用层已提交日志流程" title="通知应用层已提交日志流程"></p>
<h2 id="快照数据-1">快照数据</h2>
<p>快照数据由应用层生成，然后将生成的快照数据、当前appliedIndex、配置状态一起交给存储层，保存之后就可以把在该快照之前的数据给删除了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (rc <span style="color:#666">*</span>raftNode) <span style="color:#00a000">maybeTriggerSnapshot</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 生成快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	data, err <span style="color:#666">:=</span> rc.<span style="color:#00a000">getSnapshot</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 通知存储层快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	rc.raftStorage.<span style="color:#00a000">CreateSnapshot</span>(rc.appliedIndex, <span style="color:#666">&amp;</span>rc.confState, data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 保存快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	rc.<span style="color:#00a000">saveSnap</span>(snap)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 将快照之前的数据压缩
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	compactIndex <span style="color:#666">:=</span> <span style="color:#a2f">uint64</span>(<span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>	rc.raftStorage.<span style="color:#00a000">Compact</span>(compactIndex)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 更新快照数据索引，以便下一次生成新的快照数据
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	rc.snapshotIndex = rc.appliedIndex
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="数据的修复">数据的修复</h2>
<p>从上面的分析中可以看到，日志数据是在客户端提交之后，就马上落盘到WAL文件中的，不会等到日志在集群中达成一致。</p>
<p>这样会带来一个问题，比如：</p>
<ul>
<li>节点A认为自己还是集群的leader节点，此时收到客户端日志之后，将数据落盘到WAL文件中。</li>
<li>落盘之后，节点A将日志同步给集群的其它节点，但是发现自己已经不再是集群的leader节点了。</li>
</ul>
<p>在这种情况下，显然第一步已经落盘的日志是无效的，需要进行修复，这时候是怎么操作的呢？</p>
<p>etcd raft的做法是不回退日志，继续走正常的流程，用新的、正确的日志添加在错误的日志后面，这样回放数据的时候恢复数据。</p>
<p>继续以上面的例子为例：</p>
<ul>
<li>节点A在认为自己是leader的情况下落盘日志到本地WAL中，落盘完毕之后同步给集群内其他节点。</li>
<li>同步到集群其他节点的过程中，才发现节点A已经不是集群的leader，此时节点A降级为follower节点，并开始从正确的集群节点那里同步日志。</li>
<li>同步日志的流程中，节点A将收到来自leader节点的正确日志，这些日志也将落盘到节点A的WAL中。</li>
</ul>
<p>第二步中同步日志的流程可以参见 <a href="https://www.codedump.info/post/20180921-raft/#%E6%96%B0leader%E4%B8%8Efollower%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE">Raft算法原理 - codedump的网络日志</a>，这里不再阐述。</p>
<p>上面的流程之后，节点A的WAL中将存在：</p>
<ul>
<li>认为自己是leader时已落盘的日志；</li>
<li>集群leader纠正节点A同步过来的日志。</li>
</ul>
<p>这样，当重启恢复时，会一并将这些日志重放，应用层只要按顺序回放日志即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20210628-etcd-wal/wal-failback.png" alt="WAL日志的纠错机制" title="WAL日志的纠错机制"></p>
<p>如上图中：</p>
<ul>
<li>节点认为自己是leader节点时，落盘到WAL文件中的日志是<code>[(1,10),(1,11)]</code>，列表中的二元组数据中，第一个元素是任期号，第二个元素是日志索引号。</li>
<li>在落盘日志之后，节点将数据广播到集群，才发现自己已经不是集群的leader节点，此时集群的leader节点发现从日志10开始，该节点的数据就是不对的，开始同步正确的日志给节点，于是把正确的日志<code>[(2,10),(2,11)]</code>同步给了节点，这部分日志会添加到前面错误的日志之后。</li>
<li>假设节点重启恢复，那么会依次重放前面这四条日志，其中前两条日志是错误的日志，但是由于有后面的两条正确日志，最终节点的状态还是会恢复正确状态。</li>
<li>随着后面日志数据压缩成快照文件，冗余的错误日志的磁盘占用将被解决。</li>
</ul>
<p><strong>读者不妨在这里就着这个流程多思考一个问题：做为follower的节点，是什么时候将日志落盘到WAL文件中，是在收到leader节点同步过来的日志时，还是在leader节点通知某个日志已经在集群达成一致？为什么以及流程是怎样的？</strong></p>
<h1 id="总结">总结</h1>
<ul>
<li>etcd的wal模块，虽然并没有和raft模块放在一起，但并不是说这一部分就需要应用者来自己实现，这两部分其实是一起打包做为整个etcd raft算法库提供给使用者的。可以认为raft模块提供算法，wal和快照模块提供日志存储读写的接口。</li>
<li>日志落盘部分，包括wal文件以及快照文件读写这两部分内容，etcd将这两部分统一到<code>Storage</code>接口统一对外服务。</li>
<li>raft算法是在收到客户端日志之后就理解落盘日志到wal文件中保存的，如果后面发现出错，就走正常的同步正确日志的流程，将正确的日志添加到后面，这样恢复时重放整个日志，最终节点达成一致的正确状态。</li>
</ul>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://www.codedump.info/post/20210515-raft/">← prev</a>
    
    
    <a class="link" href="https://www.codedump.info/post/20210701-memcached/">next →</a>
    
  </div>

    
<h1>相关文章</h1><li><strong> 7059-05-07: </strong> <a href="https://www.codedump.info/post/20220507-weekly-14/">周刊（第14期）：重读Raft论文中的集群成员变更算法（二）：实践篇</a>  </li><li><strong> 17049-04-17: </strong> <a href="https://www.codedump.info/post/20220417-weekly-13/">周刊（第13期）：重读Raft论文中的集群成员变更算法（一）：理论篇</a>  </li><li><strong> 1019-01-01: </strong> <a href="https://www.codedump.info/post/20220101-etcd3.5-joint-consensus/">etcd 3.5版本的joint consensus实现解析</a>  </li><li><strong> 11109-10-11: </strong> <a href="https://www.codedump.info/post/20211011-raft-propose-prev-term/">为什么Raft协议不能提交之前任期的日志？</a>  </li><li><strong> 15059-05-15: </strong> <a href="https://www.codedump.info/post/20210515-raft/">Etcd Raft库的工程化实现</a>  </li><li><strong> 25119-11-25: </strong> <a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a>  </li><li><strong> 22099-09-22: </strong> <a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a>  </li><li><strong> 21099-09-21: </strong> <a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a>  </li>

<h1>邮件订阅</h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>

<img align="center" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">
    <footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/etcd/">etcd</a>
          <a href="/tags/raft/">raft</a>
          <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          </div><div class="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lichuang-codedump" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    
    
    
        <script src="https://utteranc.es/client.js"
            repo="{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
  
    
  </div>

  <main id="main" class="main">
    <div class="content-wrapper">
      <div id="content" class="content">
        
      </div>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
    <script src="https://utteranc.es/client.js"
            repo="lichuang/lichuang.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
  </main>


  
</main>

    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/lichuang>GitHub</a>,
<a class=link href=https://twitter.com/lichuang>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  



  
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>

</html>
