<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="codedump">

  
  
  <meta name="description" content="boltdb 1.3.0实现分析">
  

  
  <link rel="icon" href="https://www.codedump.info/favicon.ico">

  
  
  <meta name="keywords" content=" boltdb  存储引擎 ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:title" content="boltdb 1.3.0实现分析（一）" />
<meta property="og:description" content="boltdb 1.3.0实现分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codedump.info/post/20200625-boltdb-1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-06-25T21:43:17+08:00" />
<meta property="article:modified_time" content="2020-06-25T21:43:17+08:00" />



  
  <link rel="canonical" href="https://www.codedump.info/post/20200625-boltdb-1/">

  
  
  <meta itemprop="name" content="boltdb 1.3.0实现分析（一）">
<meta itemprop="description" content="boltdb 1.3.0实现分析"><meta itemprop="datePublished" content="2020-06-25T21:43:17+08:00" />
<meta itemprop="dateModified" content="2020-06-25T21:43:17+08:00" />
<meta itemprop="wordCount" content="4077">
<meta itemprop="keywords" content="存储,存储引擎," />

  
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://www.codedump.info/css/content.css'>

  
  
  <title>boltdb 1.3.0实现分析（一） - codedump的网络日志</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="boltdb 1.3.0实现分析（一）"/>
<meta name="twitter:description" content="boltdb 1.3.0实现分析"/>


  
<link rel="stylesheet" href='https://www.codedump.info/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://www.codedump.info">codedump的网络日志</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">发表</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/20200122-series-pages/">系列文章索引</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/weekly">周刊</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="https://www.codedump.info/index.xml">订阅</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/page/about">关于</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>boltdb 1.3.0实现分析（一）</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8'>#存储</a>
    
    <a class="link" href='https://www.codedump.info/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E'>#存储引擎</a>
    
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#page结构体">page结构体</a></li>
    <li><a href="#meta页面">meta页面</a></li>
    <li><a href="#freelist页面">freelist页面</a></li>
    <li><a href="#branch页面">branch页面</a></li>
    <li><a href="#leaf页面">leaf页面</a></li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <blockquote>
<p>本文基于boltdb 1.3.0对其实现进行分析。boltdb是etcd系统存储数据使用的KV嵌入式DB，使用Go编码实现，内部是一个B+树结构体。关于etcd、raft协议以及B+树，可以参考之前的文章：</p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a></li>
<li><a href="https://www.codedump.info/post/20180922-etcd-raft/">etcd Raft库解析</a></li>
<li><a href="https://www.codedump.info/post/20181125-etcd-server/">Etcd存储的实现</a></li>
<li><a href="https://www.codedump.info/post/20200609-btree-1/">B树、B+树索引算法原理（上）</a></li>
<li><a href="https://www.codedump.info/post/20200615-btree-2/">B树、B+树索引算法原理（下）</a></li>
</ul>
</blockquote>
<blockquote>
<p>本文的写作，主要参考了<a href="https://www.jianshu.com/p/b86a69892990">《区块的持久化之BoltDB》系列文章</a>以及<a href="https://youjiali1995.github.io/storage/boltdb">boltdb 源码分析</a></p>
</blockquote>
<h1 id="概述">概述</h1>
<p>boltdb是etcd项目使用的kv存储引擎，代码量不大，不算测试用例的话仅有几千行代码量，是入门存储引擎不错的参考项目。</p>
<p>boltdb中与mysql这类的关系数据库相对应的概念列举如下：</p>
<table>
<thead>
<tr>
<th>boltdb</th>
<th>mysql</th>
</tr>
</thead>
<tbody>
<tr>
<td>db</td>
<td>database</td>
</tr>
<tr>
<td>bucket</td>
<td>table</td>
</tr>
</tbody>
</table>
<p>即：在boltdb中，db代表一个数据库，对应一个db文件；而一个数据库中可能有多个表，对应的概念就是boltdb中的bucket。</p>
<p>另外，对B+树有了解的都知道，B+树中为了减少磁盘读写次数，每次读写都是以页为单位的，对应到boltdb中用<code>page</code>数据结构表示，<code>page</code>只是描述磁盘上一个页面的数据结构，当一个页面读取到内存中时，就使用<code>node</code>结构体来描述。另外，既然落地到磁盘的单位是页，就需要有数据结构来管理页面的分配，这部分使用<code>freelist</code>这个数据结构来管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/page-struct.png" alt="page-struct" title="page-struct"></p>
<p>以下，首先展开对页面相关核心数据结构的分析。</p>
<h1 id="数据库文件的磁盘布局和页面">数据库文件的磁盘布局和页面</h1>
<p>前面提到过，boltdb中以页面为单位来进行磁盘的读写操作，一个页面的大小一般而言与操作系统的页面一致，即4K大小。在boltdb中，分为以下几种类型的页面：</p>
<ul>
<li>存储meta元数据的页面。</li>
<li>存储freelist，即管理页面数据的页面。</li>
<li>Branch页面，存储B+树索引节点，也就是内部节点的页面。</li>
<li>Leaf页面，存储B+树数据节点，也就是叶子节点的页面。</li>
</ul>
<p>boltdb代码中定义页面类型如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>	branchPageFlag   = <span style="color:#666">0x01</span>
</span></span><span style="display:flex;"><span>	leafPageFlag     = <span style="color:#666">0x02</span>
</span></span><span style="display:flex;"><span>	metaPageFlag     = <span style="color:#666">0x04</span>
</span></span><span style="display:flex;"><span>	freelistPageFlag = <span style="color:#666">0x10</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>这四种页面，在boltdb的数据库文件的布局大体如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/boltdb-layout.png" alt="boltdb-layout" title="boltdb-layout"></p>
<p>从上图中可以看出：</p>
<ul>
<li>最开始的两个页面是两个meta页面，至于为什么是两个，后面再展开讨论。</li>
<li>紧跟着的一个页面是freelist页面。</li>
<li>从上面可知，数据库文件中最开始的三个页面存的都是管理信息，此后数据数据型的branch以及leaf页面了。</li>
</ul>
<p>接下来就这几种页面具体的结构展开说明，不过在此之前还是首先来看看<code>page</code>结构体，它用于表示一个磁盘页面的数据结构。</p>
<h2 id="page结构体">page结构体</h2>
<p><code>page</code>结构体的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> pgid <span style="color:#0b0;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> page <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    id       pgid
</span></span><span style="display:flex;"><span>    flags    <span style="color:#0b0;font-weight:bold">uint16</span>
</span></span><span style="display:flex;"><span>    count    <span style="color:#0b0;font-weight:bold">uint16</span>
</span></span><span style="display:flex;"><span>    overflow <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>    ptr      <span style="color:#0b0;font-weight:bold">uintptr</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>id：页面ID。</li>
<li>flags：标志位，不同类型的页面用不同的标志位来区分。分为：metaPageFlag、freelistPageFlag、branchPageFlag、leafPageFlag。</li>
<li>count：页面中存储的数据数量，仅在页面类型是branch以及leaf的时候起作用。</li>
<li>overflow：当前页面如果还不够存放数据，就会有后续页面，这个字段表示后续页面的数量。</li>
<li>ptr：指向页表头数据结尾，也就是页面数据的起始位置。一个页面的页表头由前面的id、flags、count和overflow字段构成，而ptr并不是页表头的一部分。</li>
</ul>
<p>根据以上的分析，一个页面的格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/page-layout.png" alt="page-layout" title="page-layout"></p>
<p>有了对页面的初步认识，接着下来看具体的几种不同类型页面的格式。</p>
<h2 id="meta页面">meta页面</h2>
<p>meta页面用于存储表示整个数据库信息的元数据，其格式如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> meta <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    magic    <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>    version  <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>    pageSize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>    flags    <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>    root     bucket
</span></span><span style="display:flex;"><span>    freelist pgid
</span></span><span style="display:flex;"><span>    pgid     pgid
</span></span><span style="display:flex;"><span>    txid     txid
</span></span><span style="display:flex;"><span>    checksum <span style="color:#0b0;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>magic：boltdb的magic number，值为“0xED0CDAED”。</li>
<li>version：boltdb的版本号，当前为2。</li>
<li>pageSize：boltdb文件的页面大小。</li>
<li>flags：保留字段，暂时未使用。</li>
<li>root：保存boltdb的根bucket的信息，后续介绍bucket时详细展开。</li>
<li>freelist：保存freelist页面的页面ID。</li>
<li>pgid：保存当前总的页面数量，即最大页面号加一。</li>
<li>txid：上一次写数据库的事务ID，可以看作是当前boltdb的修改版本号，每次写数据库时加1，只读时不改变。</li>
<li>checksum：校验码，用于校验元数据页面是否出错的。</li>
</ul>
<p>从上面对<code>page</code>结构体的分析，ptr指向具体的页面数据内容，据此，从<code>page</code>结构体中返回<code>meta</code>指针的函数如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (p <span style="color:#666">*</span>page) <span style="color:#00a000">meta</span>() <span style="color:#666">*</span>meta {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> (<span style="color:#666">*</span>meta)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>p.ptr))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>即：将<code>page</code>的ptr指针转换为<code>meta</code>类型返回。</p>
<p>因此，一个<code>meta</code>页面的格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/meta-page-layout.png" alt="meta-page-layout" title="meta-page-layout"></p>
<h2 id="freelist页面">freelist页面</h2>
<p>接下来看freelist页面的构成。由于boltdb磁盘分配的单位是页面，所以当前哪些页面可用、哪些闲置，就需要用一个数据结构来描述，这部分信息就由freelist页面来维护。如果当前磁盘页面已经不够分配了，boltdb就需要扩大磁盘文件的大小，创建出更多可用的闲置页面供分配。</p>
<p>来看freelist的数据结构定义：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">type</span> freelist <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	ids     []pgid          <span style="color:#080;font-style:italic">// all free and available free page ids.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	pending <span style="color:#a2f;font-weight:bold">map</span>[txid][]pgid <span style="color:#080;font-style:italic">// mapping of soon-to-be free page ids by tx.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	cache   <span style="color:#a2f;font-weight:bold">map</span>[pgid]<span style="color:#0b0;font-weight:bold">bool</span>   <span style="color:#080;font-style:italic">// fast lookup of all free and pending page ids.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>ids：保存当前闲置页面id的数组。</li>
<li>pending：保存事务操作对应的页面ID，键为事务ID，值为页面ID数组。这部分的页面ID，在事务操作完成之后即被释放。</li>
<li>cache：标记一个页面ID可用，即这个成员中的所有键都是页面ID，而这些页面ID当前都是闲置可分配使用的。</li>
</ul>
<p>在这三个成员中，并不是所有成员都是需要保存到磁盘上的数据，实际上读写freelist页面时是这样操作的：</p>
<ul>
<li>读页面内容到内存：对应操作在<code>freelist.read</code>中，页面数据部分保存的是当前闲置页面ID数组，将其读入<code>ids</code>成员中。</li>
<li>写页面内容到磁盘：对应操作在<code>freelist.write</code>中，读取<code>ids</code>数组和<code>pending</code>中的页面id，拼接、排序之后在一起写入磁盘。</li>
</ul>
<p>即：freelist页面的数据部分，仅存储的是可用的页面ID数组。这一部分在读取到内存时，写入<code>ids</code>成员中，而<code>pending</code>和<code>cache</code>，都是boltdb分配页面流程中的中间产物。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/freelist-page-layout.png" alt="freelist-page-layout" title="freelist-page-layout"></p>
<p><code>freelist</code>中的一些操作与事务有关，这里暂时不展开这部分的讨论，先来看看基本的页面分配是怎么完成的。</p>
<p><code>freelist</code>对外提供<code>allocate</code>函数，该函数的参数是一个整数n，表示希望能分配连续的n个页面，返回这些页面中第一个页面的页面ID。实际情况肯定不是每次这样分配就能成功的，在不成功的时候，boltdb就只能再进行<code>mmap</code>操作，扩大数据库磁盘文件的大小了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// allocate returns a contiguous block of memory starting at a given page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (db <span style="color:#666">*</span>DB) <span style="color:#00a000">allocate</span>(count <span style="color:#0b0;font-weight:bold">int</span>) (<span style="color:#666">*</span>page, <span style="color:#0b0;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// Use pages from the freelist if they are available.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 分配页面id，传入的count表示需要多少个连续的id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> p.id = db.freelist.<span style="color:#00a000">allocate</span>(count); p.id <span style="color:#666">!=</span> <span style="color:#666">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">return</span> p, <span style="color:#a2f;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 前面分配页面id失败，说明当前已经不够用了，所以需要重新mmap分配更大的空间出来
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Resize mmap() if we&#39;re at the end.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	p.id = db.rwtx.meta.pgid
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 计算需要的最小文件大小
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">var</span> minsz = <span style="color:#a2f">int</span>((p.id<span style="color:#666">+</span><span style="color:#00a000">pgid</span>(count))<span style="color:#666">+</span><span style="color:#666">1</span>) <span style="color:#666">*</span> db.pageSize
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// 如果大于当前文件大小，需要重新分配
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#a2f;font-weight:bold">if</span> minsz <span style="color:#666">&gt;=</span> db.datasz {
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> err <span style="color:#666">:=</span> db.<span style="color:#00a000">mmap</span>(minsz); err <span style="color:#666">!=</span> <span style="color:#a2f;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">nil</span>, fmt.<span style="color:#00a000">Errorf</span>(<span style="color:#b44">&#34;mmap allocate error: %s&#34;</span>, err)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#080;font-style:italic">// Move the page id high water mark.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	<span style="color:#080;font-style:italic">// 保存目前最高的页面id
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>	db.rwtx.meta.pgid <span style="color:#666">+=</span> <span style="color:#00a000">pgid</span>(count)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> p, <span style="color:#a2f;font-weight:bold">nil</span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从以上代码可以看到：</p>
<ul>
<li>首先调用<code>freelist.allocate</code>分配count个连续页面，返回起始页面ID。</li>
<li>这个过程一旦失败，意味着当前系统中已经没有了count个连续页面，此时计算满足条件需要的最小文件大小，如果超过了当前数据库文件大小，就调用<code>db.mmap</code>函数对磁盘文件扩容。</li>
</ul>
<p>继续看<code>db.mmap</code>函数的实现，这里仅仅列举出核心的代码：</p>
<pre tabindex="0"><code>// mmap opens the underlying memory-mapped file and initializes the meta references.
// minsz is the minimum size that the new mmap can be.
func (db *DB) mmap(minsz int) error {
	// Unmap existing data before continuing.
	if err := db.munmap(); err != nil {
		return err
	}

	// Memory-map the data file as a byte slice.
	if err := mmap(db, size); err != nil {
		return err
	}

	// Save references to the meta pages.
	// 前两页是两个meta数据
	db.meta0 = db.page(0).meta()
	db.meta1 = db.page(1).meta()
}
</code></pre><p>在上面的代码中：</p>
<ul>
<li>mmap操作之前首先调用<code>munmap</code>函数取消内存映射，再重新调用一次<code>mmap</code>函数扩大文件大小之后映射进入内存。</li>
<li>由于以上的操作，磁盘大小发生了变化，那么肯定就需要更新<code>meta</code>页面信息。</li>
</ul>
<h2 id="branch页面">branch页面</h2>
<p>branch页面就是用于存储B+树中的内部节点的页面，即这里的数据只有索引数据，由于只有索引数据，所以branch中并不会存储值。</p>
<p>branch页面的数据部分划分为两个部分：</p>
<ul>
<li>branchPageElement数组，即存储每个branch元素的元信息。</li>
<li>真实的数据部分。</li>
</ul>
<p>来看看<code>branchPageElement</code>结构体的定义，该结构体定义每个branch中的元素的信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// branchPageElement represents a node on a branch page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">type</span> branchPageElement <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	pos   <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	ksize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	pgid  pgid
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>pos：存储键相对于当前页面数据部分的偏移量。</li>
<li>ksize：键的大小。</li>
<li>pgid：子节点的页面ID。</li>
</ul>
<p>branch页面的格式布局也可以从<code>page</code>序列化到内存中的<code>node</code>结构体的代码中看出，以下列出核心的几个函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// branchPageElement retrieves the branch node by index
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">func</span> (p <span style="color:#666">*</span>page) <span style="color:#00a000">branchPageElement</span>(index <span style="color:#0b0;font-weight:bold">uint16</span>) <span style="color:#666">*</span>branchPageElement {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">&amp;</span>((<span style="color:#666">*</span>[<span style="color:#666">0x7FFFFFF</span>]branchPageElement)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>p.ptr)))[index]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (n <span style="color:#666">*</span>branchPageElement) <span style="color:#00a000">key</span>() []<span style="color:#0b0;font-weight:bold">byte</span> {
</span></span><span style="display:flex;"><span>	buf <span style="color:#666">:=</span> (<span style="color:#666">*</span>[maxAllocSize]<span style="color:#0b0;font-weight:bold">byte</span>)(unsafe.<span style="color:#00a000">Pointer</span>(n))
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">return</span> (<span style="color:#666">*</span>[maxAllocSize]<span style="color:#0b0;font-weight:bold">byte</span>)(unsafe.<span style="color:#00a000">Pointer</span>(<span style="color:#666">&amp;</span>buf[n.pos]))[:n.ksize]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">func</span> (n <span style="color:#666">*</span>node) <span style="color:#00a000">read</span>(p <span style="color:#666">*</span>page) {
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#666">:=</span> <span style="color:#666">0</span>; i &lt; <span style="color:#a2f">int</span>(p.count); i<span style="color:#666">++</span> {
</span></span><span style="display:flex;"><span>		inode <span style="color:#666">:=</span> <span style="color:#666">&amp;</span>n.inodes[i]
</span></span><span style="display:flex;"><span>		<span style="color:#a2f;font-weight:bold">if</span> n.isLeaf {
</span></span><span style="display:flex;"><span>		} <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			elem <span style="color:#666">:=</span> p.<span style="color:#00a000">branchPageElement</span>(<span style="color:#a2f">uint16</span>(i))
</span></span><span style="display:flex;"><span>			inode.pgid = elem.pgid
</span></span><span style="display:flex;"><span>			inode.key = elem.<span style="color:#00a000">key</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上代码中可以看到：</p>
<ul>
<li>根据<code>page.branchPageElement</code>函数的实现，在branch类型的页面中，<code>page.ptr</code>实际上指向的是一个<code>branchPageElement</code>类型的数组，于是将<code>ptr</code>指针转换成<code>branchPageElement</code>数组类型之后，就可以使用索引值取到对应位置的<code>branchPageElement</code>。</li>
<li>而根据<code>branchPageElement.key</code>函数的实现，一个<code>branchPageElement</code>的<code>key</code>，位置在这个元素的<code>pos</code>位置开始，长度为<code>key</code>。</li>
</ul>
<p>因此，branch页面的格式如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/branch-page-layout.png" alt="branch-page-layout" title="branch-page-layout"></p>
<h2 id="leaf页面">leaf页面</h2>
<p>leaf页面就是B+树中存储数据的叶子节点，其页面元素定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// leafPageElement represents a node on a leaf page.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">type</span> leafPageElement <span style="color:#a2f;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	flags <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	pos   <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	ksize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>	vsize <span style="color:#0b0;font-weight:bold">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与branch不同的是，leaf页面元素有以下成员：</p>
<ul>
<li>flags：标志位，为0的时候表示就是普通的叶子节点，而为1的时候表示是子bucket，子bucket后面再展开说明。</li>
<li>vsize：存储数据的大小。</li>
</ul>
<p>与branch页面类似，leaf页面也分为两大部分：</p>
<ul>
<li>存储<code>leafPageElement</code>类型数据的数组。</li>
<li>存储key、value数据的数组。</li>
</ul>
<p>可以看到，leaf节点元素与branch节点元素类似，在这里就不再加以说明，仅把格式示意图列在下面，读者可以自己参考代码阅读：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200625-boltdb-1/leaf-page-layout.png" alt="leaf-page-layout" title="leaf-page-layout"></p>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://www.codedump.info/post/20200620-sgfap-loadavg/">← prev</a>
    
    
    <a class="link" href="https://www.codedump.info/post/20200711-boltdb-2/">next →</a>
    
  </div>

    
<h1>相关文章</h1><li><strong> 1029-02-01: </strong> <a href="https://www.codedump.info/post/20220201-sqlite-btree-5-btree/">sqlite3.36版本 btree实现（五）- Btree的实现</a>  </li><li><strong> 6019-01-06: </strong> <a href="https://www.codedump.info/post/20220106-sqlite-btree-4-wal/">sqlite3.36版本 btree实现（四）- WAL的实现</a>  </li><li><strong> 22129-12-22: </strong> <a href="https://www.codedump.info/post/20211222-sqlite-btree-3-journal/">sqlite3.36版本 btree实现（三）- journal文件备份机制</a>  </li><li><strong> 18129-12-18: </strong> <a href="https://www.codedump.info/post/20211218-sqlite-btree-2-concurrency-control/">sqlite3.36版本 btree实现（二）- 并发控制框架</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-1-pagecache/">sqlite3.36版本 btree实现（一）- 管理页面缓存</a>  </li><li><strong> 17129-12-17: </strong> <a href="https://www.codedump.info/post/20211217-sqlite-btree-0/">sqlite3.36版本 btree实现（零）- 起步及概述</a>  </li><li><strong> 26079-07-26: </strong> <a href="https://www.codedump.info/post/20200726-boltdb-4/">boltdb 1.3.0实现分析（四）</a>  </li><li><strong> 25079-07-25: </strong> <a href="https://www.codedump.info/post/20200725-boltdb-3/">boltdb 1.3.0实现分析（三）</a>  </li><li><strong> 11079-07-11: </strong> <a href="https://www.codedump.info/post/20200711-boltdb-2/">boltdb 1.3.0实现分析（二）</a>  </li><li><strong> 15069-06-15: </strong> <a href="https://www.codedump.info/post/20200615-btree-2/">B树、B&#43;树索引算法原理（下）</a>  </li><li><strong> 9069-06-09: </strong> <a href="https://www.codedump.info/post/20200609-btree-1/">B树、B&#43;树索引算法原理（上）</a>  </li><li><strong> 15029-02-15: </strong> <a href="https://www.codedump.info/post/20190215-leveldb/">Leveldb代码阅读笔记</a>  </li>

<h1>邮件订阅</h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>

<img align="center" src="https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">
    <footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%AD%98%E5%82%A8/">存储</a>
          <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</a>
          </div><div class="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "lichuang-codedump" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    
    
    
        <script src="https://utteranc.es/client.js"
            repo="{{ .Site.Params.utterances.owner }}/{{ .Site.Params.utterances.repo }}"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
  
    
  </div>

  <main id="main" class="main">
    <div class="content-wrapper">
      <div id="content" class="content">
        
      </div>
      <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
    <script src="https://utteranc.es/client.js"
            repo="lichuang/lichuang.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </div>
  </main>


  
</main>

    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/lichuang>GitHub</a>,
<a class=link href=https://twitter.com/lichuang>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  



  
  

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>

</html>
