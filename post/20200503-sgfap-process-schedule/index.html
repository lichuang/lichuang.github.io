<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>《面向应用开发者的系统指南》CPU篇之进程调度 - codedump的网络日志</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="https://www.codedump.info/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="https://www.codedump.info/js/eureka.min.a3e627c430c1281e6e0f18283a36c9cd4ddd90b993c45656c2290b897d81d6b0753b8fd02dc595974e0b8afcb4e8e1ea.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://www.codedump.info/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://www.codedump.info/js/fontawesome.min.baf0948b0e7ea00c33313fb016b8a0e5c7725c684add602643f55da64f608bad06c1be591b2833159abe73ce50507d4b.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-126255685-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-126255685-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://www.codedump.info/images/dog_hu5c22961f17f3d038037c179f30645f4a_467474_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://www.codedump.info/images/dog_hu5c22961f17f3d038037c179f30645f4a_467474_180x180_fill_box_center_3.png">

<meta name="description"
  content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 一种资源，如果本身数量有限，需要多个资源需求方来使">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://www.codedump.info/post/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"《面向应用开发者的系统指南》CPU篇之进程调度",
      "item":"https://www.codedump.info/post/20200503-sgfap-process-schedule/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.codedump.info/post/20200503-sgfap-process-schedule/"
    },
    "headline": "《面向应用开发者的系统指南》CPU篇之进程调度 - codedump的网络日志","datePublished": "2020-05-03T09:53:34+08:00",
    "dateModified": "2020-05-03T09:53:34+08:00",
    "wordCount":  12825 ,
    "publisher": {
        "@type": "Person",
        "name": "lichuang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.codedump.info/images/dog.png"
        }
        },
    "description": "本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 一种资源，如果本身数量有限，需要多个资源需求方来使"
}
</script><meta property="og:title" content="《面向应用开发者的系统指南》CPU篇之进程调度 - codedump的网络日志" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://www.codedump.info/images/dog.png">


<meta property="og:url" content="https://www.codedump.info/post/20200503-sgfap-process-schedule/" />




<meta property="og:description" content="本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见《面向应用开发者的系统指南》导论。 概述 一种资源，如果本身数量有限，需要多个资源需求方来使" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="codedump的网络日志" />






<meta property="article:published_time" content="2020-05-03T09:53:34&#43;08:00" />


<meta property="article:modified_time" content="2020-05-03T09:53:34&#43;08:00" />



<meta property="article:section" content="post" />


<meta property="article:tag" content="Linux系统" />









<meta property="og:see_also" content="https://www.codedump.info/post/20200522-sgfap-softirq/" />



<meta property="og:see_also" content="https://www.codedump.info/post/20200503-sgfap-process-systemtap/" />





<meta property="og:see_also" content="https://www.codedump.info/post/20200502-sgfap-process/" />



<meta property="og:see_also" content="https://www.codedump.info/post/20200501-system-guide-for-application-programmer/" />






  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">codedump的网络日志</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
            <a href="/post/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">分类</a>
            <a href="/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">标签</a>
            <a href="/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">系列</a>
            <a href="/index.xml" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">RSS</a>
            <a href="https://www.getrevue.co/profile/lichuang" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">邮件订阅</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">《面向应用开发者的系统指南》CPU篇之进程调度</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2020-05-03</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>26分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="https://www.codedump.info/categories/linux%E7%B3%BB%E7%BB%9F/" class="hover:text-eureka"
          >Linux系统</a
        >
      
    </div>
  

  
    <div class="me-6 my-2">
      <i class="fas fa-th-list me-1"></i>
      
        <a href="https://www.codedump.info/series/%E9%9D%A2%E5%90%91%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8D%97/" class="hover:text-eureka"
          >面向应用开发者的系统指南</a
        >
      
    </div>
  
</div>


  
  

  <blockquote>
<p>本文是《面向应用开发者的系统指南》文档其中的一篇，完整的目录见<a href="https://www.codedump.info/post/20200501-system-guide-for-application-programmer/">《面向应用开发者的系统指南》导论</a>。</p>
</blockquote>
<h1 id="概述">概述</h1>
<p>一种资源，如果本身数量有限，需要多个资源需求方来使用的情况下，就涉及到<code>资源调度</code>的问题。在内核中，CPU就是一种有限的资源，同时在系统中处于运行状态的进程数量有很多，此时就需要设计出一种方法，尽可能的保证这种资源被公平的分配到进程中间。</p>
<p>Linux内核中的进程调度，涉及到以下几个重要概念：</p>
<ul>
<li>核心调度器：核心调度器可以认为是内核中进程调度模块，对外提供了周期性调度（定时触发）以及主调度器两个接口。</li>
<li>就绪队列：所有当前运行的进程都在这个队列中维护，需要选择出下一个执行的进程也从这个队列中选举。</li>
<li>调度优先级：给予不同的进程不同的优先级，这样分配到的时间就不一样。</li>
<li>调度算法：不同类型的进程使用不同的调度算法来选择执行进程。</li>
</ul>
<p>以下来简单阐述这几个组件如何一起作用完成进程调度的工作。</p>
<p>每个CPU维护自己的就绪队列，就绪队列由结构体<code>rq</code>来表示，队列中的每个元素都是前面提到的描述进程信息的结构体<code>task_struct</code>。这里需要注意的是，虽然称之为“队列”，内部的实现中，根据不同的调度算法，使用了不同的数据结构来保存进程，比如CFS调度器使用了红黑树来保存进程，这一点在后面展开阐述，目前为止，暂且认为就绪队列是一个维护CPU所有当前就绪进程的容器。</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/runqueue.png" alt="runqueue" title="runqueue"></p>
<p>不同的调度器算法，无论内部如何实现，其最终都是从就绪队列中选择下一个可执行的进程来运行。
在这个版本的内核中一共实现了如下几种调度器算法，它们统一由结构体<code>sched_class</code>来表示：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/sched_class.png" alt="sched_class" title="sched_class"></p>
<table>
<thead>
<tr>
<th>调度器</th>
<th>描述</th>
<th>对应调度策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>dl_sched_class</td>
<td>deadline调度器</td>
<td>SCHED_DEADLINE</td>
</tr>
<tr>
<td>rt_sched_class</td>
<td>实时调度器</td>
<td>SCHED_FIFO、SCHED_RR</td>
</tr>
<tr>
<td>fair_sched_class</td>
<td>完全公平调度器</td>
<td>SCHED_NORMAL、SCHED_BATCH</td>
</tr>
<tr>
<td>idle_sched_class</td>
<td>idle调度器</td>
<td>SCHED_IDLE</td>
</tr>
</tbody>
</table>
<p>以上列举了进程的几种调度器及对应的调度策略，其优先级依次递减。在下面的内容中，将详细介绍完全公平调度器（Completely Fair Scheduler，简称CFS），因为这是最普遍的进程调度器。</p>
<p>从以上的介绍可以看到，内核的调度器负责维护就绪队列，即提供了调度进程所需的数据来源；而不同的调度器算法则根据自己的实现来从就绪队列中选择进程来执行，那么选择的依据又是什么？答案是进程的优先级。</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/schedule.png" alt="schedule" title="schedule"></p>
<p>以上简单阐述了Linux进程调度中涉及到的四个最重要的要素，下面将展开讨论。</p>
<p>首先将介绍进程的优先级，通过这个值如何计算得到进程的权重，进一步得到<code>CFS</code>调度器算法中所需的虚拟运行时间。</p>
<p>紧接着介绍与进程调度相关的数据结构，以及内核中进程调度的核心调度器的实现。</p>
<p>最后就是详细展开<code>CFS</code>调度器内部的实现。</p>
<h1 id="优先级权重和虚拟运行时间">优先级、权重和虚拟运行时间</h1>
<h2 id="优先级">优先级</h2>
<p>Linux通过nice命令设置进程的静态优先级，进程的nice值在[-20,19]之间，值越小优先级越高。而内核本身，选择范围[0,139]在内部表示优先级，同样是数值越低优先级越高：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/nice.png" alt="nice" title="nice"></p>
<p>对于普通的进程，可以认为优先级不会发生变化，而实时进程则不然：</p>
<pre><code class="language-C">// kernel/sched/core.c
static int effective_prio(struct task_struct *p)
{
	p-&gt;normal_prio = normal_prio(p);
	// 如果不是实时进程，返回前面normal_prio的计算结果
	if (!rt_prio(p-&gt;prio))
		return p-&gt;normal_prio;
	return p-&gt;prio;
}
</code></pre>
<p>由于在这里不讨论实时进程，仅讨论普通进程，因此可以认为进程优先级就是静态不变的。</p>
<h2 id="cpu时间权重">CPU时间权重</h2>
<p>CFS调度器的设计理念，就是能够实现理想、精确的多任务CPU进程调度。与以往的调度器不同的是，CFS调度器没有时间片的概念，使用的是分配CPU时间的比例。通过进程的优先级，就可以计算出来一个进程在就绪队列中所占时间的权重了。</p>
<p>nice值与权重之间是一对一的关系，为了实现普通进程的nice值到CPU时间权重的快速计算，内核预计算好了一个映射数组：</p>
<pre><code class="language-C">// kernel/sched/core.c
const int sched_prio_to_weight[40] = {
 /* -20 */     88761,     71755,     56483,     46273,     36291,
 /* -15 */     29154,     23254,     18705,     14949,     11916,
 /* -10 */      9548,      7620,      6100,      4904,      3906,
 /*  -5 */      3121,      2501,      1991,      1586,      1277,
 /*   0 */      1024,       820,       655,       526,       423,
 /*   5 */       335,       272,       215,       172,       137,
 /*  10 */       110,        87,        70,        56,        45,
 /*  15 */        36,        29,        23,        18,        15,
};
</code></pre>
<p>该数组的可以认为是这样根据nice值预先计算出来的：</p>
<pre><code>weight = 1024 / (1.25 ^ nice)
</code></pre>
<p>公式中的1.25取值依据是：进程每降低一个nice值，将多获得10%的cpu时间。公式中以1024权重为基准值计算得来，1024权重对应nice值为0，其权重被称为NICE_0_LOAD。默认情况下，大部分进程的权重基本都是NICE_0_LOAD。</p>
<p>根据进程的权重值，可以得到分配给进程的CPU时间计算公式如下：</p>
<pre><code>分配给进程的时间 = 总的cpu时间 * 进程的权重/就绪队列中所有进程权重之和
</code></pre>
<h2 id="虚拟运行时间">虚拟运行时间</h2>
<p>有了进程在CPU运行的权重之后，内核就可以根据权重值计算出进程的虚拟运行时间（virtual runtime）。什么是“虚拟运行时间”，就是内核根据进程运行的实际时间和权重计算出来的一个时间，CFS调度器只需要保证在同一个CPU上面运行的进程，其虚拟运行时间一致即可。</p>
<p>比如，进程A和进程B，权重分别为1024和820（nice值分别为0和1），在6ms的运行周期中，进程A获得的运行时间<code>6*1024/(1024+820) = 3.3ms</code>，进程B获得的运行时间为<code>6*820/(1024+820) = 2.7ms</code>。进程A的cpu使用比例是<code>3.3/6x100%=55%</code>，进程B的cpu使用比例是<code>2.7/6x100%=45%</code>。计算结果也符合上面说的“进程每降低一个nice值，将多获得10% CPU的时间”。使用下面的公式转换成虚拟运行时间：</p>
<pre><code>vriture_runtime = wall_time * NICE_0_LOAD / weight
</code></pre>
<p>即：进程A的虚拟时间<code>3.3 * 1024 / 1024 = 3.3ms</code>，可以看出nice值为0的进程的虚拟时间和实际时间是相等的。进程B的虚拟时间是<code>2.7 * 1024 / 820 = 3.3ms</code>。</p>
<p>可以看出尽管A和B进程的权重值不一样，但是计算得到的虚拟时间是一样的。CFS调度器只要保证在同一个CPU上面运行的进程，其虚拟时间一致即可。</p>
<p>从上面虚拟运行时间的计算也可以知道，一个进程的虚拟允许时间越小，其权重反而是越大的，即虚拟运行时间小的进程被调度执行的权重更大。</p>
<p>为了避免浮点数运算，内核中采用先放大再缩小的方法以保证计算精度。内核又对前面计算虚拟运行时间的公式做了如下转换：</p>
<pre><code>vriture_runtime = (wall_time * NICE_0_LOAD) / weight
= (wall_time * NICE_0_LOAD * 2 ^32 / weight) &gt;&gt; 32
= (wall_time * NICE_0_LOAD * inv_weight) &gt;&gt; 32 (其中inv_weight=(2^32 / weight))
</code></pre>
<p>为了方便计算inv_weight的值，内核定义了一个预分配数组sched_prio_to_wmult，其中每一项的值为(2^32 / sched_prio_to_weight[prio])：</p>
<pre><code class="language-C">// kernel/sched/core.c
const u32 sched_prio_to_wmult[40] = {
 /* -20 */     48388,     59856,     76040,     92818,    118348,
 /* -15 */    147320,    184698,    229616,    287308,    360437,
 /* -10 */    449829,    563644,    704093,    875809,   1099582,
 /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,
 /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,
 /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,
 /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,
 /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,
};
</code></pre>
<p>内核中使用结构体<code>load_weight</code>来描述进程的权重信息：</p>
<pre><code class="language-C">// include/linux/sched.h
struct load_weight {
	unsigned long			weight;
	u32				inv_weight;
};
</code></pre>
<p>其中，成员<code>weight</code>存储进程的权重，而成员<code>inv_weight</code>存储<code>2^32/ weight</code>。</p>
<p>有了前面的铺垫，来看内核中对应的实现，内核中使用函数<code>__calc_delta</code>来将实际时间转换为虚拟时间，算法原理就是前面介绍到的公式：</p>
<pre><code class="language-C">// kernel/sched/fair.c
static u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw)
{
	u64 fact = scale_load_down(weight);
	int shift = WMULT_SHIFT;

	__update_inv_weight(lw);

	if (unlikely(fact &gt;&gt; 32)) {
		while (fact &gt;&gt; 32) {
			fact &gt;&gt;= 1;
			shift--;
		}
	}

	/* hint to use a 32x32-&gt;64 mul */
	fact = (u64)(u32)fact * lw-&gt;inv_weight;

	while (fact &gt;&gt; 32) {
		fact &gt;&gt;= 1;
		shift--;
	}

	return mul_u64_u32_shr(delta_exec, fact, shift);
}
</code></pre>
<p>以下将前面的nice值、权重、虚拟运行时间的关系总结如下图：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/vruntime.png" alt="vruntime" title="vruntime"></p>
<h2 id="更新虚拟运行时间">更新虚拟运行时间</h2>
<p>由于更新进程调度实体以及就绪队列的虚拟运行时间的操作如此重要，所以内核中有一个专门的<code>update_curr</code>函数完成这个工作：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/update_curr.png" alt="update_curr" title="update_curr"></p>
<p>这里，<code>update_curr</code>函数除了更新进程本身的虚拟运行时间之外，还要更新就绪队列的<code>min_vruntime</code>（最小虚拟运行时间），下面介绍到CFS调度算法时讲解释这个值的作用。</p>
<h1 id="数据结构">数据结构</h1>
<p>前面描述了进程的优先级是如何与进程的虚拟运行时间相关联的，接着继续看与进程调度相关的核心数据结构。</p>
<h2 id="task_struct中与调度相关的成员">task_struct中与调度相关的成员</h2>
<p><code>task_struct</code>中与调度算法相关的成员：</p>
<pre><code class="language-C">// include/linux/sched.h
struct task_struct {
	// ...
	int				prio;
	int				static_prio;
	int				normal_prio;

	const struct sched_class	*sched_class;
	struct sched_entity		se;

	unsigned int			policy;
	int				nr_cpus_allowed;
	cpumask_t			cpus_allowed;  
}
</code></pre>
<ul>
<li><code>task_struct</code>使用了如下几个成员表示进程的优先级，其中<code>prio</code>和<code>normal_prio</code>表示动态优先级，<code>static_prio</code>表示静态优先级。静态优先级在程序启动的时候就分配好了，可以使用<code>nice</code>命令进行修改。<code>normal_prio</code>是在进程运行过程中，根据静态优先级和调度策略动态计算出来的优先级。</li>
<li>结构体<code>sched_class</code>用来表示进程所所属的调度器类。</li>
<li><code>policy</code>保存了进程的调度策略，其中有三个可能的值：
<ul>
<li><code>SCHED_NORMAL</code>用于普通进程，该类型使用完全公平调度器来处理；</li>
<li><code>SCHED_BATCH</code>和<code>SCHED_IDLE</code>：也使用完全公平调度器来处理，不过可以用于次要的进程。<code>SCHED_BATCH</code>用于非交互、CPU密集的批处理进程，这类进程绝不会抢占CFS调度器的另一个进程，因此不会干扰交互式进程。<code>SCHED_IDLE</code>类进程的重要级很低，因为权重最小。</li>
<li><code>SCHED_FIFO</code>和<code>SCHED_RR</code>：用于实现软实时进程。</li>
</ul>
</li>
<li><code>cpus_allowed</code>：是一个位域，在多处理器系统上使用，用来限制进程可以在哪些CPU上运行。</li>
</ul>
<h2 id="调度器类">调度器类</h2>
<p><code>sched_class</code>是用于表示所有调度器算法的结构体，各种调度器算法需要实现里面的成员函数，可以用面向对象的思想理解为所有调度器的“基类”。</p>
<pre><code class="language-C">// kernel/sched/sched.c
struct sched_class {
	const struct sched_class *next;

	void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);
	void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);
	void (*yield_task) (struct rq *rq);
	bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt);

	void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);

	struct task_struct * (*pick_next_task) (struct rq *rq,
						struct task_struct *prev,
						struct rq_flags *rf);
	void (*put_prev_task) (struct rq *rq, struct task_struct *p);

	void (*set_curr_task) (struct rq *rq);
	void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
};
</code></pre>
<p>其中的几个重要成员如下：</p>
<ul>
<li><code>enqueue_task</code>：进程从睡眠状态切换到可运行状态时调用，意为向就绪队列放入一个进程。</li>
<li><code>dequeue_task</code>：用于实现进程出队列操作，当进程从可运行状态切换到不可运行状态时调用。</li>
<li><code>yield_task</code>：进程要让出对CPU的占用时，可使用系统调用<code>sched_yield</code>，最终会调用<code>yield_task</code>。</li>
<li><code>check_preempt_curr</code>：用一个新创建的进程来抢占当前进程，比如当<code>wake_up_new_task</code>函数唤醒新进程就会使用这个函数。</li>
<li><code>pick_next_task</code>：用于选择下一个将要执行的进程，而<code>put_prev_task</code>则在另一个进程代替当前运行的进程之前调用。这两个操作并不等价于将进程加入或撤出就绪队列。</li>
<li><code>task_tick</code>：由周期性调度器调用，下面会谈到。</li>
</ul>
<h2 id="就绪队列">就绪队列</h2>
<p>就绪队列用于维护所有当前可运行的进程，每个CPU上都有一个就绪队列，由结构体<code>rq</code>来表示：</p>
<pre><code class="language-C">// kernel/sched/sched.h
struct rq {
	unsigned int nr_running;

	#define CPU_LOAD_IDX_MAX 5
	unsigned long cpu_load[CPU_LOAD_IDX_MAX];

	struct load_weight load;

	struct cfs_rq cfs;

	struct task_struct *curr, *idle, *stop;
	u64 clock;

  // ...
};
</code></pre>
<ul>
<li><code>nr_running</code>：就绪队列上可运行进程的数目。</li>
<li><code>load</code>：提供CPU就绪队列当前负载的度量。</li>
<li><code>cpu_load</code>：跟踪当前的负荷状态。</li>
<li><code>cfs</code>：分别用于完全公平调度器的就绪队列。</li>
<li><code>curr</code>：指向当前运行进程的<code>task_struct</code>结构体指针。</li>
<li><code>idle</code>：指向当前<code>idle</code>进程的<code>task_struct</code>结构体指针，当当前没有进程在运行的时候执行该进程。</li>
<li><code>clock</code>：用于实现就绪队列自身的时钟。</li>
</ul>
<p>内核中用如下的宏来定义了per-CPU的变量<code>runqueues</code>：</p>
<pre><code class="language-C">// kernel/sched/sched.h
DECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);
</code></pre>
<p>也提供了另外一些与就绪队列相关的宏：</p>
<pre><code class="language-C">// kernel/sched/sched.h

// 得到该CPU的就绪队列
#define cpu_rq(cpu)		(&amp;per_cpu(runqueues, (cpu)))
// 得到当前CPU的就绪队列
#define this_rq()		this_cpu_ptr(&amp;runqueues)
// 根据task_struct指针拿到对应CPU的就绪队列
#define task_rq(p)		cpu_rq(task_cpu(p))
// 得到cpu当前运行的进程task_struct指针
#define cpu_curr(cpu)		(cpu_rq(cpu)-&gt;curr)
</code></pre>
<h2 id="cfs调度器的就绪队列">CFS调度器的就绪队列</h2>
<p>前面看到就绪队列结构体<code>rq</code>中，使用结构体<code>cfs_rq</code>来维护CFS调度器的就绪进程，下面简单了解一下：</p>
<pre><code class="language-C">struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;

	u64 min_vruntime;

	struct rb_root_cached tasks_timeline;
};
</code></pre>
<p>其中：</p>
<ul>
<li>load：就绪队列上所有进程的累积负载值。</li>
<li>nr_running：就绪队列上的进程数量。</li>
<li>min_vruntime：记录就绪队列上进程的最小虚拟运行时间。这个值是计算就绪队列虚拟运行时间的基础，大部分情况下是CFS红黑树最小子节点（最左节点）的虚拟运行时间，但实际情况下可能有时候会比最小子节点的虚拟运行时间稍大一些，后面将展开讨论。</li>
<li>tasks_timeline：将就绪队列上所有进程的虚拟运行时间维护的红黑树。</li>
</ul>
<h2 id="调度实体">调度实体</h2>
<p>CFS调度器可以操作的对象是比进程更一般的实体，所以又使用了<code>sched_entity</code>结构体来描述进程调度的实体信息：</p>
<pre><code class="language-C">// kernel/linux/sched.h
struct sched_entity {
	// 权重信息，在计算虚拟时间的时候会用到inv_weight成员。
	struct load_weight		load;
	unsigned long			runnable_weight;
	// CFS调度器使用红黑树维护调度的进程信息
	struct rb_node			run_node;
	// 进入就绪队列是为1
	unsigned int			on_rq;

	u64				exec_start;
	// 调度实体已经运行实际时间总合
	u64				sum_exec_runtime;
	// 调度实体已经运行的虚拟时间总合。
	u64				vruntime;
	u64				prev_sum_exec_runtime;
};
</code></pre>
<p>总结上面提到的<code>rq</code>、<code>cfs_rq</code>以及<code>sched_entity</code>结构体的关系如下图：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/cfs_rq.png" alt="cfs_rq" title="cfs_rq"></p>
<p>即：<code>rq</code>结构体内部有一个类型为<code>cfs_rq</code>结构体的成员，用于维护CFS算法的运行队列，而<code>cfs_rq</code>内部又是使用红黑树结构来维护成员的，每个红黑树成员是<code>sched_entity</code>结构体类型的节点。</p>
<h1 id="核心调度器">核心调度器</h1>
<p><code>核心调度器</code>指的是内核的进程调度框架，由内核来触发调度进程的时机，而如何选择进程的工作，交予调度器类来实现：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/scheduler-core.png" alt="scheduler-core" title="scheduler-core"></p>
<p>核心调度器中，一共有以下几处地方有机会触发进程调度，下面来分别说明。</p>
<h2 id="周期性调度器">周期性调度器</h2>
<p>周期性调度器的入口函数是<code>scheduler_tick</code>，内核会按照系统频率HZ来自动调用该函数，将<code>scheduler_tick</code>函数精简如下：</p>
<pre><code class="language-C">// kernel/sched/core.c
void scheduler_tick(void)
{
	int cpu = smp_processor_id();
	struct rq *rq = cpu_rq(cpu);
	struct task_struct *curr = rq-&gt;curr;

	// 调用调度类对应的task_tick方法，针对CFS调度类该函数是task_tick_fair。
	curr-&gt;sched_class-&gt;task_tick(rq, curr, 0);
}
</code></pre>
<p>可以看到，周期性调度器通过调度器算法的task_tick函数来完成调度工作，下面讲解CFS算法时详细分析。</p>
<h2 id="主调度器">主调度器</h2>
<p>主调度器的入口函数是<code>schedule</code>，在内核中，当需要将CPU分配给与当前进程不同的另一个进程时，就会调用<code>schedule</code>函数来选择下一个可执行进程。<code>schedule</code>函数最终调用的是<code>__schedule</code>函数，所以这里将<code>__schedule</code>函数拆分来讲解。</p>
<pre><code class="language-C">// kernel/sched/core.c
static void __sched notrace __schedule(bool preempt)
{
	struct task_struct *prev, *next;
	unsigned long *switch_count;
	struct rq_flags rf;
	struct rq *rq;
	int cpu;

	cpu = smp_processor_id();
	rq = cpu_rq(cpu);
	prev = rq-&gt;curr;

	switch_count = &amp;prev-&gt;nivcsw;
	if (!preempt &amp;&amp; prev-&gt;state) {
		if (unlikely(signal_pending_state(prev-&gt;state, prev))) {
			prev-&gt;state = TASK_RUNNING;	/* 1 */
		} else {
			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);	/* 2 */
			prev-&gt;on_rq = 0;
	}

	next = pick_next_task(rq, prev, &amp;rf);	/* 3 */
	clear_tsk_need_resched(prev);	/* 4 */
	clear_preempt_need_resched();

	if (likely(prev != next)) {
		rq = context_switch(rq, prev, next, &amp;rf);	/* 5 */
	}
}
 
</code></pre>
<ol>
<li>如果当前进程处于可中断的睡眠状态，同时现在接收到了信号，那么将再次被提升为可运行进程。</li>
<li>否则就调用<code>deactivate_task</code>函数将当前进程变成不活跃状态，这个函数最终会调用调度器类的<code>dequeue_task</code>完成删除进程的工作。将进程的on_rq标志位置为0，表示不在就绪队列上了。</li>
<li>调用<code>pick_next_task</code>函数选择下一个执行的进程。</li>
<li>清除当前进程的<code>TIF_NEED_RESCHED</code>标志位，意味着不需要重调度。</li>
<li>如果下一个被调度执行进程不是当前进程，调用<code>context_switch</code>函数进行进程上下文切换。</li>
</ol>
<h2 id="与fork的交互">与fork的交互</h2>
<p>除了以上两种场景，即周期性调度器以及主调度器之外，fork创建出新进程的时候也会出现与调度器类的交互，其入口函数是<code>sched_fork</code>：</p>
<pre><code class="language-C">// kernel/sched/core.c
int sched_fork(unsigned long clone_flags, struct task_struct *p)
{ 
	if (p-&gt;sched_class-&gt;task_fork)
		p-&gt;sched_class-&gt;task_fork(p);
}
</code></pre>
<p><code>sched_fork</code>函数中会调用到对应调度器类的<code>task_fork</code>成员函数来处理，下面讲到CFS调度器的时候再详细分析对应的函数。</p>
<p>另外，调用<code>wake_up_new_task</code>唤醒新的子进程执行时，也可能调用到抢占进程相关的操作，下面会分析到。</p>
<h1 id="cfs调度器">CFS调度器</h1>
<h2 id="概述-1">概述</h2>
<p>了解了优先级、虚拟运行时间、相关数据结构、内核调度框架之后，下面正式进入CFS调度器的讲解。</p>
<p>前面介绍了从进程的优先级出发，如何计算出进程在就绪队列中的时间权重，进而再计算出进程的虚拟运行时间。</p>
<p>CFS调度器内部维护一颗红黑树，红黑树的键值即为进程的虚拟运行时间，虚拟运行时间越小的进程，被调度执行的优先级越高，获得更多的CPU时间。</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/cfs.png" alt="cfs" title="cfs"></p>
<p>对比两个调度实体在红黑树中的先后顺序，也就只需要对比其中的虚拟运行时间即可：</p>
<pre><code class="language-C">// kernel/sched/fair.c
static inline int entity_before(struct sched_entity *a,
				struct sched_entity *b)
{
	return (s64)(a-&gt;vruntime - b-&gt;vruntime) &lt; 0;
}
</code></pre>
<p>一个进程在刚刚加入到CFS就绪队列的红黑树中时，需要有一个基准值，即这个新加入的进程，应该和什么虚拟运行时间进行对比，找到它在红黑树中的合适位置。这个值由就绪队列中的最小虚拟运行时间来维护，对应的成员是<code>min_vruntime</code>。</p>
<p>为什么这个最小虚拟运行时间不能直接取最左子节点对应进程的虚拟运行时间？因为系统在运行，对应的里面的每个进程其虚拟运行时间也是一直在增加，因此每个就绪队列的最小虚拟运行时间也一直是增加的才对。正因为这样，这个值不能取最左子节点进程的虚拟运行时间，而是根据系统的情况一直累加，不能发生回退。</p>
<p>还需要注意的一点是，既然虚拟运行时间是一直累加的，那么在进程一直运行的情况下，就可能发生数据溢出现象，因此在对比两个虚拟运行时间大小的时候，不是直接比较而是判断的两者的差值（包括上面的<code>entity_before</code>函数也是比较的差值）：</p>
<pre><code class="language-C">// kernel/sched/fair.c
static inline u64 max_vruntime(u64 max_vruntime, u64 vruntime)
{
	s64 delta = (s64)(vruntime - max_vruntime);
	if (delta &gt; 0)
		max_vruntime = vruntime;

	return max_vruntime;
}
</code></pre>
<p>下面首先讲就绪队列最小虚拟运行时间的计算逻辑。</p>
<h2 id="最小虚拟运行时间的更新">最小虚拟运行时间的更新</h2>
<p>前面讲解虚拟运行时间的计算时，已经介绍了对应的函数<code>update_curr</code>的核心流程，其中最后一步是更新CFS就绪队列的最小虚拟运行时间值，来看对应的<code>update_min_vruntime</code>函数。</p>
<pre><code class="language-C">// kernel/sched/fair.c
static void update_min_vruntime(struct cfs_rq *cfs_rq)
{
	struct sched_entity *curr = cfs_rq-&gt;curr;
	struct rb_node *leftmost = rb_first_cached(&amp;cfs_rq-&gt;tasks_timeline);	/* 1 */
	u64 vruntime = cfs_rq-&gt;min_vruntime;	/* 2 */
 
	if (curr) {
		if (curr-&gt;on_rq)	
			vruntime = curr-&gt;vruntime;	/* 3 */
		else
			curr = NULL;
	}
 
	if (leftmost) { /* non-empty tree */
		struct sched_entity *se;
		se = rb_entry(leftmost, struct sched_entity, run_node);
 
		if (!curr)
			vruntime = se-&gt;vruntime;	/* 4 */
		else
			vruntime = min_vruntime(vruntime, se-&gt;vruntime);	/* 5 */
	}
 
	/* ensure we never gain time by being placed backwards. */
	cfs_rq-&gt;min_vruntime = max_vruntime(cfs_rq-&gt;min_vruntime, vruntime);	/* 6 *
}
</code></pre>
<ol>
<li>首先根据CFS就绪队列的tasks_timeline成员，拿到红黑树的最左子节点。</li>
<li>拿到当期就绪队列的最小虚拟运行时间。</li>
<li>在当前就绪队列运行进程存在且该进程on_rq标志为1的情况下，使用该进程的虚拟运行时间。</li>
<li>在最左子节点存在的情况下，如果当前进程不存在，那么就取最左子节点的虚拟运行时间。</li>
<li>否则取当前进程以及最左子节点进程的虚拟运行时间的最小值。</li>
<li>更新CFS就绪队列的最小虚拟运行时间，其值取当前最小虚拟进程与前面拿到的较小的虚拟运行时间的较大值，这样就能保证CFS就绪队列的最小虚拟运行时间不会发生回退现象。</li>
</ol>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/min_vruntime.png" alt="min_vruntime" title="min_vruntime"></p>
<p>之所以要保证CFS就绪队列的最小虚拟运行时间不回退，是因为CFS就绪队列中的红黑树排序是以调度实体的vruntime作为基准来进行计算的。vruntime值越小的节点，说明虚拟运行时间越少，对应的当前被调度的优先级就越往前，会被更快的调度来执行。</p>
<ul>
<li>在进程运行的时候，vruntime值稳定增加，于是在红黑树中就是向右边移动。</li>
<li>进程在睡眠时，vruntime值保持不变，而每个队列的min_vruntime时间在增加，那么当睡眠进程被唤醒时（比如等待IO事件），其在红黑树中的位置就靠左，因为其键值变小了，于是会被更快的执行。</li>
</ul>
<h2 id="place_entity函数">place_entity函数</h2>
<p>place_entity函数属于CFS调度器算法内部使用的一个函数，其作用是调整进程调度实体的虚拟运行时间，传入的第三个参数initial为1的情况下表示是新创建的进程，否则是被唤醒的进程。</p>
<pre><code class="language-C">// kernel/sched/fair.c
static void
place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)
{
	u64 vruntime = cfs_rq-&gt;min_vruntime;

	if (initial &amp;&amp; sched_feat(START_DEBIT))
		vruntime += sched_vslice(cfs_rq, se);	/* 1 */

	if (!initial) {
		unsigned long thresh = sysctl_sched_latency;

		if (sched_feat(GENTLE_FAIR_SLEEPERS))
			thresh &gt;&gt;= 1;

		vruntime -= thresh;	/* 2 */
	}

	se-&gt;vruntime = max_vruntime(se-&gt;vruntime, vruntime);	/* 3 */
}
</code></pre>
<ol>
<li>initial为1的情况下，表示是新创建的进程，此时将加上一个虚拟时间表示惩罚，因为虚拟时间越大在红黑树中位置就越靠右，被调度执行的顺序也越在后面。计算这个惩罚时间的函数是sched_vslice，后面展开解释。</li>
<li>这种情况是针对被唤醒的进程，期望它能够更快的得到调度执行，所以这里减去一个虚拟运行时间做为补偿。</li>
<li>调度实体的虚拟运行时间，取上面计算出来的时间以及自身的虚拟运行时间的较大值，保证不会发生回退情况。</li>
</ol>
<p>接着看计算惩罚新创建进程虚拟运行时间的函数sched_vslice：</p>
<pre><code class="language-C">// kernel/sched/fair.c
static u64 sched_vslice(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	return calc_delta_fair(sched_slice(cfs_rq, se), se);
}

static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	u64 slice = __sched_period(cfs_rq-&gt;nr_running + !se-&gt;on_rq);	/* 1 */

	slice = __calc_delta(slice, se-&gt;load.weight, load);	/* 2 */

	return slice;
}
</code></pre>
<ol>
<li>通过__sched_period函数计算调度周期时间。</li>
<li>将第一步中计算得到的周期时间通过__calc_delta函数转换为虚拟运行时间。__calc_delta()函数有两个功能，除了可以把计算进程运行时间转换成虚拟时间以外，还有第二个功能：计算调度实体se的权重占整个就绪队列权重的比例，然后乘以调度周期时间即可得到当前调度实体应该运行的时间（参数weught传递调度实体se权重，参数lw传递就绪队列权重cfs_rq-&gt;load）。例如，就绪队列权重是3072，当前调度实体se权重是1024，调度周期是6ms，那么调度实体应该得到的时间是6*1024/3072=2ms。</li>
</ol>
<h2 id="创建新进程时">创建新进程时</h2>
<p>在调用<code>fork</code>函数创建子进程的时候，会调用<code>sched_fork</code>函数设置子进程调度器相关的信息。该函数会调用调度器类中的<code>task_fork</code>成员函数来完成工作，CFS调度器对应的函数就是<code>task_fork_fair</code>函数：</p>
<pre><code class="language-C">static void task_fork_fair(struct task_struct *p)
{
	struct cfs_rq *cfs_rq;
	struct sched_entity *se = &amp;p-&gt;se, *curr;
	struct rq *rq = this_rq();
	struct rq_flags rf;

	cfs_rq = task_cfs_rq(current);
	curr = cfs_rq-&gt;curr;
	if (curr) {
		update_curr(cfs_rq);	/* 1 */
		se-&gt;vruntime = curr-&gt;vruntime;	/* 2 */
	}

	place_entity(cfs_rq, se, 1);	/* 3 */

	se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;	/* 4 */
}
</code></pre>
<ol>
<li>更新CFS就绪队列的虚拟运行时间信息。</li>
<li>初始化新创建的进程对应进程调度实体的虚拟运行时间，与当前进程（其父进程）一样。</li>
<li>place_entity函数在新创建进程以及进程被唤醒的时候都会被调用，新创建的情况下第三个参数为1。</li>
<li>以当前CPU的就绪队列最小虚拟时间为基准，对虚拟运行时间进行一定的补偿（虚拟时间越小，调度的顺位越靠前）。</li>
</ol>
<p>在这里，需要就第四段代码做一个说明。进程在刚创建的时候，其虚拟运行时间是根据当时所在的CPU就绪队列的最小虚拟运行时间为基础计算的，而进程真正开始被调度执行的时候，其所在的CPU很有可能不是最开始创建时所在的CPU了，中间发生了进程在不同CPU之间的迁移。因为不同的CPU之间，其虚拟运行时间也不尽相同，所以这里要做一下处理。比如进程从虚拟运行时间更小的CPU A迁移到虚拟运行时间更大的CPU B上时，可能就会占便宜，因为这个进程比CPU B上面其他的进程虚拟运行时间都小，将获得更大的执行时间。反过来也是如此。</p>
<p>因此，内核对这部分相关情况的处理是：</p>
<ul>
<li>进程刚创建时（函数task_fork_fair）：在以就绪队列的最小虚拟运行时间为基准设置其最初的虚拟运行时间时，还需要再减去队列的最小虚拟运行时间。</li>
<li>进程加入一个CFS就绪队列时（函数enqueue_entity）：虚拟运行时间要加上就绪队列的最小虚拟运行时间。</li>
<li>进程离开一个CFS就绪队列时（函数dequeue_entity）：虚拟运行时间要减去就绪队列的最小虚拟运行时间。</li>
</ul>
<h2 id="队列操作">队列操作</h2>
<h3 id="入队列操作">入队列操作</h3>
<p>CFS调度算法的入队列操作是函数是<code>enqueue_task_fair</code>，其最终会调用<code>enqueue_entity</code>函数完成一个调度实体入队列的操作，来看看这个函数的工作流程。</p>
<pre><code class="language-C">static void
enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
{
	bool renorm = !(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED);
	bool curr = cfs_rq-&gt;curr == se;

	if (renorm &amp;&amp; curr)
		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;	/* 1 */

	update_curr(cfs_rq);	/* 2 */

	if (renorm &amp;&amp; !curr)
		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;	/*3 */

	account_entity_enqueue(cfs_rq, se);	/* 4 */

	if (flags &amp; ENQUEUE_WAKEUP)
		place_entity(cfs_rq, se, 0);	/* 5 */

	if (!curr)
		__enqueue_entity(cfs_rq, se);	/* 6 */

	se-&gt;on_rq = 1;	/* 7 */
}
</code></pre>
<ol>
<li>如果传入的调度实体是当前进程，并且当前进程不是被唤醒或者迁移CPU，那么当前进程的虚拟运行时间就需要加上队列当前的最小虚拟运行时间。虚拟运行时间增加，意味着在红黑树中往右边移动，下一次会更晚的被调度到。这一步需要在下面调用update_curr函数之前进行。</li>
<li>调用update_curr更新当前CFS就绪队列的虚拟运行时间信息。</li>
<li>如果不是被唤醒或者迁移CPU，并且不是当前进程，那么task_fork_fair中减去的虚拟运行时间这里加回来。</li>
<li>flags有ENQUEUE_WAKEUP标志，意味着是被唤醒的进程，调用place_entity函数给予一定的补偿。</li>
<li>不是当前进程的情况下，调用__enqueue_entity函数将调度实体加入红黑树中。</li>
<li>将on_rq标志位置为1。</li>
</ol>
<h3 id="出队列操作">出队列操作</h3>
<p>CFS调度算法的入队列操作是函数是<code>dequeue_task_fair</code>，其最终会调用<code>dequeue_entity</code>函数完成一个调度实体入队列的操作，来看看这个函数的工作流程。</p>
<pre><code class="language-C">static void
dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
{
	update_curr(cfs_rq);	/* 1 */

	if (se != cfs_rq-&gt;curr)
		__dequeue_entity(cfs_rq, se);	/* 2 */

	se-&gt;on_rq = 0;	/* 3 */

	account_entity_dequeue(cfs_rq, se);	/* 4 */

	if (!(flags &amp; DEQUEUE_SLEEP))
		se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;	/* 5 */
}
</code></pre>
<ol>
<li>更新CFS就绪队列的当前虚拟运行时间。</li>
<li>如果不是当前进程，调用__dequeue_entity从红黑树中删除该调度实体。</li>
<li>on_rq标志位置为0，表示不在就绪队列中。</li>
<li>调用account_entity_dequeue更新队列的权重信息。</li>
<li>如果进程不是由于睡眠导致的出队（比如是因为CPU迁移），那么进程的虚拟运行时间就需要减去就绪队列的最小虚拟运行时间。</li>
</ol>
<h2 id="选择下一个执行进程">选择下一个执行进程</h2>
<p>CFS调度器选择下一个执行进程的操作由函数pick_next_task_fair完成，其主要流程如下：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/pick_next_task_fair.png" alt="pick_next_task_fair" title="pick_next_task_fair"></p>
<p>下面逐个分析这几个函数。</p>
<h3 id="put_prev_task">put_prev_task</h3>
<p>put_prev_task函数的作用，是将即将逝去执行权的当前进程，放回到其调度器的就绪队列中，核心工作由put_prev_entity函数完成：</p>
<pre><code>static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)
{
	if (prev-&gt;on_rq)                            /* 1 */
		update_curr(cfs_rq);
	if (prev-&gt;on_rq) {

		__enqueue_entity(cfs_rq, prev);         /* 2 */

		update_load_avg(cfs_rq, prev, 0);       /* 3 */
	}
	cfs_rq-&gt;curr = NULL;                        /* 4 */
} 
</code></pre>
<ol>
<li>如果进程的on_rq为1，表示当进程被剥夺执行权的时候，还是在就绪队列上面的，那么极有可能就是被抢占了执行权。在这种情况下，需要调用update_curr函数更新就绪队列的虚拟运行时间。反之，如果进程不在就绪队列上了，这里并不做操作跳过更新，因为在deactivate_task函数中已经调用update_curr函数进行了更新。</li>
<li>如果进程还在就绪队列上，调用__enqueue_entity函数重新加入就绪队列的红黑树中。</li>
<li>调用update_load_avg函数更新就绪队列的负载信息。</li>
<li>将就绪队列的当前进程指针置为NULL。</li>
</ol>
<h3 id="pick_next_entity">pick_next_entity</h3>
<p>pick_next_entity函数的作用是从红黑树中选择下一个调度进程的调度实体返回：</p>
<pre><code class="language-C">static struct sched_entity *
pick_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
	struct sched_entity *left = __pick_first_entity(cfs_rq);	/* 1 */
	struct sched_entity *se;

	if (!left || (curr &amp;&amp; entity_before(curr, left)))
		left = curr;	/* 2 */

	se = left; /* 3 */

	/* 4 */
	if (cfs_rq-&gt;skip == se) {
		struct sched_entity *second;

		if (se == curr) {	
			second = __pick_first_entity(cfs_rq);	/* 5 */
		} else {
			second = __pick_next_entity(se);	/* 6 */
			if (!second || (curr &amp;&amp; entity_before(curr, second)))
				second = curr;	/* 7 */
		}

		if (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; 1)
			se = second;	/* 8 */
	}

	if (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; 1)
		se = cfs_rq-&gt;last;	/* 9 */

	if (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; 1)
		se = cfs_rq-&gt;next;	/* 10 */

	return se;
}
</code></pre>
<ol>
<li>调用__pick_first_entity函数，取红黑树最左子节点的调度实体，根据我们前面的分析，这是目前虚拟运行时间最小的进程。</li>
<li>如果left为NULL，或者当前进程curr的虚拟运行时间比left节点更小，说明curr进程是主动放弃了执行权力，且其优先级比最左子节点的进程更优，此时将left指向curr。</li>
<li>此时left存储的是目前最优的调度实体指针，se保存下来。</li>
<li>cfs_rq-&gt;skip存储了需要调过不参与调度的进程调度实体，如果我们挑选出来的最优调度实体se正好是skip，就需要重新作出选择。</li>
<li>如果前面选择的se指针，正好是当前进程，这样就重新__pick_first_entity拿到当前红黑树的最左子节点。</li>
<li>否则，skip = se = left的情况，调用__pick_next_entity选择se的下一个子节点。</li>
<li>如果second == NULL，说明没有次优的进程，或者curr不为NULL的情况下，且curr进程比second进程更优，就将second指向curr，即curr是最优的进程。</li>
<li>在second不为NULL，且left和second的vruntime的差距是否小于sysctl_sched_wakeup_granularity的情况下，那么second进程能抢占left的执行权。</li>
<li>判断上一个执行的进程能否抢占left的执行权。</li>
<li>判断next的执行权能否抢占left的执行权。</li>
</ol>
<h3 id="set_next_entity">set_next_entity</h3>
<p><code>set_next_entity</code>函数用于将调度实体存放的进程做为下一个可执行进程的信息保存下来。</p>
<pre><code class="language-C">static void
set_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	if (se-&gt;on_rq) {
		__dequeue_entity(cfs_rq, se);	/* 1 */

		update_load_avg(cfs_rq, se, UPDATE_TG);	/* 2 */
	}

	cfs_rq-&gt;curr = se;	/* 3 */

	se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime;	/* 4 */
}
</code></pre>
<ol>
<li>__dequeue_entity用于将调度实体从红黑树中删除。对于即将被调度执行的进程，都会从红黑树中删除。而当进程被抢占后，会调用<code>put_prev_entity</code>函数重新插入到红黑树中。因此这里与<code>put_prev_entity</code>函数中插入红黑树的操作一一对应。</li>
<li>调用<code>update_load_avg</code>函数更新就绪队列的负载信息，在负载均衡的时候会用到。</li>
<li>更新就绪队列的当前在执行进程指针。</li>
<li>更新调度实体的<code>prev_sum_exec_runtime</code>成员，该成员用于统计当前进程已经运行的时间，<code>check_preempt_tick</code>函数中会使用到，做为判断进程是否能够被抢占的依据。</li>
</ol>
<h2 id="处理周期性调度器">处理周期性调度器</h2>
<p>CFS调度器中，处理周期性调度器的函数是<code>task_tick_fair</code>，实际工作由<code>entity_tick</code>函数负责，其核心流程如下：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/entity_tick.png" alt="entity_tick" title="entity_tick"></p>
<p>其中的<code>update_curr</code>是更新就绪队列虚拟运行时间的函数，前面已经介绍过就不再阐述，重点看这里的<code>check_preempt_tick</code>函数。</p>
<pre><code class="language-C">static void
check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
	unsigned long ideal_runtime, delta_exec;
	struct sched_entity *se;
	s64 delta;
 
	ideal_runtime = sched_slice(cfs_rq, curr);    /* 1 */
	delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;    /* 2 */
	if (delta_exec &gt; ideal_runtime) {
		resched_curr(rq_of(cfs_rq));              /* 3 */
		clear_buddies(cfs_rq, curr);
		return;
	}
 
	if (delta_exec &lt; sysctl_sched_min_granularity)    /* 4 */
		return;
 
	se = __pick_first_entity(cfs_rq);             /* 5 */
	delta = curr-&gt;vruntime - se-&gt;vruntime;
 
	if (delta &lt; 0)                                /* 6 */
		return;
 
	if (delta &gt; ideal_runtime)                    /* 7 */
		resched_curr(rq_of(cfs_rq));
}
</code></pre>
<ol>
<li>sched_slice()函数上面已经分析过，计算curr进程在本次调度周期中应该分配的时间片。时间片用完就应该被抢占。</li>
<li>sum_exec_runtime与prev_sum_exec_runtime的差值delta_exec是当前进程已经运行的实际时间。</li>
<li>如果实际运行时间已经超过分配给进程的时间片，自然就需要抢占当前进程。设置TIF_NEED_RESCHED flag。</li>
<li>为了防止频繁过度抢占，我们应该保证每个进程运行时间不应该小于最小粒度时间sysctl_sched_min_granularity。因此如果运行时间小于最小粒度时间，不应该抢占。</li>
<li>从红黑树中找到虚拟时间最小的调度实体。</li>
<li>如果当前进程的虚拟时间仍然比红黑树中最左边调度实体虚拟时间小，也不应该发生调度。</li>
<li>这里把虚拟时间和实际时间比较，看起来很奇怪。感觉就像是bug一样，然后经过查看提交记录，作者的意图是：希望权重小的任务更容易被抢占。</li>
</ol>
<h2 id="唤醒抢占">唤醒抢占</h2>
<p>当进程被唤醒时（wake_up_new_task、try_to_wake_up等），也是检查进程是否可以抢占当前进程执行权的时机，此时会调用<code>check_preempt_curr</code>来做这个抢占检查的工作：</p>
<pre><code>void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
{
	const struct sched_class *class;
 
	if (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class) {
		rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);   /* 1 */
	} else {
		for_each_class(class) {                                    /* 2 */
			if (class == rq-&gt;curr-&gt;sched_class)
				break;
			if (class == p-&gt;sched_class) {
				resched_curr(rq);
				break;
			}
		}
	}
}
</code></pre>
<ol>
<li>唤醒的进程和当前的进程同属于一个调度类，直接调用调度类的<code>check_preempt_curr</code>函数检查抢占条件。</li>
<li>否则如果唤醒的进程和当前进程不属于一个调度类，就需要按照调度器类的优先级来选择。</li>
</ol>
<p>CFS调度器的<code>check_preempt_curr</code>函数由<code>check_preempt_wakeup</code>实现：</p>
<pre><code class="language-C">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)
{
	struct sched_entity *se = &amp;curr-&gt;se, *pse = &amp;p-&gt;se;
	struct cfs_rq *cfs_rq = task_cfs_rq(curr);
 
	if (wakeup_preempt_entity(se, pse) == 1)    /* 1 */
		goto preempt;
 
	return;
preempt:
	resched_curr(rq);                           /* 2 */
}
</code></pre>
<ol>
<li>调用<code>wakeup_preempt_entity</code>函数检查唤醒的进程是否满足抢占当前进程的条件。</li>
<li>如果可以抢占当前进程，调用<code>resched_curr</code>函数，其内部实现是设置TIF_NEED_RESCHED flag。</li>
</ol>
<p><code>wakeup_preempt_entity</code>函数传入两个调度实体，返回对比结果，分为以下几种情况：</p>
<p><img src="/media/imgs/20200503-sgfap-process-schedule/wakeup_preempt_entity.png" alt="wakeup_preempt_entity" title="wakeup_preempt_entity"></p>
<p>这里之所以要在大于se虚拟运行时间的情况下，需要保证大于gran值才返回1允许调度，是为了避免抢占过于频繁，导致大量上下文切换影响系统性能。默认情况下，wakeup_gran()函数返回的值是1ms根据调度实体se的权重计算的虚拟时间。</p>
<p>因此，满足抢占的条件就是，唤醒的进程的虚拟时间首先要比正在运行进程的虚拟时间小，
并且差值还要大于一定的值才行（这个值是sysctl_sched_wakeup_granularity，称作唤醒抢占粒度）。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《深入Linux内核架构》第2章《进程管理和调度》</li>
<li><a href="http://www.wowotech.net/process_management/447.html">CFS调度器（1）-基本原理</a></li>
<li><a href="http://www.wowotech.net/process_management/448.html">CFS调度器（2）-源码解析</a></li>
</ul>

</article>


      
        <div class="my-4">
    
    <a href="https://www.codedump.info/tags/linux%E7%B3%BB%E7%BB%9F/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#Linux系统</a>
    
</div>
      

      <h1><b>邮件订阅</b></h1>

<div class="custom-footer">
  <form action="https://www.getrevue.co/profile/lichuang/add_subscriber" method="post" id="revue-form" name="revue-form"  target="_blank" align="center">
    <input class="newsletter-email-field" placeholder="邮件订阅本站更新" type="email" name="member[email]" size="26">
    <input class="newsletter-submit-button" type="submit" value="点击订阅" name="member[subscribe]">
    <div class="revue-form-footer">By subscribing, you agree with Revue’s <a target="_blank" href="https://www.getrevue.co/terms">Terms of Service</a> and <a target="_blank" href="https://www.getrevue.co/privacy">Privacy Policy</a>.</div>
  </form>
</div>
      <h1><b>微信公众号</b></h1>

<img align="center" src="https://www.codedump.info/media/imgs/reward/qrcode.png" alt="wechat-account-qrcode">

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >上一页</span
        >
        <a href="https://www.codedump.info/post/20200503-sgfap-process-systemtap/" class="block">《面向应用开发者的系统指南》CPU篇之使用systemtap分析进程的行为</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://www.codedump.info/post/20200502-sgfap-process/" class="block">《面向应用开发者的系统指南》CPU篇之进程</a>
      
    </div>
  </div>


    </div>
    
      <div class="col-span-2">

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="https://www.codedump.info/post/20200502-sgfap-process/" class="no-underline">《面向应用开发者的系统指南》CPU篇之进程</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200501-system-guide-for-application-programmer/" class="no-underline">《面向应用开发者的系统指南》导论</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200218-linux-traceevent/" class="no-underline">Systemtap中内核trace事件的实现</a>
          <br />
        
          <a href="https://www.codedump.info/post/20200128-systemtap-by-example/" class="no-underline">通过实例快速入门Systemtap</a>
          <br />
        
      </div>
    

    <div
    class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
  >      
      



  <script src="https://utteranc.es/client.js"
  repo="lichuang/lichuang.github.io"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async>
</script>

<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
  </div>


  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2018 <a href="https://www.codedump.info/">codedump</a>   
  <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
</span>
 &middot; 
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/wangchucheng/hugo-eureka" rel="noopener" target="_blank">Eureka</a>
</div></div>
    </footer>
  </body>
</html>
