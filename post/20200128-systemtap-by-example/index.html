<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>通过实例快速入门Systemtap - codedump</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="codedump" />
  <meta name="description" content="我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个awesome-" />

  <meta name="keywords" content="Hugo, theme, even" />



<meta name="google-site-verification" content="UA-126255685-1" />


<meta name="generator" content="Hugo 0.54.0" />


<link rel="canonical" href="https://codedump.info/post/20200128-systemtap-by-example/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="通过实例快速入门Systemtap" />
<meta property="og:description" content="我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个awesome-" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://codedump.info/post/20200128-systemtap-by-example/" />
<meta property="article:published_time" content="2020-01-28T11:56:56&#43;08:00"/>
<meta property="article:modified_time" content="2020-01-28T11:56:56&#43;08:00"/>

<meta itemprop="name" content="通过实例快速入门Systemtap">
<meta itemprop="description" content="我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个awesome-">


<meta itemprop="datePublished" content="2020-01-28T11:56:56&#43;08:00" />
<meta itemprop="dateModified" content="2020-01-28T11:56:56&#43;08:00" />
<meta itemprop="wordCount" content="8389">



<meta itemprop="keywords" content="Linux系统,动态跟踪,systemtap," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="通过实例快速入门Systemtap"/>
<meta name="twitter:description" content="我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个awesome-"/>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">codedump</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/page/about">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">codedump</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/page/about">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">通过实例快速入门Systemtap</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-01-28 </span>
        <div class="post-category">
            
              <a href="/categories/linux%E7%B3%BB%E7%BB%9F/"> Linux系统 </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#工作原理">工作原理</a></li>
<li><a href="#stap命令行参数">stap命令行参数</a>
<ul>
<li><a href="#x-pid">-x PID</a></li>
<li><a href="#t-seconds">-T seconds</a></li>
<li><a href="#l和-l">-L和-l</a></li>
<li><a href="#g-var-val">-G VAR=VAL</a></li>
</ul></li>
<li><a href="#探测点">探测点</a>
<ul>
<li><a href="#同步事件">同步事件</a>
<ul>
<li><a href="#模块">模块</a></li>
<li><a href="#所在的函数">所在的函数</a></li>
<li><a href="#调用时机">调用时机</a></li>
</ul></li>
<li><a href="#异步事件">异步事件</a></li>
<li><a href="#探测点别名-alias">探测点别名（alias）</a>
<ul>
<li><a href="#探测点动态定义">探测点动态定义</a></li>
</ul></li>
</ul></li>
<li><a href="#变量">变量</a>
<ul>
<li><a href="#目标变量-target-variables">目标变量（Target Variables）</a></li>
<li><a href="#全局变量">全局变量</a></li>
<li><a href="#打印结构体内容">打印结构体内容</a></li>
<li><a href="#类型转换-typecasting">类型转换（Typecasting）</a></li>
<li><a href="#打印局部变量">打印局部变量</a></li>
</ul></li>
<li><a href="#关联数组-associative-arrays">关联数组（Associative Arrays）</a>
<ul>
<li><a href="#遍历关联数组">遍历关联数组</a>
<ul>
<li><a href="#修改遍历关联数组顺序">修改遍历关联数组顺序</a></li>
<li><a href="#限定遍历关联数组数量">限定遍历关联数组数量</a></li>
</ul></li>
<li><a href="#测试元素存在性">测试元素存在性</a></li>
</ul></li>
<li><a href="#计算统计集合-statistical-aggregates">计算统计集合（Statistical Aggregates）</a>
<ul>
<li><a href="#常规操作">常规操作</a></li>
<li><a href="#打印柱状图数据">打印柱状图数据</a></li>
</ul></li>
<li><a href="#常用函数">常用函数</a></li>
<li><a href="#defined和-choose-defined">@defined和@choose_defined</a></li>
<li><a href="#entry">@entry</a></li>
<li><a href="#嵌入c代码">嵌入C代码</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      

<p>我这段时间好好学习了一下Systemtap相关的使用，这篇文章算是学习过程中总结的一些笔记，我另外在github上创建了一个<a href="https://github.com/lichuang/awesome-systemtap-cn">awesome-systemtap-cn</a>项目，收集systemtap相关的优秀学习资源，欢迎提供其他更好的参考资料。</p>

<h1 id="概述">概述</h1>

<p>systemtap是一款“动态跟踪（dynamic tracing）”工具，为什么需要这类工具？打一个比方，这类工具就好比医生的听诊器，病人就好比是在运行的系统，很多时候查看一些问题需要在系统在运行的时候来观察，这时候就需要这类动态跟踪工具。与之对应的是，类似gdb这样的调试工具，其工作原理是让进程在某些断点暂停下来，查看进程的行为，这种技术称为“静态调试”。</p>

<p>关于动态跟踪技术，推荐阅读<a href="https://openresty.org/posts/dynamic-tracing/">《动态追踪技术漫谈》</a>。</p>

<p>本文旨在通过实例，快速解释systemtap脚本语言的最常见用法和语法。</p>

<h1 id="工作原理">工作原理</h1>

<p>如下图，systemtap使用.stp脚本语言，由命令行<code>stap</code>编译生成对应的内核模块，动态放入内核中执行：</p>

<p><center>
<img src="/media/imgs/20200128-systemtap-by-example/systemtap.gif" alt="systemtap" title="systemtap" />
</center></p>

<ol>
<li>stap 流程从将脚本转换成解析树开始 (pass 1)。</li>
<li>然后使用细化（elaboration）步骤 (pass 2) 中关于当前运行的内核的符号信息解析符号。</li>
<li>接下来，转换流程将解析树转换成 C 源代码 (pass 3) 并使用解析后的信息和 tapset 脚本（SystemTap 定义的库，包含有用的功能）。</li>
<li>stap 的最后步骤是构造使用本地内核模块构建进程的内核模块 (pass 4)。</li>
<li>有了可用的内核模块之后，stap 完成了自己的任务，并将控制权交给其他两个实用程序 SystemTap：staprun 和 stapio。这两个实用程序协调工作，负责将模块安装到内核中并将输出发送到 stdout (pass 5)。如果在 shell 中按组合键 Ctrl-C 或脚本退出，将执行清除进程，这将导致卸载模块并退出所有相关的实用程序。</li>
</ol>

<h1 id="stap命令行参数">stap命令行参数</h1>

<h2 id="x-pid">-x PID</h2>

<p>-x用于传递PID参数给systemtap脚本，这样在脚本内部可以通过target()函数拿到这个传递进来的参数：</p>

<pre><code>// $ sudo stap x-param.stp -x 10
// 输出：pid:10
probe begin
{
  printf(&quot;pid:%d\n&quot;, target())
}
</code></pre>

<h2 id="t-seconds">-T seconds</h2>

<p>-T 参数后面可以带上秒数，这样脚本在这个时间之后自动退出，这样可以设置脚本执行的时间。</p>

<pre><code>// $ sudo stap T-params.stp -T 3
// 输出：time:2
global count

probe timer.s(1) {
  count += 1
}

probe end {
  printf(&quot;time:%d\n&quot;, count)
}
</code></pre>

<h2 id="l和-l">-L和-l</h2>

<p>这两个参数大体作用一样，都可以列举出二进制文件对应的函数在哪里（所在文件和行数），所不同的是，-L比-l还多了一些信息：可以打印出函数局部变量的信息。</p>

<p>比如下面这个简单的C代码：</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;

int func1(int a, int b) {
  return a+b;
}

void func() {
  int a,b,c;

  c = func1(a,b);
  printf(&quot;c:%d\n&quot;, c);
}

int main() {
  func();
  return 0;
}
</code></pre>

<p>使用两个大小写不同的-l参数的输出如下：</p>

<pre><code>$ sudo stap -L 'process(&quot;./a.out&quot;).function(&quot;func&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;) $a:int $b:int $c:int

$ sudo stap -l 'process(&quot;./a.out&quot;).function(&quot;func&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;)
</code></pre>

<p>需要注意的是，要探测的二进制文件必须有调试信息，比如上面的test.c编译出来的a.out文件，需要使用-g参数编译这样才能带上调试信息，否则输出就是这样的：</p>

<pre><code>$ sudo stap -L 'process(&quot;./a.out&quot;).function(&quot;func&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func&quot;)
</code></pre>

<p>还要注意的是，有一些编译优化级别可能会把局部变量优化掉，比如上面的文件分别使用O0和O2编译，看到的结果就不一样了：</p>

<pre><code>$ gcc test.c -g -O0
$ sudo stap -L 'process(&quot;./a.out&quot;).function(&quot;func&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;) $a:int $b:int $c:int


$ gcc test.c -g -O2
$ sudo stap -L 'process(&quot;./a.out&quot;).function(&quot;func&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;)
</code></pre>

<p>有了这两个命令行参数，搭配<code>grep</code>命令很容易的查询到相应的探针。</p>

<p>查询应用层程序探针：</p>

<pre><code>$ sudo stap -L 'process(&quot;./a.out&quot;).function(&quot;*&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;__do_global_dtors_aux&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;__libc_csu_fini&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;__libc_csu_init&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;_fini&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;_init&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;_start&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;deregister_tm_clones&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;frame_dummy&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func1@/home/codedump/source/systemtap-examples/src/test.c:3&quot;) $a:int $b:int
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;) $d:int $n:char const* $a:int $b:int $c:int
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;main@/home/codedump/source/systemtap-examples/src/test.c:16&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;register_tm_clones&quot;)
</code></pre>

<p>查询内核中包含<code>tcp_</code>的探针：</p>

<pre><code>$ sudo stap -L 'kernel.function(&quot;*&quot;)' | grep tcp_ | more
kernel.function(&quot;__parse_nl_addr@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_metrics.c:785&quot;) $addr:struct inetpeer_addr* $hash:unsigned int* $optional:int $v4:int $v6:int
kernel.function(&quot;__pskb_trim_head@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_output.c:1398&quot;) $skb:struct sk_buff* $len:int
kernel.function(&quot;__tcp_ack_snd_check@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp_input.c:5062&quot;) $sk:struct sock* $ofo_possible:int
kernel.function(&quot;__tcp_add_write_queue_tail@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/include/net/tcp.h:1647&quot;)
kernel.function(&quot;__tcp_alloc_md5sig_pool@/build/linux-hwe-dAr4iK/linux-hwe-4.15.0/net/ipv4/tcp.c:3371&quot;)
</code></pre>

<h2 id="g-var-val">-G VAR=VAL</h2>

<p>-G命令行参数，可以设置全局变量VAR的值为VAL，相应地就可以作为开关来控制脚本的行为，比如：</p>

<pre><code>// sudo stap G-params.stp -G flag=1
// flag has set
global flag=0

probe begin {
  if (flag == 0) {
    printf(&quot;flag not set\n&quot;)
  } else {
    printf(&quot;flag has set\n&quot;)
  }
}
</code></pre>

<h1 id="探测点">探测点</h1>

<p>由于systemtap用于动态跟踪探测，所以首先的第一步就是在语言中定义探测点，在systemtap中被称为“probe”。其基本语法是：</p>

<pre><code>probe event { statement }
</code></pre>

<p>在这里，“event”分为两种：</p>

<ul>
<li>同步事件：发生在进程执行某一条确定的命令时的事件。</li>
<li>异步事件：不是执行到指定的指令或代码位置，这一类包括计时器，定时器等。</li>
</ul>

<p>以下分开解释。</p>

<h2 id="同步事件">同步事件</h2>

<p>同步事件有好多种，同步事件的探测点又分为以下几个组成部分：</p>

<ul>
<li>前缀部分，定义所在的模块：可以是内核，还可以是内核模块，还可以是用户进程，还可以是systemtap在tapset中预定义的探测点。</li>
<li>中间部分，定义所在的函数：函数可以通过函数名指定，也可以根据文件名:行号指定。</li>
<li>后缀部分，定义调用时机：可以在函数调用时触发，也可以在函数返回时触发。</li>
</ul>

<p>根据以上几个划分，再来拆解“探测点”就相对容易了。</p>

<h3 id="模块">模块</h3>

<p>其中几类的语法分别是：</p>

<ul>
<li>内核：语法为kernel.function(PATTERN)，即以“kernel”开头来指定的就是内核中的函数。</li>
<li>内核模块：语法为module(MPATTERN).function(PATTERN)，即以“module(MPATTERN)”开头来指定的就是内核模块中的函数。</li>
<li>用户进程：语法为process(PROCESSPATH).function(PATTERN)，即以“process(PROCESSPATH)”开头来指定的就是用户进程的函数。</li>
<li>异步调用的模块：比如begin、end、timer等。</li>
<li>如果不是以上的格式，那么大概率就是systemtap自带的tapset中已经定义的探测点，实际上这些还是封装了以上几种调用的别名（alias）探测点，后面将谈到探测点的别名定义。tapset于systemtap的意义，就好比libc库于C程序的意义。</li>
</ul>

<h3 id="所在的函数">所在的函数</h3>

<p>所在的函数，可以通过两种方式指定：</p>

<ul>
<li>function(PATTERN)</li>
<li>statement(PATTERN)</li>
</ul>

<p>PATTERN由三部分组成：</p>

<ul>
<li>函数名（必填）。</li>
<li>@文件名：选填。</li>
<li>如果存在“@文件名”的情况下，还可以选填行号。</li>
</ul>

<p>即PATTERN的格式是：</p>

<pre><code>func[@file][:linenumber]
</code></pre>

<p>在这里，函数名这部分可以使用通配符（wildcarded）来定义文件的名字以及函数的名字，比如：</p>

<pre><code># 所有内核中以sys_前缀开头的函数
kernel.function(&quot;sys_*)

# nginx用户进程中名为ngx_http_process_*的函数
process(&quot;/home/admin/nginx/bin/nginx&quot;).function(&quot;ngx_http_process_*&quot;)
</code></pre>

<p>有时候如果不确定函数的名字，那么就可以使用前面的-L和-l命令来辅助查询，比如还是上面test.c的例子：</p>

<pre><code>$ sudo stap -l 'process(&quot;./a.out&quot;).function(&quot;fu*&quot;)'
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func1@/home/codedump/source/systemtap-examples/src/test.c:3&quot;)
process(&quot;/home/codedump/source/systemtap-examples/src/a.out&quot;).function(&quot;func@/home/codedump/source/systemtap-examples/src/test.c:7&quot;)
</code></pre>

<p>使用<code>statement</code>可以很方便定位到具体的某一行代码执行前后，变量的变化情况，比如下面这个最简单的C代码：</p>

<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
	int a;

	a = 1;
	printf(&quot;a:%d\n&quot;, a);
	a = 2;
	printf(&quot;a:%d\n&quot;, a);
	return 0;
}
</code></pre>

<p>使用下面这个systemtap脚本针对代码中的第8行和第10行打印当时变量a的值：</p>

<pre><code>probe process(&quot;./a.out&quot;).statement(&quot;main@./cc_stap_test.c:8&quot;)
{
    printf(&quot;systemtap probe line 8 a:%d\n&quot;, $a);
}

probe process(&quot;./a.out&quot;).statement(&quot;main@./cc_stap_test.c:10&quot;)
{
    printf(&quot;systemtap probe line 10 a:%d\n&quot;, $a);
}
</code></pre>

<p>输出如下：</p>

<pre><code>$ sudo stap cc_stap_test.stp -c ./a.out
a:1
a:2
systemtap probe line 8 a:1
systemtap probe line 10 a:2
</code></pre>

<h3 id="调用时机">调用时机</h3>

<p>有了以上两个要素，已经可以在具体的函数、文件行中定义探测点了，但是有时候针对某一个具体函数，想在不同的时机定义探测点，比如函数被调用和调用返回的时候，那么可以在后面以后缀的方式定义出来：</p>

<pre><code>probe kernel.function(&quot;*@net/socket.c&quot;).call {
  printf (&quot;%s -&gt; %s\n&quot;, thread_indent(1), probefunc())
}
probe kernel.function(&quot;*@net/socket.c&quot;).return {
  printf (&quot;%s &lt;- %s\n&quot;, thread_indent(-1), probefunc())
}
</code></pre>

<p>比如这两个探测点，分别在socket.c中的任何函数被调用以及返回的时候被调用。</p>

<h2 id="异步事件">异步事件</h2>

<p>常见的异步事件是begin、end、never、timers。</p>

<ul>
<li>begin、end分别在脚本开始执行以及结束执行的时候被调用。</li>
<li>timers用于定义定时器探测点，常见的格式timer.s(1)来定义每秒触发的探测点。</li>
<li>never定义的探测点不会被调用到，很多时候加这个探测点只是为了检查一些语法错误。</li>
</ul>

<p>这里统一用一个例子来说明：</p>

<pre><code>// sudo stap begin.stp -T 2
// 输出：
// probe begin
// in timer
// probe end

probe begin {
  printf(&quot;probe begin\n&quot;)
}

probe end {
  printf(&quot;probe end\n&quot;)
}

probe timer.s(1) {
  printf(&quot;in timer\n&quot;)
}

probe never {
  printf(&quot;never do this\n&quot;)
}
</code></pre>

<p>以下图片简单总结探针事件的划分：</p>

<p><center>
<img src="/media/imgs/20200128-systemtap-by-example/probe-event.png" alt="probe-event" title="probe-event" />
</center></p>

<h2 id="探测点别名-alias">探测点别名（alias）</h2>

<p>除了以上的探测点之后，还可以通过探测点别名技术将多个探测点的处理行为合并在一个处理函数中，比如tapset scheduler中是这么定义scheduler.cpu_off这个探测点的：</p>

<pre><code>probe scheduler.cpu_off =
	kernel.trace(&quot;sched_switch&quot;) !,
	kernel.function(&quot;context_switch&quot;)
{
    name = &quot;cpu_off&quot;
    task_prev = $prev
    task_next = $next
    idle = __is_idle()
}
</code></pre>

<p>在这里，新定义的别名探测点scheduler.cpu_off将内核的两个探测点kernel.trace(&ldquo;sched_switch&rdquo;)和kernel.function(&ldquo;context_switch&rdquo;)的处理行为合并在了一起。</p>

<p>需要注意的是，<code>kernel.trace(&quot;sched_switch&quot;)</code>这个探测点的后面加上了<code>!</code>，这表示这个探测点可能由于版本的差异是不存在的，但是一旦存在，那么将不再解析这个探测点以后的以<code>,</code>隔开的其他探测点，所以<code>!</code>一定用在多个以<code>,</code>分隔开的探测点列表中。相应地，还有<code>?</code>后缀，也是表示这个探测点可能不存在，但是与前面的区别是，即便存在这种探测点也不影响其他探测点的检测，所以<code>?</code>后缀的探测点可以独立存在。</p>

<h3 id="探测点动态定义">探测点动态定义</h3>

<p>此外，还可以根据命令行参数来指定探测点，比如：</p>

<pre><code>function trace(entry_p)
{
  printf(&quot;%s%s%s\n&quot;,
         thread_indent (entry_p),
         (entry_p&gt;0?&quot;-&gt;&quot;:&quot;&lt;-&quot;),
         ppfunc ())
}

probe $1.call   { trace(1) }
probe $1.return { trace(-1) }
</code></pre>

<p>这个脚本可以根据脚本中传入的第一个参数，来打印其调用情况，比如：</p>

<pre><code>$ stap callgraph.stp 'kernel.function(&quot;sys_open&quot;)'

     0 nscd(23451):-&gt;SyS_open
     6 nscd(23451):&lt;-SyS_open
     0 nscd(23451):-&gt;SyS_open
     7 nscd(23451):&lt;-SyS_open
     0 roxterm(21323):-&gt;SyS_open
    43 roxterm(21323):&lt;-SyS_open
     0 roxterm(21323):-&gt;SyS_open
  2604 roxterm(21323):&lt;-SyS_open
     0 systemd-udevd(637):-&gt;SyS_open
   268 systemd-udevd(637):&lt;-SyS_open
     0 roxterm(21323):-&gt;SyS_open
    24 roxterm(21323):&lt;-SyS_open
[...]

</code></pre>

<h1 id="变量">变量</h1>

<h2 id="目标变量-target-variables">目标变量（Target Variables）</h2>

<p>目标变量指的是当前代码位置可见的变量，官方文档对这个概念的解释是：</p>

<blockquote>
<p>The probe events that map to actual locations in the code (for example kernel.function(“function”) and kernel.statement(“statement”)) allow the use of target variables to obtain the value of variables visible at that location in the code. You can use the -L option to list the target variable available at a probe point.</p>
</blockquote>

<p>比如前面提过的，可以使用-L命令行参数，拿到一个探测点的位置及相关的变量：</p>

<pre><code>stap -L 'kernel.function(&quot;vfs_read&quot;)'
kernel.function(&quot;vfs_read@fs/read_write.c:277&quot;) $file:struct file* $buf:char* $count:size_t $pos:loff_t*
</code></pre>

<p>在这里，给出变量相关信息的时候，是以如下格式给出的：</p>

<pre><code>$变量名:变量类型
</code></pre>

<p>比如这里的<code>$file:struct file*</code>。</p>

<h2 id="全局变量">全局变量</h2>

<p>如果不是在当前代码位置的变量，此时可以通过这种格式拿到：</p>

<pre><code>@var(&quot;varname@src/file.c&quot;)
</code></pre>

<p>比如：</p>

<pre><code>// test2.c
#include &lt;stdio.h&gt;

int g = 100;
int func1(int a, int b) {
  g = 102;
  return a+b;
}

int func(int d, const char *n) {
  int a,b,c;

  g = 101;
  a = 1;
  b = 3;
  c = func1(a,b);
  return c;
}

int main() {
  func(100, &quot;test&quot;);
  return 0;
}
</code></pre>

<p>stp脚本如下：</p>

<pre><code>probe process(&quot;./a.out&quot;).function(&quot;func&quot;).call {
	printf(&quot;call func:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}

probe process(&quot;./a.out&quot;).function(&quot;func&quot;) {
	printf(&quot;func:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}

probe process(&quot;./a.out&quot;).function(&quot;func&quot;).return {
	printf(&quot;return func:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}

probe process(&quot;./a.out&quot;).function(&quot;func1&quot;).call {
	printf(&quot;call func1:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}

probe process(&quot;./a.out&quot;).function(&quot;func1&quot;) {
	printf(&quot;func1:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}

probe process(&quot;./a.out&quot;).function(&quot;func1&quot;).return {
	printf(&quot;return func1:g=%d\n&quot;, @var(&quot;g@test.c&quot;))
}
</code></pre>

<p>执行<code>sudo stap t.stap -c ./a.out</code>得到下面的结果：</p>

<pre><code>call func:g=100
func:g=100
call func1:g=101
func1:g=101
return func1:g=102
return func:g=102
</code></pre>

<h2 id="打印结构体内容">打印结构体内容</h2>

<p>有一些变量，本身是一个结构体，如果想打印其成员信息，但是又不知道结构体的成员分布的情况，可以首先使用<code>$变量名$</code>，比如：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;).return {printf(&quot;%s\n&quot;, $file$); exit(); }'

{.f_u={...}, .f_path={...}, .f_inode=0xffff8eaf11a9ef80, .f_op=0xffff8eafef9a7100, .f_lock={...}, .f_write_hint=0, .f_count={...}, .f_flags=34818, .f_mode=491551, .f_pos_lock={...}, .f_pos=0, .f_owner={...}, .f_cred=0xffff8eafed747f00, .f_ra={...}, .f_version=0, .f_security=0xffff8eafbfb5f708, .private_data=0x0, .f_ep_links={...}, .f_tfile_llink={...}, .f_mapping=0xffff8eaf11a9f0f8, .f_wb_err=0}
</code></pre>

<p>这样就一目了然知道这个结构体的构成了。</p>

<p>而如果需要打印某个成员的信息，就可以使用<code>-&gt;</code>操作符，注意在systemtap中，无论是指针还是引用都使用<code>-&gt;</code>来查看成员：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;).return {printf(&quot;%d\n&quot;, $file-&gt;private_data); exit(); }'

0
</code></pre>

<p>这里还有另一个知识点，即一个成员可能又是一个结构体，如果要一层一层“扒掉”成员的外衣，就需要在后面加<code>$</code>符号，每多一个<code>$</code>符号，就扒掉一层外衣，例子：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;).return {printf(&quot;%s\n&quot;, $file-&gt;f_pos_lock$); exit(); }' -w
{.owner={...}, .wait_lock={...}, .osq={...}, .wait_list={...}}

$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;).return {printf(&quot;%s\n&quot;, $file-&gt;f_pos_lock$$); exit(); }' -w
{.owner={.counter=-124589570406976}, .wait_lock={&lt;union&gt;={.rlock={.raw_lock={&lt;union&gt;={.val={.counter=0}, &lt;class&gt;={.locked='\000', .pending='\000'}, &lt;class&gt;={.locked_pending=0, .tail=0}}}}}}, .osq={.tail={.counter=0}}, .wait_list={.next=0xffff8eaf34c8cc58, .prev=0xffff8eaf34c8cc58}}

$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;).return {printf(&quot;%s\n&quot;, $file-&gt;f_pos_lock$$$); exit(); }' -w
{.owner={.counter=-124589338874240}, .wait_lock={&lt;union&gt;={.rlock={.raw_lock={&lt;union&gt;={.val={.counter=0}, &lt;class&gt;={.locked='\000', .pending='\000'}, &lt;class&gt;={.locked_pending=0, .tail=0}}}}}}, .osq={.tail={.counter=0}}, .wait_list={.next=0xffff8eaf42b71458, .prev=0xffff8eaf42b71458}}
</code></pre>

<p>结合打印全局变量和打印结构体成员这两个知识点，如果想知道全局变量的结构体成员分布，就需要：</p>

<pre><code>@var(&quot;全局变量名@src/file.c&quot;)$
</code></pre>

<p>比如：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;) {
           printf (&quot;current files_stat max_files: %s\n&quot;,
                   @var(&quot;files_stat@fs/file_table.c&quot;)$);
           exit(); }'
current files_stat max_files: {.nr_files=0, .nr_free_files=0, .max_files=774499}
</code></pre>

<p>然后用这个格式打印全局变量结构体成员数据：</p>

<pre><code>@var(&quot;全局变量名@src/file.c&quot;)-&gt;结构体成员名称
</code></pre>

<p>比如：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;vfs_read&quot;) {
           printf (&quot;current files_stat max_files: %d\n&quot;,
                   @var(&quot;files_stat@fs/file_table.c&quot;)-&gt;max_files);
           exit(); }'
current files_stat max_files: 774499
</code></pre>

<h2 id="类型转换-typecasting">类型转换（Typecasting）</h2>

<p>当指针为void*指针时，如果知道它的确切类型，可以通过类型转换来输出其信息：</p>

<pre><code>@cast(p, &quot;type_name&quot;[, &quot;module&quot;])-&gt;member
</code></pre>

<p>在这里，<code>type_name</code>是类型名称，而可选的module是模块+文件信息，好让systemtap知道到哪里找到这个类型信息，比如：</p>

<pre><code>@cast(tv, “timeval”, “&lt;sys/time.h&gt;”)-&gt;tvsec
@cast(task, “taskstruct”, “kernel&lt;linux/sched.h&gt;”)-&gt;tgid
@cast(task, “taskstruct”, “kernel&lt;linux/sched.h&gt;&lt;linux/fsstruct.h&gt;”)-&gt;fs-&gt;umask
</code></pre>

<p>所以可以如下例打印：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;do_dentry_open&quot;) {printf(&quot;%d\n&quot;, @cast($f, &quot;file&quot;, &quot;kernel&lt;linux/fs.h&gt;&quot; )-&gt;f_flags); exit(); }'
32768
</code></pre>

<p>在使用<code>@cast</code>转换类型之后，同样可以在后面加上<code>$</code>打印更多详细信息：</p>

<pre><code>$ sudo stap -e 'probe kernel.function(&quot;do_dentry_open&quot;) {printf(&quot;%s\n&quot;, @cast($f, &quot;file&quot;, &quot;kernel&lt;linux/fs.h&gt;&quot;)$); exit(); }'
{.f_u={...}, .f_path={...}, .f_inode=0x0, .f_op=0x0, .f_lock={...}, .f_write_hint=0, .f_count={...}, .f_flags=32768, .f_mode=0, .f_pos_lock={...}, .f_pos=0, .f_owner={...}, .f_cred=0xffff8eafef8f80c0, .f_ra={...}, .f_version=0, .f_security=0xffff8eafeb5c09c0, .private_data=0x0, .f_ep_links={...}, .f_tfile_llink={...}, .f_mapping=0x0, .f_wb_err=0}
</code></pre>

<p><code>@cast</code>操作符同样也可以用在应用程序中，比如：</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct Test {
  int a;
  int b;
} Test;

int func(void *p) {
  printf(&quot;in func\n&quot;);
}

int main() {
  Test t = {.a=101,.b=102};
  func(&amp;t);
  return 0;
}
</code></pre>

<p>可以如下打印：</p>

<pre><code>probe process(&quot;./a.out&quot;).function(&quot;func&quot;).call {
	printf(&quot;call func:g=%d\n&quot;, @cast($p, &quot;Test&quot;)-&gt;a)
}

/*输出：
in func
call func:g=101
*/
</code></pre>

<h2 id="打印局部变量">打印局部变量</h2>

<p>可以使用如下几个变量来打印函数局部变量：</p>

<ul>
<li>$$vars：打印函数的所有局部变量以及传递进来的函数参数。</li>
<li>$$parms：$$vars的子集，打印函数传递进来的函数参数。</li>
<li>$$locals：$$vars的子集，打印函数的所有局部变量。</li>
</ul>

<p><center>
<img src="/media/imgs/20200128-systemtap-by-example/vars.png" alt="vars" title="vars" />
</center></p>

<p>同样的，在这些变量后面也可以加上<code>$</code>美观打印：</p>

<pre><code>#include &lt;stdio.h&gt;

int func1(int a, int b) {
  return a+b;
}

int func(int d, const char *n) {
  int a,b,c;

  a = 1;
  b = 3;
  c = func1(a,b);
  return c;
}

int main() {
  func(100, &quot;test&quot;);
  return 0;
}
</code></pre>

<p>脚本如下：</p>

<pre><code>probe process(&quot;./a.out&quot;).function(&quot;func&quot;).call {
	printf(&quot;call func:vars=%s\n&quot;, $$vars)
	printf(&quot;call func:vars=%s\n&quot;, $$vars$)
	printf(&quot;call func:params=%s\n&quot;, $$parms)
	printf(&quot;call func:params=%s\n&quot;, $$parms$)
	printf(&quot;call func:locals=%s\n&quot;, $$locals)
	printf(&quot;call func:locals=%s\n&quot;, $$locals$)
}

/*
sudo stap t.stap -c ./a.out
call func:vars=d=0x64 n=0x4005c4 a=0x0 b=0x4003e0 c=0x0
call func:vars=d=100 n=&quot;test&quot; a=0 b=4195296 c=0
call func:params=d=0x64 n=0x4005c4
call func:params=d=100 n=&quot;test&quot;
call func:locals=a=0x0 b=0x4003e0 c=0x0
call func:locals=a=0 b=4195296 c=0  
 */
</code></pre>

<p>另外，如果需要打印函数的返回值，可以使用<code>$$return</code>变量，但是要注意这个变量只能在<code>.return</code>中使用，毕竟既然是要打印函数返回值，就要在函数返回的时候才能知道，使用下面的脚本来看上面C程序的返回值：</p>

<pre><code>probe process(&quot;./a.out&quot;).function(&quot;func&quot;).return {
	printf(&quot;call func:return=%s\n&quot;, $$return)
	printf(&quot;call func:return=%s\n&quot;, $$return$)
}

/*
$ sudo stap t.stap -c ./a.out
call func:return=return=0x4
call func:return=return=4
 */
</code></pre>

<h1 id="关联数组-associative-arrays">关联数组（Associative Arrays）</h1>

<p>准确的说，systemtap中没有数组这个概念，关联数组就是systemtap中的字典（dict）。</p>

<p>字典有可能是嵌套型的字典，比如C++代码中<code>dict[keya][keyb]</code>，即一个字典中的值又是另一个字典。systemtap中的关联数组也可以做到类似的效果，但是语法略有不同，多个层级的键之间使用<code>,</code>分隔，比如：</p>

<pre><code>bt[execname(),tid(),$mem,sprint_ubacktrace()] = 1
</code></pre>

<p>这段代码用C++类似表达就是：</p>

<pre><code>bt[execname()][tid()][$mem,sprint_ubacktrace()] = 1
</code></pre>

<p>在systemtap中，最多允许嵌套9个键。</p>

<p>关联数组的常规操作，并无什么特别的地方，如下代码所示：</p>

<pre><code>// 赋值
array_name[index_expression] = value

// 读取
delta = gettimeofday_s() - foo[tid()]

// 递增
array_name[index_expression] ++

// 删除数组中的某一项
delete array_name[index_expression]

// 删除整个关联数组
delete array_name
</code></pre>

<h2 id="遍历关联数组">遍历关联数组</h2>

<p>最简单的遍历关联数组的方式，可以使用<code>foreach</code>表达式：</p>

<pre><code>foreach (element in array_name)
  statement
</code></pre>

<p>例子：</p>

<pre><code>global reads 

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++ 
} 

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads)
    printf(&quot;%s : %d \n&quot;, count, reads[count])
  delete reads 
}
</code></pre>

<p>输出：</p>

<pre><code>$ sudo stap vfs-read-1.stp -T 4
stapio : 21
docker-containe : 12
dockerd : 12
gmain : 7
rtkit-daemon : 1
compiz : 6
systemd-journal : 1
gdbus : 6
upstart-dbus-br : 4
nm-applet : 3
avahi-daemon : 29
</code></pre>

<p>除了常规的遍历之外，<code>foreach</code>操作符还可以指定遍历的顺序，以及遍历的数量。</p>

<h3 id="修改遍历关联数组顺序">修改遍历关联数组顺序</h3>

<p>上面的脚本文件稍作修改：</p>

<pre><code>global reads 

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++ 
} 

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads+)
    printf(&quot;%s : %d \n&quot;, count, reads[count])
  delete reads 
}
</code></pre>

<p>即在<code>foreach</code>所遍历的关联数组名称后面加上<code>+</code>，表示按照键递增的顺序来遍历数组，输出为：</p>

<pre><code>$ sudo stap vfs-read-1.stp -T 4
systemd-journal : 1
indicator-datet : 3
gmain : 4
upstart-dbus-br : 5
unity-panel-ser : 6
compiz : 7
docker-containe : 12
dockerd : 12
stapio : 21
gdbus : 23
avahi-daemon : 28
</code></pre>

<p>相反的，如果使用<code>-</code>则表示是递减顺序来遍历。</p>

<h3 id="限定遍历关联数组数量">限定遍历关联数组数量</h3>

<p>除此之外，还可以在<code>foreach</code>操作符中，使用<code>limit 数量</code>来限制遍历关联数组中元素的数量：</p>

<pre><code>global reads

// 以进程名字为键，记录下每个进程调用vfs.read的次数
probe vfs.read {
  reads[execname()] ++
}

// 每隔3秒打印一次
probe timer.s(3) {
  foreach (count in reads+ limit 2)
    printf(&quot;%s : %d \n&quot;, count, reads[count])
  delete reads
}
</code></pre>

<p>输出就只有两项了：</p>

<pre><code>$ sudo stap vfs-read-1.stp -T 4
systemd-journal : 1
systemd-logind : 1
</code></pre>

<h2 id="测试元素存在性">测试元素存在性</h2>

<p>除此之外，还可以使用<code>in</code>操作符测试一个元素是否在关联数组中，语法如下：</p>

<pre><code>if([index_expression] in array_name) statement
</code></pre>

<p>例子：</p>

<pre><code>global reads

probe vfs.read { 
  reads[execname()] ++ 
}

probe timer.s(3) {
  printf(&quot;=======\n&quot;) 
  foreach (count in reads+)
    printf(&quot;%s : %d \n&quot;, count, reads[count]) 
  if([&quot;stapio&quot;] in reads) {
    printf(&quot;stapio read detected, exiting\n&quot;)
    exit() 
  }
}
</code></pre>

<p>输出：</p>

<pre><code>$ sudo stap vfs-read-1.stp -T 4
=======
systemd-journal : 1
rtkit-daemon : 1
nm-applet : 3
gmain : 4
upstart-dbus-br : 4
compiz : 5
gdbus : 6
docker-containe : 12
dockerd : 12
avahi-daemon : 19
stapio : 21
stapio read detected, exiting
</code></pre>

<h1 id="计算统计集合-statistical-aggregates">计算统计集合（Statistical Aggregates）</h1>

<h2 id="常规操作">常规操作</h2>

<p>systemtap中的变量，除了具备其他语言中常见的操作之外，还有一个其他语言没有的特色，可以作为统计集合来存储数据。即一个变量，可以存储多个数据，后期可以对这个变量的数据进行常规的统计计算。</p>

<p>一个变量要存储统计数据，此时不能使用<code>=</code>来赋值，需要使用<code>&lt;&lt;&lt;</code>操作符。比如：</p>

<pre><code>global reads 

probe vfs.read 
{ 
  reads[execname()] &lt;&lt;&lt; $count 
}
</code></pre>

<p>这里的$count是内核中vfs_read函数传入的参数，存储的读取数据的数量：</p>

<pre><code class="language-C">ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
</code></pre>

<p>这样，这个systemtap脚本就针对同一个进程，就把这个进程所有调用vfs_read函数的count值记录了下来。</p>

<p>下面来具体看看systemtap都提供了针对统计数据的哪些操作。常规的操作有以下几种：</p>

<blockquote>
<p>@count(variable)：返回同一个变量中存储的数据数量。</p>

<p>@sum(variable)：返回同一个变量中存储的数据总和。</p>

<p>@min(variable)：返回同一个变量存储的最小数据。</p>

<p>@max(variable)：返回同一个变量中存储的最大数据。</p>

<p>@avg(variable)：返回同一个变量中存储的数据均值。</p>

<p>@variance(variable)：返回同一个变量中存储的数据方差。</p>
</blockquote>

<p>以上的操作符，又被称为抽取函数（extractor function），即可以输入一个存有统计数据的变量，相应返回一些数据。</p>

<h2 id="打印柱状图数据">打印柱状图数据</h2>

<p>还可以使用<code>@hist_log</code>来打印以2为底指数分布的直方图：</p>

<pre><code>global histogram
 
probe begin {
  printf(&quot;Capturing...\n&quot;)
}
 
probe netdev.receive {
  histogram &lt;&lt;&lt; length
}
 
probe netdev.transmit {
  histogram &lt;&lt;&lt; length
}
 
probe end {
  printf( &quot;\n&quot; )
  print( @hist_log(histogram) )
}
</code></pre>

<p>输出：</p>

<pre><code>$ sudo stap hist_log.stp -T 2
Capturing...

value |-------------------------------------------------- count
    8 |                                                   0
   16 |                                                   0
   32 |@@                                                 2
   64 |@                                                  1
  128 |                                                   0
  256 |                                                   0
  512 |                                                   0
 1024 |@@@@                                               4
 2048 |                                                   0
 4096 |                                                   0
</code></pre>

<p>除了<code>@hist_log</code>之外，还可以使用<code>@hist_linear(v, start, stop, interval)</code>来打印start-stop区间interval间隔的直方图</p>

<pre><code>global reads

probe netdev.receive {
	reads &lt;&lt;&lt; length
}

probe end {
	print(@hist_linear(reads, 0, 1024, 200))
}
</code></pre>

<p>这里打印的是分布在[0,1024]，并且每个柱子的数据间间隔100的柱状图，输出如下：</p>

<pre><code>$ sudo stap hist_linear.stp -T 2
value |-------------------------------------------------- count
    0 |@@@@@@@@@@@@@                                      13
  200 |@@@@                                                4
  400 |                                                    0
  600 |                                                    0
</code></pre>

<h1 id="常用函数">常用函数</h1>

<p>本节来介绍systemtap中常用的一些函数。</p>

<ul>
<li>tid()：当前线程ID。</li>
<li>uid()：当前用户ID。</li>
<li>cpu()：当前CPU编号。</li>
<li>ctime()：当前UNIX epoch秒数。</li>
<li>pp()：当前探测点的描述字符串。</li>
<li>execname()：当前运行的进程名称。</li>
<li>probefunc()：探测点函数名称。</li>
<li>target()：在stap使用<code>-c command</code>或者<code>-x process</code>命令时，target()能拿到进程的pid。</li>
<li>name：返回系统调用的名称字符串，仅能在syscall类型的探针处理函数中使用。</li>
<li>thread_indent(delta)：它可以输出当前probe所处的可执行程序名称、线程id、函数执行的相对时间和执行的次数（通过空格的数量）信息，它的返回值就是一个字符串。参数delta是在每次调用时增加或移除的空白数量。</li>
</ul>

<p>这里其他的都好理解，thread_indent需要一个例子来说明：</p>

<pre><code>probe kernel.function(&quot;*@net/socket.c&quot;).call
{
  printf (&quot;%s -&gt; %s\n&quot;, thread_indent(1), probefunc())
}
probe kernel.function(&quot;*@net/socket.c&quot;).return
{
  printf (&quot;%s &lt;- %s\n&quot;, thread_indent(-1), probefunc())
}
</code></pre>

<p>输出：</p>

<pre><code>0 ftp(7223): -&gt; sys_socketcall
1159 ftp(7223):  -&gt; sys_socket
2173 ftp(7223):   -&gt; __sock_create
2286 ftp(7223):    -&gt; sock_alloc_inode
2737 ftp(7223):    &lt;- sock_alloc_inode
3349 ftp(7223):    -&gt; sock_alloc
3389 ftp(7223):    &lt;- sock_alloc
3417 ftp(7223):   &lt;- __sock_create
4117 ftp(7223):   -&gt; sock_create
4160 ftp(7223):   &lt;- sock_create
4301 ftp(7223):   -&gt; sock_map_fd
4644 ftp(7223):    -&gt; sock_map_file
4699 ftp(7223):    &lt;- sock_map_file
4715 ftp(7223):   &lt;- sock_map_fd
4732 ftp(7223):  &lt;- sys_socket
4775 ftp(7223): &lt;- sys_socketcall
</code></pre>

<p>可以看到，thread_indent()搭配<code>.call</code>和<code>.return</code>，美化输出了函数调用的流程。</p>

<p>以下再演示一下<code>name</code>的使用，这个变量仅能用在<code>syscall</code>类的探针中，以下脚本每隔一秒打印出当前20个被调用最多的系统调用数量：</p>

<pre><code>global syscalls_count

probe syscall_any {
  syscalls_count[name] &lt;&lt;&lt; 1
}

function print_systop () {
  printf (&quot;%25s %10s\n&quot;, &quot;SYSCALL&quot;, &quot;COUNT&quot;)
  foreach (syscall in syscalls_count- limit 20) {
    printf(&quot;%25s %10d\n&quot;, syscall, @count(syscalls_count[syscall]))
  }
  delete syscalls_count
}

probe timer.s(1) {
  print_systop ()
  printf(&quot;--------------------------------------------------------------\n&quot;)
}
</code></pre>

<p>输出：</p>

<pre><code>$ sudo stap syscall.stp -T 2
                  SYSCALL      COUNT
                    ioctl        127
               epoll_wait         47
                    futex         42
                 pselect6         29
                     read         28
                    write         17
                  recvmsg         16
                     poll         14
           rt_sigprocmask          8
                    fcntl          6
                   writev          5
                    ppoll          5
                 recvfrom          4
                setitimer          4
        inotify_add_watch          3
                   select          3
                nanosleep          2
          timerfd_settime          2
            clock_gettime          2
                ftruncate          1
--------------------------------------------------------------
</code></pre>

<h1 id="defined和-choose-defined">@defined和@choose_defined</h1>

<p>由于版本变化，有一些变量可能在新版本中不存在了，此时可以使用<code>@define</code>来检查变量是否存在：</p>

<pre><code>probe vm.pagefault = kernel.function(&quot;__handle_mm_fault@mm/memory.c&quot;) ?,
                     kernel.function(&quot;handle_mm_fault@mm/memory.c&quot;) ?
{
  write_access = (@defined($flags) ? $flags &amp; FAULT_FLAG_WRITE : $write_access)
}
</code></pre>

<p>上面的脚本根据是否存在变量flag，来给write_access不同的赋值。</p>

<p>此外还有<code>@choose_defined($a,$b)</code>，其作用相当于：<code>@defined($a)? $a : $b</code>，例子：</p>

<pre><code>probe vm.pagefault = kernel.function(&quot;handle_mm_fault@mm/memory.c&quot;)
{
  write_access = @choose_defined($write_access, 0)
}
</code></pre>

<h1 id="entry">@entry</h1>

<p>在<code>.return</code>探针中，有一个特殊的操作符<code>@entry</code>，用于存储该探针的入口处的表达式的值，可以使用这个操作符，完成比如计算探针函数执行时间计算等工作，比如：</p>

<pre><code>global sloth = 50
      
probe vfs.open.return {
  time = gettimeofday_us()-@entry(gettimeofday_us())
  if (time &gt;= sloth)
    printf(&quot;%s[%d] %d %s\n&quot;, execname(), tid(), time, pathname)
}
</code></pre>

<p>这个脚本在<code>vfs.open.return</code>探针处理函数中，通过<code>@entry</code>操作符，计算完成vfs.open操作的时间差，如果超过设置的阈值50就打印相关信息。</p>

<h1 id="嵌入c代码">嵌入C代码</h1>

<p>systemtap中支持嵌入C代码，使用guru模式（-g参数），在“%{“和“%}&ldquo;标记之间就能嵌入C代码，其中访问参数的值以<code>STAP_ARG_+参数名</code>的形式，而返回值以<code>STAP_RETVALUE=xxx</code>的形式。</p>

<pre><code>%{
	#include &lt;linux/in.h&gt;
	#include &lt;linux/ip.h&gt;
%} /* &lt;-- top level */

function read_iphdr:long(skb:long)
%{
	struct iphdr *iph = ip_hdr((struct sk_buff *)STAP_ARG_skb);
	STAP_RETVALUE = (long)iph;
%}

/* Determines whether an IP packet is TCP, based on the iphdr: */
function is_tcp_packet:long(iphdr)
{
	protocol = @cast(iphdr, &quot;iphdr&quot;)-&gt;protocol
	return (protocol == %{ IPPROTO_TCP %}) /* &lt;-- expression */
}

probe begin {
	printf(&quot;SystemTap start!\n&quot;);
}

probe kernel.function(&quot;ip_local_deliver&quot;) {
	iph = read_iphdr(pointer_arg(1));
	printf(&quot;tcp packet ? %s\n&quot;, is_tcp_packet(iph) ? &quot;yes&quot; : &quot;no&quot;);
}
</code></pre>

<p>这里的read_iphdr函数，其处理函数就使用的是嵌入C代码完成。</p>

    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">codedump</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2020-01-28</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。 转载时请注明原文链接，图片使用<a href="https://www.omnigroup.com/omnigraffle/">OmniGraffle</a>进行绘制。</span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">打赏</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/media/imgs/reward/wechat.png">
        <span>微信支付</span>
      </label>
    
  </div>
</div>

 

      
      <h1>相关文章</h1>
      















































































































































































































































































































































































































































<h1>微信公众号</h1>

<img align="center" src="https://www.codedump.info/media/imgs/reward/qrcode_codedumpnote.png" alt="wechat-account-qrcode">

<footer class="post-footer">
  <div class="post-tags">
      
      <a href="/tags/linux%E7%B3%BB%E7%BB%9F/">Linux系统</a>
      
      <a href="/tags/%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA/">动态跟踪</a>
      
      <a href="/tags/systemtap/">systemtap</a>
      
    </div>



      
      <nav class="post-nav">
        
          <a class="prev" href="/post/20200122-series-pages/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">博客系列文章索引</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/20191214-cxx11-memory-model-2/">
            <span class="next-text nav-default">C&#43;&#43;11中的内存模型下篇 - C&#43;&#43;11支持的几种内存模型</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>


  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'lichuang-codedump';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

	
  <div class="post bg-white">
    <script src="https://utteranc.es/client.js"
          repo="lichuang/lichuang.github.io"
          issue-term="pathname"
          theme="github-light"
          crossorigin="anonymous"
          async>
    </script>
  </div>    
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/lichuang" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/lichuang" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/codedump" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/Lichuang/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://codedump.info/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2018 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">codedump</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-126255685-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?f23d5f22e2f2472e1e8f23afb0523e40";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
